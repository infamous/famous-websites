(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Position = require('./Position');

/**
 * Align is a component designed to allow for smooth tweening
 * of the alignment of a node relative to its parent.
 *
 * @class Align
 * @augments Position
 *
 * @param {Node} node Node that the Align component will be attached to
 */
function Align(node) {
    Position.call(this, node);

    var initial = node.getAlign();

    this._x.set(initial[0]);
    this._y.set(initial[1]);
    this._z.set(initial[2]);
}

/**
 * Return the name of the Align component
 *
 * @method
 *
 * @return {String} Name of the component
 */
Align.prototype.toString = function toString() {
    return 'Align';
};

Align.prototype = Object.create(Position.prototype);
Align.prototype.constructor = Align;

/**
 * When the node this component is attached to updates, update the value
 * of the Node's align.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Align.prototype.update = function update() {
    this._node.setAlign(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Align.prototype.onUpdate = Align.prototype.update;

module.exports = Align;

},{"./Position":3}],2:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Commands = require('../core/Commands');

/**
 * Camera is a component that is responsible for sending information to the renderer about where
 * the camera is in the scene.  This allows the user to set the type of projection, the focal depth,
 * and other properties to adjust the way the scenes are rendered.
 *
 * @class Camera
 *
 * @param {Node} node to which the instance of Camera will be a component of
 */
function Camera(node) {
    this._node = node;
    this._projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
    this._focalDepth = 0;
    this._near = 0;
    this._far = 0;
    this._requestingUpdate = false;
    this._id = node.addComponent(this);
    this._viewTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    this._viewDirty = false;
    this._perspectiveDirty = false;
    this.setFlat();
}

Camera.FRUSTUM_PROJECTION = 0;
Camera.PINHOLE_PROJECTION = 1;
Camera.ORTHOGRAPHIC_PROJECTION = 2;

/**
 * @method
 *
 * @return {String} Name of the component
 */
Camera.prototype.toString = function toString() {
    return 'Camera';
};

/**
 * Gets object containing serialized data for the component
 *
 * @method
 *
 * @return {Object} the state of the component
 */
Camera.prototype.getValue = function getValue() {
    return {
        component: this.toString(),
        projectionType: this._projectionType,
        focalDepth: this._focalDepth,
        near: this._near,
        far: this._far
    };
};

/**
 * Set the components state based on some serialized data
 *
 * @method
 *
 * @param {Object} state an object defining what the state of the component should be
 *
 * @return {Boolean} status of the set
 */
Camera.prototype.setValue = function setValue(state) {
    if (this.toString() === state.component) {
        this.set(state.projectionType, state.focalDepth, state.near, state.far);
        return true;
    }
    return false;
};

/**
 * Set the internals of the component
 *
 * @method
 *
 * @param {Number} type an id corresponding to the type of projection to use
 * @param {Number} depth the depth for the pinhole projection model
 * @param {Number} near the distance of the near clipping plane for a frustum projection
 * @param {Number} far the distance of the far clipping plane for a frustum projection
 *
 * @return {Boolean} status of the set
 */
Camera.prototype.set = function set(type, depth, near, far) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._projectionType = type;
    this._focalDepth = depth;
    this._near = near;
    this._far = far;
};

/**
 * Set the camera depth for a pinhole projection model
 *
 * @method
 *
 * @param {Number} depth the distance between the Camera and the origin
 *
 * @return {Camera} this
 */
Camera.prototype.setDepth = function setDepth(depth) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._perspectiveDirty = true;
    this._projectionType = Camera.PINHOLE_PROJECTION;
    this._focalDepth = depth;
    this._near = 0;
    this._far = 0;

    return this;
};

/**
 * Gets object containing serialized data for the component
 *
 * @method
 *
 * @param {Number} near distance from the near clipping plane to the camera
 * @param {Number} far distance from the far clipping plane to the camera
 *
 * @return {Camera} this
 */
Camera.prototype.setFrustum = function setFrustum(near, far) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._perspectiveDirty = true;
    this._projectionType = Camera.FRUSTUM_PROJECTION;
    this._focalDepth = 0;
    this._near = near;
    this._far = far;

    return this;
};

/**
 * Set the Camera to have orthographic projection
 *
 * @method
 *
 * @return {Camera} this
 */
Camera.prototype.setFlat = function setFlat() {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._perspectiveDirty = true;
    this._projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
    this._focalDepth = 0;
    this._near = 0;
    this._far = 0;

    return this;
};

/**
 * When the node this component is attached to updates, the Camera will
 * send new camera information to the Compositor to update the rendering
 * of the scene.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Camera.prototype.onUpdate = function onUpdate() {
    this._requestingUpdate = false;

    var path = this._node.getLocation();

    this._node
        .sendDrawCommand(Commands.WITH)
        .sendDrawCommand(path);

    if (this._perspectiveDirty) {
        this._perspectiveDirty = false;

        switch (this._projectionType) {
            case Camera.FRUSTUM_PROJECTION:
                this._node.sendDrawCommand(Commands.FRUSTRUM_PROJECTION);
                this._node.sendDrawCommand(this._near);
                this._node.sendDrawCommand(this._far);
                break;
            case Camera.PINHOLE_PROJECTION:
                this._node.sendDrawCommand(Commands.PINHOLE_PROJECTION);
                this._node.sendDrawCommand(this._focalDepth);
                break;
            case Camera.ORTHOGRAPHIC_PROJECTION:
                this._node.sendDrawCommand(Commands.ORTHOGRAPHIC_PROJECTION);
                break;
        }
    }

    if (this._viewDirty) {
        this._viewDirty = false;

        this._node.sendDrawCommand(Commands.CHANGE_VIEW_TRANSFORM);
        this._node.sendDrawCommand(this._viewTransform[0]);
        this._node.sendDrawCommand(this._viewTransform[1]);
        this._node.sendDrawCommand(this._viewTransform[2]);
        this._node.sendDrawCommand(this._viewTransform[3]);

        this._node.sendDrawCommand(this._viewTransform[4]);
        this._node.sendDrawCommand(this._viewTransform[5]);
        this._node.sendDrawCommand(this._viewTransform[6]);
        this._node.sendDrawCommand(this._viewTransform[7]);

        this._node.sendDrawCommand(this._viewTransform[8]);
        this._node.sendDrawCommand(this._viewTransform[9]);
        this._node.sendDrawCommand(this._viewTransform[10]);
        this._node.sendDrawCommand(this._viewTransform[11]);

        this._node.sendDrawCommand(this._viewTransform[12]);
        this._node.sendDrawCommand(this._viewTransform[13]);
        this._node.sendDrawCommand(this._viewTransform[14]);
        this._node.sendDrawCommand(this._viewTransform[15]);
    }
};

/**
 * When the transform of the node this component is attached to
 * changes, have the Camera update its projection matrix and
 * if needed, flag to node to update.
 *
 * @method
 *
 * @param {Array} transform an array denoting the transform matrix of the node
 *
 * @return {Camera} this
 */
Camera.prototype.onTransformChange = function onTransformChange(transform) {
    var a = transform;
    this._viewDirty = true;

    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
    a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
    a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
    a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

    b00 = a00 * a11 - a01 * a10,
    b01 = a00 * a12 - a02 * a10,
    b02 = a00 * a13 - a03 * a10,
    b03 = a01 * a12 - a02 * a11,
    b04 = a01 * a13 - a03 * a11,
    b05 = a02 * a13 - a03 * a12,
    b06 = a20 * a31 - a21 * a30,
    b07 = a20 * a32 - a22 * a30,
    b08 = a20 * a33 - a23 * a30,
    b09 = a21 * a32 - a22 * a31,
    b10 = a21 * a33 - a23 * a31,
    b11 = a22 * a33 - a23 * a32,

    det = 1/(b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);

    this._viewTransform[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    this._viewTransform[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    this._viewTransform[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    this._viewTransform[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    this._viewTransform[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    this._viewTransform[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    this._viewTransform[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    this._viewTransform[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    this._viewTransform[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    this._viewTransform[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    this._viewTransform[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    this._viewTransform[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    this._viewTransform[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    this._viewTransform[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    this._viewTransform[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    this._viewTransform[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
};

module.exports = Camera;

},{"../core/Commands":6}],3:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Transitionable = require('../transitions/Transitionable');

/**
 * The Position component serves as a way to tween to translation of a Node.
 *  It is also the base class for the other core components that interact
 * with the Vec3 properties on the Node
 *
 * @class Position
 *
 * @param {Node} node Node that the Position component will be attached to
 */
function Position(node) {
    this._node = node;
    this._id = node.addComponent(this);
  
    this._requestingUpdate = false;
    
    var initialPosition = node.getPosition();

    this._x = new Transitionable(initialPosition[0]);
    this._y = new Transitionable(initialPosition[1]);
    this._z = new Transitionable(initialPosition[2]);
}

/**
 * Return the name of the Position component
 *
 * @method
 *
 * @return {String} Name of the component
 */
Position.prototype.toString = function toString() {
    return 'Position';
};

/**
 * Gets object containing stringified constructor, and corresponding dimensional values
 *
 * @method
 *
 * @return {Object} the internal state of the component
 */
Position.prototype.getValue = function getValue() {
    return {
        component: this.toString(),
        x: this._x.get(),
        y: this._y.get(),
        z: this._z.get()
    };
};

/**
 * Set the translation of the Node
 *
 * @method
 *
 * @param {Object} state Object -- component: stringified constructor, x: number, y: number, z: number
 *
 * @return {Boolean} status of the set
 */
Position.prototype.setValue = function setValue(state) {
    if (this.toString() === state.component) {
        this.set(state.x, state.y, state.z);
        return true;
    }
    return false;
};

/**
 * Getter for X translation
 *
 * @method
 *
 * @return {Number} the Node's translation along its x-axis
 */
Position.prototype.getX = function getX() {
    return this._x.get();
};

/**
 * Getter for Y translation
 *
 * @method
 *
 * @return {Number} the Node's translation along its Y-axis
 */
Position.prototype.getY = function getY() {
    return this._y.get();
};

/**
 * Getter for z translation
 *
 * @method
 *
 * @return {Number} the Node's translation along its z-axis
 */
Position.prototype.getZ = function getZ() {
    return this._z.get();
};

/**
 * Whether or not the Position is currently changing
 *
 * @method
 *
 * @return {Boolean} whether or not the Position is changing the Node's position
 */
Position.prototype.isActive = function isActive() {
    return this._x.isActive() || this._y.isActive() || this._z.isActive();
};

/**
 * Decide whether the component needs to be updated on the next tick.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
Position.prototype._checkUpdate = function _checkUpdate() {
    if (this.isActive()) this._node.requestUpdateOnNextTick(this._id);
    else this._requestingUpdate = false;
};

/**
 * When the node this component is attached to updates, update the value
 * of the Node's position
 *
 * @method
 *
 * @return {undefined} undefined
 */
Position.prototype.update = function update () {
    this._node.setPosition(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Position.prototype.onUpdate = Position.prototype.update;

/** 
 * Setter for X position
 *
 * @method
 * 
 * @param {Number} val used to set x coordinate
 * @param {Object} transition options for the transition
 * @param {Function} callback function to execute after setting X 
 *
 * @return {Position} this
 */
Position.prototype.setX = function setX(val, transition, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._x.set(val, transition, callback);
    return this;
};

/** 
 * Setter for Y position
 *
 * @method
 * 
 * @param {Number} val used to set y coordinate
 * @param {Object} transition options for the transition
 * @param {Function} callback function to execute after setting Y 
 *
 * @return {Position} this
 */
Position.prototype.setY = function setY(val, transition, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._y.set(val, transition, callback);
    return this;
};

/** 
 * Setter for Z position
 *
 * @method
 * 
 * @param {Number} val used to set z coordinate
 * @param {Object} transition options for the transition
 * @param {Function} callback function to execute after setting Z 
 *
 * @return {Position} this
 */
Position.prototype.setZ = function setZ(val, transition, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._z.set(val, transition, callback);
    return this;
};


/** 
 * Setter for X, Y, and Z positions
 *
 * @method
 * 
 * @param {Number} x used to set x coordinate
 * @param {Number} y used to set y coordinate
 * @param {Number} z used to set z coordinate
 * @param {Object} transition options for the transition
 * @param {Function} callback function to execute after setting X 
 *
 * @return {Position} this
 */
Position.prototype.set = function set(x, y, z, transition, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    if (x != null) this._x.set(x, transition, xCallback);
    if (y != null) this._y.set(y, transition, yCallback);
    if (z != null) this._z.set(z, transition, zCallback);

    return this;
};

/**
 * Stops transition of Position component
 *
 * @method
 *
 * @return {Position} this
 */
Position.prototype.halt = function halt() {
    this._x.halt();
    this._y.halt();
    this._z.halt();
    return this;
};

module.exports = Position;

},{"../transitions/Transitionable":41}],4:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Channels are being used for interacting with the UI Thread when running in
 * a Web Worker or with the UIManager/ Compositor when running in single
 * threaded mode (no Web Worker).
 *
 * @class Channel
 * @constructor
 */
function Channel() {
    if (typeof self !== 'undefined' && self.window !== self) {
        this._enterWorkerMode();
    }
}


/**
 * Called during construction. Subscribes for `message` event and routes all
 * future `sendMessage` messages to the Main Thread ("UI Thread").
 *
 * Primarily used for testing.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Channel.prototype._enterWorkerMode = function _enterWorkerMode() {
    this._workerMode = true;
    var _this = this;
    self.addEventListener('message', function onmessage(ev) {
        _this.onMessage(ev.data);
    });
};

/**
 * Meant to be overridden by `Famous`.
 * Assigned method will be invoked for every received message.
 *
 * @type {Function}
 * @override
 *
 * @return {undefined} undefined
 */
Channel.prototype.onMessage = null;

/**
 * Sends a message to the UIManager.
 *
 * @param  {Any}    message Arbitrary message object.
 *
 * @return {undefined} undefined
 */
Channel.prototype.sendMessage = function sendMessage (message) {
    if (this._workerMode) {
        self.postMessage(message);
    }
    else {
        this.onmessage(message);
    }
};

/**
 * Meant to be overriden by the UIManager when running in the UI Thread.
 * Used for preserving API compatibility with Web Workers.
 * When running in Web Worker mode, this property won't be mutated.
 *
 * Assigned method will be invoked for every message posted by `famous-core`.
 *
 * @type {Function}
 * @override
 */
Channel.prototype.onmessage = null;

/**
 * Sends a message to the manager of this channel (the `Famous` singleton) by
 * invoking `onMessage`.
 * Used for preserving API compatibility with Web Workers.
 *
 * @private
 * @alias onMessage
 *
 * @param {Any} message a message to send over the channel
 *
 * @return {undefined} undefined
 */
Channel.prototype.postMessage = function postMessage(message) {
    return this.onMessage(message);
};

module.exports = Channel;

},{}],5:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Equivalent of an Engine in the Worker Thread. Used to synchronize and manage
 * time across different Threads.
 *
 * @class  Clock
 * @constructor
 * @private
 */
function Clock () {
    this._time = 0;
    this._frame = 0;
    this._timerQueue = [];
    this._updatingIndex = 0;

    this._scale = 1;
    this._scaledTime = this._time;
}

/**
 * Sets the scale at which the clock time is passing.
 * Useful for slow-motion or fast-forward effects.
 *
 * `1` means no time scaling ("realtime"),
 * `2` means the clock time is passing twice as fast,
 * `0.5` means the clock time is passing two times slower than the "actual"
 * time at which the Clock is being updated via `.step`.
 *
 * Initally the clock time is not being scaled (factor `1`).
 *
 * @method  setScale
 * @chainable
 *
 * @param {Number} scale    The scale at which the clock time is passing.
 *
 * @return {Clock} this
 */
Clock.prototype.setScale = function setScale (scale) {
    this._scale = scale;
    return this;
};

/**
 * @method  getScale
 *
 * @return {Number} scale    The scale at which the clock time is passing.
 */
Clock.prototype.getScale = function getScale () {
    return this._scale;
};

/**
 * Updates the internal clock time.
 *
 * @method  step
 * @chainable
 *
 * @param  {Number} time high resolution timestamp used for invoking the
 *                       `update` method on all registered objects
 * @return {Clock}       this
 */
Clock.prototype.step = function step (time) {
    this._frame++;

    this._scaledTime = this._scaledTime + (time - this._time)*this._scale;
    this._time = time;

    for (var i = 0; i < this._timerQueue.length; i++) {
        if (this._timerQueue[i](this._scaledTime)) {
            this._timerQueue.splice(i, 1);
        }
    }
    return this;
};

/**
 * Returns the internal clock time.
 *
 * @method  now
 *
 * @return  {Number} time high resolution timestamp used for invoking the
 *                       `update` method on all registered objects
 */
Clock.prototype.now = function now () {
    return this._scaledTime;
};

/**
 * Returns the internal clock time.
 *
 * @method  getTime
 * @deprecated Use #now instead
 *
 * @return  {Number} time high resolution timestamp used for invoking the
 *                       `update` method on all registered objects
 */
Clock.prototype.getTime = Clock.prototype.now;

/**
 * Returns the number of frames elapsed so far.
 *
 * @method getFrame
 *
 * @return {Number} frames
 */
Clock.prototype.getFrame = function getFrame () {
    return this._frame;
};

/**
 * Wraps a function to be invoked after a certain amount of time.
 * After a set duration has passed, it executes the function and
 * removes it as a listener to 'prerender'.
 *
 * @method setTimeout
 *
 * @param {Function} callback function to be run after a specified duration
 * @param {Number} delay milliseconds from now to execute the function
 *
 * @return {Function} timer function used for Clock#clearTimer
 */
Clock.prototype.setTimeout = function (callback, delay) {
    var params = Array.prototype.slice.call(arguments, 2);
    var startedAt = this._time;
    var timer = function(time) {
        if (time - startedAt >= delay) {
            callback.apply(null, params);
            return true;
        }
        return false;
    };
    this._timerQueue.push(timer);
    return timer;
};


/**
 * Wraps a function to be invoked after a certain amount of time.
 *  After a set duration has passed, it executes the function and
 *  resets the execution time.
 *
 * @method setInterval
 *
 * @param {Function} callback function to be run after a specified duration
 * @param {Number} delay interval to execute function in milliseconds
 *
 * @return {Function} timer function used for Clock#clearTimer
 */
Clock.prototype.setInterval = function setInterval(callback, delay) {
    var params = Array.prototype.slice.call(arguments, 2);
    var startedAt = this._time;
    var timer = function(time) {
        if (time - startedAt >= delay) {
            callback.apply(null, params);
            startedAt = time;
        }
        return false;
    };
    this._timerQueue.push(timer);
    return timer;
};

/**
 * Removes previously via `Clock#setTimeout` or `Clock#setInterval`
 * registered callback function
 *
 * @method clearTimer
 * @chainable
 *
 * @param  {Function} timer  previously by `Clock#setTimeout` or
 *                              `Clock#setInterval` returned callback function
 * @return {Clock}              this
 */
Clock.prototype.clearTimer = function (timer) {
    var index = this._timerQueue.indexOf(timer);
    if (index !== -1) {
        this._timerQueue.splice(index, 1);
    }
    return this;
};

module.exports = Clock;


},{}],6:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * An enumeration of the commands in our command queue.
 */
var Commands = {
    INIT_DOM: 0,
    DOM_RENDER_SIZE: 1,
    CHANGE_TRANSFORM: 2,
    CHANGE_SIZE: 3,
    CHANGE_PROPERTY: 4,
    CHANGE_CONTENT: 5,
    CHANGE_ATTRIBUTE: 6,
    ADD_CLASS: 7,
    REMOVE_CLASS: 8,
    SUBSCRIBE: 9,
    GL_SET_DRAW_OPTIONS: 10,
    GL_AMBIENT_LIGHT: 11,
    GL_LIGHT_POSITION: 12,
    GL_LIGHT_COLOR: 13,
    MATERIAL_INPUT: 14,
    GL_SET_GEOMETRY: 15,
    GL_UNIFORMS: 16,
    GL_BUFFER_DATA: 17,
    GL_CUTOUT_STATE: 18,
    GL_MESH_VISIBILITY: 19,
    GL_REMOVE_MESH: 20,
    PINHOLE_PROJECTION: 21,
    ORTHOGRAPHIC_PROJECTION: 22,
    CHANGE_VIEW_TRANSFORM: 23,
    WITH: 24,
    FRAME: 25,
    ENGINE: 26,
    START: 27,
    STOP: 28,
    TIME: 29,
    TRIGGER: 30,
    NEED_SIZE_FOR: 31,
    DOM: 32,
    READY: 33,
    ALLOW_DEFAULT: 34,
    PREVENT_DEFAULT: 35
};

module.exports = Commands;

},{}],7:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Event = require('./Event');
var PathUtils = require('./Path');

/**
 * The Dispatch class is used to propogate events down the
 * scene graph.
 *
 * @class Dispatch
 * @param {Scene} context The context on which it operates
 * @constructor
 */
function Dispatch () {
    this._nodes = {}; // a container for constant time lookup of nodes

    this._queue = []; // The queue is used for two purposes
                      // 1. It is used to list indicies in the
                      //    Nodes path which are then used to lookup
                      //    a node in the scene graph.
                      // 2. It is used to assist dispatching
                      //    such that it is possible to do a breadth first
                      //    traversal of the scene graph.
}

/**
 * Protected method that sets the updater for the dispatch. The updater will
 * almost certainly be the FamousEngine class.
 *
 * @method
 * @protected
 *
 * @param {FamousEngine} updater The updater which will be passed through the scene graph
 *
 * @return {undefined} undefined
 */
Dispatch.prototype._setUpdater = function _setUpdater (updater) {
    this._updater = updater;

    for (var key in this._nodes) this._nodes[key]._setUpdater(updater);
};

/**
 * Enque the children of a node within the dispatcher. Does not clear
 * the dispatchers queue first.
 *
 * @method addChildrenToQueue
 * @return {void}
 *
 * @param {Node} node from which to add children to the queue
 */
Dispatch.prototype.addChildrenToQueue = function addChildrenToQueue (node) {
    var children = node.getChildren();
    var child;
    for (var i = 0, len = children.length ; i < len ; i++) {
        child = children[i];
        if (child) this._queue.push(child);
    }
};

/**
 * Returns the next item in the Dispatch's queue.
 *
 * @method next
 * @return {Node} next node in the queue
 */
Dispatch.prototype.next = function next () {
    return this._queue.shift();
};

/**
 * Returns the next node in the queue, but also adds its children to
 * the end of the queue. Continually calling this method will result
 * in a breadth first traversal of the render tree.
 *
 * @method breadthFirstNext
 * @return {Node | undefined} the next node in the traversal if one exists
 */
Dispatch.prototype.breadthFirstNext = function breadthFirstNext () {
    var child = this._queue.shift();
    if (!child) return void 0; 
    this.addChildrenToQueue(child);
    return child;
};

/**
 * Calls the onMount method for the node at a given path and
 * properly registers all of that nodes children to their proper
 * paths. Throws if that path doesn't have a node registered as
 * a parent or if there is no node registered at that path.
 *
 * @method mount
 *
 * @param {String} path at which to begin mounting
 * @param {Node} node the node that was mounted
 *
 * @return {void}
 */
Dispatch.prototype.mount = function mount (path, node) {
    if (!node) throw new Error('Dispatch: no node passed to mount at: ' + path);
    if (this._nodes[path])
        throw new Error('Dispatch: there is a node already registered at: ' + path);

    node._setUpdater(this._updater);
    this._nodes[path] = node;
    var parentPath = PathUtils.parent(path);

    // scenes are their own parents
    var parent = !parentPath ? node : this._nodes[parentPath];

    if (!parent)
        throw new Error(
                'Parent to path: ' + path +
                ' doesn\'t exist at expected path: ' + parentPath
        );

    var children = node.getChildren();
    var components = node.getComponents();
    var i;
    var len;

    if (parent.isMounted()) node._setMounted(true, path);
    if (parent.isShown()) node._setShown(true);

    if (parent.isMounted()) {
        node._setParent(parent);
        if (node.onMount) node.onMount(path);

        for (i = 0, len = components.length ; i < len ; i++)
            if (components[i] && components[i].onMount)
                components[i].onMount(node, i);

        for (i = 0, len = children.length ; i < len ; i++)
            if (children[i] && children[i].mount) children[i].mount(path + '/' + i);
            else if (children[i]) this.mount(path + '/' + i, children[i]);
    }

    if (parent.isShown()) {
        if (node.onShow) node.onShow();
        for (i = 0, len = components.length ; i < len ; i++)
            if (components[i] && components[i].onShow)
                components[i].onShow();
    }
};

/**
 * Calls the onDismount method for the node at a given path
 * and deregisters all of that nodes children. Throws if there
 * is no node registered at that path.
 *
 * @method dismount
 * @return {void}
 *
 * @param {String} path at which to begin dismounting
 */
Dispatch.prototype.dismount = function dismount (path) {
    var node = this._nodes[path];

    if (!node)
        throw new Error(
                'No node registered to path: ' + path
        );

    var children = node.getChildren();
    var components = node.getComponents();
    var i;
    var len;

    if (node.isShown()) {
        node._setShown(false);
        if (node.onHide) node.onHide();
        for (i = 0, len = components.length ; i < len ; i++)
            if (components[i] && components[i].onHide)
                components[i].onHide();
    }

    if (node.isMounted()) {
        if (node.onDismount) node.onDismount(path);

        for (i = 0, len = children.length ; i < len ; i++)
            if (children[i] && children[i].dismount) children[i].dismount();
            else if (children[i]) this.dismount(path + '/' + i);

        for (i = 0, len = components.length ; i < len ; i++)
            if (components[i] && components[i].onDismount)
                components[i].onDismount();

        node._setMounted(false);
        node._setParent(null);
    }

    this._nodes[path] = null;
};

/**
 * Returns a the node registered to the given path, or none
 * if no node exists at that path.
 *
 * @method getNode
 * @return {Node | void} node at the given path
 *
 * @param {String} path at which to look up the node
 */
Dispatch.prototype.getNode = function getNode (path) {
    return this._nodes[path];
};

/**
 * Issues the onShow method to the node registered at the given path,
 * and shows the entire subtree below that node. Throws if no node
 * is registered to this path.
 *
 * @method show
 * @return {void}
 *
 * @param {String} path the path of the node to show
 */
Dispatch.prototype.show = function show (path) {
    var node = this._nodes[path];

    if (!node)
        throw new Error(
                'No node registered to path: ' + path
        );

    if (node.onShow) node.onShow();

    this.addChildrenToQueue(node);
    var child;

    while ((child = this.breadthFirstNext()))
        this.show(child.getLocation());

};

/**
 * Issues the onHide method to the node registered at the given path,
 * and hides the entire subtree below that node. Throws if no node
 * is registered to this path.
 *
 * @method hide
 * @return {void}
 *
 * @param {String} path the path of the node to hide
 */
Dispatch.prototype.hide = function hide (path) {
    var node = this._nodes[path];

    if (!node)
        throw new Error(
                'No node registered to path: ' + path
        );

    if (node.onHide) node.onHide();

    this.addChildrenToQueue(node);
    var child;

    while ((child = this.breadthFirstNext()))
        this.hide(child.getLocation());

};

/**
 * lookupNode takes a path and returns the node at the location specified
 * by the path, if one exists. If not, it returns undefined.
 *
 * @param {String} location The location of the node specified by its path
 *
 * @return {Node | undefined} The node at the requested path
 */
Dispatch.prototype.lookupNode = function lookupNode (location) {
    if (!location) throw new Error('lookupNode must be called with a path');

    this._queue.length = 0;
    var path = this._queue;

    _splitTo(location, path);

    for (var i = 0, len = path.length ; i < len ; i++)
        path[i] = this._nodes[path[i]];

    return path[path.length - 1];
};

/**
 * dispatch takes an event name and a payload and dispatches it to the
 * entire scene graph below the node that the dispatcher is on. The nodes
 * receive the events in a breadth first traversal, meaning that parents
 * have the opportunity to react to the event before children.
 *
 * @param {String} path path of the node to send the event to
 * @param {String} event name of the event
 * @param {Any} payload data associated with the event
 *
 * @return {undefined} undefined
 */
Dispatch.prototype.dispatch = function dispatch (path, event, payload) {
    if (!path) throw new Error('dispatch requires a path as it\'s first argument');
    if (!event) throw new Error('dispatch requires an event name as it\'s second argument');

    var node = this._nodes[path];
    if (!node)
        throw new Error('No node registered at path: ' + path);

    this.addChildrenToQueue(node);
    var child;

    while ((child = this.breadthFirstNext()))
        if (child.onReceive)
            child.onReceive(event, payload);

};

/**
 * dispatchUIevent takes a path, an event name, and a payload and dispatches them in
 * a manner anologous to DOM bubbling. It first traverses down to the node specified at
 * the path. That node receives the event first, and then every ancestor receives the event
 * until the context.
 *
 * @param {String} path the path of the node
 * @param {String} event the event name
 * @param {Any} payload the payload
 *
 * @return {undefined} undefined
 */
Dispatch.prototype.dispatchUIEvent = function dispatchUIEvent (path, event, payload) {
    if (!path) throw new Error('dispatchUIEvent needs a valid path to dispatch to');
    if (!event) throw new Error('dispatchUIEvent needs an event name as its second argument');
    var node;

    Event.call(payload);
    node = this.getNode(path);
    if (node) {
        var parent;
        var components;
        var i;
        var len;

        payload.node = node;

        while (node) {
            if (node.onReceive) node.onReceive(event, payload);
            components = node.getComponents();

            for (i = 0, len = components.length ; i < len ; i++)
                if (components[i] && components[i].onReceive)
                    components[i].onReceive(event, payload);

            if (payload.propagationStopped) break;
            parent = node.getParent();
            if (parent === node) return;
            node = parent;
        }
    }
};

/**
 * _splitTo is a private method which takes a path and splits it at every '/'
 * pushing the result into the supplied array. This is a destructive change.
 *
 * @private
 * @param {String} string the specified path
 * @param {Array} target the array to which the result should be written
 *
 * @return {Array} the target after having been written to
 */
function _splitTo (string, target) {
    target.length = 0; // clears the array first.
    var last = 0;
    var i;
    var len = string.length;

    for (i = 0 ; i < len ; i++) {
        if (string[i] === '/') {
            target.push(string.substring(last, i));
            last = i + 1;
        }
    }

    if (i - last > 0) target.push(string.substring(last, i));

    return target;
}

module.exports = new Dispatch();

},{"./Event":8,"./Path":11}],8:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * The Event class adds the stopPropagation functionality
 * to the UIEvents within the scene graph.
 *
 * @constructor Event
 */
function Event () {
    this.propagationStopped = false;
    this.stopPropagation = stopPropagation;
}

/**
 * stopPropagation ends the bubbling of the event in the
 * scene graph.
 *
 * @method stopPropagation
 *
 * @return {undefined} undefined
 */
function stopPropagation () {
    this.propagationStopped = true;
}

module.exports = Event;


},{}],9:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Clock = require('./Clock');
var Scene = require('./Scene');
var Channel = require('./Channel');
var Dispatch = require('./Dispatch');
var UIManager = require('../renderers/UIManager');
var Compositor = require('../renderers/Compositor');
var RequestAnimationFrameLoop = require('../render-loops/RequestAnimationFrameLoop');
var TransformSystem = require('./TransformSystem');
var SizeSystem = require('./SizeSystem');
var Commands = require('./Commands');

var ENGINE_START = [Commands.ENGINE, Commands.START];
var ENGINE_STOP = [Commands.ENGINE, Commands.STOP];
var TIME_UPDATE = [Commands.TIME, null];

/**
 * Famous has two responsibilities, one to act as the highest level
 * updater and another to send messages over to the renderers. It is
 * a singleton.
 *
 * @class FamousEngine
 * @constructor
 */
function FamousEngine() {
    var _this = this;

    Dispatch._setUpdater(this);

    this._updateQueue = []; // The updateQueue is a place where nodes
                            // can place themselves in order to be
                            // updated on the frame.

    this._nextUpdateQueue = []; // the nextUpdateQueue is used to queue
                                // updates for the next tick.
                                // this prevents infinite loops where during
                                // an update a node continuously puts itself
                                // back in the update queue.

    this._scenes = {}; // a hash of all of the scenes's that the FamousEngine
                         // is responsible for.

    this._messages = TIME_UPDATE;   // a queue of all of the draw commands to
                                    // send to the the renderers this frame.

    this._inUpdate = false; // when the famous is updating this is true.
                            // all requests for updates will get put in the
                            // nextUpdateQueue

    this._clock = new Clock(); // a clock to keep track of time for the scene
                               // graph.


    this._channel = new Channel();
    this._channel.onMessage = function (message) {
        _this.handleMessage(message);
    };
}


/**
 * An init script that initializes the FamousEngine with options
 * or default parameters.
 *
 * @method
 *
 * @param {Object} options a set of options containing a compositor and a render loop
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.init = function init(options) {
    this.compositor = options && options.compositor || new Compositor();
    this.renderLoop = options && options.renderLoop || new RequestAnimationFrameLoop();
    this.uiManager = new UIManager(this.getChannel(), this.compositor, this.renderLoop);
    return this;
};

/**
 * Sets the channel that the engine will use to communicate to
 * the renderers.
 *
 * @method
 *
 * @param {Channel} channel     The channel to be used for communicating with
 *                              the `UIManager`/ `Compositor`.
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.setChannel = function setChannel(channel) {
    this._channel = channel;
    return this;
};

/**
 * Returns the channel that the engine is currently using
 * to communicate with the renderers.
 *
 * @method
 *
 * @return {Channel} channel    The channel to be used for communicating with
 *                              the `UIManager`/ `Compositor`.
 */
FamousEngine.prototype.getChannel = function getChannel () {
    return this._channel;
};

/**
 * _update is the body of the update loop. The frame consists of
 * pulling in appending the nextUpdateQueue to the currentUpdate queue
 * then moving through the updateQueue and calling onUpdate with the current
 * time on all nodes. While _update is called _inUpdate is set to true and
 * all requests to be placed in the update queue will be forwarded to the
 * nextUpdateQueue.
 *
 * @method
 *
 * @return {undefined} undefined
 */
FamousEngine.prototype._update = function _update () {
    this._inUpdate = true;
    var time = this._clock.now();
    var nextQueue = this._nextUpdateQueue;
    var queue = this._updateQueue;
    var item;

    this._messages[1] = time;

    SizeSystem.update();
    TransformSystem.onUpdate();

    while (nextQueue.length) queue.unshift(nextQueue.pop());

    while (queue.length) {
        item = queue.shift();
        if (item && item.update) item.update(time);
        if (item && item.onUpdate) item.onUpdate(time);
    }

    this._inUpdate = false;
};

/**
 * requestUpdates takes a class that has an onUpdate method and puts it
 * into the updateQueue to be updated at the next frame.
 * If FamousEngine is currently in an update, requestUpdate
 * passes its argument to requestUpdateOnNextTick.
 *
 * @method
 *
 * @param {Object} requester an object with an onUpdate method
 *
 * @return {undefined} undefined
 */
FamousEngine.prototype.requestUpdate = function requestUpdate (requester) {
    if (!requester)
        throw new Error(
            'requestUpdate must be called with a class to be updated'
        );

    if (this._inUpdate) this.requestUpdateOnNextTick(requester);
    else this._updateQueue.push(requester);
};

/**
 * requestUpdateOnNextTick is requests an update on the next frame.
 * If FamousEngine is not currently in an update than it is functionally equivalent
 * to requestUpdate. This method should be used to prevent infinite loops where
 * a class is updated on the frame but needs to be updated again next frame.
 *
 * @method
 *
 * @param {Object} requester an object with an onUpdate method
 *
 * @return {undefined} undefined
 */
FamousEngine.prototype.requestUpdateOnNextTick = function requestUpdateOnNextTick (requester) {
    this._nextUpdateQueue.push(requester);
};

/**
 * postMessage sends a message queue into FamousEngine to be processed.
 * These messages will be interpreted and sent into the scene graph
 * as events if necessary.
 *
 * @method
 *
 * @param {Array} messages an array of commands.
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.handleMessage = function handleMessage (messages) {
    if (!messages)
        throw new Error(
            'onMessage must be called with an array of messages'
        );

    var command;

    while (messages.length > 0) {
        command = messages.shift();
        switch (command) {
            case Commands.WITH:
                this.handleWith(messages);
                break;
            case Commands.FRAME:
                this.handleFrame(messages);
                break;
            default:
                throw new Error('received unknown command: ' + command);
        }
    }
    return this;
};

/**
 * handleWith is a method that takes an array of messages following the
 * WITH command. It'll then issue the next commands to the path specified
 * by the WITH command.
 *
 * @method
 *
 * @param {Array} messages array of messages.
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.handleWith = function handleWith (messages) {
    var path = messages.shift();
    var command = messages.shift();
    switch (command) {
        case Commands.TRIGGER: // the TRIGGER command sends a UIEvent to the specified path
            var type = messages.shift();
            var ev = messages.shift();
            Dispatch.dispatchUIEvent(path, type, ev);
            break;
        default:
            throw new Error('received unknown command: ' + command);
    }
    return this;
};

/**
 * handleFrame is called when the renderers issue a FRAME command to
 * FamousEngine. FamousEngine will then step updating the scene graph to the current time.
 *
 * @method
 *
 * @param {Array} messages array of messages.
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.handleFrame = function handleFrame (messages) {
    if (!messages) throw new Error('handleFrame must be called with an array of messages');
    if (!messages.length) throw new Error('FRAME must be sent with a time');

    this.step(messages.shift());
    return this;
};

/**
 * step updates the clock and the scene graph and then sends the draw commands
 * that accumulated in the update to the renderers.
 *
 * @method
 *
 * @param {Number} time current engine time
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.step = function step (time) {
    if (time == null) throw new Error('step must be called with a time');

    this._clock.step(time);
    this._update();

    if (this._messages.length) {
        this._channel.sendMessage(this._messages);
        while (this._messages.length > 2) this._messages.pop();
    }

    return this;
};

/**
 * returns the context of a particular path. The context is looked up by the selector
 * portion of the path and is listed from the start of the string to the first
 * '/'.
 *
 * @method
 *
 * @param {String} selector the path to look up the context for.
 *
 * @return {Context | Undefined} the context if found, else undefined.
 */
FamousEngine.prototype.getContext = function getContext (selector) {
    if (!selector) throw new Error('getContext must be called with a selector');

    var index = selector.indexOf('/');
    selector = index === -1 ? selector : selector.substring(0, index);

    return this._scenes[selector];
};

/**
 * Returns the instance of clock used by the FamousEngine.
 *
 * @method
 *
 * @return {Clock} FamousEngine's clock
 */
FamousEngine.prototype.getClock = function getClock () {
    return this._clock;
};

/**
 * Enqueues a message to be transfered to the renderers.
 *
 * @method
 *
 * @param {Any} command Draw Command
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.message = function message (command) {
    this._messages.push(command);
    return this;
};

/**
 * Creates a scene under which a scene graph could be built.
 *
 * @method
 *
 * @param {String} selector a dom selector for where the scene should be placed
 *
 * @return {Scene} a new instance of Scene.
 */
FamousEngine.prototype.createScene = function createScene (selector) {
    selector = selector || 'body';

    if (this._scenes[selector]) this._scenes[selector].dismount();
    this._scenes[selector] = new Scene(selector, this);
    return this._scenes[selector];
};

/**
 * Introduce an already instantiated scene to the engine.
 *
 * @method
 *
 * @param {Scene} scene the scene to reintroduce to the engine
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.addScene = function addScene (scene) {
    var selector = scene._selector;

    var current = this._scenes[selector];
    if (current && current !== scene) current.dismount();
    if (!scene.isMounted()) scene.mount();
    this._scenes[selector] = scene;
    return this;
};

/**
 * Remove a scene.
 *
 * @method
 *
 * @param {Scene} scene the scene to remove from the engine
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.removeScene = function removeScene (scene) {
    var selector = scene._selector;

    var current = this._scenes[selector];
    if (current && current === scene) {
        if (scene.isMounted()) scene.dismount();
        delete this._scenes[selector];
    }
    return this;
};

/**
 * Starts the engine running in the Main-Thread.
 * This effects **every** updateable managed by the Engine.
 *
 * @method
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.startRenderLoop = function startRenderLoop() {
    this._channel.sendMessage(ENGINE_START);
    return this;
};

/**
 * Stops the engine running in the Main-Thread.
 * This effects **every** updateable managed by the Engine.
 *
 * @method
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.stopRenderLoop = function stopRenderLoop() {
    this._channel.sendMessage(ENGINE_STOP);
    return this;
};

/**
 * @method
 * @deprecated Use {@link FamousEngine#startRenderLoop} instead!
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.startEngine = function startEngine() {
    console.warn(
        'FamousEngine.startEngine is deprecated! Use ' +
        'FamousEngine.startRenderLoop instead!'
    );
    return this.startRenderLoop();
};

/**
 * @method
 * @deprecated Use {@link FamousEngine#stopRenderLoop} instead!
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.stopEngine = function stopEngine() {
    console.warn(
        'FamousEngine.stopEngine is deprecated! Use ' +
        'FamousEngine.stopRenderLoop instead!'
    );
    return this.stopRenderLoop();
};

module.exports = new FamousEngine();

},{"../render-loops/RequestAnimationFrameLoop":35,"../renderers/Compositor":36,"../renderers/UIManager":38,"./Channel":4,"./Clock":5,"./Commands":6,"./Dispatch":7,"./Scene":13,"./SizeSystem":15,"./TransformSystem":17}],10:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jshint -W079 */

'use strict';

var SizeSystem = require('./SizeSystem');
var Dispatch = require('./Dispatch');
var TransformSystem = require('./TransformSystem');
var Size = require('./Size');
var Transform = require('./Transform');

/**
 * Nodes define hierarchy and geometrical transformations. They can be moved
 * (translated), scaled and rotated.
 *
 * A Node is either mounted or unmounted. Unmounted nodes are detached from the
 * scene graph. Unmounted nodes have no parent node, while each mounted node has
 * exactly one parent. Nodes have an arbitary number of children, which can be
 * dynamically added using {@link Node#addChild}.
 *
 * Each Node has an arbitrary number of `components`. Those components can
 * send `draw` commands to the renderer or mutate the node itself, in which case
 * they define behavior in the most explicit way. Components that send `draw`
 * commands are considered `renderables`. From the node's perspective, there is
 * no distinction between nodes that send draw commands and nodes that define
 * behavior.
 *
 * Because of the fact that Nodes themself are very unopinioted (they don't
 * "render" to anything), they are often being subclassed in order to add e.g.
 * components at initialization to them. Because of this flexibility, they might
 * as well have been called `Entities`.
 *
 * @example
 * // create three detached (unmounted) nodes
 * var parent = new Node();
 * var child1 = new Node();
 * var child2 = new Node();
 *
 * // build an unmounted subtree (parent is still detached)
 * parent.addChild(child1);
 * parent.addChild(child2);
 *
 * // mount parent by adding it to the context
 * var context = Famous.createContext("body");
 * context.addChild(parent);
 *
 * @class Node
 * @constructor
 */
function Node () {
    this._requestingUpdate = false;
    this._inUpdate = false;
    this._mounted = false;
    this._shown = false;
    this._updater = null;
    this._opacity = 1;
    this._UIEvents = [];

    this._updateQueue = [];
    this._nextUpdateQueue = [];

    this._freedComponentIndicies = [];
    this._components = [];

    this._freedChildIndicies = [];
    this._children = [];

    this._parent = null;

    this._id = null;

    this._transformID = null;
    this._sizeID = null;

    if (this.constructor.INIT_DEFAULT_COMPONENTS) this._init();
}

Node.RELATIVE_SIZE = 0;
Node.ABSOLUTE_SIZE = 1;
Node.RENDER_SIZE = 2;
Node.DEFAULT_SIZE = 0;
Node.INIT_DEFAULT_COMPONENTS = true;

/**
 * Protected method. Initializes a node with a default Transform and Size component
 *
 * @method
 * @protected
 *
 * @return {undefined} undefined
 */
Node.prototype._init = function _init () {
    this._transformID = this.addComponent(new Transform());
    this._sizeID = this.addComponent(new Size());
};

/**
 * Protected method. Sets the parent of this node such that it can be looked up.
 *
 * @method
 * 
 * @param {Node} parent The node to set as the parent of this
 *
 * @return {undefined} undefined;
 */
Node.prototype._setParent = function _setParent (parent) {
    if (this._parent && this._parent.getChildren().indexOf(this) !== -1) {
        this._parent.removeChild(this);
    }
    this._parent = parent;
};

/**
 * Protected method. Sets the mount state of the node. Should only be called
 * by the dispatch
 *
 * @method
 *
 * @param {Boolean} mounted whether or not the Node is mounted.
 * @param {String} path The path that the node will be mounted to
 *
 * @return {undefined} undefined
 */
Node.prototype._setMounted = function _setMounted (mounted, path) {
    this._mounted = mounted;
    this._id = path ? path : null;
};

/**
 * Protected method, sets whether or not the Node is shown. Should only
 * be called by the dispatch
 *
 * @method
 *
 * @param {Boolean} shown whether or not the node is shown
 *
 * @return {undefined} undefined
 */
Node.prototype._setShown = function _setShown (shown) {
    this._shown = shown;
};

/**
 * Protected method. Sets the updater of the node.
 *
 * @method
 *
 * @param {FamousEngine} updater the Updater of the node.
 *
 * @return {undefined} undefined
 */
Node.prototype._setUpdater = function _setUpdater (updater) {
    this._updater = updater;
    if (this._requestingUpdate) this._updater.requestUpdate(this);
};

/**
 * Determine the node's location in the scene graph hierarchy.
 * A location of `body/0/1` can be interpreted as the following scene graph
 * hierarchy (ignoring siblings of ancestors and additional child nodes):
 *
 * `Context:body` -> `Node:0` -> `Node:1`, where `Node:1` is the node the
 * `getLocation` method has been invoked on.
 *
 * @method getLocation
 *
 * @return {String} location (path), e.g. `body/0/1`
 */
Node.prototype.getLocation = function getLocation () {
    return this._id;
};

/**
 * @alias getId
 *
 * @return {String} the path of the Node
 */
Node.prototype.getId = Node.prototype.getLocation;

/**
 * Globally dispatches the event using the Dispatch. All descendent nodes will
 * receive the dispatched event.
 *
 * @method emit
 *
 * @param  {String} event   Event type.
 * @param  {Object} payload Event object to be dispatched.
 *
 * @return {Node} this
 */
Node.prototype.emit = function emit (event, payload) {
    Dispatch.dispatch(this.getLocation(), event, payload);
    return this;
};

// THIS WILL BE DEPRECATED
Node.prototype.sendDrawCommand = function sendDrawCommand (message) {
    this._updater.message(message);
    return this;
};

/**
 * Recursively serializes the Node, including all previously added components.
 *
 * @method getValue
 *
 * @return {Object}     Serialized representation of the node, including
 *                      components.
 */
Node.prototype.getValue = function getValue () {
    var numberOfChildren = this._children.length;
    var numberOfComponents = this._components.length;
    var i = 0;
 
    var value = {
        location: this.getId(),
        spec: {
            location: this.getId(),
            showState: {
                mounted: this.isMounted(),
                shown: this.isShown(),
                opacity: this.getOpacity() || null
            },
            offsets: {
                mountPoint: [0, 0, 0],
                align: [0, 0, 0],
                origin: [0, 0, 0]
            },
            vectors: {
                position: [0, 0, 0],
                rotation: [0, 0, 0, 1],
                scale: [1, 1, 1]
            },
            size: {
                sizeMode: [0, 0, 0],
                proportional: [1, 1, 1],
                differential: [0, 0, 0],
                absolute: [0, 0, 0],
                render: [0, 0, 0]
            }
        },
        UIEvents: this._UIEvents,
        components: [],
        children: []
    };
    
    if (value.location) {
        var transform = TransformSystem.get(this.getId());
        var size = SizeSystem.get(this.getId());

        for (i = 0 ; i < 3 ; i++) {
            value.spec.offsets.mountPoint[i] = transform.offsets.mountPoint[i];
            value.spec.offsets.align[i] = transform.offsets.align[i];
            value.spec.offsets.origin[i] = transform.offsets.origin[i];
            value.spec.vectors.position[i] = transform.vectors.position[i];
            value.spec.vectors.rotation[i] = transform.vectors.rotation[i];
            value.spec.vectors.scale[i] = transform.vectors.scale[i];
            value.spec.size.sizeMode[i] = size.sizeMode[i];
            value.spec.size.proportional[i] = size.proportionalSize[i];
            value.spec.size.differential[i] = size.differentialSize[i];
            value.spec.size.absolute[i] = size.absoluteSize[i];
            value.spec.size.render[i] = size.renderSize[i];
        }

        value.spec.vectors.rotation[3] = transform.vectors.rotation[3];
    }

    for (i = 0; i < numberOfChildren ; i++)
        if (this._children[i] && this._children[i].getValue)
            value.children.push(this._children[i].getValue());

    for (i = 0 ; i < numberOfComponents ; i++)
        if (this._components[i] && this._components[i].getValue)
            value.components.push(this._components[i].getValue());

    return value;
};

/**
 * Similar to {@link Node#getValue}, but returns the actual "computed" value. E.g.
 * a proportional size of 0.5 might resolve into a "computed" size of 200px
 * (assuming the parent has a width of 400px).
 *
 * @method getComputedValue
 *
 * @return {Object}     Serialized representation of the node, including
 *                      children, excluding components.
 */
Node.prototype.getComputedValue = function getComputedValue () {
    console.warn('Node.getComputedValue is depricated. Use Node.getValue instead');
    var numberOfChildren = this._children.length;

    var value = {
        location: this.getId(),
        computedValues: {
            transform: this.isMounted() ? TransformSystem.get(this.getLocation()).getLocalTransform() : null,
            size: this.isMounted() ? SizeSystem.get(this.getLocation()).get() : null
        },
        children: []
    };

    for (var i = 0 ; i < numberOfChildren ; i++)
        if (this._children[i] && this._children[i].getComputedValue)
            value.children.push(this._children[i].getComputedValue());

    return value;
};

/**
 * Retrieves all children of the current node.
 *
 * @method getChildren
 *
 * @return {Array.<Node>}   An array of children.
 */
Node.prototype.getChildren = function getChildren () {
    return this._children;
};

/**
 * Retrieves the parent of the current node. Unmounted nodes do not have a
 * parent node.
 *
 * @method getParent
 *
 * @return {Node}       Parent node.
 */
Node.prototype.getParent = function getParent () {
    return this._parent;
};

/**
 * Schedules the {@link Node#update} function of the node to be invoked on the
 * next frame (if no update during this frame has been scheduled already).
 * If the node is currently being updated (which means one of the requesters
 * invoked requestsUpdate while being updated itself), an update will be
 * scheduled on the next frame.
 *
 * @method requestUpdate
 *
 * @param  {Object} requester   If the requester has an `onUpdate` method, it
 *                              will be invoked during the next update phase of
 *                              the node.
 *
 * @return {Node} this
 */
Node.prototype.requestUpdate = function requestUpdate (requester) {
    if (this._inUpdate || !this.isMounted())
        return this.requestUpdateOnNextTick(requester);
    this._updateQueue.push(requester);
    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};

/**
 * Schedules an update on the next tick. Similarily to
 * {@link Node#requestUpdate}, `requestUpdateOnNextTick` schedules the node's
 * `onUpdate` function to be invoked on the frame after the next invocation on
 * the node's onUpdate function.
 *
 * @method requestUpdateOnNextTick
 *
 * @param  {Object} requester   If the requester has an `onUpdate` method, it
 *                              will be invoked during the next update phase of
 *                              the node.
 *
 * @return {Node} this
 */
Node.prototype.requestUpdateOnNextTick = function requestUpdateOnNextTick (requester) {
    this._nextUpdateQueue.push(requester);
    return this;
};

/**
 * Checks if the node is mounted. Unmounted nodes are detached from the scene
 * graph.
 *
 * @method isMounted
 *
 * @return {Boolean}    Boolean indicating whether the node is mounted or not.
 */
Node.prototype.isMounted = function isMounted () {
    return this._mounted;
};

/**
 * Checks if the node is visible ("shown").
 *
 * @method isShown
 *
 * @return {Boolean}    Boolean indicating whether the node is visible
 *                      ("shown") or not.
 */
Node.prototype.isShown = function isShown () {
    return this._shown;
};

/**
 * Determines the node's relative opacity.
 * The opacity needs to be within [0, 1], where 0 indicates a completely
 * transparent, therefore invisible node, whereas an opacity of 1 means the
 * node is completely solid.
 *
 * @method getOpacity
 *
 * @return {Number}         Relative opacity of the node.
 */
Node.prototype.getOpacity = function getOpacity () {
    return this._opacity;
};

/**
 * Determines the node's previously set mount point.
 *
 * @method getMountPoint
 *
 * @return {Float32Array}   An array representing the mount point.
 */
Node.prototype.getMountPoint = function getMountPoint () {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        return this.getComponent(this._transformID).getMountPoint();
    else if (this.isMounted())
        return TransformSystem.get(this.getLocation()).getMountPoint();
    else throw new Error('This node does not have access to a transform component');
};

/**
 * Determines the node's previously set align.
 *
 * @method getAlign
 *
 * @return {Float32Array}   An array representing the align.
 */
Node.prototype.getAlign = function getAlign () {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        return this.getComponent(this._transformID).getAlign();
    else if (this.isMounted())
        return TransformSystem.get(this.getLocation()).getAlign();
    else throw new Error('This node does not have access to a transform component');
};

/**
 * Determines the node's previously set origin.
 *
 * @method getOrigin
 *
 * @return {Float32Array}   An array representing the origin.
 */
Node.prototype.getOrigin = function getOrigin () {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        return this.getComponent(this._transformID).getOrigin();
    else if (this.isMounted())
        return TransformSystem.get(this.getLocation()).getOrigin();
    else throw new Error('This node does not have access to a transform component');
};

/**
 * Determines the node's previously set position.
 *
 * @method getPosition
 *
 * @return {Float32Array}   An array representing the position.
 */
Node.prototype.getPosition = function getPosition () {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        return this.getComponent(this._transformID).getPosition();
    else if (this.isMounted())
        return TransformSystem.get(this.getLocation()).getPosition();
    else throw new Error('This node does not have access to a transform component');
};

/**
 * Returns the node's current rotation
 *
 * @method getRotation
 *
 * @return {Float32Array} an array of four values, showing the rotation as a quaternion
 */
Node.prototype.getRotation = function getRotation () {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        return this.getComponent(this._transformID).getRotation();
    else if (this.isMounted())
        return TransformSystem.get(this.getLocation()).getRotation();
    else throw new Error('This node does not have access to a transform component');
};

/**
 * Returns the scale of the node
 *
 * @method
 *
 * @return {Float32Array} an array showing the current scale vector
 */
Node.prototype.getScale = function getScale () {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        return this.getComponent(this._transformID).getScale();
    else if (this.isMounted())
        return TransformSystem.get(this.getLocation()).getScale();
    else throw new Error('This node does not have access to a transform component');
};

/**
 * Returns the current size mode of the node
 *
 * @method
 *
 * @return {Float32Array} an array of numbers showing the current size mode
 */
Node.prototype.getSizeMode = function getSizeMode () {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        return this.getComponent(this._sizeID).getSizeMode();
    else if (this.isMounted())
        return SizeSystem.get(this.getLocation()).getSizeMode();
    else throw new Error('This node does not have access to a size component');
};

/**
 * Returns the current proportional size
 *
 * @method
 *
 * @return {Float32Array} a vector 3 showing the current proportional size
 */
Node.prototype.getProportionalSize = function getProportionalSize () {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        return this.getComponent(this._sizeID).getProportional();
    else if (this.isMounted())
        return SizeSystem.get(this.getLocation()).getProportional();
    else throw new Error('This node does not have access to a size component');
};

/**
 * Returns the differential size of the node
 *
 * @method
 *
 * @return {Float32Array} a vector 3 showing the current differential size
 */
Node.prototype.getDifferentialSize = function getDifferentialSize () {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        return this.getComponent(this._sizeID).getDifferential();
    else if (this.isMounted())
        return SizeSystem.get(this.getLocation()).getDifferential();
    else throw new Error('This node does not have access to a size component');
};

/**
 * Returns the absolute size of the node
 *
 * @method
 *
 * @return {Float32Array} a vector 3 showing the current absolute size of the node
 */
Node.prototype.getAbsoluteSize = function getAbsoluteSize () {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        return this.getComponent(this._sizeID).getAbsolute();
    else if (this.isMounted())
        return SizeSystem.get(this.getLocation()).getAbsolute();
    else throw new Error('This node does not have access to a size component');
};

/**
 * Returns the current Render Size of the node. Note that the render size
 * is asynchronous (will always be one frame behind) and needs to be explicitely
 * calculated by setting the proper size mode.
 *
 * @method
 *
 * @return {Float32Array} a vector 3 showing the current render size
 */
Node.prototype.getRenderSize = function getRenderSize () {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        return this.getComponent(this._sizeID).getRender();
    else if (this.isMounted())
        return SizeSystem.get(this.getLocation()).getRender();
    else throw new Error('This node does not have access to a size component');
};

/**
 * Returns the external size of the node
 *
 * @method
 *
 * @return {Float32Array} a vector 3 of the final calculated side of the node
 */
Node.prototype.getSize = function getSize () {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        return this.getComponent(this._sizeID).get();
    else if (this.isMounted())
        return SizeSystem.get(this.getLocation()).get();
    else throw new Error('This node does not have access to a size component');
};

/**
 * Returns the current world transform of the node
 *
 * @method
 *
 * @return {Float32Array} a 16 value transform
 */
Node.prototype.getTransform = function getTransform () {
    return TransformSystem.get(this.getLocation());
};

/**
 * Get the list of the UI Events that are currently associated with this node
 *
 * @method
 *
 * @return {Array} an array of strings representing the current subscribed UI event of this node
 */
Node.prototype.getUIEvents = function getUIEvents () {
    return this._UIEvents;
};

/**
 * Adds a new child to this node. If this method is called with no argument it will
 * create a new node, however it can also be called with an existing node which it will
 * append to the node that this method is being called on. Returns the new or passed in node.
 *
 * @method
 *
 * @param {Node | void} child the node to appended or no node to create a new node.
 *
 * @return {Node} the appended node.
 */
Node.prototype.addChild = function addChild (child) {
    var index = child ? this._children.indexOf(child) : -1;
    child = child ? child : new Node();

    if (index === -1) {
        index = this._freedChildIndicies.length ?
                this._freedChildIndicies.pop() : this._children.length;

        this._children[index] = child;
    }

    if (this.isMounted())
        child.mount(this.getLocation() + '/' + index);

    return child;
};

/**
 * Removes a child node from another node. The passed in node must be
 * a child of the node that this method is called upon.
 *
 * @method
 *
 * @param {Node} child node to be removed
 *
 * @return {Boolean} whether or not the node was successfully removed
 */
Node.prototype.removeChild = function removeChild (child) {
    var index = this._children.indexOf(child);

    if (index > - 1) {
        this._freedChildIndicies.push(index);

        this._children[index] = null;

        if (child.isMounted()) child.dismount();

        return true;
    } else throw new Error('Node is not a child of this node');
};

/**
 * Each component can only be added once per node.
 *
 * @method addComponent
 *
 * @param {Object} component    A component to be added.
 * @return {Number} index       The index at which the component has been
 *                              registered. Indices aren't necessarily
 *                              consecutive.
 */
Node.prototype.addComponent = function addComponent (component) {
    var index = this._components.indexOf(component);
    if (index === -1) {
        index = this._freedComponentIndicies.length ? this._freedComponentIndicies.pop() : this._components.length;
        this._components[index] = component;

        if (this.isMounted() && component.onMount)
            component.onMount(this, index);

        if (this.isShown() && component.onShow)
            component.onShow();
    }

    return index;
};

/**
 * @method  getComponent
 *
 * @param  {Number} index   Index at which the component has been registered
 *                          (using `Node#addComponent`).
 * @return {*}              The component registered at the passed in index (if
 *                          any).
 */
Node.prototype.getComponent = function getComponent (index) {
    return this._components[index];
};

/**
 * Removes a previously via {@link Node#addComponent} added component.
 *
 * @method removeComponent
 *
 * @param  {Object} component   An component that has previously been added
 *                              using {@link Node#addComponent}.
 *
 * @return {Node} this
 */
Node.prototype.removeComponent = function removeComponent (component) {
    var index = this._components.indexOf(component);
    if (index !== -1) {
        this._freedComponentIndicies.push(index);
        if (this.isShown() && component.onHide)
            component.onHide();

        if (this.isMounted() && component.onDismount)
            component.onDismount();

        this._components[index] = null;
    }
    return component;
};

/**
 * Removes a node's subscription to a particular UIEvent. All components 
 * on the node will have the opportunity to remove all listeners depending
 * on this event.
 *
 * @method
 *
 * @param {String} eventName the name of the event
 *
 * @return {undefined} undefined
 */
Node.prototype.removeUIEvent = function removeUIEvent (eventName) {
    var UIEvents = this.getUIEvents();
    var components = this._components;
    var component;

    var index = UIEvents.indexOf(eventName);
    if (index !== -1) {
        UIEvents.splice(index, 1);
        for (var i = 0, len = components.length ; i < len ; i++) {
            component = components[i];
            if (component && component.onRemoveUIEvent) component.onRemoveUIEvent(eventName);
        }
    }
};

/**
 * Subscribes a node to a UI Event. All components on the node
 * will have the opportunity to begin listening to that event
 * and alerting the scene graph.
 *
 * @method
 *
 * @param {String} eventName the name of the event
 *
 * @return {undefined} undefined
 */
Node.prototype.addUIEvent = function addUIEvent (eventName) {
    var UIEvents = this.getUIEvents();
    var components = this._components;
    var component;

    var added = UIEvents.indexOf(eventName) !== -1;
    if (!added) {
        UIEvents.push(eventName);
        for (var i = 0, len = components.length ; i < len ; i++) {
            component = components[i];
            if (component && component.onAddUIEvent) component.onAddUIEvent(eventName);
        }
    }
};

/**
 * Private method for the Node to request an update for itself.
 *
 * @method
 * @private
 *
 * @param {Boolean} force whether or not to force the update
 *
 * @return {undefined} undefined
 */
Node.prototype._requestUpdate = function _requestUpdate (force) {
    if (force || !this._requestingUpdate) {
        if (this._updater)
            this._updater.requestUpdate(this);
        this._requestingUpdate = true;
    }
};

/**
 * Private method to set an optional value in an array, and
 * request an update if this changes the value of the array.
 *
 * @method
 *
 * @param {Array} vec the array to insert the value into
 * @param {Number} index the index at which to insert the value
 * @param {Any} val the value to potentially insert (if not null or undefined)
 *
 * @return {Boolean} whether or not a new value was inserted.
 */
Node.prototype._vecOptionalSet = function _vecOptionalSet (vec, index, val) {
    if (val != null && vec[index] !== val) {
        vec[index] = val;
        if (!this._requestingUpdate) this._requestUpdate();
        return true;
    }
    return false;
};

/**
 * Shows the node, which is to say, calls onShow on all of the
 * node's components. Renderable components can then issue the
 * draw commands necessary to be shown.
 *
 * @method
 *
 * @return {Node} this
 */
Node.prototype.show = function show () {
    Dispatch.show(this.getLocation());
    this._shown = true;
    return this;
};

/**
 * Hides the node, which is to say, calls onHide on all of the
 * node's components. Renderable components can then issue
 * the draw commands necessary to be hidden
 *
 * @method
 *
 * @return {Node} this
 */
Node.prototype.hide = function hide () {
    Dispatch.hide(this.getLocation());
    this._shown = false;
    return this;
};

/**
 * Sets the align value of the node. Will call onAlignChange
 * on all of the Node's components.
 *
 * @method
 *
 * @param {Number} x Align value in the x dimension.
 * @param {Number} y Align value in the y dimension.
 * @param {Number} z Align value in the z dimension.
 *
 * @return {Node} this
 */
Node.prototype.setAlign = function setAlign (x, y, z) {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        this.getComponent(this._transformID).setAlign(x, y, z);
    else if (this.isMounted())
        TransformSystem.get(this.getLocation()).setAlign(x, y, z);
    else throw new Error('This node does not have access to a transform component');
    return this;
};

/**
 * Sets the mount point value of the node. Will call onMountPointChange
 * on all of the node's components.
 *
 * @method
 *
 * @param {Number} x MountPoint value in x dimension
 * @param {Number} y MountPoint value in y dimension
 * @param {Number} z MountPoint value in z dimension
 *
 * @return {Node} this
 */
Node.prototype.setMountPoint = function setMountPoint (x, y, z) {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        this.getComponent(this._transformID).setMountPoint(x, y, z);
    else if (this.isMounted())
        TransformSystem.get(this.getLocation()).setMountPoint(x, y, z);
    else throw new Error('This node does not have access to a transform component');
    return this;
};

/**
 * Sets the origin value of the node. Will call onOriginChange
 * on all of the node's components.
 *
 * @method
 *
 * @param {Number} x Origin value in x dimension
 * @param {Number} y Origin value in y dimension
 * @param {Number} z Origin value in z dimension
 *
 * @return {Node} this
 */
Node.prototype.setOrigin = function setOrigin (x, y, z) {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        this.getComponent(this._transformID).setOrigin(x, y, z);
    else if (this.isMounted())
        TransformSystem.get(this.getLocation()).setOrigin(x, y, z);
    else throw new Error('This node does not have access to a transform component');
    return this;
};

/**
 * Sets the position of the node. Will call onPositionChange
 * on all of the node's components.
 *
 * @method
 *
 * @param {Number} x Position in x
 * @param {Number} y Position in y
 * @param {Number} z Position in z
 *
 * @return {Node} this
 */
Node.prototype.setPosition = function setPosition (x, y, z) {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        this.getComponent(this._transformID).setPosition(x, y, z);
    else if (this.isMounted())
        TransformSystem.get(this.getLocation()).setPosition(x, y, z);
    else throw new Error('This node does not have access to a transform component');
    return this;
};

/**
 * Sets the rotation of the node. Will call onRotationChange
 * on all of the node's components. This method takes either
 * Euler angles or a quaternion. If the fourth argument is undefined
 * Euler angles are assumed.
 *
 * @method
 *
 * @param {Number} x Either the rotation around the x axis or the magnitude in x of the axis of rotation.
 * @param {Number} y Either the rotation around the y axis or the magnitude in y of the axis of rotation.
 * @param {Number} z Either the rotation around the z axis or the magnitude in z of the axis of rotation.
 * @param {Number|undefined} w the amount of rotation around the axis of rotation, if a quaternion is specified.
 *
 * @return {Node} this
 */
Node.prototype.setRotation = function setRotation (x, y, z, w) {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        this.getComponent(this._transformID).setRotation(x, y, z, w);
    else if (this.isMounted())
        TransformSystem.get(this.getLocation()).setRotation(x, y, z, w);
    else throw new Error('This node does not have access to a transform component');
    return this;
};

/**
 * Sets the scale of the node. The default value is 1 in all dimensions.
 * The node's components will have onScaleChanged called on them.
 *
 * @method
 *
 * @param {Number} x Scale value in x
 * @param {Number} y Scale value in y
 * @param {Number} z Scale value in z
 *
 * @return {Node} this
 */
Node.prototype.setScale = function setScale (x, y, z) {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        this.getComponent(this._transformID).setScale(x, y, z);
    else if (this.isMounted())
        TransformSystem.get(this.getLocation()).setScale(x, y, z);
    else throw new Error('This node does not have access to a transform component');
    return this;
};

/**
 * Sets the value of the opacity of this node. All of the node's
 * components will have onOpacityChange called on them/
 *
 * @method
 *
 * @param {Number} val Value of the opacity. 1 is the default.
 *
 * @return {Node} this
 */
Node.prototype.setOpacity = function setOpacity (val) {
    if (val !== this._opacity) {
        this._opacity = val;
        if (!this._requestingUpdate) this._requestUpdate();

        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onOpacityChange) item.onOpacityChange(val);
        }
    }
    return this;
};

/**
 * Sets the size mode being used for determining the node's final width, height
 * and depth.
 * Size modes are a way to define the way the node's size is being calculated.
 * Size modes are enums set on the {@link Size} constructor (and aliased on
 * the Node).
 *
 * @example
 * node.setSizeMode(Node.RELATIVE_SIZE, Node.ABSOLUTE_SIZE, Node.ABSOLUTE_SIZE);
 * // Instead of null, any proportional height or depth can be passed in, since
 * // it would be ignored in any case.
 * node.setProportionalSize(0.5, null, null);
 * node.setAbsoluteSize(null, 100, 200);
 *
 * @method setSizeMode
 *
 * @param {SizeMode} x    The size mode being used for determining the size in
 *                        x direction ("width").
 * @param {SizeMode} y    The size mode being used for determining the size in
 *                        y direction ("height").
 * @param {SizeMode} z    The size mode being used for determining the size in
 *                        z direction ("depth").
 *
 * @return {Node} this
 */
Node.prototype.setSizeMode = function setSizeMode (x, y, z) {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        this.getComponent(this._sizeID).setSizeMode(x, y, z);
    else if (this.isMounted())
        SizeSystem.get(this.getLocation()).setSizeMode(x, y, z);
    else throw new Error('This node does not have access to a size component');
    return this;
};

/**
 * A proportional size defines the node's dimensions relative to its parents
 * final size.
 * Proportional sizes need to be within the range of [0, 1].
 *
 * @method setProportionalSize
 *
 * @param {Number} x    x-Size in pixels ("width").
 * @param {Number} y    y-Size in pixels ("height").
 * @param {Number} z    z-Size in pixels ("depth").
 *
 * @return {Node} this
 */
Node.prototype.setProportionalSize = function setProportionalSize (x, y, z) {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        this.getComponent(this._sizeID).setProportional(x, y, z);
    else if (this.isMounted())
        SizeSystem.get(this.getLocation()).setProportional(x, y, z);
    else throw new Error('This node does not have access to a size component');
    return this;
};

/**
 * Differential sizing can be used to add or subtract an absolute size from an
 * otherwise proportionally sized node.
 * E.g. a differential width of `-10` and a proportional width of `0.5` is
 * being interpreted as setting the node's size to 50% of its parent's width
 * *minus* 10 pixels.
 *
 * @method setDifferentialSize
 *
 * @param {Number} x    x-Size to be added to the relatively sized node in
 *                      pixels ("width").
 * @param {Number} y    y-Size to be added to the relatively sized node in
 *                      pixels ("height").
 * @param {Number} z    z-Size to be added to the relatively sized node in
 *                      pixels ("depth").
 *
 * @return {Node} this
 */
Node.prototype.setDifferentialSize = function setDifferentialSize (x, y, z) {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        this.getComponent(this._sizeID).setDifferential(x, y, z);
    else if (this.isMounted())
        SizeSystem.get(this.getLocation()).setDifferential(x, y, z);
    else throw new Error('This node does not have access to a size component');
    return this;
};

/**
 * Sets the node's size in pixels, independent of its parent.
 *
 * @method setAbsoluteSize
 *
 * @param {Number} x x-Size in pixels ("width").
 * @param {Number} y y-Size in pixels ("height").
 * @param {Number} z z-Size in pixels ("depth").
 *
 * @return {Node} this
 */
Node.prototype.setAbsoluteSize = function setAbsoluteSize (x, y, z) {
    if (this.constructor.INIT_DEFAULT_COMPONENTS)
        this.getComponent(this._sizeID).setAbsolute(x, y, z);
    else if (this.isMounted())
        SizeSystem.get(this.getLocation()).setAbsolute(x, y, z);
    else throw new Error('This node does not have access to a size component');
    return this;
};

/**
 * Method for getting the current frame. Will be deprecated.
 *
 * @method
 *
 * @return {Number} current frame
 */
Node.prototype.getFrame = function getFrame () {
    return this._updater.getFrame();
};

/**
 * returns an array of the components currently attached to this
 * node.
 *
 * @method getComponents
 *
 * @return {Array} list of components.
 */
Node.prototype.getComponents = function getComponents () {
    return this._components;
};

/**
 * Enters the node's update phase while updating its own spec and updating its components.
 *
 * @method update
 *
 * @param  {Number} time    high-resolution timestamp, usually retrieved using
 *                          requestAnimationFrame
 *
 * @return {Node} this
 */
Node.prototype.update = function update (time){
    this._inUpdate = true;
    var nextQueue = this._nextUpdateQueue;
    var queue = this._updateQueue;
    var item;

    if (this.onUpdate) this.onUpdate();

    while (nextQueue.length) queue.unshift(nextQueue.pop());

    while (queue.length) {
        item = this._components[queue.shift()];
        if (item && item.onUpdate) item.onUpdate(time);
    }

    this._inUpdate = false;
    this._requestingUpdate = false;

    if (!this.isMounted()) {
        // last update
        this._parent = null;
        this._id = null;
    }
    else if (this._nextUpdateQueue.length) {
        this._updater.requestUpdateOnNextTick(this);
        this._requestingUpdate = true;
    }
    return this;
};

/**
 * Mounts the node and therefore its subtree by setting it as a child of the
 * passed in parent.
 *
 * @method mount
 *
 * @param  {String} path unique path of node (e.g. `body/0/1`)
 *
 * @return {Node} this
 */
Node.prototype.mount = function mount (path) {
    if (this.isMounted())
        throw new Error('Node is already mounted at: ' + this.getLocation());

    if (this.constructor.INIT_DEFAULT_COMPONENTS){
        TransformSystem.registerTransformAtPath(path, this.getComponent(this._transformID));
        SizeSystem.registerSizeAtPath(path, this.getComponent(this._sizeID));
    }
    else {
        TransformSystem.registerTransformAtPath(path);
        SizeSystem.registerSizeAtPath(path);
    }
    Dispatch.mount(path, this);

    if (!this._requestingUpdate) this._requestUpdate();
    return this;

};

/**
 * Dismounts (detaches) the node from the scene graph by removing it as a
 * child of its parent.
 *
 * @method
 *
 * @return {Node} this
 */
Node.prototype.dismount = function dismount () {
    if (!this.isMounted())
        throw new Error('Node is not mounted');

    var path = this.getLocation();

    TransformSystem.deregisterTransformAtPath(path);
    SizeSystem.deregisterSizeAtPath(path);
    Dispatch.dismount(path);

    if (!this._requestingUpdate) this._requestUpdate();
};

module.exports = Node;

},{"./Dispatch":7,"./Size":14,"./SizeSystem":15,"./Transform":16,"./TransformSystem":17}],11:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * A collection of utilities for handling paths.
 *
 * @class
 */
function PathUtils () {
}

/**
 * determines if the passed in path has a trailing slash. Paths of the form
 * 'body/0/1/' return true, while paths of the form 'body/0/1' return false.
 *
 * @method
 *
 * @param {String} path the path
 *
 * @return {Boolean} whether or not the path has a trailing slash
 */
PathUtils.prototype.hasTrailingSlash = function hasTrailingSlash (path) {
    return path[path.length - 1] === '/';
};

/**
 * Returns the depth in the tree this path represents. Essentially counts
 * the slashes ignoring a trailing slash.
 *
 * @method
 *
 * @param {String} path the path
 *
 * @return {Number} the depth in the tree that this path represents
 */
PathUtils.prototype.depth = function depth (path) {
    var count = 0;
    var length = path.length;
    var len = this.hasTrailingSlash(path) ? length - 1 : length;
    var i = 0;
    for (; i < len ; i++) count += path[i] === '/' ? 1 : 0;
    return count;
};

/**
 * Gets the position of this path in relation to its siblings.
 *
 * @method
 *
 * @param {String} path the path
 *
 * @return {Number} the index of this path in relation to its siblings.
 */
PathUtils.prototype.index = function index (path) {
    var length = path.length;
    var len = this.hasTrailingSlash(path) ? length - 1 : length;
    while (len--) if (path[len] === '/') break;
    var result = parseInt(path.substring(len + 1));
    return isNaN(result) ? 0 : result;
};

/**
 * Gets the position of the path at a particular breadth in relationship
 * to its siblings
 *
 * @method
 *
 * @param {String} path the path
 * @param {Number} depth the breadth at which to find the index
 *
 * @return {Number} index at the particular depth
 */
PathUtils.prototype.indexAtDepth = function indexAtDepth (path, depth) {
    var i = 0;
    var len = path.length;
    var index = 0;
    for (; i < len ; i++) {
        if (path[i] === '/') index++;
        if (index === depth) {
            path = path.substring(i ? i + 1 : i);
            index = path.indexOf('/');
            path = index === -1 ? path : path.substring(0, index);
            index = parseInt(path);
            return isNaN(index) ? path : index;
        }
    }
};

/**
 * returns the path of the passed in path's parent.
 *
 * @method
 *
 * @param {String} path the path
 *
 * @return {String} the path of the passed in path's parent
 */
PathUtils.prototype.parent = function parent (path) {
    return path.substring(0, path.lastIndexOf('/', path.length - 2));
};

/**
 * Determines whether or not the first argument path is the direct child
 * of the second argument path.
 *
 * @method
 *
 * @param {String} child the path that may be a child
 * @param {String} parent the path that may be a parent
 *
 * @return {Boolean} whether or not the first argument path is a child of the second argument path
 */
PathUtils.prototype.isChildOf = function isChildOf (child, parent) {
    return this.isDescendentOf(child, parent) && this.depth(child) === this.depth(parent) + 1;
};

/**
 * Returns true if the first argument path is a descendent of the second argument path.
 *
 * @method
 *
 * @param {String} child potential descendent path
 * @param {String} parent potential ancestor path
 *
 * @return {Boolean} whether or not the path is a descendent
 */
PathUtils.prototype.isDescendentOf = function isDescendentOf(child, parent) {
    if (child === parent) return false;
    child = this.hasTrailingSlash(child) ? child : child + '/';
    parent = this.hasTrailingSlash(parent) ? parent : parent + '/';
    return this.depth(parent) < this.depth(child) && child.indexOf(parent) === 0;
};

/**
 * returns the selector portion of the path.
 *
 * @method
 *
 * @param {String} path the path
 *
 * @return {String} the selector portion of the path.
 */
PathUtils.prototype.getSelector = function getSelector(path) {
    var index = path.indexOf('/');
    return index === -1 ? path : path.substring(0, index);
};

module.exports = new PathUtils();


},{}],12:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jshint -W079 */

'use strict';

var PathUtils = require('./Path');

/**
 * A class that can be used to associate any item with a path.
 * Items and paths are kept in flat arrays for easy iteration
 * and a memo is used to provide constant time lookup.
 *
 * @class
 *
 */
function PathStore () {
    this.items = [];
    this.paths = [];
    this.memo = {};
}

/**
 * Associates an item with the given path. Errors if an item
 * already exists at the given path.
 *
 * @method
 *
 * @param {String} path The path at which to insert the item
 * @param {Any} item The item to associate with the given path.
 *
 * @return {undefined} undefined
 */
PathStore.prototype.insert = function insert (path, item) {
    var paths = this.paths;
    var index = paths.indexOf(path);
    if (index !== -1)
        throw new Error('item already exists at path: ' + path);

    var i = 0;
    var targetDepth = PathUtils.depth(path);
    var targetIndex = PathUtils.index(path);

    // The item will be inserted at a point in the array
    // such that it is within its own breadth in the tree
    // that the paths represent
    while (
        paths[i] &&
        targetDepth >= PathUtils.depth(paths[i])
    ) i++;

    // The item will be sorted within its breadth by index
    // in regard to its siblings.
    while (
        paths[i] &&
        targetDepth === PathUtils.depth(paths[i]) &&
        targetIndex < PathUtils.index(paths[i])
    ) i++;

    // insert the items in the path
    paths.splice(i, 0, path);
    this.items.splice(i, 0, item);

    // store the relationship between path and index in the memo
    this.memo[path] = i;

    // all items behind the inserted item are now no longer
    // accurately stored in the memo. Thus the memo must be cleared for
    // these items.
    for (var len = this.paths.length ; i < len ; i++)
        this.memo[this.paths[i]] = null;
};

/**
 * Removes the the item from the store at the given path.
 * Errors if no item exists at the given path.
 *
 * @method
 *
 * @param {String} path The path at which to remove the item.
 *
 * @return {undefined} undefined
 */
PathStore.prototype.remove = function remove (path) {
    var paths = this.paths;
    var index = this.memo[path] ? this.memo[path] : paths.indexOf(path);
    if (index === -1)
        throw new Error('Cannot remove. No item exists at path: ' + path);

    paths.splice(index, 1);
    this.items.splice(index, 1);

    this.memo[path] = null;

    for (var len = this.paths.length ; index < len ; index++)
        this.memo[this.paths[index]] = null;
};

/**
 * Returns the item stored at the current path. Returns undefined
 * if no item is stored at that path.
 *
 * @method
 *
 * @param {String} path The path to lookup the item for
 *
 * @return {Any | undefined} the item stored or undefined
 */
PathStore.prototype.get = function get (path) {
    if (this.memo[path]) return this.items[this.memo[path]];

    var index = this.paths.indexOf(path);

    if (index === -1) return void 0;

    this.memo[path] = index;

    return this.items[index];
};

/**
 * Returns an array of the items currently stored in this
 * PathStore.
 *
 * @method
 *
 * @return {Array} items currently stored
 */
PathStore.prototype.getItems = function getItems () {
    return this.items;
};

/**
 * Returns an array of the paths currently stored in this
 * PathStore.
 *
 * @method
 *
 * @return {Array} paths currently stored
 */
PathStore.prototype.getPaths = function getPaths () {
    return this.paths;
};

module.exports = PathStore;

},{"./Path":11}],13:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jshint -W079 */

'use strict';

var Node = require('./Node');
var Dispatch = require('./Dispatch');
var Commands = require('./Commands');
var TransformSystem = require('./TransformSystem');
var SizeSystem = require('./SizeSystem');

/**
 * Scene is the bottom of the scene graph. It is its own
 * parent and provides the global updater to the scene graph.
 *
 * @class Scene
 * @constructor
 *
 * @param {String} selector a string which is a dom selector
 *                 signifying which dom element the context
 *                 should be set upon
 * @param {Famous} updater a class which conforms to Famous' interface
 *                 it needs to be able to send methods to
 *                 the renderers and update nodes in the scene graph
 */
function Scene (selector, updater) {
    if (!selector) throw new Error('Scene needs to be created with a DOM selector');
    if (!updater) throw new Error('Scene needs to be created with a class like Famous');

    Node.call(this);         // Scene inherits from node

    this._globalUpdater = updater; // The updater that will both
                                   // send messages to the renderers
                                   // and update dirty nodes

    this._selector = selector; // reference to the DOM selector
                               // that represents the element
                               // in the dom that this context
                               // inhabits

    this.mount(selector); // Mount the context to itself
                          // (it is its own parent)

    this._globalUpdater                  // message a request for the dom
        .message(Commands.NEED_SIZE_FOR)  // size of the context so that
        .message(selector);               // the scene graph has a total size

    this.show(); // the context begins shown (it's already present in the dom)
}

// Scene inherits from node
Scene.prototype = Object.create(Node.prototype);
Scene.prototype.constructor = Scene;

/**
 * Scene getUpdater function returns the passed in updater
 *
 * @return {Famous} the updater for this Scene
 */
Scene.prototype.getUpdater = function getUpdater () {
    return this._updater;
};

/**
 * Returns the selector that the context was instantiated with
 *
 * @return {String} dom selector
 */
Scene.prototype.getSelector = function getSelector () {
    return this._selector;
};

/**
 * Returns the dispatcher of the context. Used to send events
 * to the nodes in the scene graph.
 *
 * @return {Dispatch} the Scene's Dispatch
 * @deprecated
 */
Scene.prototype.getDispatch = function getDispatch () {
    console.warn('Scene#getDispatch is deprecated, require the dispatch directly');
    return Dispatch;
};

/**
 * Receives an event. If the event is 'CONTEXT_RESIZE' it sets the size of the scene
 * graph to the payload, which must be an array of numbers of at least
 * length three representing the pixel size in 3 dimensions.
 *
 * @param {String} event the name of the event being received
 * @param {*} payload the object being sent
 *
 * @return {undefined} undefined
 */
Scene.prototype.onReceive = function onReceive (event, payload) {
    // TODO: In the future the dom element that the context is attached to
    // should have a representation as a component. It would be render sized
    // and the context would receive its size the same way that any render size
    // component receives its size.
    if (event === 'CONTEXT_RESIZE') {
        if (payload.length < 2)
            throw new Error(
                    'CONTEXT_RESIZE\'s payload needs to be at least a pair' +
                    ' of pixel sizes'
            );

        this.setSizeMode('absolute', 'absolute', 'absolute');
        this.setAbsoluteSize(payload[0],
                             payload[1],
                             payload[2] ? payload[2] : 0);

        this._updater.message(Commands.WITH).message(this._selector).message(Commands.READY);
    }
};


Scene.prototype.mount = function mount (path) {
    if (this.isMounted())
        throw new Error('Scene is already mounted at: ' + this.getLocation());
    Dispatch.mount(path, this);
    this._id = path;
    this._mounted = true;
    this._parent = this;
    TransformSystem.registerTransformAtPath(path);
    SizeSystem.registerSizeAtPath(path);
};

module.exports = Scene;

},{"./Commands":6,"./Dispatch":7,"./Node":10,"./SizeSystem":15,"./TransformSystem":17}],14:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var ONES = [1, 1, 1];
var ZEROS = [0, 0, 0];

/**
 * The Size class is responsible for processing Size from a node
 * @constructor Size
 *
 * @param {Size} parent the parent size
 */
function Size (parent) {

    this.finalSize = new Float32Array(3);
    this.sizeChanged = false;

    this.sizeMode = new Uint8Array(3);
    this.sizeModeChanged = false;

    this.absoluteSize = new Float32Array(3);
    this.absoluteSizeChanged = false;

    this.proportionalSize = new Float32Array(ONES);
    this.proportionalSizeChanged = false;

    this.differentialSize = new Float32Array(3);
    this.differentialSizeChanged = false;

    this.renderSize = new Float32Array(3);
    this.renderSizeChanged = false;

    this.parent = parent != null ? parent : null;
}

// an enumeration of the different types of size modes
Size.RELATIVE = 0;
Size.ABSOLUTE = 1;
Size.RENDER = 2;
Size.DEFAULT = Size.RELATIVE;

/**
 * Private method which sets a value within an array
 * and report if the value has changed.
 *
 * @method
 *
 * @param {Array} vec The array to set the value in
 * @param {Number} index The index at which to set the value
 * @param {Any} val If the val is undefined or null, or if the value
 *                  is the same as what is already there, then nothing
 *                  is set.
 *
 * @return {Boolean} returns true if anything changed
 */
function _vecOptionalSet (vec, index, val) {
    if (val != null && vec[index] !== val) {
        vec[index] = val;
        return true;
    } else return false;
}

/**
 * Private method which sets three values within an array of three
 * using _vecOptionalSet. Returns whether anything has changed.
 *
 * @method
 *
 * @param {Array} vec The array to set the values of
 * @param {Any} x The first value to set within the array
 * @param {Any} y The second value to set within the array
 * @param {Any} z The third value to set within the array
 *
 * @return {Boolean} whether anything has changed
 */
function setVec (vec, x, y, z) {
    var propagate = false;

    propagate = _vecOptionalSet(vec, 0, x) || propagate;
    propagate = _vecOptionalSet(vec, 1, y) || propagate;
    propagate = _vecOptionalSet(vec, 2, z) || propagate;

    return propagate;
}

/**
 * Private method to allow for polymorphism in the size mode such that strings
 * or the numbers from the enumeration can be used.
 *
 * @method
 *
 * @param {String|Number} val The Size mode to resolve.
 *
 * @return {Number} the resolved size mode from the enumeration.
 */
function resolveSizeMode (val) {
    if (val.constructor === String) {
        switch (val.toLowerCase()) {
            case 'relative':
            case 'default': return Size.RELATIVE;
            case 'absolute': return Size.ABSOLUTE;
            case 'render': return Size.RENDER;
            default: throw new Error('unknown size mode: ' + val);
        }
    }
    else if (val < 0 || val > Size.RENDER) throw new Error('unknown size mode: ' + val);
    return val;
}

/**
 * Sets the parent of this size.
 *
 * @method
 *
 * @param {Size} parent The parent size component
 *
 * @return {Size} this
 */
Size.prototype.setParent = function setParent (parent) {
    this.parent = parent;
    return this;
};

/**
 * Gets the parent of this size.
 *
 * @method
 *
 * @returns {Size|undefined} the parent if one exists
 */
Size.prototype.getParent = function getParent () {
    return this.parent;
};

/**
 * Gets the size mode of this size representation
 *
 * @method
 *
 * @param {Number} x the size mode to use for the width
 * @param {Number} y the size mode to use for the height
 * @param {Number} z the size mode to use for the depth
 *
 * @return {array} array of size modes
 */
Size.prototype.setSizeMode = function setSizeMode (x, y, z) {
    if (x != null) x = resolveSizeMode(x);
    if (y != null) y = resolveSizeMode(y);
    if (z != null) z = resolveSizeMode(z);
    this.sizeModeChanged = setVec(this.sizeMode, x, y, z);
    return this;
};

/**
 * Returns the size mode of this component.
 *
 * @method
 *
 * @return {Array} the current size mode of the this.
 */
Size.prototype.getSizeMode = function getSizeMode () {
    return this.sizeMode;
};

/**
 * Sets the absolute size of this size representation.
 *
 * @method
 *
 * @param {Number} x The x dimension of the absolute size
 * @param {Number} y The y dimension of the absolute size
 * @param {Number} z The z dimension of the absolute size
 *
 * @return {Size} this
 */
Size.prototype.setAbsolute = function setAbsolute (x, y, z) {
    this.absoluteSizeChanged = setVec(this.absoluteSize, x, y, z);
    return this;
};

/**
 * Gets the absolute size of this size representation
 *
 * @method
 *
 * @return {array} array of absolute size
 */
Size.prototype.getAbsolute = function getAbsolute () {
    return this.absoluteSize;
};

/**
 * Sets the proportional size of this size representation.
 *
 * @method
 *
 * @param {Number} x The x dimension of the proportional size
 * @param {Number} y The y dimension of the proportional size
 * @param {Number} z The z dimension of the proportional size
 *
 * @return {Size} this
 */
Size.prototype.setProportional = function setProportional (x, y, z) {
    this.proportionalSizeChanged = setVec(this.proportionalSize, x, y, z);
    return this;
};

/**
 * Gets the propotional size of this size representation
 *
 * @method
 *
 * @return {array} array of proportional size
 */
Size.prototype.getProportional = function getProportional () {
    return this.proportionalSize;
};

/**
 * Sets the differential size of this size representation.
 *
 * @method
 *
 * @param {Number} x The x dimension of the differential size
 * @param {Number} y The y dimension of the differential size
 * @param {Number} z The z dimension of the differential size
 *
 * @return {Size} this
 */
Size.prototype.setDifferential = function setDifferential (x, y, z) {
    this.differentialSizeChanged = setVec(this.differentialSize, x, y, z);
    return this;
};

/**
 * Gets the differential size of this size representation
 *
 * @method
 *
 * @return {array} array of differential size
 */
Size.prototype.getDifferential = function getDifferential () {
    return this.differentialSize;
};

/**
 * Sets the size of this size representation.
 *
 * @method
 *
 * @param {Number} x The x dimension of the size
 * @param {Number} y The y dimension of the size
 * @param {Number} z The z dimension of the size
 *
 * @return {Size} this
 */
Size.prototype.get = function get () {
    return this.finalSize;
};

/**
 * fromSpecWithParent takes the parent node's size, the target node's spec,
 * and a target array to write to. Using the node's size mode it calculates
 * a final size for the node from the node's spec. Returns whether or not
 * the final size has changed from its last value.
 *
 * @method
 *
 * @param {Array} components the node's components
 *
 * @return {Boolean} true if the size of the node has changed.
 */
Size.prototype.fromComponents = function fromComponents (components) {
    var mode = this.sizeMode;
    var target = this.finalSize;
    var parentSize = this.parent ? this.parent.get() : ZEROS;
    var prev;
    var changed = false;
    var len = components.length;
    var j;
    for (var i = 0 ; i < 3 ; i++) {
        prev = target[i];
        switch (mode[i]) {
            case Size.RELATIVE:
                target[i] = parentSize[i] * this.proportionalSize[i] + this.differentialSize[i];
                break;
            case Size.ABSOLUTE:
                target[i] = this.absoluteSize[i];
                break;
            case Size.RENDER:
                var candidate;
                var component;
                for (j = 0; j < len ; j++) {
                    component = components[j];
                    if (component && component.getRenderSize) {
                        candidate = component.getRenderSize()[i];
                        target[i] = target[i] < candidate || target[i] === 0 ? candidate : target[i];
                    }
                }
                break;
        }
        changed = changed || prev !== target[i];
    }
    this.sizeChanged = changed;
    return changed;
};

module.exports = Size;


},{}],15:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var PathStore = require('./PathStore');
var Size = require('./Size');
var Dispatch = require('./Dispatch');
var PathUtils = require('./Path');

/**
 * The size system is used to calculate size throughout the scene graph.
 * It holds size components and operates upon them.
 *
 * @constructor
 */
function SizeSystem () {
    this.pathStore = new PathStore();
}

/**
 * Registers a size component to a give path. A size component can be passed as the second argument
 * or a default one will be created. Throws if no size component has been added at the parent path.
 *
 * @method
 *
 * @param {String} path The path at which to register the size component
 * @param {Size | undefined} size The size component to be registered or undefined.
 *
 * @return {undefined} undefined
 */
SizeSystem.prototype.registerSizeAtPath = function registerSizeAtPath (path, size) {
    if (!PathUtils.depth(path)) return this.pathStore.insert(path, size ? size : new Size());

    var parent = this.pathStore.get(PathUtils.parent(path));

    if (!parent) throw new Error(
            'No parent size registered at expected path: ' + PathUtils.parent(path)
    );

    if (size) size.setParent(parent);

    this.pathStore.insert(path, size ? size : new Size(parent));
};

/**
 * Removes the size component from the given path. Will throw if no component is at that
 * path
 *
 * @method
 *
 * @param {String} path The path at which to remove the size.
 *
 * @return {undefined} undefined
 */
SizeSystem.prototype.deregisterSizeAtPath = function deregisterSizeAtPath(path) {
    this.pathStore.remove(path);
};

/**
 * Returns the size component stored at a given path. Returns undefined if no
 * size component is registered to that path.
 *
 * @method
 *
 * @param {String} path The path at which to get the size component.
 *
 * @return {undefined} undefined
 */
SizeSystem.prototype.get = function get (path) {
    return this.pathStore.get(path);
};

/**
 * Updates the sizes in the scene graph. Called internally by the famous engine.
 *
 * @method
 *
 * @return {undefined} undefined
 */
SizeSystem.prototype.update = function update () {
    var sizes = this.pathStore.getItems();
    var paths = this.pathStore.getPaths();
    var node;
    var size;
    var i;
    var len;
    var components;

    for (i = 0, len = sizes.length ; i < len ; i++) {
        node = Dispatch.getNode(paths[i]);
        components = node.getComponents();
        if (!node) continue;
        size = sizes[i];
        if (size.sizeModeChanged) sizeModeChanged(node, components, size);
        if (size.absoluteSizeChanged) absoluteSizeChanged(node, components, size);
        if (size.proportionalSizeChanged) proportionalSizeChanged(node, components, size);
        if (size.differentialSizeChanged) differentialSizeChanged(node, components, size);
        if (size.renderSizeChanged) renderSizeChanged(node, components, size);
        if (size.fromComponents(components)) sizeChanged(node, components, size);
    }
};

// private methods

/**
 * Private method to alert the node and components that size mode changed.
 *
 * @method
 * @private
 *
 * @param {Node} node Node to potentially call sizeModeChanged on
 * @param {Array} components a list of the nodes' components
 * @param {Size} size the size class for the Node
 *
 * @return {undefined} undefined
 */
function sizeModeChanged (node, components, size) {
    var sizeMode = size.getSizeMode();
    var x = sizeMode[0];
    var y = sizeMode[1];
    var z = sizeMode[2];
    if (node.onSizeModeChange) node.onSizeModeChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onSizeModeChange)
            components[i].onSizeModeChange(x, y, z);
    size.sizeModeChanged = false;
}

/**
 * Private method to alert the node and components that absoluteSize changed.
 *
 * @method
 * @private
 *
 * @param {Node} node Node to potentially call onAbsoluteSizeChange on
 * @param {Array} components a list of the nodes' components
 * @param {Size} size the size class for the Node
 *
 * @return {undefined} undefined
 */
function absoluteSizeChanged (node, components, size) {
    var absoluteSize = size.getAbsolute();
    var x = absoluteSize[0];
    var y = absoluteSize[1];
    var z = absoluteSize[2];
    if (node.onAbsoluteSizeChange) node.onAbsoluteSizeChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onAbsoluteSizeChange)
            components[i].onAbsoluteSizeChange(x, y, z);
    size.absoluteSizeChanged = false;
}

/**
 * Private method to alert the node and components that the proportional size changed.
 *
 * @method
 * @private
 *
 * @param {Node} node Node to potentially call onProportionalSizeChange on
 * @param {Array} components a list of the nodes' components
 * @param {Size} size the size class for the Node
 *
 * @return {undefined} undefined
 */
function proportionalSizeChanged (node, components, size) {
    var proportionalSize = size.getProportional();
    var x = proportionalSize[0];
    var y = proportionalSize[1];
    var z = proportionalSize[2];
    if (node.onProportionalSizeChange) node.onProportionalSizeChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onProportionalSizeChange)
            components[i].onProportionalSizeChange(x, y, z);
    size.proportionalSizeChanged = false;
}

/**
 * Private method to alert the node and components that differential size changed.
 *
 * @method
 * @private
 *
 * @param {Node} node Node to potentially call onDifferentialSize on
 * @param {Array} components a list of the nodes' components
 * @param {Size} size the size class for the Node
 *
 * @return {undefined} undefined
 */
function differentialSizeChanged (node, components, size) {
    var differentialSize = size.getDifferential();
    var x = differentialSize[0];
    var y = differentialSize[1];
    var z = differentialSize[2];
    if (node.onDifferentialSizeChange) node.onDifferentialSizeChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onDifferentialSizeChange)
            components[i].onDifferentialSizeChange(x, y, z);
    size.differentialSizeChanged = false;
}

/**
 * Private method to alert the node and components that render size changed.
 *
 * @method
 * @private
 *
 * @param {Node} node Node to potentially call onRenderSizeChange on
 * @param {Array} components a list of the nodes' components
 * @param {Size} size the size class for the Node
 *
 * @return {undefined} undefined
 */
function renderSizeChanged (node, components, size) {
    var renderSize = size.getRenderSize();
    var x = renderSize[0];
    var y = renderSize[1];
    var z = renderSize[2];
    if (node.onRenderSizeChange) node.onRenderSizeChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onRenderSizeChange)
            components[i].onRenderSizeChange(x, y, z);
    size.renderSizeChanged = false;
}

/**
 * Private method to alert the node and components that the size changed.
 *
 * @method
 * @private
 *
 * @param {Node} node Node to potentially call onSizeChange on
 * @param {Array} components a list of the nodes' components
 * @param {Size} size the size class for the Node
 *
 * @return {undefined} undefined
 */
function sizeChanged (node, components, size) {
    var finalSize = size.get();
    var x = finalSize[0];
    var y = finalSize[1];
    var z = finalSize[2];
    if (node.onSizeChange) node.onSizeChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onSizeChange)
            components[i].onSizeChange(x, y, z);
    size.sizeChanged = false;
}

module.exports = new SizeSystem();

},{"./Dispatch":7,"./Path":11,"./PathStore":12,"./Size":14}],16:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var QUAT = [0, 0, 0, 1];
var ONES = [1, 1, 1];

/**
 * The transform class is responsible for calculating the transform of a particular
 * node from the data on the node and its parent
 *
 * @constructor Transform
 *
 * @param {Transform} parent the parent Transform
 */
function Transform (parent) {
    this.local = new Float32Array(Transform.IDENT);
    this.global = new Float32Array(Transform.IDENT);
    this.offsets = {
        align: new Float32Array(3),
        alignChanged: false,
        mountPoint: new Float32Array(3),
        mountPointChanged: false,
        origin: new Float32Array(3),
        originChanged: false
    };
    this.vectors = {
        position: new Float32Array(3),
        positionChanged: false,
        rotation: new Float32Array(QUAT),
        rotationChanged: false,
        scale: new Float32Array(ONES),
        scaleChanged: false
    };
    this._lastEulerVals = [0, 0, 0];
    this._lastEuler = false;
    this.parent = parent ? parent : null;
    this.breakPoint = false;
}

Transform.IDENT = [ 1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1 ];

Transform.WORLD_CHANGED = 1;
Transform.LOCAL_CHANGED = 2;

/**
 * resets the transform state such that it no longer has a parent
 * and is not a breakpoint.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Transform.prototype.reset = function reset () {
    this.parent = null;
    this.breakPoint = false;
};

/**
 * sets the parent of this transform.
 *
 * @method
 *
 * @param {Transform} parent The transform class that parents this class
 *
 * @return {undefined} undefined
 */
Transform.prototype.setParent = function setParent (parent) {
    this.parent = parent;
};

/**
 * returns the parent of this transform
 *
 * @method
 *
 * @return {Transform | null} the parent of this transform if one exists
 */
Transform.prototype.getParent = function getParent () {
    return this.parent;
};

/**
 * Makes this transform a breakpoint. This will cause it to calculate
 * both a local (relative to the nearest ancestor breakpoint) and a world
 * matrix (relative to the scene).
 *
 * @method
 *
 * @return {undefined} undefined
 */
Transform.prototype.setBreakPoint = function setBreakPoint () {
    this.breakPoint = true;
};

/**
 * returns whether or not this transform is a breakpoint.
 *
 * @method
 *
 * @return {Boolean} true if this transform is a breakpoint
 */
Transform.prototype.isBreakPoint = function isBreakPoint () {
    return this.breakPoint;
};

/**
 * returns the local transform
 *
 * @method
 *
 * @return {Float32Array} local transform
 */
Transform.prototype.getLocalTransform = function getLocalTransform () {
    return this.local;
};

/**
 * returns the world transform. Requires that this transform is a breakpoint.
 *
 * @method
 *
 * @return {Float32Array} world transform.
 */
Transform.prototype.getWorldTransform = function getWorldTransform () {
    if (!this.isBreakPoint())
        throw new Error('This transform is not calculating world transforms');
    return this.global;
};

/**
 * Takes a node and calculates the proper transform from it.
 *
 * @method
 *
 * @param {Node} node the node to calculate the transform from
 *
 * @return {undefined} undefined
 */
Transform.prototype.calculate = function calculate (node) {
    if (!this.parent || this.parent.isBreakPoint())
        return fromNode(node, this);
    else return fromNodeWithParent(node, this);
};

/**
 * A private method to potentially set a value within an
 * array. Will set the value if a value was given
 * for the third argument and if that value is different
 * than the value that is currently in the array at the given index.
 * Returns true if a value was set and false if not.
 *
 * @method
 *
 * @param {Array} vec The array to set the value within
 * @param {Number} index The index at which to set the value
 * @param {Any} val The value to potentially set in the array
 *
 * @return {Boolean} whether or not a value was set
 */
function _vecOptionalSet (vec, index, val) {
    if (val != null && vec[index] !== val) {
        vec[index] = val;
        return true;
    } else return false;
}

/**
 * private method to set values within an array.
 * Returns whether or not the array has been changed.
 *
 * @method
 *
 * @param {Array} vec The vector to be operated upon
 * @param {Number | null | undefined} x The x value of the vector
 * @param {Number | null | undefined} y The y value of the vector
 * @param {Number | null | undefined} z The z value of the vector
 * @param {Number | null | undefined} w the w value of the vector
 *
 * @return {Boolean} whether or not the array was changed
 */
function setVec (vec, x, y, z, w) {
    var propagate = false;

    propagate = _vecOptionalSet(vec, 0, x) || propagate;
    propagate = _vecOptionalSet(vec, 1, y) || propagate;
    propagate = _vecOptionalSet(vec, 2, z) || propagate;
    if (w != null)
        propagate = _vecOptionalSet(vec, 3, w) || propagate;

    return propagate;
}

/**
 * Gets the position component of the transform
 *
 * @method
 *
 * @return {Float32Array} the position component of the transform
 */
Transform.prototype.getPosition = function getPosition () {
    return this.vectors.position;
};

/**
 * Sets the position component of the transform.
 *
 * @method
 *
 * @param {Number} x The x dimension of the position
 * @param {Number} y The y dimension of the position
 * @param {Number} z The z dimension of the position
 *
 * @return {undefined} undefined
 */
Transform.prototype.setPosition = function setPosition (x, y, z) {
    this.vectors.positionChanged = setVec(this.vectors.position, x, y, z);
};

/**
 * Gets the rotation component of the transform. Will return a quaternion.
 *
 * @method
 *
 * @return {Float32Array} the quaternion representation of the transform's rotation
 */
Transform.prototype.getRotation = function getRotation () {
    return this.vectors.rotation;
};

/**
 * Sets the rotation component of the transform. Can take either Euler
 * angles or a quaternion.
 *
 * @method
 *
 * @param {Number} x The rotation about the x axis or the extent in the x dimension
 * @param {Number} y The rotation about the y axis or the extent in the y dimension
 * @param {Number} z The rotation about the z axis or the extent in the z dimension
 * @param {Number} w The rotation about the proceeding vector
 *
 * @return {undefined} undefined
 */
Transform.prototype.setRotation = function setRotation (x, y, z, w) {
    var quat = this.vectors.rotation;
    var qx, qy, qz, qw;

    if (w != null) {
        qx = x;
        qy = y;
        qz = z;
        qw = w;
        this._lastEulerVals[0] = null;
        this._lastEulerVals[1] = null;
        this._lastEulerVals[2] = null;
        this._lastEuler = false;
    }
    else {
        if (x == null || y == null || z == null) {
            if (this._lastEuler) {
                x = x == null ? this._lastEulerVals[0] : x;
                y = y == null ? this._lastEulerVals[1] : y;
                z = z == null ? this._lastEulerVals[2] : z;
            }
            else {
                var sp = -2 * (quat[1] * quat[2] - quat[3] * quat[0]);

                if (Math.abs(sp) > 0.99999) {
                    y = y == null ? Math.PI * 0.5 * sp : y;
                    x = x == null ? Math.atan2(-quat[0] * quat[2] + quat[3] * quat[1], 0.5 - quat[1] * quat[1] - quat[2] * quat[2]) : x;
                    z = z == null ? 0 : z;
                }
                else {
                    y = y == null ? Math.asin(sp) : y;
                    x = x == null ? Math.atan2(quat[0] * quat[2] + quat[3] * quat[1], 0.5 - quat[0] * quat[0] - quat[1] * quat[1]) : x;
                    z = z == null ? Math.atan2(quat[0] * quat[1] + quat[3] * quat[2], 0.5 - quat[0] * quat[0] - quat[2] * quat[2]) : z;
                }
            }
        }

        var hx = x * 0.5;
        var hy = y * 0.5;
        var hz = z * 0.5;

        var sx = Math.sin(hx);
        var sy = Math.sin(hy);
        var sz = Math.sin(hz);
        var cx = Math.cos(hx);
        var cy = Math.cos(hy);
        var cz = Math.cos(hz);

        var sysz = sy * sz;
        var cysz = cy * sz;
        var sycz = sy * cz;
        var cycz = cy * cz;

        qx = sx * cycz + cx * sysz;
        qy = cx * sycz - sx * cysz;
        qz = cx * cysz + sx * sycz;
        qw = cx * cycz - sx * sysz;

        this._lastEuler = true;
        this._lastEulerVals[0] = x;
        this._lastEulerVals[1] = y;
        this._lastEulerVals[2] = z;
    }

    this.vectors.rotationChanged = setVec(quat, qx, qy, qz, qw);
};

/**
 * Gets the scale component of the transform
 *
 * @method
 *
 * @return {Float32Array} the scale component of the transform
 */
Transform.prototype.getScale = function getScale () {
    return this.vectors.scale;
};

/**
 * Sets the scale component of the transform.
 *
 * @method
 *
 * @param {Number | null | undefined} x The x dimension of the scale
 * @param {Number | null | undefined} y The y dimension of the scale
 * @param {Number | null | undefined} z The z dimension of the scale
 *
 * @return {undefined} undefined
 */
Transform.prototype.setScale = function setScale (x, y, z) {
    this.vectors.scaleChanged = setVec(this.vectors.scale, x, y, z);
};

/**
 * Gets the align value of the transform
 *
 * @method
 *
 * @return {Float32Array} the align value of the transform
 */
Transform.prototype.getAlign = function getAlign () {
    return this.offsets.align;
};

/**
 * Sets the align value of the transform.
 *
 * @method
 *
 * @param {Number | null | undefined} x The x dimension of the align
 * @param {Number | null | undefined} y The y dimension of the align
 * @param {Number | null | undefined} z The z dimension of the align
 *
 * @return {undefined} undefined
 */
Transform.prototype.setAlign = function setAlign (x, y, z) {
    this.offsets.alignChanged = setVec(this.offsets.align, x, y, z != null ? z - 0.5 : z);
};

/**
 * Gets the mount point value of the transform.
 *
 * @method
 *
 * @return {Float32Array} the mount point of the transform
 */
Transform.prototype.getMountPoint = function getMountPoint () {
    return this.offsets.mountPoint;
};

/**
 * Sets the mount point value of the transform.
 *
 * @method
 *
 * @param {Number | null | undefined} x the x dimension of the mount point
 * @param {Number | null | undefined} y the y dimension of the mount point
 * @param {Number | null | undefined} z the z dimension of the mount point
 *
 * @return {undefined} undefined
 */
Transform.prototype.setMountPoint = function setMountPoint (x, y, z) {
    this.offsets.mountPointChanged = setVec(this.offsets.mountPoint, x, y, z != null ? z - 0.5 : z);
};

/**
 * Gets the origin of the transform.
 *
 * @method
 *
 * @return {Float32Array} the origin
 */
Transform.prototype.getOrigin = function getOrigin () {
    return this.offsets.origin;
};

/**
 * Sets the origin of the transform.
 *
 * @method
 *
 * @param {Number | null | undefined} x the x dimension of the origin
 * @param {Number | null | undefined} y the y dimension of the origin
 * @param {Number | null | undefined} z the z dimension of the origin
 *
 * @return {undefined} undefined
 */
Transform.prototype.setOrigin = function setOrigin (x, y, z) {
    this.offsets.originChanged = setVec(this.offsets.origin, x, y, z != null ? z - 0.5 : z);
};

/**
 * Calculates the world for this particular transform.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Transform.prototype.calculateWorldMatrix = function calculateWorldMatrix () {
    var nearestBreakPoint = this.parent;

    while (nearestBreakPoint && !nearestBreakPoint.isBreakPoint())
        nearestBreakPoint = nearestBreakPoint.parent;

    if (nearestBreakPoint) return multiply(this.global, nearestBreakPoint.getWorldTransform(), this.local);
    else {
        for (var i = 0; i < 16 ; i++) this.global[i] = this.local[i];
        return false;
    }
};


/**
 * Private function. Creates a transformation matrix from a Node's spec.
 *
 * @param {Node} node the node to create a transform for
 * @param {Transform} transform transform to apply
 *
 * @return {Boolean} whether or not the target array was changed
 */
function fromNode (node, transform) {
    var target = transform.getLocalTransform();
    var mySize = node.getSize();
    var vectors = transform.vectors;
    var offsets = transform.offsets;
    var parentSize = node.getParent().getSize();
    var changed = 0;

    var t00         = target[0];
    var t01         = target[1];
    var t02         = target[2];
    var t10         = target[4];
    var t11         = target[5];
    var t12         = target[6];
    var t20         = target[8];
    var t21         = target[9];
    var t22         = target[10];
    var t30         = target[12];
    var t31         = target[13];
    var t32         = target[14];
    var posX        = vectors.position[0];
    var posY        = vectors.position[1];
    var posZ        = vectors.position[2];
    var rotX        = vectors.rotation[0];
    var rotY        = vectors.rotation[1];
    var rotZ        = vectors.rotation[2];
    var rotW        = vectors.rotation[3];
    var scaleX      = vectors.scale[0];
    var scaleY      = vectors.scale[1];
    var scaleZ      = vectors.scale[2];
    var alignX      = offsets.align[0] * parentSize[0];
    var alignY      = offsets.align[1] * parentSize[1];
    var alignZ      = offsets.align[2] * parentSize[2];
    var mountPointX = offsets.mountPoint[0] * mySize[0];
    var mountPointY = offsets.mountPoint[1] * mySize[1];
    var mountPointZ = offsets.mountPoint[2] * mySize[2];
    var originX     = offsets.origin[0] * mySize[0];
    var originY     = offsets.origin[1] * mySize[1];
    var originZ     = offsets.origin[2] * mySize[2];

    var wx = rotW * rotX;
    var wy = rotW * rotY;
    var wz = rotW * rotZ;
    var xx = rotX * rotX;
    var yy = rotY * rotY;
    var zz = rotZ * rotZ;
    var xy = rotX * rotY;
    var xz = rotX * rotZ;
    var yz = rotY * rotZ;

    target[0] = (1 - 2 * (yy + zz)) * scaleX;
    target[1] = (2 * (xy + wz)) * scaleX;
    target[2] = (2 * (xz - wy)) * scaleX;
    target[3] = 0;
    target[4] = (2 * (xy - wz)) * scaleY;
    target[5] = (1 - 2 * (xx + zz)) * scaleY;
    target[6] = (2 * (yz + wx)) * scaleY;
    target[7] = 0;
    target[8] = (2 * (xz + wy)) * scaleZ;
    target[9] = (2 * (yz - wx)) * scaleZ;
    target[10] = (1 - 2 * (xx + yy)) * scaleZ;
    target[11] = 0;
    target[12] = alignX + posX - mountPointX + originX -
                 (target[0] * originX + target[4] * originY + target[8] * originZ);
    target[13] = alignY + posY - mountPointY + originY -
                 (target[1] * originX + target[5] * originY + target[9] * originZ);
    target[14] = alignZ + posZ - mountPointZ + originZ -
                 (target[2] * originX + target[6] * originY + target[10] * originZ);
    target[15] = 1;

    if (transform.isBreakPoint() && transform.calculateWorldMatrix())
        changed |= Transform.WORLD_CHANGED;

    if (t00 !== target[0] ||
        t01 !== target[1] ||
        t02 !== target[2] ||
        t10 !== target[4] ||
        t11 !== target[5] ||
        t12 !== target[6] ||
        t20 !== target[8] ||
        t21 !== target[9] ||
        t22 !== target[10] ||
        t30 !== target[12] ||
        t31 !== target[13] ||
        t32 !== target[14]) changed |= Transform.LOCAL_CHANGED;

    return changed;
}

/**
 * Private function. Uses the parent transform, the node's spec, the node's size, and the parent's size
 * to calculate a final transform for the node. Returns true if the transform has changed.
 *
 * @private
 *
 * @param {Node} node the node to create a transform for
 * @param {Transform} transform transform to apply
 *
 * @return {Boolean} whether or not the transform changed
 */
function fromNodeWithParent (node, transform) {
    var target = transform.getLocalTransform();
    var parentMatrix = transform.parent.getLocalTransform();
    var mySize = node.getSize();
    var vectors = transform.vectors;
    var offsets = transform.offsets;
    var parentSize = node.getParent().getSize();
    var changed = false;

    // local cache of everything
    var t00         = target[0];
    var t01         = target[1];
    var t02         = target[2];
    var t10         = target[4];
    var t11         = target[5];
    var t12         = target[6];
    var t20         = target[8];
    var t21         = target[9];
    var t22         = target[10];
    var t30         = target[12];
    var t31         = target[13];
    var t32         = target[14];
    var p00         = parentMatrix[0];
    var p01         = parentMatrix[1];
    var p02         = parentMatrix[2];
    var p10         = parentMatrix[4];
    var p11         = parentMatrix[5];
    var p12         = parentMatrix[6];
    var p20         = parentMatrix[8];
    var p21         = parentMatrix[9];
    var p22         = parentMatrix[10];
    var p30         = parentMatrix[12];
    var p31         = parentMatrix[13];
    var p32         = parentMatrix[14];
    var posX        = vectors.position[0];
    var posY        = vectors.position[1];
    var posZ        = vectors.position[2];
    var rotX        = vectors.rotation[0];
    var rotY        = vectors.rotation[1];
    var rotZ        = vectors.rotation[2];
    var rotW        = vectors.rotation[3];
    var scaleX      = vectors.scale[0];
    var scaleY      = vectors.scale[1];
    var scaleZ      = vectors.scale[2];
    var alignX      = offsets.align[0] * parentSize[0];
    var alignY      = offsets.align[1] * parentSize[1];
    var alignZ      = offsets.align[2] * parentSize[2];
    var mountPointX = offsets.mountPoint[0] * mySize[0];
    var mountPointY = offsets.mountPoint[1] * mySize[1];
    var mountPointZ = offsets.mountPoint[2] * mySize[2];
    var originX     = offsets.origin[0] * mySize[0];
    var originY     = offsets.origin[1] * mySize[1];
    var originZ     = offsets.origin[2] * mySize[2];

    var wx = rotW * rotX;
    var wy = rotW * rotY;
    var wz = rotW * rotZ;
    var xx = rotX * rotX;
    var yy = rotY * rotY;
    var zz = rotZ * rotZ;
    var xy = rotX * rotY;
    var xz = rotX * rotZ;
    var yz = rotY * rotZ;

    var rs0 = (1 - 2 * (yy + zz)) * scaleX;
    var rs1 = (2 * (xy + wz)) * scaleX;
    var rs2 = (2 * (xz - wy)) * scaleX;
    var rs3 = (2 * (xy - wz)) * scaleY;
    var rs4 = (1 - 2 * (xx + zz)) * scaleY;
    var rs5 = (2 * (yz + wx)) * scaleY;
    var rs6 = (2 * (xz + wy)) * scaleZ;
    var rs7 = (2 * (yz - wx)) * scaleZ;
    var rs8 = (1 - 2 * (xx + yy)) * scaleZ;

    var tx = alignX + posX - mountPointX + originX - (rs0 * originX + rs3 * originY + rs6 * originZ);
    var ty = alignY + posY - mountPointY + originY - (rs1 * originX + rs4 * originY + rs7 * originZ);
    var tz = alignZ + posZ - mountPointZ + originZ - (rs2 * originX + rs5 * originY + rs8 * originZ);

    target[0] = p00 * rs0 + p10 * rs1 + p20 * rs2;
    target[1] = p01 * rs0 + p11 * rs1 + p21 * rs2;
    target[2] = p02 * rs0 + p12 * rs1 + p22 * rs2;
    target[3] = 0;
    target[4] = p00 * rs3 + p10 * rs4 + p20 * rs5;
    target[5] = p01 * rs3 + p11 * rs4 + p21 * rs5;
    target[6] = p02 * rs3 + p12 * rs4 + p22 * rs5;
    target[7] = 0;
    target[8] = p00 * rs6 + p10 * rs7 + p20 * rs8;
    target[9] = p01 * rs6 + p11 * rs7 + p21 * rs8;
    target[10] = p02 * rs6 + p12 * rs7 + p22 * rs8;
    target[11] = 0;
    target[12] = p00 * tx + p10 * ty + p20 * tz + p30;
    target[13] = p01 * tx + p11 * ty + p21 * tz + p31;
    target[14] = p02 * tx + p12 * ty + p22 * tz + p32;
    target[15] = 1;

    if (transform.isBreakPoint() && transform.calculateWorldMatrix())
        changed |= Transform.WORLD_CHANGED;

    if (t00 !== target[0] ||
        t01 !== target[1] ||
        t02 !== target[2] ||
        t10 !== target[4] ||
        t11 !== target[5] ||
        t12 !== target[6] ||
        t20 !== target[8] ||
        t21 !== target[9] ||
        t22 !== target[10] ||
        t30 !== target[12] ||
        t31 !== target[13] ||
        t32 !== target[14]) changed |= Transform.LOCAL_CHANGED;

    return changed;
}

/**
 * private method to multiply two transforms.
 *
 * @method
 *
 * @param {Array} out The array to write the result to
 * @param {Array} a the left hand transform
 * @param {Array} b the right hand transform
 *
 * @return {undefined} undefined
 */
function multiply (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[4], a11 = a[5], a12 = a[6],
        a20 = a[8], a21 = a[9], a22 = a[10],
        a30 = a[12], a31 = a[13], a32 = a[14];

    var changed = false;
    var res;

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];

    res = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    changed = changed ? changed : out[0] === res;
    out[0] = res;

    res = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    changed = changed ? changed : out[1] === res;
    out[1] = res;

    res = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    changed = changed ? changed : out[2] === res;
    out[2] = res;

    out[3] = 0;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];

    res = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    changed = changed ? changed : out[4] === res;
    out[4] = res;

    res = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    changed = changed ? changed : out[5] === res;
    out[5] = res;

    res = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    changed = changed ? changed : out[6] === res;
    out[6] = res;

    out[7] = 0;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];

    res = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    changed = changed ? changed : out[8] === res;
    out[8] = res;

    res = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    changed = changed ? changed : out[9] === res;
    out[9] = res;

    res = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    changed = changed ? changed : out[10] === res;
    out[10] = res;

    out[11] = 0;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];

    res = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    changed = changed ? changed : out[12] === res;
    out[12] = res;

    res = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    changed = changed ? changed : out[13] === res;
    out[13] = res;

    res = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    changed = changed ? changed : out[14] === res;
    out[14] = res;

    out[15] = 1;

    return changed;
}

module.exports = Transform;

},{}],17:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var PathUtils = require('./Path');
var Transform = require('./Transform');
var Dispatch = require('./Dispatch');
var PathStore = require('./PathStore');

/**
 * The transform class is responsible for calculating the transform of a particular
 * node from the data on the node and its parent
 *
 * @constructor {TransformSystem}
 */
function TransformSystem () {
    this.pathStore = new PathStore();
}

/**
 * registers a new Transform for the given path. This transform will be updated
 * when the TransformSystem updates.
 *
 * @method registerTransformAtPath
 * @return {undefined} undefined
 *
 * @param {String} path for the transform to be registered to.
 * @param {Transform | undefined} transform optional transform to register.
 */
TransformSystem.prototype.registerTransformAtPath = function registerTransformAtPath (path, transform) {
    if (!PathUtils.depth(path)) return this.pathStore.insert(path, transform ? transform : new Transform());

    var parent = this.pathStore.get(PathUtils.parent(path));

    if (!parent) throw new Error(
            'No parent transform registered at expected path: ' + PathUtils.parent(path)
    );

    if (transform) transform.setParent(parent);

    this.pathStore.insert(path, transform ? transform : new Transform(parent));
};

/**
 * deregisters a transform registered at the given path.
 *
 * @method deregisterTransformAtPath
 * @return {void}
 *
 * @param {String} path at which to register the transform
 */
TransformSystem.prototype.deregisterTransformAtPath = function deregisterTransformAtPath (path) {
    this.pathStore.remove(path);
};

/**
 * Method which will make the transform currently stored at the given path a breakpoint.
 * A transform being a breakpoint means that both a local and world transform will be calculated
 * for that point. The local transform being the concatinated transform of all ancestor transforms up
 * until the nearest breakpoint, and the world being the concatinated transform of all ancestor transforms.
 * This method throws if no transform is at the provided path.
 *
 * @method
 *
 * @param {String} path The path at which to turn the transform into a breakpoint
 *
 * @return {undefined} undefined
 */
TransformSystem.prototype.makeBreakPointAt = function makeBreakPointAt (path) {
    var transform = this.pathStore.get(path);
    if (!transform) throw new Error('No transform Registered at path: ' + path);
    transform.setBreakPoint();
};

/**
 * Returns the instance of the transform class associated with the given path,
 * or undefined if no transform is associated.
 *
 * @method
 * 
 * @param {String} path The path to lookup
 *
 * @return {Transform | undefined} the transform at that path is available, else undefined.
 */
TransformSystem.prototype.get = function get (path) {
    return this.pathStore.get(path);
};

/**
 * onUpdate is called when the transform system requires an update.
 * It traverses the transform array and evaluates the necessary transforms
 * in the scene graph with the information from the corresponding node
 * in the scene graph
 *
 * @method onUpdate
 *
 * @return {undefined} undefined
 */
TransformSystem.prototype.onUpdate = function onUpdate () {
    var transforms = this.pathStore.getItems();
    var paths = this.pathStore.getPaths();
    var transform;
    var changed;
    var node;
    var vectors;
    var offsets;
    var components;

    for (var i = 0, len = transforms.length ; i < len ; i++) {
        node = Dispatch.getNode(paths[i]);
        if (!node) continue;
        components = node.getComponents();
        transform = transforms[i];
        vectors = transform.vectors;
        offsets = transform.offsets;
        if (offsets.alignChanged) alignChanged(node, components, offsets);
        if (offsets.mountPointChanged) mountPointChanged(node, components, offsets);
        if (offsets.originChanged) originChanged(node, components, offsets);
        if (vectors.positionChanged) positionChanged(node, components, vectors);
        if (vectors.rotationChanged) rotationChanged(node, components, vectors);
        if (vectors.scaleChanged) scaleChanged(node, components, vectors);
        if ((changed = transform.calculate(node))) {
            transformChanged(node, components, transform);
            if (changed & Transform.LOCAL_CHANGED) localTransformChanged(node, components, transform.getLocalTransform());
            if (changed & Transform.WORLD_CHANGED) worldTransformChanged(node, components, transform.getWorldTransform());
        }
    }
};

// private methods

/**
 * Private method to call when align changes. Triggers 'onAlignChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to call onAlignChange if necessary
 * @param {Array} components the components on which to call onAlignChange if necessary
 * @param {Object} offsets the set of offsets from the transform
 *
 * @return {undefined} undefined
 */
function alignChanged (node, components, offsets) {
    var x = offsets.align[0];
    var y = offsets.align[1];
    var z = offsets.align[2];
    if (node.onAlignChange) node.onAlignChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onAlignChange)
            components[i].onAlignChange(x, y, z);
    offsets.alignChanged = false;
}

/**
 * Private method to call when MountPoint changes. Triggers 'onMountPointChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Object} offsets the set of offsets from the transform
 *
 * @return {undefined} undefined
 */
function mountPointChanged (node, components, offsets) {
    var x = offsets.mountPoint[0];
    var y = offsets.mountPoint[1];
    var z = offsets.mountPoint[2];
    if (node.onMountPointChange) node.onMountPointChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onMountPointChange)
            components[i].onMountPointChange(x, y, z);
    offsets.mountPointChanged = false;
}

/**
 * Private method to call when Origin changes. Triggers 'onOriginChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Object} offsets the set of offsets from the transform
 *
 * @return {undefined} undefined
 */
function originChanged (node, components, offsets) {
    var x = offsets.origin[0];
    var y = offsets.origin[1];
    var z = offsets.origin[2];
    if (node.onOriginChange) node.onOriginChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onOriginChange)
            components[i].onOriginChange(x, y, z);
    offsets.originChanged = false;
}

/**
 * Private method to call when Position changes. Triggers 'onPositionChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Object} vectors the set of vectors from the transform
 *
 * @return {undefined} undefined
 */
function positionChanged (node, components, vectors) {
    var x = vectors.position[0];
    var y = vectors.position[1];
    var z = vectors.position[2];
    if (node.onPositionChange) node.onPositionChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onPositionChange)
            components[i].onPositionChange(x, y, z);
    vectors.positionChanged = false;
}

/**
 * Private method to call when Rotation changes. Triggers 'onRotationChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Object} vectors the set of vectors from the transform
 *
 * @return {undefined} undefined
 */
function rotationChanged (node, components, vectors) {
    var x = vectors.rotation[0];
    var y = vectors.rotation[1];
    var z = vectors.rotation[2];
    var w = vectors.rotation[3];
    if (node.onRotationChange) node.onRotationChange(x, y, z, w);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onRotationChange)
            components[i].onRotationChange(x, y, z, w);
    vectors.rotationChanged = false;
}

/**
 * Private method to call when Scale changes. Triggers 'onScaleChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Object} vectors the set of vectors from the transform
 *
 * @return {undefined} undefined
 */
function scaleChanged (node, components, vectors) {
    var x = vectors.scale[0];
    var y = vectors.scale[1];
    var z = vectors.scale[2];
    if (node.onScaleChange) node.onScaleChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onScaleChange)
            components[i].onScaleChange(x, y, z);
    vectors.scaleChanged = false;
}

/**
 * Private method to call when either the Local or World Transform changes.
 * Triggers 'onTransformChange' methods on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Transform} transform the transform class that changed
 *
 * @return {undefined} undefined
 */
function transformChanged (node, components, transform) {
    if (node.onTransformChange) node.onTransformChange(transform);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onTransformChange)
            components[i].onTransformChange(transform);
}

/**
 * Private method to call when the local transform changes. Triggers 'onLocalTransformChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Array} transform the local transform
 *
 * @return {undefined} undefined
 */
function localTransformChanged (node, components, transform) {
    if (node.onLocalTransformChange) node.onLocalTransformChange(transform);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onLocalTransformChange)
            components[i].onLocalTransformChange(transform);
}

/**
 * Private method to call when the world transform changes. Triggers 'onWorldTransformChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Array} transform the world transform
 *
 * @return {undefined} undefined
 */
function worldTransformChanged (node, components, transform) {
    if (node.onWorldTransformChange) node.onWorldTransformChange(transform);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onWorldTransformChange)
            components[i].onWorldTransformChange(transform);
}

module.exports = new TransformSystem();


},{"./Dispatch":7,"./Path":11,"./PathStore":12,"./Transform":16}],18:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var CallbackStore = require('../utilities/CallbackStore');
var TransformSystem = require('../core/TransformSystem');
var Commands = require('../core/Commands');

var RENDER_SIZE = 2;

/**
 * A DOMElement is a component that can be added to a Node with the
 * purpose of sending draw commands to the renderer. Renderables send draw commands
 * to through their Nodes to the Compositor where they are acted upon.
 *
 * @class DOMElement
 *
 * @param {Node} node                   The Node to which the `DOMElement`
 *                                      renderable should be attached to.
 * @param {Object} options              Initial options used for instantiating
 *                                      the Node.
 * @param {Object} options.properties   CSS properties that should be added to
 *                                      the actual DOMElement on the initial draw.
 * @param {Object} options.attributes   Element attributes that should be added to
 *                                      the actual DOMElement.
 * @param {String} options.id           String to be applied as 'id' of the actual
 *                                      DOMElement.
 * @param {String} options.content      String to be applied as the content of the
 *                                      actual DOMElement.
 * @param {Boolean} options.cutout      Specifies the presence of a 'cutout' in the
 *                                      WebGL canvas over this element which allows
 *                                      for DOM and WebGL layering.  On by default.
 */
function DOMElement(node, options) {
    if (!node) throw new Error('DOMElement must be instantiated on a node');

    this._changeQueue = [];
    
    this._requestingUpdate = false;
    this._renderSized = false;
    this._requestRenderSize = false;

    this._UIEvents = node.getUIEvents().slice(0);
    this._classes = ['famous-dom-element'];
    this._requestingEventListeners = [];
    this._styles = {};

    this._attributes = {};
    this._content = '';

    this._tagName = options && options.tagName ? options.tagName : 'div';
    this._renderSize = [0, 0, 0];

    this._id = node ? node.addComponent(this) : null;
    this._node = node;

    this.onSizeModeChange.apply(this, node.getSizeMode());

    this._callbacks = new CallbackStore();

    this.setProperty('display', node.isShown() ? 'block' : 'none');
    this.onOpacityChange(node.getOpacity());

    if (!options) return;

    var i;
    var key;

    if (options.classes)
        for (i = 0; i < options.classes.length; i++)
            this.addClass(options.classes[i]);

    if (options.attributes)
        for (key in options.attributes)
            this.setAttribute(key, options.attributes[key]);

    if (options.properties)
        for (key in options.properties)
            this.setProperty(key, options.properties[key]);

    if (options.id) this.setId(options.id);
    if (options.content) this.setContent(options.content);
    if (options.cutout === false) this.setCutoutState(options.cutout);
}

/**
 * Serializes the state of the DOMElement.
 *
 * @method
 *
 * @return {Object} serialized interal state
 */
DOMElement.prototype.getValue = function getValue() {
    return {
        classes: this._classes,
        styles: this._styles,
        attributes: this._attributes,
        content: this._content,
        id: this._attributes.id,
        tagName: this._tagName
    };
};

/**
 * Method to be invoked by the node as soon as an update occurs. This allows
 * the DOMElement renderable to dynamically react to state changes on the Node.
 *
 * This flushes the internal draw command queue by sending individual commands
 * to the node using `sendDrawCommand`.
 *
 * @method
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onUpdate = function onUpdate () {
    var node = this._node;
    var queue = this._changeQueue;
    var len = queue.length;

    if (len && node) {
        node.sendDrawCommand(Commands.WITH);
        node.sendDrawCommand(node.getLocation());

        while (len--) node.sendDrawCommand(queue.shift());
        if (this._requestRenderSize) {
            node.sendDrawCommand(Commands.DOM_RENDER_SIZE);
            node.sendDrawCommand(node.getLocation());
            this._requestRenderSize = false;
        }

    }

    this._requestingUpdate = false;
};

/**
 * Method to be invoked by the Node as soon as the node (or any of its
 * ancestors) is being mounted.
 *
 * @method onMount
 *
 * @param {Node} node      Parent node to which the component should be added.
 * @param {String} id      Path at which the component (or node) is being
 *                          attached. The path is being set on the actual
 *                          DOMElement as a `data-fa-path`-attribute.
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onMount = function onMount(node, id) {
    this._node = node;
    this._id = id;
    this._UIEvents = node.getUIEvents().slice(0);
    TransformSystem.makeBreakPointAt(node.getLocation());
    this.draw();
    this.setAttribute('data-fa-path', node.getLocation());
};

/**
 * Method to be invoked by the Node as soon as the node is being dismounted
 * either directly or by dismounting one of its ancestors.
 *
 * @method
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onDismount = function onDismount() {
    this.setProperty('display', 'none');
    this.setAttribute('data-fa-path', '');
    this.setCutoutState(false);

    this.onUpdate();
    this._initialized = false;
};

/**
 * Method to be invoked by the node as soon as the DOMElement is being shown.
 * This results into the DOMElement setting the `display` property to `block`
 * and therefore visually showing the corresponding DOMElement (again).
 *
 * @method
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onShow = function onShow() {
    this.setProperty('display', 'block');
};

/**
 * Method to be invoked by the node as soon as the DOMElement is being hidden.
 * This results into the DOMElement setting the `display` property to `none`
 * and therefore visually hiding the corresponding DOMElement (again).
 *
 * @method
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onHide = function onHide() {
    this.setProperty('display', 'none');
};

/**
 * Enables or disables WebGL 'cutout' for this element, which affects
 * how the element is layered with WebGL objects in the scene.
 *
 * @method
 *
 * @param {Boolean} usesCutout  The presence of a WebGL 'cutout' for this element.
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.setCutoutState = function setCutoutState (usesCutout) {
    if (this._initialized)
        this._changeQueue.push(Commands.GL_CUTOUT_STATE, usesCutout);

    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};

/**
 * Method to be invoked by the node as soon as the transform matrix associated
 * with the node changes. The DOMElement will react to transform changes by sending
 * `CHANGE_TRANSFORM` commands to the `DOMRenderer`.
 *
 * @method
 *
 * @param {Float32Array} transform The final transform matrix
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onTransformChange = function onTransformChange (transform) {
    this._changeQueue.push(Commands.CHANGE_TRANSFORM);
    transform = transform.getLocalTransform();

    for (var i = 0, len = transform.length ; i < len ; i++)
        this._changeQueue.push(transform[i]);

    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Method to be invoked by the node as soon as its computed size changes.
 *
 * @method
 *
 * @param {Number} x width of the Node the DOMElement is attached to
 * @param {Number} y height of the Node the DOMElement is attached to
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.onSizeChange = function onSizeChange(x, y) {
    var sizeMode = this._node.getSizeMode();
    var sizedX = sizeMode[0] !== RENDER_SIZE;
    var sizedY = sizeMode[1] !== RENDER_SIZE;
    if (this._initialized)
        this._changeQueue.push(Commands.CHANGE_SIZE,
            sizedX ? x : sizedX,
            sizedY ? y : sizedY);

    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};

/**
 * Method to be invoked by the node as soon as its opacity changes
 *
 * @method
 *
 * @param {Number} opacity The new opacity, as a scalar from 0 to 1
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.onOpacityChange = function onOpacityChange(opacity) {
    return this.setProperty('opacity', opacity);
};

/**
 * Method to be invoked by the node as soon as a new UIEvent is being added.
 * This results into an `ADD_EVENT_LISTENER` command being sent.
 *
 * @param {String} uiEvent uiEvent to be subscribed to (e.g. `click`)
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onAddUIEvent = function onAddUIEvent(uiEvent) {
    if (this._UIEvents.indexOf(uiEvent) === -1) {
        this._subscribe(uiEvent);
        this._UIEvents.push(uiEvent);
    }
    else if (this._inDraw) {
        this._subscribe(uiEvent);
    }
    return this;
};

/**
 * Method to be invoked by the node as soon as a UIEvent is removed from
 * the node.  This results into an `UNSUBSCRIBE` command being sent.
 *
 * @param {String} UIEvent UIEvent to be removed (e.g. `mousedown`)
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onRemoveUIEvent = function onRemoveUIEvent(UIEvent) {
    var index = this._UIEvents.indexOf(UIEvent);
    if (index !== -1) {
        this._unsubscribe(UIEvent);
        this._UIEvents.splice(index, 1);
    }
    else if (this._inDraw) {
        this._unsubscribe(UIEvent);
    }
    return this;
};

/**
 * Appends an `SUBSCRIBE` command to the command queue.
 *
 * @method
 * @private
 *
 * @param {String} uiEvent Event type (e.g. `click`)
 *
 * @return {undefined} undefined
 */
DOMElement.prototype._subscribe = function _subscribe (uiEvent) {
    if (this._initialized) {
        this._changeQueue.push(Commands.SUBSCRIBE, uiEvent);
    }

    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * When running in a worker, the browser's default action for specific events
 * can't be prevented on a case by case basis (via `e.preventDefault()`).
 * Instead this function should be used to register an event to be prevented by
 * default.
 *
 * @method
 *
 * @param  {String} uiEvent     UI Event (e.g. wheel) for which to prevent the
 *                              browser's default action (e.g. form submission,
 *                              scrolling)
 * @return {undefined}          undefined
 */
DOMElement.prototype.preventDefault = function preventDefault (uiEvent) {
    if (this._initialized) {
        this._changeQueue.push(Commands.PREVENT_DEFAULT, uiEvent);
    }
    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Opposite of {@link DOMElement#preventDefault}. No longer prevent the
 * browser's default action on subsequent events of this type.
 *
 * @method
 *
 * @param  {type} uiEvent       UI Event previously registered using
 *                              {@link DOMElement#preventDefault}.
 * @return {undefined}          undefined
 */
DOMElement.prototype.allowDefault = function allowDefault (uiEvent) {
    if (this._initialized) {
        this._changeQueue.push(Commands.ALLOW_DEFAULT, uiEvent);
    }

    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Appends an `UNSUBSCRIBE` command to the command queue.
 *
 * @method
 * @private
 *
 * @param {String} UIEvent Event type (e.g. `click`)
 *
 * @return {undefined} undefined
 */
DOMElement.prototype._unsubscribe = function _unsubscribe (UIEvent) {
    if (this._initialized) {
        this._changeQueue.push('UNSUBSCRIBE', UIEvent);
    }
    
    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Method to be invoked by the node as soon as the underlying size mode
 * changes. This results into the size being fetched from the node in
 * order to update the actual, rendered size.
 *
 * @method
 *
 * @param {Number} x the sizing mode in use for determining size in the x direction
 * @param {Number} y the sizing mode in use for determining size in the y direction
 * @param {Number} z the sizing mode in use for determining size in the z direction
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onSizeModeChange = function onSizeModeChange(x, y, z) {
    if (x === RENDER_SIZE || y === RENDER_SIZE || z === RENDER_SIZE) {
        this._renderSized = true;
        this._requestRenderSize = true;
    }
    var size = this._node.getSize();
    this.onSizeChange(size[0], size[1]);
};

/**
 * Method to be retrieve the rendered size of the DOM element that is
 * drawn for this node.
 *
 * @method
 *
 * @return {Array} size of the rendered DOM element in pixels
 */
DOMElement.prototype.getRenderSize = function getRenderSize() {
    return this._renderSize;
};

/**
 * Method to have the component request an update from its Node
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
DOMElement.prototype._requestUpdate = function _requestUpdate() {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
};

/**
 * Initializes the DOMElement by sending the `INIT_DOM` command. This creates
 * or reallocates a new Element in the actual DOM hierarchy.
 *
 * @method
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.init = function init () {
    this._changeQueue.push(Commands.INIT_DOM, this._tagName);
    this._initialized = true;
    this.onTransformChange(TransformSystem.get(this._node.getLocation()));
    var size = this._node.getSize();
    this.onSizeChange(size[0], size[1]);
    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Sets the id attribute of the DOMElement.
 *
 * @method
 *
 * @param {String} id New id to be set
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.setId = function setId (id) {
    this.setAttribute('id', id);
    return this;
};

/**
 * Adds a new class to the internal class list of the underlying Element in the
 * DOM.
 *
 * @method
 *
 * @param {String} value New class name to be added
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.addClass = function addClass (value) {
    if (this._classes.indexOf(value) < 0) {
        if (this._initialized) this._changeQueue.push(Commands.ADD_CLASS, value);
        this._classes.push(value);
        if (!this._requestingUpdate) this._requestUpdate();
        if (this._renderSized) this._requestRenderSize = true;
        return this;
    }

    if (this._inDraw) {
        if (this._initialized) this._changeQueue.push(Commands.ADD_CLASS, value);
        if (!this._requestingUpdate) this._requestUpdate();
    }
    return this;
};

/**
 * Removes a class from the DOMElement's classList.
 *
 * @method
 *
 * @param {String} value Class name to be removed
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.removeClass = function removeClass (value) {
    var index = this._classes.indexOf(value);

    if (index < 0) return this;

    this._changeQueue.push(Commands.REMOVE_CLASS, value);

    this._classes.splice(index, 1);

    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};


/**
 * Checks if the DOMElement has the passed in class.
 *
 * @method
 *
 * @param {String} value The class name
 *
 * @return {Boolean} Boolean value indicating whether the passed in class name is in the DOMElement's class list.
 */
DOMElement.prototype.hasClass = function hasClass (value) {
    return this._classes.indexOf(value) !== -1;
};

/**
 * Sets an attribute of the DOMElement.
 *
 * @method
 *
 * @param {String} name Attribute key (e.g. `src`)
 * @param {String} value Attribute value (e.g. `http://famo.us`)
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.setAttribute = function setAttribute (name, value) {
    if (this._attributes[name] !== value || this._inDraw) {
        this._attributes[name] = value;
        if (this._initialized) this._changeQueue.push(Commands.CHANGE_ATTRIBUTE, name, value);
        if (!this._requestUpdate) this._requestUpdate();
    }

    return this;
};

/**
 * Sets a CSS property
 *
 * @chainable
 *
 * @param {String} name  Name of the CSS rule (e.g. `background-color`)
 * @param {String} value Value of CSS property (e.g. `red`)
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.setProperty = function setProperty (name, value) {
    if (this._styles[name] !== value || this._inDraw) {
        this._styles[name] = value;
        if (this._initialized) this._changeQueue.push(Commands.CHANGE_PROPERTY, name, value);
        if (!this._requestingUpdate) this._requestUpdate();
        if (this._renderSized) this._requestRenderSize = true;
    }

    return this;
};

/**
 * Sets the content of the DOMElement. This is using `innerHTML`, escaping user
 * generated content is therefore essential for security purposes.
 *
 * @method
 *
 * @param {String} content Content to be set using `.innerHTML = ...`
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.setContent = function setContent (content) {
    if (this._content !== content || this._inDraw) {
        this._content = content;
        if (this._initialized) this._changeQueue.push(Commands.CHANGE_CONTENT, content);
        if (!this._requestingUpdate) this._requestUpdate();
        if (this._renderSized) this._requestRenderSize = true;
    }

    return this;
};

/**
 * Subscribes to a DOMElement using.
 *
 * @method on
 *
 * @param {String} event       The event type (e.g. `click`).
 * @param {Function} listener  Handler function for the specified event type
 *                              in which the payload event object will be
 *                              passed into.
 *
 * @return {Function} A function to call if you want to remove the callback
 */
DOMElement.prototype.on = function on (event, listener) {
    return this._callbacks.on(event, listener);
};

/**
 * Function to be invoked by the Node whenever an event is being received.
 * There are two different ways to subscribe for those events:
 *
 * 1. By overriding the onReceive method (and possibly using `switch` in order
 *     to differentiate between the different event types).
 * 2. By using DOMElement and using the built-in CallbackStore.
 *
 * @method
 *
 * @param {String} event Event type (e.g. `click`)
 * @param {Object} payload Event object.
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onReceive = function onReceive (event, payload) {
    if (event === 'resize') {
        this._renderSize[0] = payload.val[0];
        this._renderSize[1] = payload.val[1];
        if (!this._requestingUpdate) this._requestUpdate();
    }
    this._callbacks.trigger(event, payload);
};

/**
 * The draw function is being used in order to allow mutating the DOMElement
 * before actually mounting the corresponding node.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.draw = function draw() {
    var key;
    var i;
    var len;

    this._inDraw = true;

    this.init();

    for (i = 0, len = this._classes.length ; i < len ; i++)
        this.addClass(this._classes[i]);

    if (this._content) this.setContent(this._content);

    for (key in this._styles)
        if (this._styles[key] != null)
            this.setProperty(key, this._styles[key]);

    for (key in this._attributes)
        if (this._attributes[key] != null)
            this.setAttribute(key, this._attributes[key]);

    for (i = 0, len = this._UIEvents.length ; i < len ; i++)
        this.onAddUIEvent(this._UIEvents[i]);

    this._inDraw = false;
};

module.exports = DOMElement;

},{"../core/Commands":6,"../core/TransformSystem":17,"../utilities/CallbackStore":42}],19:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var ElementCache = require('./ElementCache');
var math = require('./Math');
var PathUtils = require('../core/Path');
var vendorPrefix = require('../utilities/vendorPrefix');
var eventMap = require('./events/EventMap');

var TRANSFORM = null;

/**
 * DOMRenderer is a class responsible for adding elements
 * to the DOM and writing to those elements.
 * There is a DOMRenderer per context, represented as an
 * element and a selector. It is instantiated in the
 * context class.
 *
 * @class DOMRenderer
 *
 * @param {HTMLElement} element an element.
 * @param {String} selector the selector of the element.
 * @param {Compositor} compositor the compositor controlling the renderer
 */
function DOMRenderer (element, selector, compositor) {
    var _this = this;

    element.classList.add('famous-dom-renderer');

    TRANSFORM = TRANSFORM || vendorPrefix('transform');
    this._compositor = compositor; // a reference to the compositor

    this._target = null; // a register for holding the current
                         // element that the Renderer is operating
                         // upon

    this._parent = null; // a register for holding the parent
                         // of the target

    this._path = null; // a register for holding the path of the target
                       // this register must be set first, and then
                       // children, target, and parent are all looked
                       // up from that.

    this._children = []; // a register for holding the children of the
                         // current target.

    this._root = new ElementCache(element, selector); // the root
                                                      // of the dom tree that this
                                                      // renderer is responsible
                                                      // for

    this._boundTriggerEvent = function (ev) {
        return _this._triggerEvent(ev);
    };

    this._selector = selector;

    this._elements = {};

    this._elements[selector] = this._root;

    this.perspectiveTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    this._VPtransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);

    this._lastEv = null;
}


/**
 * Attaches an EventListener to the element associated with the passed in path.
 * Prevents the default browser action on all subsequent events if
 * `preventDefault` is truthy.
 * All incoming events will be forwarded to the compositor by invoking the
 * `sendEvent` method.
 * Delegates events if possible by attaching the event listener to the context.
 *
 * @method
 *
 * @param {String} type DOM event type (e.g. click, mouseover).
 * @param {Boolean} preventDefault Whether or not the default browser action should be prevented.
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.subscribe = function subscribe(type) {
    this._assertTargetLoaded();
    this._listen(type);
    this._target.subscribe[type] = true;
};

/**
 * Unsubscribes from all events that are of the specified type.
 *
 * @method
 *
 * @param  {String} type    Event type to unsubscribe from.
 * @return {undefined}      undefined
 */
DOMRenderer.prototype.unsubscribe = function unsubscribe(type) {
    this._assertTargetLoaded();
    this._listen(type);
    this._target.subscribe[type] = false;
};

/**
 * Used to preventDefault if an event of the specified type is being emitted on
 * the currently loaded target.
 *
 * @method
 *
 * @param  {String} type    The type of events that should be prevented.
 * @return {undefined}      undefined
 */
DOMRenderer.prototype.preventDefault = function preventDefault(type) {
    this._assertTargetLoaded();
    this._listen(type);
    this._target.preventDefault[type] = true;
};

/**
 * Used to undo a previous call to preventDefault. No longer `preventDefault`
 * for this event on the loaded target.
 *
 * @method
 * @private
 *
 * @param  {String} type    The event type that should no longer be affected by
 *                          `preventDefault`.
 * @return {undefined}      undefined
 */
DOMRenderer.prototype.allowDefault = function allowDefault(type) {
    this._assertTargetLoaded();
    this._listen(type);
    this._target.preventDefault[type] = false;
};

/**
 * Internal helper function used for adding an event listener for the the
 * currently loaded ElementCache.
 *
 * If the event can be delegated as specified in the {@link EventMap}, the
 * bound {@link _triggerEvent} function will be added as a listener on the
 * root element. Otherwise, the listener will be added directly to the target
 * element.
 *
 * @private
 * @method
 *
 * @param  {String} type    The event type to listen to (e.g. click).
 * @return {undefined}      undefined
 */
DOMRenderer.prototype._listen = function _listen(type) {
    this._assertTargetLoaded();

    if (
        !this._target.listeners[type] && !this._root.listeners[type]
    ) {
        // FIXME Add to content DIV if available
        var target = eventMap[type][1] ? this._root : this._target;
        target.listeners[type] = this._boundTriggerEvent;
        target.element.addEventListener(type, this._boundTriggerEvent);
    }
};

/**
 * Removes an EventListener of given type from the element on which it was
 * registered.
 *
 * @method
 *
 * @param {String} type DOM event type (e.g. click, mouseover).
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.unsubscribe = function unsubscribe(type) {
    this._assertTargetLoaded();
    this._target.subscribe[type] = false;
};

/**
 * Function to be added using `addEventListener` to the corresponding
 * DOMElement.
 *
 * @method
 * @private
 *
 * @param {Event} ev DOM Event payload
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype._triggerEvent = function _triggerEvent(ev) {
    if (this._lastEv === ev) return;

    // Use ev.path, which is an array of Elements (polyfilled if needed).
    var evPath = ev.path ? ev.path : _getPath(ev);
    // First element in the path is the element on which the event has actually
    // been emitted.
    for (var i = 0; i < evPath.length; i++) {
        // Skip nodes that don't have a dataset property or data-fa-path
        // attribute.
        if (!evPath[i].dataset) continue;
        var path = evPath[i].dataset.faPath;
        if (!path) continue;

        // Optionally preventDefault. This needs forther consideration and
        // should be optional. Eventually this should be a separate command/
        // method.
        if (this._elements[path].preventDefault[ev.type]) {
            ev.preventDefault();
        }

        // Stop further event propogation and path traversal as soon as the
        // first ElementCache subscribing for the emitted event has been found.
        if (this._elements[path] && this._elements[path].subscribe[ev.type]) {
            this._lastEv = ev;

            var NormalizedEventConstructor = eventMap[ev.type][0];

            // Finally send the event to the Worker Thread through the
            // compositor.
            this._compositor.sendEvent(path, ev.type, new NormalizedEventConstructor(ev));

            break;
        }
    }
};


/**
 * getSizeOf gets the dom size of a particular DOM element.  This is
 * needed for render sizing in the scene graph.
 *
 * @method
 *
 * @param {String} path path of the Node in the scene graph
 *
 * @return {Array} a vec3 of the offset size of the dom element
 */
DOMRenderer.prototype.getSizeOf = function getSizeOf(path) {
    var element = this._elements[path];
    if (!element) return null;

    var res = {val: element.size};
    this._compositor.sendEvent(path, 'resize', res);
    return res;
};

function _getPath(ev) {
    // TODO move into _triggerEvent, avoid object allocation
    var path = [];
    var node = ev.target;
    while (node !== document.body) {
        path.push(node);
        node = node.parentNode;
    }
    return path;
}

/**
 * Executes the retrieved draw commands. Draw commands only refer to the
 * cross-browser normalized `transform` property.
 *
 * @method
 *
 * @param {Object} renderState description
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.draw = function draw(renderState) {
    if (renderState.perspectiveDirty) {
        this.perspectiveDirty = true;

        this.perspectiveTransform[0] = renderState.perspectiveTransform[0];
        this.perspectiveTransform[1] = renderState.perspectiveTransform[1];
        this.perspectiveTransform[2] = renderState.perspectiveTransform[2];
        this.perspectiveTransform[3] = renderState.perspectiveTransform[3];

        this.perspectiveTransform[4] = renderState.perspectiveTransform[4];
        this.perspectiveTransform[5] = renderState.perspectiveTransform[5];
        this.perspectiveTransform[6] = renderState.perspectiveTransform[6];
        this.perspectiveTransform[7] = renderState.perspectiveTransform[7];

        this.perspectiveTransform[8] = renderState.perspectiveTransform[8];
        this.perspectiveTransform[9] = renderState.perspectiveTransform[9];
        this.perspectiveTransform[10] = renderState.perspectiveTransform[10];
        this.perspectiveTransform[11] = renderState.perspectiveTransform[11];

        this.perspectiveTransform[12] = renderState.perspectiveTransform[12];
        this.perspectiveTransform[13] = renderState.perspectiveTransform[13];
        this.perspectiveTransform[14] = renderState.perspectiveTransform[14];
        this.perspectiveTransform[15] = renderState.perspectiveTransform[15];
    }

    if (renderState.viewDirty || renderState.perspectiveDirty) {
        math.multiply(this._VPtransform, this.perspectiveTransform, renderState.viewTransform);
        this._root.element.style[TRANSFORM] = this._stringifyMatrix(this._VPtransform);
    }
};


/**
 * Internal helper function used for ensuring that a path is currently loaded.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype._assertPathLoaded = function _asserPathLoaded() {
    if (!this._path) throw new Error('path not loaded');
};

/**
 * Internal helper function used for ensuring that a parent is currently loaded.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype._assertParentLoaded = function _assertParentLoaded() {
    if (!this._parent) throw new Error('parent not loaded');
};

/**
 * Internal helper function used for ensuring that children are currently
 * loaded.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype._assertChildrenLoaded = function _assertChildrenLoaded() {
    if (!this._children) throw new Error('children not loaded');
};

/**
 * Internal helper function used for ensuring that a target is currently loaded.
 *
 * @method  _assertTargetLoaded
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype._assertTargetLoaded = function _assertTargetLoaded() {
    if (!this._target) throw new Error('No target loaded');
};

/**
 * Finds and sets the parent of the currently loaded element (path).
 *
 * @method
 * @private
 *
 * @return {ElementCache} Parent element.
 */
DOMRenderer.prototype.findParent = function findParent () {
    this._assertPathLoaded();

    var path = this._path;
    var parent;

    while (!parent && path.length) {
        path = path.substring(0, path.lastIndexOf('/'));
        parent = this._elements[path];
    }
    this._parent = parent;
    return parent;
};

/**
 * Used for determining the target loaded under the current path.
 *
 * @method
 *
 * @return {ElementCache|undefined} Element loaded under defined path.
 */
DOMRenderer.prototype.findTarget = function findTarget() {
    this._target = this._elements[this._path];
    return this._target;
};


/**
 * Loads the passed in path.
 *
 * @method
 *
 * @param {String} path Path to be loaded
 *
 * @return {String} Loaded path
 */
DOMRenderer.prototype.loadPath = function loadPath (path) {
    this._path = path;
    return this._path;
};

/**
 * Finds children of a parent element that are descendents of a inserted element in the scene
 * graph. Appends those children to the inserted element.
 *
 * @method resolveChildren
 * @return {void}
 *
 * @param {HTMLElement} element the inserted element
 * @param {HTMLElement} parent the parent of the inserted element
 */
DOMRenderer.prototype.resolveChildren = function resolveChildren (element, parent) {
    var i = 0;
    var childNode;
    var path = this._path;
    var childPath;

    while ((childNode = parent.childNodes[i])) {
        if (!childNode.dataset) {
            i++;
            continue;
        }
        childPath = childNode.dataset.faPath;
        if (!childPath) {
            i++;
            continue;
        }
        if (PathUtils.isDescendentOf(childPath, path)) element.appendChild(childNode);
        else i++;
    }
};

/**
 * Inserts a DOMElement at the currently loaded path, assuming no target is
 * loaded. Only one DOMElement can be associated with each path.
 *
 * @method
 *
 * @param {String} tagName Tag name (capitalization will be normalized).
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.insertEl = function insertEl (tagName) {
    if (!this._target ||
        this._target.element.tagName.toLowerCase() !== tagName.toLowerCase()) {

        this.findParent();

        this._assertParentLoaded();

        if (this._parent.void)
            throw new Error(
                this._parent.path + ' is a void element. ' +
                'Void elements are not allowed to have children.'
            );

        if (this._target) this._parent.element.removeChild(this._target.element);

        this._target = new ElementCache(document.createElement(tagName), this._path);

        var el = this._target.element;
        var parent = this._parent.element;

        this.resolveChildren(el, parent);

        this._parent.element.appendChild(this._target.element);
        this._elements[this._path] = this._target;
    }
};


/**
 * Sets a property on the currently loaded target.
 *
 * @method
 *
 * @param {String} name Property name (e.g. background, color, font)
 * @param {String} value Proprty value (e.g. black, 20px)
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.setProperty = function setProperty (name, value) {
    this._assertTargetLoaded();
    this._target.element.style[name] = value;
};


/**
 * Sets the size of the currently loaded target.
 * Removes any explicit sizing constraints when passed in `false`
 * ("true-sizing").
 * 
 * Invoking setSize is equivalent to a manual invocation of `setWidth` followed
 * by `setHeight`.
 *
 * @method
 *
 * @param {Number|false} width   Width to be set.
 * @param {Number|false} height  Height to be set.
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.setSize = function setSize (width, height) {
    this._assertTargetLoaded();

    this.setWidth(width);
    this.setHeight(height);
};

/**
 * Sets the width of the currently loaded ElementCache.
 * 
 * @method
 *  
 * @param  {Number|false} width     The explicit width to be set on the
 *                                  ElementCache's target (and content) element.
 *                                  `false` removes any explicit sizing
 *                                  constraints from the underlying DOM
 *                                  Elements.
 *
 * @return {undefined} undefined
 */ 
DOMRenderer.prototype.setWidth = function setWidth(width) {
    this._assertTargetLoaded();

    var contentWrapper = this._target.content;

    if (width === false) {
        this._target.explicitWidth = true;
        if (contentWrapper) contentWrapper.style.width = '';
        width = contentWrapper ? contentWrapper.offsetWidth : 0;
        this._target.element.style.width = width + 'px';
    }
    else {
        this._target.explicitWidth = false;
        if (contentWrapper) contentWrapper.style.width = width + 'px';
        this._target.element.style.width = width + 'px';
    }

    this._target.size[0] = width;
};

/**
 * Sets the height of the currently loaded ElementCache.
 * 
 * @method  setHeight
 *  
 * @param  {Number|false} height    The explicit height to be set on the
 *                                  ElementCache's target (and content) element.
 *                                  `false` removes any explicit sizing
 *                                  constraints from the underlying DOM
 *                                  Elements.
 *
 * @return {undefined} undefined
 */ 
DOMRenderer.prototype.setHeight = function setHeight(height) {
    this._assertTargetLoaded();

    var contentWrapper = this._target.content;

    if (height === false) {
        this._target.explicitHeight = true;
        if (contentWrapper) contentWrapper.style.height = '';
        height = contentWrapper ? contentWrapper.offsetHeight : 0;
        this._target.element.style.height = height + 'px';
    }
    else {
        this._target.explicitHeight = false;
        if (contentWrapper) contentWrapper.style.height = height + 'px';
        this._target.element.style.height = height + 'px';
    }

    this._target.size[1] = height;
};

/**
 * Sets an attribute on the currently loaded target.
 *
 * @method
 *
 * @param {String} name Attribute name (e.g. href)
 * @param {String} value Attribute value (e.g. http://famous.org)
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.setAttribute = function setAttribute(name, value) {
    this._assertTargetLoaded();
    this._target.element.setAttribute(name, value);
};

/**
 * Sets the `innerHTML` content of the currently loaded target.
 *
 * @method
 *
 * @param {String} content Content to be set as `innerHTML`
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.setContent = function setContent(content) {
    this._assertTargetLoaded();

    if (this._target.formElement) {
        this._target.element.value = content;
    }
    else {
        if (!this._target.content) {
            this._target.content = document.createElement('div');
            this._target.content.classList.add('famous-dom-element-content');
            this._target.element.insertBefore(
                this._target.content,
                this._target.element.firstChild
            );
        }
        this._target.content.innerHTML = content;
    }


    this.setSize(
        this._target.explicitWidth ? false : this._target.size[0],
        this._target.explicitHeight ? false : this._target.size[1]
    );
};


/**
 * Sets the passed in transform matrix (world space). Inverts the parent's world
 * transform.
 *
 * @method
 *
 * @param {Float32Array} transform The transform for the loaded DOM Element in world space
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.setMatrix = function setMatrix (transform) {
    this._assertTargetLoaded();
    this._target.element.style[TRANSFORM] = this._stringifyMatrix(transform);
};


/**
 * Adds a class to the classList associated with the currently loaded target.
 *
 * @method
 *
 * @param {String} domClass Class name to be added to the current target.
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.addClass = function addClass(domClass) {
    this._assertTargetLoaded();
    this._target.element.classList.add(domClass);
};


/**
 * Removes a class from the classList associated with the currently loaded
 * target.
 *
 * @method
 *
 * @param {String} domClass Class name to be removed from currently loaded target.
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.removeClass = function removeClass(domClass) {
    this._assertTargetLoaded();
    this._target.element.classList.remove(domClass);
};


/**
 * Stringifies the passed in matrix for setting the `transform` property.
 *
 * @method  _stringifyMatrix
 * @private
 *
 * @param {Array} m    Matrix as an array or array-like object.
 * @return {String}     Stringified matrix as `matrix3d`-property.
 */
DOMRenderer.prototype._stringifyMatrix = function _stringifyMatrix(m) {
    var r = 'matrix3d(';
    
    r += (m[0] < 0.000001 && m[0] > -0.000001) ? '0,' : m[0] + ',';
    r += (m[1] < 0.000001 && m[1] > -0.000001) ? '0,' : m[1] + ',';
    r += (m[2] < 0.000001 && m[2] > -0.000001) ? '0,' : m[2] + ',';
    r += (m[3] < 0.000001 && m[3] > -0.000001) ? '0,' : m[3] + ',';
    r += (m[4] < 0.000001 && m[4] > -0.000001) ? '0,' : m[4] + ',';
    r += (m[5] < 0.000001 && m[5] > -0.000001) ? '0,' : m[5] + ',';
    r += (m[6] < 0.000001 && m[6] > -0.000001) ? '0,' : m[6] + ',';
    r += (m[7] < 0.000001 && m[7] > -0.000001) ? '0,' : m[7] + ',';
    r += (m[8] < 0.000001 && m[8] > -0.000001) ? '0,' : m[8] + ',';
    r += (m[9] < 0.000001 && m[9] > -0.000001) ? '0,' : m[9] + ',';
    r += (m[10] < 0.000001 && m[10] > -0.000001) ? '0,' : m[10] + ',';
    r += (m[11] < 0.000001 && m[11] > -0.000001) ? '0,' : m[11] + ',';
    r += (m[12] < 0.000001 && m[12] > -0.000001) ? '0,' : m[12] + ',';
    r += (m[13] < 0.000001 && m[13] > -0.000001) ? '0,' : m[13] + ',';
    r += (m[14] < 0.000001 && m[14] > -0.000001) ? '0,' : m[14] + ',';
    
    r += m[15] + ')';
    return r;
};

module.exports = DOMRenderer;

},{"../core/Path":11,"../utilities/vendorPrefix":45,"./ElementCache":20,"./Math":21,"./events/EventMap":25}],20:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var VoidElements = require('./VoidElements');

/**
 * ElementCache is being used for keeping track of an element's DOM Element,
 * path, world transform, inverted parent, final transform (as being used for
 * setting the actual `transform`-property) and post render size (final size as
 * being rendered to the DOM).
 *
 * @class ElementCache
 *
 * @param {Element} element DOMElement
 * @param {String} path Path used for uniquely identifying the location in the
 *                      scene graph.
 */
function ElementCache (element, path) {
    this.tagName = element.tagName.toLowerCase();
    this.void = VoidElements[this.tagName];

    var constructor = element.constructor;

    this.formElement = constructor === HTMLInputElement ||
        constructor === HTMLTextAreaElement ||
        constructor === HTMLSelectElement;

    this.element = element;
    this.path = path;
    this.content = null;
    this.size = new Int16Array(3);
    this.explicitHeight = false;
    this.explicitWidth = false;
    this.postRenderSize = new Float32Array(2);
    this.listeners = {};
    this.preventDefault = {};
    this.subscribe = {};
}

module.exports = ElementCache;

},{"./VoidElements":22}],21:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * A method for inverting a transform matrix
 *
 * @method
 *
 * @param {Array} out array to store the return of the inversion
 * @param {Array} a transform matrix to inverse
 *
 * @return {Array} out
 *   output array that is storing the transform matrix
 */
function invert (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
}

/**
 * A method for multiplying two matricies
 *
 * @method
 *
 * @param {Array} out array to store the return of the multiplication
 * @param {Array} a transform matrix to multiply
 * @param {Array} b transform matrix to multiply
 *
 * @return {Array} out
 *   output array that is storing the transform matrix
 */
function multiply (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3],
        b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7],
        b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11],
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    var changed = false;
    var out0, out1, out2, out3;

    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[0] ||
                        out1 === out[1] ||
                        out2 === out[2] ||
                        out3 === out[3];

    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = out3;

    b0 = b4; b1 = b5; b2 = b6; b3 = b7;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[4] ||
                        out1 === out[5] ||
                        out2 === out[6] ||
                        out3 === out[7];

    out[4] = out0;
    out[5] = out1;
    out[6] = out2;
    out[7] = out3;

    b0 = b8; b1 = b9; b2 = b10; b3 = b11;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[8] ||
                        out1 === out[9] ||
                        out2 === out[10] ||
                        out3 === out[11];

    out[8] = out0;
    out[9] = out1;
    out[10] = out2;
    out[11] = out3;

    b0 = b12; b1 = b13; b2 = b14; b3 = b15;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[12] ||
                        out1 === out[13] ||
                        out2 === out[14] ||
                        out3 === out[15];

    out[12] = out0;
    out[13] = out1;
    out[14] = out2;
    out[15] = out3;

    return out;
}

module.exports = {
    multiply: multiply,
    invert: invert
};

},{}],22:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Map of void elements as defined by the
 * [HTML5 spec](http://www.w3.org/TR/html5/syntax.html#elements-0).
 *
 * @type {Object}
 */
var VoidElements = {
    area  : true,
    base  : true,
    br    : true,
    col   : true,
    embed : true,
    hr    : true,
    img   : true,
    input : true,
    keygen: true,
    link  : true,
    meta  : true,
    param : true,
    source: true,
    track : true,
    wbr   : true
};

module.exports = VoidElements;

},{}],23:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

/**
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428/#events-compositionevents).
 *
 * @class CompositionEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function CompositionEvent(ev) {
    // [Constructor(DOMString typeArg, optional CompositionEventInit compositionEventInitDict)]
    // interface CompositionEvent : UIEvent {
    //     readonly    attribute DOMString data;
    // };

    UIEvent.call(this, ev);

    /**
     * @name CompositionEvent#data
     * @type String
     */
    this.data = ev.data;
}

CompositionEvent.prototype = Object.create(UIEvent.prototype);
CompositionEvent.prototype.constructor = CompositionEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
CompositionEvent.prototype.toString = function toString () {
    return 'CompositionEvent';
};

module.exports = CompositionEvent;

},{"./UIEvent":31}],24:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * The Event class is being used in order to normalize native DOM events.
 * Events need to be normalized in order to be serialized through the structured
 * cloning algorithm used by the `postMessage` method (Web Workers).
 *
 * Wrapping DOM events also has the advantage of providing a consistent
 * interface for interacting with DOM events across browsers by copying over a
 * subset of the exposed properties that is guaranteed to be consistent across
 * browsers.
 *
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428/#interface-Event).
 *
 * @class Event
 *
 * @param {Event} ev The native DOM event.
 */
function Event(ev) {
    // [Constructor(DOMString type, optional EventInit eventInitDict),
    //  Exposed=Window,Worker]
    // interface Event {
    //   readonly attribute DOMString type;
    //   readonly attribute EventTarget? target;
    //   readonly attribute EventTarget? currentTarget;

    //   const unsigned short NONE = 0;
    //   const unsigned short CAPTURING_PHASE = 1;
    //   const unsigned short AT_TARGET = 2;
    //   const unsigned short BUBBLING_PHASE = 3;
    //   readonly attribute unsigned short eventPhase;

    //   void stopPropagation();
    //   void stopImmediatePropagation();

    //   readonly attribute boolean bubbles;
    //   readonly attribute boolean cancelable;
    //   void preventDefault();
    //   readonly attribute boolean defaultPrevented;

    //   [Unforgeable] readonly attribute boolean isTrusted;
    //   readonly attribute DOMTimeStamp timeStamp;

    //   void initEvent(DOMString type, boolean bubbles, boolean cancelable);
    // };

    /**
     * @name Event#type
     * @type String
     */
    this.type = ev.type;

    /**
     * @name Event#defaultPrevented
     * @type Boolean
     */
    this.defaultPrevented = ev.defaultPrevented;

    /**
     * @name Event#timeStamp
     * @type Number
     */
    this.timeStamp = ev.timeStamp;


    /**
     * Used for exposing the current target's value.
     *
     * @name Event#value
     * @type String
     */
    var targetConstructor = ev.target.constructor;
    // TODO Support HTMLKeygenElement
    if (
        targetConstructor === HTMLInputElement ||
        targetConstructor === HTMLTextAreaElement ||
        targetConstructor === HTMLSelectElement
    ) {
        this.value = ev.target.value;
    }
}

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
Event.prototype.toString = function toString () {
    return 'Event';
};

module.exports = Event;

},{}],25:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var CompositionEvent = require('./CompositionEvent');
var Event = require('./Event');
var FocusEvent = require('./FocusEvent');
var InputEvent = require('./InputEvent');
var KeyboardEvent = require('./KeyboardEvent');
var MouseEvent = require('./MouseEvent');
var TouchEvent = require('./TouchEvent');
var UIEvent = require('./UIEvent');
var WheelEvent = require('./WheelEvent');

/**
 * A mapping of DOM events to the corresponding handlers
 *
 * @name EventMap
 * @type Object
 */
var EventMap = {
    change                         : [Event, true],
    submit                         : [Event, true],

    // UI Events (http://www.w3.org/TR/uievents/)
    abort                          : [Event, false],
    beforeinput                    : [InputEvent, true],
    blur                           : [FocusEvent, false],
    click                          : [MouseEvent, true],
    compositionend                 : [CompositionEvent, true],
    compositionstart               : [CompositionEvent, true],
    compositionupdate              : [CompositionEvent, true],
    dblclick                       : [MouseEvent, true],
    focus                          : [FocusEvent, false],
    focusin                        : [FocusEvent, true],
    focusout                       : [FocusEvent, true],
    input                          : [InputEvent, true],
    keydown                        : [KeyboardEvent, true],
    keyup                          : [KeyboardEvent, true],
    load                           : [Event, false],
    mousedown                      : [MouseEvent, true],
    mouseenter                     : [MouseEvent, false],
    mouseleave                     : [MouseEvent, false],

    // bubbles, but will be triggered very frequently
    mousemove                      : [MouseEvent, false],

    mouseout                       : [MouseEvent, true],
    mouseover                      : [MouseEvent, true],
    mouseup                        : [MouseEvent, true],
    resize                         : [UIEvent, false],

    // might bubble
    scroll                         : [UIEvent, false],

    select                         : [Event, true],
    unload                         : [Event, false],
    wheel                          : [WheelEvent, true],

    // Touch Events Extension (http://www.w3.org/TR/touch-events-extensions/)
    touchcancel                    : [TouchEvent, true],
    touchend                       : [TouchEvent, true],
    touchmove                      : [TouchEvent, true],
    touchstart                     : [TouchEvent, true]
};

module.exports = EventMap;

},{"./CompositionEvent":23,"./Event":24,"./FocusEvent":26,"./InputEvent":27,"./KeyboardEvent":28,"./MouseEvent":29,"./TouchEvent":30,"./UIEvent":31,"./WheelEvent":32}],26:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

/**
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428/#events-focusevent).
 *
 * @class FocusEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function FocusEvent(ev) {
    // [Constructor(DOMString typeArg, optional FocusEventInit focusEventInitDict)]
    // interface FocusEvent : UIEvent {
    //     readonly    attribute EventTarget? relatedTarget;
    // };

    UIEvent.call(this, ev);
}

FocusEvent.prototype = Object.create(UIEvent.prototype);
FocusEvent.prototype.constructor = FocusEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
FocusEvent.prototype.toString = function toString () {
    return 'FocusEvent';
};

module.exports = FocusEvent;

},{"./UIEvent":31}],27:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

/**
 * See [Input Events](http://w3c.github.io/editing-explainer/input-events.html#idl-def-InputEvent).
 *
 * @class InputEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function InputEvent(ev) {
    // [Constructor(DOMString typeArg, optional InputEventInit inputEventInitDict)]
    // interface InputEvent : UIEvent {
    //     readonly    attribute DOMString inputType;
    //     readonly    attribute DOMString data;
    //     readonly    attribute boolean   isComposing;
    //     readonly    attribute Range     targetRange;
    // };

    UIEvent.call(this, ev);

    /**
     * @name    InputEvent#inputType
     * @type    String
     */
    this.inputType = ev.inputType;

    /**
     * @name    InputEvent#data
     * @type    String
     */
    this.data = ev.data;

    /**
     * @name    InputEvent#isComposing
     * @type    Boolean
     */
    this.isComposing = ev.isComposing;

    /**
     * **Limited browser support**.
     *
     * @name    InputEvent#targetRange
     * @type    Boolean
     */
    this.targetRange = ev.targetRange;
}

InputEvent.prototype = Object.create(UIEvent.prototype);
InputEvent.prototype.constructor = InputEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
InputEvent.prototype.toString = function toString () {
    return 'InputEvent';
};

module.exports = InputEvent;

},{"./UIEvent":31}],28:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

/**
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428/#events-keyboardevents).
 *
 * @class KeyboardEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function KeyboardEvent(ev) {
    // [Constructor(DOMString typeArg, optional KeyboardEventInit keyboardEventInitDict)]
    // interface KeyboardEvent : UIEvent {
    //     // KeyLocationCode
    //     const unsigned long DOM_KEY_LOCATION_STANDARD = 0x00;
    //     const unsigned long DOM_KEY_LOCATION_LEFT = 0x01;
    //     const unsigned long DOM_KEY_LOCATION_RIGHT = 0x02;
    //     const unsigned long DOM_KEY_LOCATION_NUMPAD = 0x03;
    //     readonly    attribute DOMString     key;
    //     readonly    attribute DOMString     code;
    //     readonly    attribute unsigned long location;
    //     readonly    attribute boolean       ctrlKey;
    //     readonly    attribute boolean       shiftKey;
    //     readonly    attribute boolean       altKey;
    //     readonly    attribute boolean       metaKey;
    //     readonly    attribute boolean       repeat;
    //     readonly    attribute boolean       isComposing;
    //     boolean getModifierState (DOMString keyArg);
    // };

    UIEvent.call(this, ev);

    /**
     * @name KeyboardEvent#DOM_KEY_LOCATION_STANDARD
     * @type Number
     */
    this.DOM_KEY_LOCATION_STANDARD = 0x00;

    /**
     * @name KeyboardEvent#DOM_KEY_LOCATION_LEFT
     * @type Number
     */
    this.DOM_KEY_LOCATION_LEFT = 0x01;

    /**
     * @name KeyboardEvent#DOM_KEY_LOCATION_RIGHT
     * @type Number
     */
    this.DOM_KEY_LOCATION_RIGHT = 0x02;

    /**
     * @name KeyboardEvent#DOM_KEY_LOCATION_NUMPAD
     * @type Number
     */
    this.DOM_KEY_LOCATION_NUMPAD = 0x03;

    /**
     * @name KeyboardEvent#key
     * @type String
     */
    this.key = ev.key;

    /**
     * @name KeyboardEvent#code
     * @type String
     */
    this.code = ev.code;

    /**
     * @name KeyboardEvent#location
     * @type Number
     */
    this.location = ev.location;

    /**
     * @name KeyboardEvent#ctrlKey
     * @type Boolean
     */
    this.ctrlKey = ev.ctrlKey;

    /**
     * @name KeyboardEvent#shiftKey
     * @type Boolean
     */
    this.shiftKey = ev.shiftKey;

    /**
     * @name KeyboardEvent#altKey
     * @type Boolean
     */
    this.altKey = ev.altKey;

    /**
     * @name KeyboardEvent#metaKey
     * @type Boolean
     */
    this.metaKey = ev.metaKey;

    /**
     * @name KeyboardEvent#repeat
     * @type Boolean
     */
    this.repeat = ev.repeat;

    /**
     * @name KeyboardEvent#isComposing
     * @type Boolean
     */
    this.isComposing = ev.isComposing;

    /**
     * @name KeyboardEvent#keyCode
     * @type String
     * @deprecated
     */
    this.keyCode = ev.keyCode;
}

KeyboardEvent.prototype = Object.create(UIEvent.prototype);
KeyboardEvent.prototype.constructor = KeyboardEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
KeyboardEvent.prototype.toString = function toString () {
    return 'KeyboardEvent';
};

module.exports = KeyboardEvent;

},{"./UIEvent":31}],29:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

/**
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428/#events-mouseevents).
 *
 * @class KeyboardEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function MouseEvent(ev) {
    // [Constructor(DOMString typeArg, optional MouseEventInit mouseEventInitDict)]
    // interface MouseEvent : UIEvent {
    //     readonly    attribute long           screenX;
    //     readonly    attribute long           screenY;
    //     readonly    attribute long           clientX;
    //     readonly    attribute long           clientY;
    //     readonly    attribute boolean        ctrlKey;
    //     readonly    attribute boolean        shiftKey;
    //     readonly    attribute boolean        altKey;
    //     readonly    attribute boolean        metaKey;
    //     readonly    attribute short          button;
    //     readonly    attribute EventTarget?   relatedTarget;
    //     // Introduced in this specification
    //     readonly    attribute unsigned short buttons;
    //     boolean getModifierState (DOMString keyArg);
    // };

    UIEvent.call(this, ev);

    /**
     * @name MouseEvent#screenX
     * @type Number
     */
    this.screenX = ev.screenX;

    /**
     * @name MouseEvent#screenY
     * @type Number
     */
    this.screenY = ev.screenY;

    /**
     * @name MouseEvent#clientX
     * @type Number
     */
    this.clientX = ev.clientX;

    /**
     * @name MouseEvent#clientY
     * @type Number
     */
    this.clientY = ev.clientY;

    /**
     * @name MouseEvent#ctrlKey
     * @type Boolean
     */
    this.ctrlKey = ev.ctrlKey;

    /**
     * @name MouseEvent#shiftKey
     * @type Boolean
     */
    this.shiftKey = ev.shiftKey;

    /**
     * @name MouseEvent#altKey
     * @type Boolean
     */
    this.altKey = ev.altKey;

    /**
     * @name MouseEvent#metaKey
     * @type Boolean
     */
    this.metaKey = ev.metaKey;

    /**
     * @type MouseEvent#button
     * @type Number
     */
    this.button = ev.button;

    /**
     * @type MouseEvent#buttons
     * @type Number
     */
    this.buttons = ev.buttons;

    /**
     * @type MouseEvent#pageX
     * @type Number
     */
    this.pageX = ev.pageX;

    /**
     * @type MouseEvent#pageY
     * @type Number
     */
    this.pageY = ev.pageY;

    /**
     * @type MouseEvent#x
     * @type Number
     */
    this.x = ev.x;

    /**
     * @type MouseEvent#y
     * @type Number
     */
    this.y = ev.y;

    /**
     * @type MouseEvent#offsetX
     * @type Number
     */
    this.offsetX = ev.offsetX;

    /**
     * @type MouseEvent#offsetY
     * @type Number
     */
    this.offsetY = ev.offsetY;
}

MouseEvent.prototype = Object.create(UIEvent.prototype);
MouseEvent.prototype.constructor = MouseEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
MouseEvent.prototype.toString = function toString () {
    return 'MouseEvent';
};

module.exports = MouseEvent;

},{"./UIEvent":31}],30:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

var EMPTY_ARRAY = [];

/**
 * See [Touch Interface](http://www.w3.org/TR/2013/REC-touch-events-20131010/#touch-interface).
 *
 * @class Touch
 * @private
 *
 * @param {Touch} touch The native Touch object.
 */
function Touch(touch) {
    // interface Touch {
    //     readonly    attribute long        identifier;
    //     readonly    attribute EventTarget target;
    //     readonly    attribute double      screenX;
    //     readonly    attribute double      screenY;
    //     readonly    attribute double      clientX;
    //     readonly    attribute double      clientY;
    //     readonly    attribute double      pageX;
    //     readonly    attribute double      pageY;
    // };

    /**
     * @name Touch#identifier
     * @type Number
     */
    this.identifier = touch.identifier;

    /**
     * @name Touch#screenX
     * @type Number
     */
    this.screenX = touch.screenX;

    /**
     * @name Touch#screenY
     * @type Number
     */
    this.screenY = touch.screenY;

    /**
     * @name Touch#clientX
     * @type Number
     */
    this.clientX = touch.clientX;

    /**
     * @name Touch#clientY
     * @type Number
     */
    this.clientY = touch.clientY;

    /**
     * @name Touch#pageX
     * @type Number
     */
    this.pageX = touch.pageX;

    /**
     * @name Touch#pageY
     * @type Number
     */
    this.pageY = touch.pageY;
}


/**
 * Normalizes the browser's native TouchList by converting it into an array of
 * normalized Touch objects.
 *
 * @method  cloneTouchList
 * @private
 *
 * @param  {TouchList} touchList    The native TouchList array.
 * @return {Array.<Touch>}          An array of normalized Touch objects.
 */
function cloneTouchList(touchList) {
    if (!touchList) return EMPTY_ARRAY;
    // interface TouchList {
    //     readonly    attribute unsigned long length;
    //     getter Touch? item (unsigned long index);
    // };

    var touchListArray = [];
    for (var i = 0; i < touchList.length; i++) {
        touchListArray[i] = new Touch(touchList[i]);
    }
    return touchListArray;
}

/**
 * See [Touch Event Interface](http://www.w3.org/TR/2013/REC-touch-events-20131010/#touchevent-interface).
 *
 * @class TouchEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function TouchEvent(ev) {
    // interface TouchEvent : UIEvent {
    //     readonly    attribute TouchList touches;
    //     readonly    attribute TouchList targetTouches;
    //     readonly    attribute TouchList changedTouches;
    //     readonly    attribute boolean   altKey;
    //     readonly    attribute boolean   metaKey;
    //     readonly    attribute boolean   ctrlKey;
    //     readonly    attribute boolean   shiftKey;
    // };
    UIEvent.call(this, ev);

    /**
     * @name TouchEvent#touches
     * @type Array.<Touch>
     */
    this.touches = cloneTouchList(ev.touches);

    /**
     * @name TouchEvent#targetTouches
     * @type Array.<Touch>
     */
    this.targetTouches = cloneTouchList(ev.targetTouches);

    /**
     * @name TouchEvent#changedTouches
     * @type TouchList
     */
    this.changedTouches = cloneTouchList(ev.changedTouches);

    /**
     * @name TouchEvent#altKey
     * @type Boolean
     */
    this.altKey = ev.altKey;

    /**
     * @name TouchEvent#metaKey
     * @type Boolean
     */
    this.metaKey = ev.metaKey;

    /**
     * @name TouchEvent#ctrlKey
     * @type Boolean
     */
    this.ctrlKey = ev.ctrlKey;

    /**
     * @name TouchEvent#shiftKey
     * @type Boolean
     */
    this.shiftKey = ev.shiftKey;
}

TouchEvent.prototype = Object.create(UIEvent.prototype);
TouchEvent.prototype.constructor = TouchEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
TouchEvent.prototype.toString = function toString () {
    return 'TouchEvent';
};

module.exports = TouchEvent;

},{"./UIEvent":31}],31:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Event = require('./Event');

/**
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428).
 *
 * @class UIEvent
 * @augments Event
 *
 * @param  {Event} ev   The native DOM event.
 */
function UIEvent(ev) {
    // [Constructor(DOMString type, optional UIEventInit eventInitDict)]
    // interface UIEvent : Event {
    //     readonly    attribute Window? view;
    //     readonly    attribute long    detail;
    // };
    Event.call(this, ev);

    /**
     * @name UIEvent#detail
     * @type Number
     */
    this.detail = ev.detail;
}

UIEvent.prototype = Object.create(Event.prototype);
UIEvent.prototype.constructor = UIEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
UIEvent.prototype.toString = function toString () {
    return 'UIEvent';
};

module.exports = UIEvent;

},{"./Event":24}],32:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var MouseEvent = require('./MouseEvent');

/**
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428/#events-wheelevents).
 *
 * @class WheelEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function WheelEvent(ev) {
    // [Constructor(DOMString typeArg, optional WheelEventInit wheelEventInitDict)]
    // interface WheelEvent : MouseEvent {
    //     // DeltaModeCode
    //     const unsigned long DOM_DELTA_PIXEL = 0x00;
    //     const unsigned long DOM_DELTA_LINE = 0x01;
    //     const unsigned long DOM_DELTA_PAGE = 0x02;
    //     readonly    attribute double        deltaX;
    //     readonly    attribute double        deltaY;
    //     readonly    attribute double        deltaZ;
    //     readonly    attribute unsigned long deltaMode;
    // };

    MouseEvent.call(this, ev);

    /**
     * @name WheelEvent#DOM_DELTA_PIXEL
     * @type Number
     */
    this.DOM_DELTA_PIXEL = 0x00;

    /**
     * @name WheelEvent#DOM_DELTA_LINE
     * @type Number
     */
    this.DOM_DELTA_LINE = 0x01;

    /**
     * @name WheelEvent#DOM_DELTA_PAGE
     * @type Number
     */
    this.DOM_DELTA_PAGE = 0x02;

    /**
     * @name WheelEvent#deltaX
     * @type Number
     */
    this.deltaX = ev.deltaX;

    /**
     * @name WheelEvent#deltaY
     * @type Number
     */
    this.deltaY = ev.deltaY;

    /**
     * @name WheelEvent#deltaZ
     * @type Number
     */
    this.deltaZ = ev.deltaZ;

    /**
     * @name WheelEvent#deltaMode
     * @type Number
     */
    this.deltaMode = ev.deltaMode;
}

WheelEvent.prototype = Object.create(MouseEvent.prototype);
WheelEvent.prototype.constructor = WheelEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
WheelEvent.prototype.toString = function toString () {
    return 'WheelEvent';
};

module.exports = WheelEvent;

},{"./MouseEvent":29}],33:[function(require,module,exports){
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
// MIT license

'use strict';

var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];

var rAF, cAF;

if (typeof window === 'object') {
    rAF = window.requestAnimationFrame;
    cAF = window.cancelAnimationFrame || window.cancelRequestAnimationFrame;
    for (var x = 0; x < vendors.length && !rAF; ++x) {
        rAF = window[vendors[x] + 'RequestAnimationFrame'];
        cAF = window[vendors[x] + 'CancelRequestAnimationFrame'] ||
              window[vendors[x] + 'CancelAnimationFrame'];
    }

    if (rAF && !cAF) {
        // cAF not supported.
        // Fall back to setInterval for now (very rare).
        rAF = null;
    }
}

if (!rAF) {
    var now = Date.now ? Date.now : function () {
        return new Date().getTime();
    };

    rAF = function(callback) {
        var currTime = now();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = setTimeout(function () {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };

    cAF = function (id) {
        clearTimeout(id);
    };
}

var animationFrame = {
    /**
     * Cross browser version of [requestAnimationFrame]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}.
     *
     * Used by Engine in order to establish a render loop.
     *
     * If no (vendor prefixed version of) `requestAnimationFrame` is available,
     * `setTimeout` will be used in order to emulate a render loop running at
     * approximately 60 frames per second.
     *
     * @method  requestAnimationFrame
     *
     * @param   {Function}  callback function to be invoked on the next frame.
     * @return  {Number}    requestId to be used to cancel the request using
     *                      {@link cancelAnimationFrame}.
     */
    requestAnimationFrame: rAF,

    /**
     * Cross browser version of [cancelAnimationFrame]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}.
     *
     * Cancels a previously using [requestAnimationFrame]{@link animationFrame#requestAnimationFrame}
     * scheduled request.
     *
     * Used for immediately stopping the render loop within the Engine.
     *
     * @method  cancelAnimationFrame
     *
     * @param   {Number}    requestId of the scheduled callback function
     *                      returned by [requestAnimationFrame]{@link animationFrame#requestAnimationFrame}.
     */
    cancelAnimationFrame: cAF
};

module.exports = animationFrame;

},{}],34:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

module.exports = {
    requestAnimationFrame: require('./animationFrame').requestAnimationFrame,
    cancelAnimationFrame: require('./animationFrame').cancelAnimationFrame
};

},{"./animationFrame":33}],35:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var polyfills = require('../polyfills');
var rAF = polyfills.requestAnimationFrame;
var cAF = polyfills.cancelAnimationFrame;

/**
 * Boolean constant indicating whether the RequestAnimationFrameLoop has access
 * to the document. The document is being used in order to subscribe for
 * visibilitychange events used for normalizing the RequestAnimationFrameLoop
 * time when e.g. when switching tabs.
 *
 * @constant
 * @type {Boolean}
 */
var DOCUMENT_ACCESS = typeof document !== 'undefined';

if (DOCUMENT_ACCESS) {
    var VENDOR_HIDDEN, VENDOR_VISIBILITY_CHANGE;

    // Opera 12.10 and Firefox 18 and later support
    if (typeof document.hidden !== 'undefined') {
        VENDOR_HIDDEN = 'hidden';
        VENDOR_VISIBILITY_CHANGE = 'visibilitychange';
    }
    else if (typeof document.mozHidden !== 'undefined') {
        VENDOR_HIDDEN = 'mozHidden';
        VENDOR_VISIBILITY_CHANGE = 'mozvisibilitychange';
    }
    else if (typeof document.msHidden !== 'undefined') {
        VENDOR_HIDDEN = 'msHidden';
        VENDOR_VISIBILITY_CHANGE = 'msvisibilitychange';
    }
    else if (typeof document.webkitHidden !== 'undefined') {
        VENDOR_HIDDEN = 'webkitHidden';
        VENDOR_VISIBILITY_CHANGE = 'webkitvisibilitychange';
    }
}

/**
 * RequestAnimationFrameLoop class used for updating objects on a frame-by-frame.
 * Synchronizes the `update` method invocations to the refresh rate of the
 * screen. Manages the `requestAnimationFrame`-loop by normalizing the passed in
 * timestamp when switching tabs.
 *
 * @class RequestAnimationFrameLoop
 */
function RequestAnimationFrameLoop() {
    var _this = this;

    // References to objects to be updated on next frame.
    this._updates = [];

    this._looper = function(time) {
        _this.loop(time);
    };
    this._time = 0;
    this._stoppedAt = 0;
    this._sleep = 0;

    // Indicates whether the engine should be restarted when the tab/ window is
    // being focused again (visibility change).
    this._startOnVisibilityChange = true;

    // requestId as returned by requestAnimationFrame function;
    this._rAF = null;

    this._sleepDiff = true;

    // The engine is being started on instantiation.
    // TODO(alexanderGugel)
    this.start();

    // The RequestAnimationFrameLoop supports running in a non-browser
    // environment (e.g. Worker).
    if (DOCUMENT_ACCESS) {
        document.addEventListener(VENDOR_VISIBILITY_CHANGE, function() {
            _this._onVisibilityChange();
        });
    }
}

/**
 * Handle the switching of tabs.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
RequestAnimationFrameLoop.prototype._onVisibilityChange = function _onVisibilityChange() {
    if (document[VENDOR_HIDDEN]) {
        this._onUnfocus();
    }
    else {
        this._onFocus();
    }
};

/**
 * Internal helper function to be invoked as soon as the window/ tab is being
 * focused after a visibiltiy change.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
RequestAnimationFrameLoop.prototype._onFocus = function _onFocus() {
    if (this._startOnVisibilityChange) {
        this._start();
    }
};

/**
 * Internal helper function to be invoked as soon as the window/ tab is being
 * unfocused (hidden) after a visibiltiy change.
 *
 * @method  _onFocus
 * @private
 *
 * @return {undefined} undefined
 */
RequestAnimationFrameLoop.prototype._onUnfocus = function _onUnfocus() {
    this._stop();
};

/**
 * Starts the RequestAnimationFrameLoop. When switching to a differnt tab/
 * window (changing the visibiltiy), the engine will be retarted when switching
 * back to a visible state.
 *
 * @method
 *
 * @return {RequestAnimationFrameLoop} this
 */
RequestAnimationFrameLoop.prototype.start = function start() {
    if (!this._running) {
        this._startOnVisibilityChange = true;
        this._start();
    }
    return this;
};

/**
 * Internal version of RequestAnimationFrameLoop's start function, not affecting
 * behavior on visibilty change.
 *
 * @method
 * @private
*
 * @return {undefined} undefined
 */
RequestAnimationFrameLoop.prototype._start = function _start() {
    this._running = true;
    this._sleepDiff = true;
    this._rAF = rAF(this._looper);
};

/**
 * Stops the RequestAnimationFrameLoop.
 *
 * @method
 * @private
 *
 * @return {RequestAnimationFrameLoop} this
 */
RequestAnimationFrameLoop.prototype.stop = function stop() {
    if (this._running) {
        this._startOnVisibilityChange = false;
        this._stop();
    }
    return this;
};

/**
 * Internal version of RequestAnimationFrameLoop's stop function, not affecting
 * behavior on visibilty change.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
RequestAnimationFrameLoop.prototype._stop = function _stop() {
    this._running = false;
    this._stoppedAt = this._time;

    // Bug in old versions of Fx. Explicitly cancel.
    cAF(this._rAF);
};

/**
 * Determines whether the RequestAnimationFrameLoop is currently running or not.
 *
 * @method
 *
 * @return {Boolean} boolean value indicating whether the
 * RequestAnimationFrameLoop is currently running or not
 */
RequestAnimationFrameLoop.prototype.isRunning = function isRunning() {
    return this._running;
};

/**
 * Updates all registered objects.
 *
 * @method
 *
 * @param {Number} time high resolution timstamp used for invoking the `update`
 * method on all registered objects
 *
 * @return {RequestAnimationFrameLoop} this
 */
RequestAnimationFrameLoop.prototype.step = function step (time) {
    this._time = time;
    if (this._sleepDiff) {
        this._sleep += time - this._stoppedAt;
        this._sleepDiff = false;
    }

    // The same timetamp will be emitted immediately before and after visibility
    // change.
    var normalizedTime = time - this._sleep;
    for (var i = 0, len = this._updates.length ; i < len ; i++) {
        this._updates[i].update(normalizedTime);
    }
    return this;
};

/**
 * Method being called by `requestAnimationFrame` on every paint. Indirectly
 * recursive by scheduling a future invocation of itself on the next paint.
 *
 * @method
 *
 * @param {Number} time high resolution timstamp used for invoking the `update`
 * method on all registered objects
 * @return {RequestAnimationFrameLoop} this
 */
RequestAnimationFrameLoop.prototype.loop = function loop(time) {
    this.step(time);
    this._rAF = rAF(this._looper);
    return this;
};

/**
 * Registeres an updateable object which `update` method should be invoked on
 * every paint, starting on the next paint (assuming the
 * RequestAnimationFrameLoop is running).
 *
 * @method
 *
 * @param {Object} updateable object to be updated
 * @param {Function} updateable.update update function to be called on the
 * registered object
 *
 * @return {RequestAnimationFrameLoop} this
 */
RequestAnimationFrameLoop.prototype.update = function update(updateable) {
    if (this._updates.indexOf(updateable) === -1) {
        this._updates.push(updateable);
    }
    return this;
};

/**
 * Deregisters an updateable object previously registered using `update` to be
 * no longer updated.
 *
 * @method
 *
 * @param {Object} updateable updateable object previously registered using
 * `update`
 *
 * @return {RequestAnimationFrameLoop} this
 */
RequestAnimationFrameLoop.prototype.noLongerUpdate = function noLongerUpdate(updateable) {
    var index = this._updates.indexOf(updateable);
    if (index > -1) {
        this._updates.splice(index, 1);
    }
    return this;
};

module.exports = RequestAnimationFrameLoop;

},{"../polyfills":34}],36:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Context = require('./Context');
var injectCSS = require('./inject-css');
var Commands = require('../core/Commands');

/**
 * Instantiates a new Compositor.
 * The Compositor receives draw commands frm the UIManager and routes the to the
 * respective context objects.
 *
 * Upon creation, it injects a stylesheet used for styling the individual
 * renderers used in the context objects.
 *
 * @class Compositor
 * @constructor
 * @return {undefined} undefined
 */
function Compositor() {
    injectCSS();

    this._contexts = {};
    this._outCommands = [];
    this._inCommands = [];
    this._time = null;

    this._resized = false;

    var _this = this;
    window.addEventListener('resize', function() {
        _this.onResize();
    });
}

Compositor.prototype.onResize = function onResize () {
    this._resized = true;
    for (var selector in this._contexts) {
        this._contexts[selector].updateSize();
    }
};

/**
 * Retrieves the time being used by the internal clock managed by
 * `FamousEngine`.
 *
 * The time is being passed into core by the Engine through the UIManager.
 * Since core has the ability to scale the time, the time needs to be passed
 * back to the rendering system.
 *
 * @method
 *
 * @return {Number} time The clock time used in core.
 */
Compositor.prototype.getTime = function getTime() {
    return this._time;
};

/**
 * Schedules an event to be sent the next time the out command queue is being
 * flushed.
 *
 * @method
 * @private
 *
 * @param  {String} path Render path to the node the event should be triggered
 * on (*targeted event*)
 * @param  {String} ev Event type
 * @param  {Object} payload Event object (serializable using structured cloning
 * algorithm)
 *
 * @return {undefined} undefined
 */
Compositor.prototype.sendEvent = function sendEvent(path, ev, payload) {
    this._outCommands.push(Commands.WITH, path, Commands.TRIGGER, ev, payload);
};

/**
 * Internal helper method used for notifying externally
 * resized contexts (e.g. by resizing the browser window).
 *
 * @method
 * @private
 *
 * @param  {String} selector render path to the node (context) that should be
 * resized
 * @param  {Array} size new context size
 *
 * @return {undefined} undefined
 */
Compositor.prototype.sendResize = function sendResize (selector, size) {
    this.sendEvent(selector, 'CONTEXT_RESIZE', size);
};

/**
 * Internal helper method used by `drawCommands`.
 * Subsequent commands are being associated with the node defined the the path
 * following the `WITH` command.
 *
 * @method
 * @private
 *
 * @param  {Number} iterator position index within the commands queue
 * @param  {Array} commands remaining message queue received, used to
 * shift single messages from
 *
 * @return {undefined} undefined
 */
Compositor.prototype.handleWith = function handleWith (iterator, commands) {
    var path = commands[iterator];
    var pathArr = path.split('/');
    var context = this.getOrSetContext(pathArr.shift());
    return context.receive(path, commands, iterator);
};

/**
 * Retrieves the top-level Context associated with the passed in document
 * query selector. If no such Context exists, a new one will be instantiated.
 *
 * @method
 *
 * @param  {String} selector document query selector used for retrieving the
 * DOM node that should be used as a root element by the Context
 *
 * @return {Context} context
 */
Compositor.prototype.getOrSetContext = function getOrSetContext(selector) {
    if (this._contexts[selector]) {
        return this._contexts[selector];
    }
    else {
        var context = new Context(selector, this);
        this._contexts[selector] = context;
        return context;
    }
};

/**
 * Retrieves a context object registered under the passed in selector.
 *
 * @method
 *
 * @param  {String} selector    Query selector that has previously been used to
 *                              register the context.
 * @return {Context}            The repsective context.
 */
Compositor.prototype.getContext = function getContext(selector) {
    if (this._contexts[selector])
        return this._contexts[selector];
};

/**
 * Processes the previously via `receiveCommands` updated incoming "in"
 * command queue.
 * Called by UIManager on a frame by frame basis.
 *
 * @method
 *
 * @return {Array} outCommands set of commands to be sent back
 */
Compositor.prototype.drawCommands = function drawCommands() {
    var commands = this._inCommands;
    var localIterator = 0;
    var command = commands[localIterator];
    while (command) {
        switch (command) {
            case Commands.TIME:
                this._time = commands[++localIterator];
                break;
            case Commands.WITH:
                localIterator = this.handleWith(++localIterator, commands);
                break;
            case Commands.NEED_SIZE_FOR:
                this.giveSizeFor(++localIterator, commands);
                break;
        }
        command = commands[++localIterator];
    }

    // TODO: Switch to associative arrays here...

    for (var key in this._contexts) {
        this._contexts[key].draw();
    }

    if (this._resized) {
        this.updateSize();
    }

    return this._outCommands;
};


/**
 * Updates the size of all previously registered context objects.
 * This results into CONTEXT_RESIZE events being sent and the root elements
 * used by the individual renderers being resized to the the DOMRenderer's root
 * size.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Compositor.prototype.updateSize = function updateSize() {
    for (var selector in this._contexts) {
        this._contexts[selector].updateSize();
    }
};

/**
 * Used by ThreadManager to update the internal queue of incoming commands.
 * Receiving commands does not immediately start the rendering process.
 *
 * @method
 *
 * @param  {Array} commands command queue to be processed by the compositor's
 * `drawCommands` method
 *
 * @return {undefined} undefined
 */
Compositor.prototype.receiveCommands = function receiveCommands(commands) {
    var len = commands.length;
    for (var i = 0; i < len; i++) {
        this._inCommands.push(commands[i]);
    }

    for (var selector in this._contexts) {
        this._contexts[selector].checkInit();
    }
};

/**
 * Internal helper method used by `drawCommands`.
 *
 * @method
 * @private
 *
 * @param  {Number} iterator position index within the command queue
 * @param  {Array} commands remaining message queue received, used to
 * shift single messages
 *
 * @return {undefined} undefined
 */
Compositor.prototype.giveSizeFor = function giveSizeFor(iterator, commands) {
    var selector = commands[iterator];
    var size = this.getOrSetContext(selector).getRootSize();
    this.sendResize(selector, size);
};

/**
 * Flushes the queue of outgoing "out" commands.
 * Called by ThreadManager.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Compositor.prototype.clearCommands = function clearCommands() {
    this._inCommands.length = 0;
    this._outCommands.length = 0;
    this._resized = false;
};

module.exports = Compositor;

},{"../core/Commands":6,"./Context":37,"./inject-css":39}],37:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var WebGLRenderer = require('../webgl-renderers/WebGLRenderer');
var Camera = require('../components/Camera');
var DOMRenderer = require('../dom-renderers/DOMRenderer');
var Commands = require('../core/Commands');

/**
 * Context is a render layer with its own WebGLRenderer and DOMRenderer.
 * It is the interface between the Compositor which receives commands
 * and the renderers that interpret them. It also relays information to
 * the renderers about resizing.
 *
 * The DOMElement at the given query selector is used as the root. A
 * new DOMElement is appended to this root element, and used as the
 * parent element for all Famous DOM rendering at this context. A
 * canvas is added and used for all WebGL rendering at this context.
 *
 * @class Context
 * @constructor
 *
 * @param {String} selector Query selector used to locate root element of
 * context layer.
 * @param {Compositor} compositor Compositor reference to pass down to
 * WebGLRenderer.
 */
function Context(selector, compositor) {
    this._compositor = compositor;
    this._rootEl = document.querySelector(selector);
    this._selector = selector;

    if (this._rootEl === null) {
        throw new Error(
            'Failed to create Context: ' +
            'No matches for "' + selector + '" found.'
        );
    }

    this._selector = selector;

    // Initializes the DOMRenderer.
    // Every Context has at least a DOMRenderer for now.
    this._initDOMRenderer();

    // WebGLRenderer will be instantiated when needed.
    this._webGLRenderer = null;
    this._domRenderer = new DOMRenderer(this._domRendererRootEl, selector, compositor);
    this._canvasEl = null;
    
    // State holders

    this._renderState = {
        projectionType: Camera.ORTHOGRAPHIC_PROJECTION,
        perspectiveTransform: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        viewTransform: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        viewDirty: false,
        perspectiveDirty: false
    };

    this._size = [];

    this._meshTransform = new Float32Array(16);
    this._meshSize = [0, 0, 0];

    this._initDOM = false;

    this._commandCallbacks = [];
    this.initCommandCallbacks();

    this.updateSize();
}

/**
 * Queries DOMRenderer size and updates canvas size. Relays size information to
 * WebGLRenderer.
 *
 * @method
 *
 * @return {Context} this
 */
Context.prototype.updateSize = function () {
    var width = this._rootEl.offsetWidth;
    var height = this._rootEl.offsetHeight;

    this._size[0] = width;
    this._size[1] = height;
    this._size[2] = (width > height) ? width : height;

    this._compositor.sendResize(this._selector, this._size);
    if (this._webGLRenderer) this._webGLRenderer.updateSize(this._size);

    return this;
};

/**
 * Draw function called after all commands have been handled for current frame.
 * Issues draw commands to all renderers with current renderState.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Context.prototype.draw = function draw() {
    this._domRenderer.draw(this._renderState);
    if (this._webGLRenderer) this._webGLRenderer.draw(this._renderState);

    if (this._renderState.perspectiveDirty) this._renderState.perspectiveDirty = false;
    if (this._renderState.viewDirty) this._renderState.viewDirty = false;
};

/**
 * Initializes the DOMRenderer by creating a root DIV element and appending it
 * to the context.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
Context.prototype._initDOMRenderer = function _initDOMRenderer() {
    this._domRendererRootEl = document.createElement('div');
    this._rootEl.appendChild(this._domRendererRootEl);
    this._domRendererRootEl.style.display = 'none';

    this._domRenderer = new DOMRenderer(
        this._domRendererRootEl,
        this._selector,
        this._compositor
    );
};

Context.prototype.getRootSize = function getRootSize() {
    return [
        this._rootEl.offsetWidth,
        this._rootEl.offsetHeight
    ];
};

Context.prototype.initCommandCallbacks = function initCommandCallbacks () {
    this._commandCallbacks[Commands.INIT_DOM] = initDOM;
    this._commandCallbacks[Commands.DOM_RENDER_SIZE] = domRenderSize;
    this._commandCallbacks[Commands.CHANGE_TRANSFORM] = changeTransform;
    this._commandCallbacks[Commands.CHANGE_SIZE] = changeSize;
    this._commandCallbacks[Commands.CHANGE_PROPERTY] = changeProperty;
    this._commandCallbacks[Commands.CHANGE_CONTENT] = changeContent;
    this._commandCallbacks[Commands.CHANGE_ATTRIBUTE] = changeAttribute;
    this._commandCallbacks[Commands.ADD_CLASS] = addClass;
    this._commandCallbacks[Commands.REMOVE_CLASS] = removeClass;
    this._commandCallbacks[Commands.SUBSCRIBE] = subscribe;
    this._commandCallbacks[Commands.GL_SET_DRAW_OPTIONS] = glSetDrawOptions;
    this._commandCallbacks[Commands.GL_AMBIENT_LIGHT] = glAmbientLight;
    this._commandCallbacks[Commands.GL_LIGHT_POSITION] = glLightPosition;
    this._commandCallbacks[Commands.GL_LIGHT_COLOR] = glLightColor;
    this._commandCallbacks[Commands.MATERIAL_INPUT] = materialInput;
    this._commandCallbacks[Commands.GL_SET_GEOMETRY] = glSetGeometry;
    this._commandCallbacks[Commands.GL_UNIFORMS] = glUniforms;
    this._commandCallbacks[Commands.GL_BUFFER_DATA] = glBufferData;
    this._commandCallbacks[Commands.GL_CUTOUT_STATE] = glCutoutState;
    this._commandCallbacks[Commands.GL_MESH_VISIBILITY] = glMeshVisibility;
    this._commandCallbacks[Commands.GL_REMOVE_MESH] = glRemoveMesh;
    this._commandCallbacks[Commands.PINHOLE_PROJECTION] = pinholeProjection;
    this._commandCallbacks[Commands.ORTHOGRAPHIC_PROJECTION] = orthographicProjection;
    this._commandCallbacks[Commands.CHANGE_VIEW_TRANSFORM] = changeViewTransform;
    this._commandCallbacks[Commands.PREVENT_DEFAULT] = preventDefault;
    this._commandCallbacks[Commands.ALLOW_DEFAULT] = allowDefault;
    this._commandCallbacks[Commands.READY] = ready;
};

/**
 * Initializes the WebGLRenderer and updates it initial size.
 *
 * The Initialization process consists of the following steps:
 *
 * 1. A new `<canvas>` element is being created and appended to the root element.
 * 2. The WebGLRenderer is being instantiated.
 * 3. The size of the WebGLRenderer is being updated.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
Context.prototype._initWebGLRenderer = function _initWebGLRenderer() {
    this._webGLRendererRootEl = document.createElement('canvas');
    this._rootEl.appendChild(this._webGLRendererRootEl);

    this._webGLRenderer = new WebGLRenderer(
        this._webGLRendererRootEl,
        this._compositor
    );

    // Don't read offset width and height.
    this._webGLRenderer.updateSize(this._size);
};

/**
 * Gets the size of the parent element of the DOMRenderer for this context.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Context.prototype.getRootSize = function getRootSize() {
    return [
        this._rootEl.offsetWidth,
        this._rootEl.offsetHeight
    ];
};


/**
 * Initializes the context if the `READY` command has been received earlier.
 *
 * @return {undefined} undefined
 */
Context.prototype.checkInit = function checkInit () {
    if (this._initDOM) {
        this._domRendererRootEl.style.display = 'block';
        this._initDOM = false;
    }
};

/**
 * Handles delegation of commands to renderers of this context.
 *
 * @method
 *
 * @param {String} path String used as identifier of a given node in the
 * scene graph.
 * @param {Array} commands List of all commands from this frame.
 * @param {Number} iterator Number indicating progress through the command
 * queue.
 *
 * @return {Number} iterator indicating progress through the command queue.
 */
Context.prototype.receive = function receive(path, commands, iterator) {
    var localIterator = iterator;

    var command = commands[++localIterator];

    this._domRenderer.loadPath(path);
    this._domRenderer.findTarget();

    while (command != null) {
        if (command === Commands.WITH || command === Commands.TIME) return localIterator - 1;
        else localIterator = this._commandCallbacks[command](this, path, commands, localIterator) + 1; 
        command = commands[localIterator];
    }

    return localIterator;
};

/**
 * Getter method used for retrieving the used DOMRenderer.
 *
 * @method
 *
 * @return {DOMRenderer}    The DOMRenderer being used by the Context.
 */
Context.prototype.getDOMRenderer = function getDOMRenderer() {
    return this._domRenderer;
};

/**
 * Getter method used for retrieving the used WebGLRenderer (if any).
 *
 * @method
 *
 * @return {WebGLRenderer|null}    The WebGLRenderer being used by the Context.
 */
Context.prototype.getWebGLRenderer = function getWebGLRenderer() {
    return this._webGLRenderer;
};

// Command Callbacks
function preventDefault (context, path, commands, iterator) {
    if (context._webGLRenderer) context._webGLRenderer.getOrSetCutout(path);
    context._domRenderer.preventDefault(commands[++iterator]);
    return iterator;
}

function allowDefault (context, path, commands, iterator) {
    if (context._webGLRenderer) context._webGLRenderer.getOrSetCutout(path);
    context._domRenderer.allowDefault(commands[++iterator]);
    return iterator;
}

function ready (context, path, commands, iterator) {
    context._initDOM = true;
    return iterator;
}

function initDOM (context, path, commands, iterator) {
    context._domRenderer.insertEl(commands[++iterator]);
    return iterator;
}

function domRenderSize (context, path, commands, iterator) {
    context._domRenderer.getSizeOf(commands[++iterator]);
    return iterator;
}

function changeTransform (context, path, commands, iterator) {
    var temp = context._meshTransform;

    temp[0] = commands[++iterator];
    temp[1] = commands[++iterator];
    temp[2] = commands[++iterator];
    temp[3] = commands[++iterator];
    temp[4] = commands[++iterator];
    temp[5] = commands[++iterator];
    temp[6] = commands[++iterator];
    temp[7] = commands[++iterator];
    temp[8] = commands[++iterator];
    temp[9] = commands[++iterator];
    temp[10] = commands[++iterator];
    temp[11] = commands[++iterator];
    temp[12] = commands[++iterator];
    temp[13] = commands[++iterator];
    temp[14] = commands[++iterator];
    temp[15] = commands[++iterator];

    context._domRenderer.setMatrix(temp);
    
    if (context._webGLRenderer)
        context._webGLRenderer.setCutoutUniform(path, 'u_transform', temp);

    return iterator;
}

function changeSize (context, path, commands, iterator) {
    var width = commands[++iterator];
    var height = commands[++iterator];

    context._domRenderer.setSize(width, height);
    if (context._webGLRenderer) {
        context._meshSize[0] = width;
        context._meshSize[1] = height;
        context._webGLRenderer.setCutoutUniform(path, 'u_size', context._meshSize);
    }
    
    return iterator;
}

function changeProperty (context, path, commands, iterator) {
    if (context._webGLRenderer) context._webGLRenderer.getOrSetCutout(path);
    context._domRenderer.setProperty(commands[++iterator], commands[++iterator]);
    return iterator;
}

function changeContent (context, path, commands, iterator) {
    if (context._webGLRenderer) context._webGLRenderer.getOrSetCutout(path);
    context._domRenderer.setContent(commands[++iterator]);
    return iterator;
}
  
function changeAttribute (context, path, commands, iterator) {
    if (context._webGLRenderer) context._webGLRenderer.getOrSetCutout(path);
    context._domRenderer.setAttribute(commands[++iterator], commands[++iterator]);
    return iterator;
}

function addClass (context, path, commands, iterator) {
    if (context._webGLRenderer) context._webGLRenderer.getOrSetCutout(path);
    context._domRenderer.addClass(commands[++iterator]);
    return iterator;
}

function removeClass (context, path, commands, iterator) {
    if (context._webGLRenderer) context._webGLRenderer.getOrSetCutout(path);
    context._domRenderer.removeClass(commands[++iterator]);
    return iterator;
}

function subscribe (context, path, commands, iterator) {
    if (context._webGLRenderer) context._webGLRenderer.getOrSetCutout(path);
    context._domRenderer.subscribe(commands[++iterator]);
    return iterator;
}

function glSetDrawOptions (context, path, commands, iterator) {
    if (!context._webGLRenderer) context._initWebGLRenderer();
    context._webGLRenderer.setMeshOptions(path, commands[++iterator]);
    return iterator;
}

function glAmbientLight (context, path, commands, iterator) {
    if (!context._webGLRenderer) context._initWebGLRenderer();
    context._webGLRenderer.setAmbientLightColor(
        path,
        commands[++iterator],
        commands[++iterator],
        commands[++iterator]
    );
    return iterator;
}

function glLightPosition (context, path, commands, iterator) {
    if (!context._webGLRenderer) context._initWebGLRenderer();
    context._webGLRenderer.setLightPosition(
        path,
        commands[++iterator],
        commands[++iterator],
        commands[++iterator]
    );
    return iterator;
}

function glLightColor (context, path, commands, iterator) {
    if (!context._webGLRenderer) context._initWebGLRenderer();
    context._webGLRenderer.setLightColor(
        path,
        commands[++iterator],
        commands[++iterator],
        commands[++iterator]
    );
    return iterator;
}

function materialInput (context, path, commands, iterator) {
    if (!context._webGLRenderer) context._initWebGLRenderer();
    context._webGLRenderer.handleMaterialInput(
        path,
        commands[++iterator],
        commands[++iterator]
    );
    return iterator;
}

function glSetGeometry (context, path, commands, iterator) {
    if (!context._webGLRenderer) context._initWebGLRenderer();
    context._webGLRenderer.setGeometry(
        path,
        commands[++iterator],
        commands[++iterator],
        commands[++iterator]
    );
    return iterator;
}

function glUniforms (context, path, commands, iterator) {
    if (!context._webGLRenderer) context._initWebGLRenderer();
    context._webGLRenderer.setMeshUniform(
        path,
        commands[++iterator],
        commands[++iterator]
    );
    return iterator;
}

function glBufferData (context, path, commands, iterator) {
    if (!context._webGLRenderer) context._initWebGLRenderer();
    context._webGLRenderer.bufferData(
        path,
        commands[++iterator],
        commands[++iterator],
        commands[++iterator],
        commands[++iterator],
        commands[++iterator]
    );
    return iterator;
}

function glCutoutState (context, path, commands, iterator) {
    if (!context._webGLRenderer) context._initWebGLRenderer();
    context._webGLRenderer.setCutoutState(path, commands[++iterator]);
    return iterator;
}

function glMeshVisibility (context, path, commands, iterator) {
    if (!context._webGLRenderer) context._initWebGLRenderer();
    context._webGLRenderer.setMeshVisibility(path, commands[++iterator]);
    return iterator;
}

function glRemoveMesh (context, path, commands, iterator) {
    if (!context._webGLRenderer) context._initWebGLRenderer();
    context._webGLRenderer.removeMesh(path);
    return iterator;
}

function pinholeProjection (context, path, commands, iterator) {
    context._renderState.projectionType = Camera.PINHOLE_PROJECTION;
    context._renderState.perspectiveTransform[11] = -1 / commands[++iterator];
    context._renderState.perspectiveDirty = true;
    return iterator;
}

function orthographicProjection (context, path, commands, iterator) {
    context._renderState.projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
    context._renderState.perspectiveTransform[11] = 0;
    context._renderState.perspectiveDirty = true;
    return iterator;
}

function changeViewTransform (context, path, commands, iterator) {
    context._renderState.viewTransform[0] = commands[++iterator];
    context._renderState.viewTransform[1] = commands[++iterator];
    context._renderState.viewTransform[2] = commands[++iterator];
    context._renderState.viewTransform[3] = commands[++iterator];

    context._renderState.viewTransform[4] = commands[++iterator];
    context._renderState.viewTransform[5] = commands[++iterator];
    context._renderState.viewTransform[6] = commands[++iterator];
    context._renderState.viewTransform[7] = commands[++iterator];

    context._renderState.viewTransform[8] = commands[++iterator];
    context._renderState.viewTransform[9] = commands[++iterator];
    context._renderState.viewTransform[10] = commands[++iterator];
    context._renderState.viewTransform[11] = commands[++iterator];

    context._renderState.viewTransform[12] = commands[++iterator];
    context._renderState.viewTransform[13] = commands[++iterator];
    context._renderState.viewTransform[14] = commands[++iterator];
    context._renderState.viewTransform[15] = commands[++iterator];

    context._renderState.viewDirty = true;
    return iterator;
}

module.exports = Context;

},{"../components/Camera":2,"../core/Commands":6,"../dom-renderers/DOMRenderer":19,"../webgl-renderers/WebGLRenderer":52}],38:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Commands = require('../core/Commands');

/**
 * The UIManager is being updated by an Engine by consecutively calling its
 * `update` method. It can either manage a real Web-Worker or the global
 * FamousEngine core singleton.
 *
 * @example
 * var compositor = new Compositor();
 * var engine = new Engine();
 *
 * // Using a Web Worker
 * var worker = new Worker('worker.bundle.js');
 * var threadmanger = new UIManager(worker, compositor, engine);
 *
 * // Without using a Web Worker
 * var threadmanger = new UIManager(Famous, compositor, engine);
 *
 * @class  UIManager
 * @constructor
 *
 * @param {Famous|Worker} thread The thread being used to receive messages
 * from and post messages to. Expected to expose a WebWorker-like API, which
 * means providing a way to listen for updates by setting its `onmessage`
 * property and sending updates using `postMessage`.
 * @param {Compositor} compositor an instance of Compositor used to extract
 * enqueued draw commands from to be sent to the thread.
 * @param {RenderLoop} renderLoop an instance of Engine used for executing
 * the `ENGINE` commands on.
 */
function UIManager (thread, compositor, renderLoop) {
    this._thread = thread;
    this._compositor = compositor;
    this._renderLoop = renderLoop;

    this._renderLoop.update(this);

    var _this = this;
    this._thread.onmessage = function (ev) {
        var message = ev.data ? ev.data : ev;
        if (message[0] === Commands.ENGINE) {
            switch (message[1]) {
                case Commands.START:
                    _this._engine.start();
                    break;
                case Commands.STOP:
                    _this._engine.stop();
                    break;
                default:
                    console.error(
                        'Unknown ENGINE command "' + message[1] + '"'
                    );
                    break;
            }
        }
        else {
            _this._compositor.receiveCommands(message);
        }
    };
    this._thread.onerror = function (error) {
        console.error(error);
    };
}

/**
 * Returns the thread being used by the UIManager.
 * This could either be an an actual web worker or a `FamousEngine` singleton.
 *
 * @method
 *
 * @return {Worker|FamousEngine} Either a web worker or a `FamousEngine` singleton.
 */
UIManager.prototype.getThread = function getThread() {
    return this._thread;
};

/**
 * Returns the compositor being used by this UIManager.
 *
 * @method
 *
 * @return {Compositor} The compositor used by the UIManager.
 */
UIManager.prototype.getCompositor = function getCompositor() {
    return this._compositor;
};

/**
 * Returns the engine being used by this UIManager.
 *
 * @method
 * @deprecated Use {@link UIManager#getRenderLoop instead!}
 *
 * @return {Engine} The engine used by the UIManager.
 */
UIManager.prototype.getEngine = function getEngine() {
    return this._renderLoop;
};


/**
 * Returns the render loop currently being used by the UIManager.
 *
 * @method
 *
 * @return {RenderLoop}  The registered render loop used for updating the
 * UIManager.
 */
UIManager.prototype.getRenderLoop = function getRenderLoop() {
    return this._renderLoop;
};

/**
 * Update method being invoked by the Engine on every `requestAnimationFrame`.
 * Used for updating the notion of time within the managed thread by sending
 * a FRAME command and sending messages to
 *
 * @method
 *
 * @param  {Number} time unix timestamp to be passed down to the worker as a
 * FRAME command
 * @return {undefined} undefined
 */
UIManager.prototype.update = function update (time) {
    this._thread.postMessage([Commands.FRAME, time]);
    var threadMessages = this._compositor.drawCommands();
    this._thread.postMessage(threadMessages);
    this._compositor.clearCommands();
};

module.exports = UIManager;

},{"../core/Commands":6}],39:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var css = '.famous-dom-renderer {' +
    'width:100%;' +
    'height:100%;' +
    'transform-style:preserve-3d;' +
    '-webkit-transform-style:preserve-3d;' +
'}' +

'.famous-dom-element {' +
    '-webkit-transform-origin:0% 0%;' +
    'transform-origin:0% 0%;' +
    '-webkit-backface-visibility:visible;' +
    'backface-visibility:visible;' +
    '-webkit-transform-style:preserve-3d;' +
    'transform-style:preserve-3d;' +
    '-webkit-tap-highlight-color:transparent;' +
    'pointer-events:auto;' +
    'z-index:1;' +
'}' +

'.famous-dom-element-content,' +
'.famous-dom-element {' +
    'position:absolute;' +
    'box-sizing:border-box;' +
    '-moz-box-sizing:border-box;' +
    '-webkit-box-sizing:border-box;' +
'}' +

'.famous-webgl-renderer {' +
    '-webkit-transform:translateZ(1000000px);' +  /* TODO: Fix when Safari Fixes*/
    'transform:translateZ(1000000px);' +
    'pointer-events:none;' +
    'position:absolute;' +
    'z-index:1;' +
    'top:0;' +
    'width:100%;' +
    'height:100%;' +
'}';

var INJECTED = typeof document === 'undefined';

function injectCSS() {
    if (INJECTED) return;
    INJECTED = true;
    if (document.createStyleSheet) {
        var sheet = document.createStyleSheet();
        sheet.cssText = css;
    }
    else {
        var head = document.getElementsByTagName('head')[0];
        var style = document.createElement('style');

        if (style.styleSheet) {
            style.styleSheet.cssText = css;
        }
        else {
            style.appendChild(document.createTextNode(css));
        }

        (head ? head : document.documentElement).appendChild(style);
    }
}

module.exports = injectCSS;

},{}],40:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jshint -W008 */

'use strict';

/**
 * A library of curves which map an animation explicitly as a function of time.
 *
 * @namespace
 * @property {Function} linear
 * @property {Function} easeIn
 * @property {Function} easeOut
 * @property {Function} easeInOut
 * @property {Function} easeOutBounce
 * @property {Function} spring
 * @property {Function} inQuad
 * @property {Function} outQuad
 * @property {Function} inOutQuad
 * @property {Function} inCubic
 * @property {Function} outCubic
 * @property {Function} inOutCubic
 * @property {Function} inQuart
 * @property {Function} outQuart
 * @property {Function} inOutQuart
 * @property {Function} inQuint
 * @property {Function} outQuint
 * @property {Function} inOutQuint
 * @property {Function} inSine
 * @property {Function} outSine
 * @property {Function} inOutSine
 * @property {Function} inExpo
 * @property {Function} outExpo
 * @property {Function} inOutExp
 * @property {Function} inCirc
 * @property {Function} outCirc
 * @property {Function} inOutCirc
 * @property {Function} inElastic
 * @property {Function} outElastic
 * @property {Function} inOutElastic
 * @property {Function} inBounce
 * @property {Function} outBounce
 * @property {Function} inOutBounce
 * @property {Function} flat            - Useful for delaying the execution of
 *                                        a subsequent transition.
 */
var Curves = {
    linear: function(t) {
        return t;
    },

    easeIn: function(t) {
        return t*t;
    },

    easeOut: function(t) {
        return t*(2-t);
    },

    easeInOut: function(t) {
        if (t <= 0.5) return 2*t*t;
        else return -2*t*t + 4*t - 1;
    },

    easeOutBounce: function(t) {
        return t*(3 - 2*t);
    },

    spring: function(t) {
        return (1 - t) * Math.sin(6 * Math.PI * t) + t;
    },

    inQuad: function(t) {
        return t*t;
    },

    outQuad: function(t) {
        return -(t-=1)*t+1;
    },

    inOutQuad: function(t) {
        if ((t/=.5) < 1) return .5*t*t;
        return -.5*((--t)*(t-2) - 1);
    },

    inCubic: function(t) {
        return t*t*t;
    },

    outCubic: function(t) {
        return ((--t)*t*t + 1);
    },

    inOutCubic: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t;
        return .5*((t-=2)*t*t + 2);
    },

    inQuart: function(t) {
        return t*t*t*t;
    },

    outQuart: function(t) {
        return -((--t)*t*t*t - 1);
    },

    inOutQuart: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t;
        return -.5 * ((t-=2)*t*t*t - 2);
    },

    inQuint: function(t) {
        return t*t*t*t*t;
    },

    outQuint: function(t) {
        return ((--t)*t*t*t*t + 1);
    },

    inOutQuint: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t*t;
        return .5*((t-=2)*t*t*t*t + 2);
    },

    inSine: function(t) {
        return -1.0*Math.cos(t * (Math.PI/2)) + 1.0;
    },

    outSine: function(t) {
        return Math.sin(t * (Math.PI/2));
    },

    inOutSine: function(t) {
        return -.5*(Math.cos(Math.PI*t) - 1);
    },

    inExpo: function(t) {
        return (t===0) ? 0.0 : Math.pow(2, 10 * (t - 1));
    },

    outExpo: function(t) {
        return (t===1.0) ? 1.0 : (-Math.pow(2, -10 * t) + 1);
    },

    inOutExpo: function(t) {
        if (t===0) return 0.0;
        if (t===1.0) return 1.0;
        if ((t/=.5) < 1) return .5 * Math.pow(2, 10 * (t - 1));
        return .5 * (-Math.pow(2, -10 * --t) + 2);
    },

    inCirc: function(t) {
        return -(Math.sqrt(1 - t*t) - 1);
    },

    outCirc: function(t) {
        return Math.sqrt(1 - (--t)*t);
    },

    inOutCirc: function(t) {
        if ((t/=.5) < 1) return -.5 * (Math.sqrt(1 - t*t) - 1);
        return .5 * (Math.sqrt(1 - (t-=2)*t) + 1);
    },

    inElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/ p));
    },

    outElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return a*Math.pow(2,-10*t) * Math.sin((t-s)*(2*Math.PI)/p) + 1.0;
    },

    inOutElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if ((t/=.5)===2) return 1.0;  if (!p) p=(.3*1.5);
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p));
        return a*Math.pow(2,-10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p)*.5 + 1.0;
    },

    inBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return t*t*((s+1)*t - s);
    },

    outBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return ((--t)*t*((s+1)*t + s) + 1);
    },

    inOutBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        if ((t/=.5) < 1) return .5*(t*t*(((s*=(1.525))+1)*t - s));
        return .5*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
    },

    inBounce: function(t) {
        return 1.0 - Curves.outBounce(1.0-t);
    },

    outBounce: function(t) {
        if (t < (1/2.75)) {
            return (7.5625*t*t);
        }
        else if (t < (2/2.75)) {
            return (7.5625*(t-=(1.5/2.75))*t + .75);
        }
        else if (t < (2.5/2.75)) {
            return (7.5625*(t-=(2.25/2.75))*t + .9375);
        }
        else {
            return (7.5625*(t-=(2.625/2.75))*t + .984375);
        }
    },

    inOutBounce: function(t) {
        if (t < .5) return Curves.inBounce(t*2) * .5;
        return Curves.outBounce(t*2-1.0) * .5 + .5;
    },

    flat: function() {
        return 0;
    }
};

module.exports = Curves;

},{}],41:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Curves = require('./Curves');
var FamousEngine = require('../core/FamousEngine');

/**
 * A state maintainer for a smooth transition between
 *    numerically-specified states. Example numeric states include floats and
 *    arrays of floats objects.
 *
 * An initial state is set with the constructor or using
 *     {@link Transitionable#from}. Subsequent transitions consist of an
 *     intermediate state, easing curve, duration and callback. The final state
 *     of each transition is the initial state of the subsequent one. Calls to
 *     {@link Transitionable#get} provide the interpolated state along the way.
 *
 * Note that there is no event loop here - calls to {@link Transitionable#get}
 *    are the only way to find state projected to the current (or provided)
 *    time and are the only way to trigger callbacks and mutate the internal
 *    transition queue.
 *
 * @example
 * var t = new Transitionable([0, 0]);
 * t
 *     .to([100, 0], 'linear', 1000)
 *     .delay(1000)
 *     .to([200, 0], 'outBounce', 1000);
 *
 * var div = document.createElement('div');
 * div.style.background = 'blue';
 * div.style.width = '100px';
 * div.style.height = '100px';
 * document.body.appendChild(div);
 *
 * div.addEventListener('click', function() {
 *     t.isPaused() ? t.resume() : t.pause();
 * });
 *
 * requestAnimationFrame(function loop() {
 *     div.style.transform = 'translateX(' + t.get()[0] + 'px)' + ' translateY(' + t.get()[1] + 'px)';
 *     requestAnimationFrame(loop);
 * });
 *
 * @class Transitionable
 * @constructor
 * @param {Number|Array.Number} initialState    initial state to transition
 *                                              from - equivalent to a pursuant
 *                                              invocation of
 *                                              {@link Transitionable#from}
 */
function Transitionable(initialState) {
    this._queue = [];
    this._from = null;
    this._state = null;
    this._startedAt = null;
    this._pausedAt = null;
    if (initialState != null) this.from(initialState);
}

/**
 * Internal Clock used for determining the current time for the ongoing
 * transitions.
 *
 * @type {Performance|Date|Clock}
 */
Transitionable.Clock = FamousEngine.getClock();

/**
 * Registers a transition to be pushed onto the internal queue.
 *
 * @method to
 * @chainable
 *
 * @param  {Number|Array.Number}    finalState              final state to
 *                                                          transiton to
 * @param  {String|Function}        [curve=Curves.linear]   easing function
 *                                                          used for
 *                                                          interpolating
 *                                                          [0, 1]
 * @param  {Number}                 [duration=100]          duration of
 *                                                          transition
 * @param  {Function}               [callback]              callback function
 *                                                          to be called after
 *                                                          the transition is
 *                                                          complete
 * @param  {String}                 [method]                method used for
 *                                                          interpolation
 *                                                          (e.g. slerp)
 * @return {Transitionable}         this
 */
Transitionable.prototype.to = function to(finalState, curve, duration, callback, method) {
    curve = curve != null && curve.constructor === String ? Curves[curve] : curve;
    if (this._queue.length === 0) {
        this._startedAt = this.constructor.Clock.now();
        this._pausedAt = null;
    }
    this._queue.push(
        finalState,
        curve != null ? curve : Curves.linear,
        duration != null ? duration : 100,
        callback,
        method
    );
    return this;
};

/**
 * Resets the transition queue to a stable initial state.
 *
 * @method from
 * @chainable
 *
 * @param  {Number|Array.Number}    initialState    initial state to
 *                                                  transition from
 * @return {Transitionable}         this
 */
Transitionable.prototype.from = function from(initialState) {
    this._state = initialState;
    this._from = this._sync(null, this._state);
    this._queue.length = 0;
    this._startedAt = this.constructor.Clock.now();
    this._pausedAt = null;
    return this;
};

/**
 * Delays the execution of the subsequent transition for a certain period of
 * time.
 *
 * @method delay
 * @chainable
 *
 * @param {Number}      duration    delay time in ms
 * @param {Function}    [callback]  Zero-argument function to call on observed
 *                                  completion (t=1)
 * @return {Transitionable}         this
 */
Transitionable.prototype.delay = function delay(duration, callback) {
    var endState = this._queue.length > 0 ? this._queue[this._queue.length - 5] : this._state;
    return this.to(endState, Curves.flat, duration, callback);
};

/**
 * Overrides current transition.
 *
 * @method override
 * @chainable
 *
 * @param  {Number|Array.Number}    [finalState]    final state to transiton to
 * @param  {String|Function}        [curve]         easing function used for
 *                                                  interpolating [0, 1]
 * @param  {Number}                 [duration]      duration of transition
 * @param  {Function}               [callback]      callback function to be
 *                                                  called after the transition
 *                                                  is complete
 * @param {String}                  [method]        optional method used for
 *                                                  interpolating between the
 *                                                  values. Set to `slerp` for
 *                                                  spherical linear
 *                                                  interpolation.
 * @return {Transitionable}         this
 */
Transitionable.prototype.override = function override(finalState, curve, duration, callback, method) {
    if (this._queue.length > 0) {
        if (finalState != null) this._queue[0] = finalState;
        if (curve != null)      this._queue[1] = curve.constructor === String ? Curves[curve] : curve;
        if (duration != null)   this._queue[2] = duration;
        if (callback != null)   this._queue[3] = callback;
        if (method != null)     this._queue[4] = method;
    }
    return this;
};


/**
 * Used for interpolating between the start and end state of the currently
 * running transition
 *
 * @method  _interpolate
 * @private
 *
 * @param  {Object|Array|Number} output     Where to write to (in order to avoid
 *                                          object allocation and therefore GC).
 * @param  {Object|Array|Number} from       Start state of current transition.
 * @param  {Object|Array|Number} to         End state of current transition.
 * @param  {Number} progress                Progress of the current transition,
 *                                          in [0, 1]
 * @param  {String} method                  Method used for interpolation (e.g.
 *                                          slerp)
 * @return {Object|Array|Number}            output
 */
Transitionable.prototype._interpolate = function _interpolate(output, from, to, progress, method) {
    if (to instanceof Object) {
        if (method === 'slerp') {
            var x, y, z, w;
            var qx, qy, qz, qw;
            var omega, cosomega, sinomega, scaleFrom, scaleTo;

            x = from[0];
            y = from[1];
            z = from[2];
            w = from[3];

            qx = to[0];
            qy = to[1];
            qz = to[2];
            qw = to[3];

            if (progress === 1) {
                output[0] = qx;
                output[1] = qy;
                output[2] = qz;
                output[3] = qw;
                return output;
            }

            cosomega = w * qw + x * qx + y * qy + z * qz;
            if ((1.0 - cosomega) > 1e-5) {
                omega = Math.acos(cosomega);
                sinomega = Math.sin(omega);
                scaleFrom = Math.sin((1.0 - progress) * omega) / sinomega;
                scaleTo = Math.sin(progress * omega) / sinomega;
            }
            else {
                scaleFrom = 1.0 - progress;
                scaleTo = progress;
            }

            output[0] = x * scaleFrom + qx * scaleTo;
            output[1] = y * scaleFrom + qy * scaleTo;
            output[2] = z * scaleFrom + qz * scaleTo;
            output[3] = w * scaleFrom + qw * scaleTo;
        }
        else if (to instanceof Array) {
            for (var i = 0, len = to.length; i < len; i++) {
                output[i] = this._interpolate(output[i], from[i], to[i], progress, method);
            }
        }
        else {
            for (var key in to) {
                output[key] = this._interpolate(output[key], from[key], to[key], progress, method);
            }
        }
    }
    else {
        output = from + progress * (to - from);
    }
    return output;
};


/**
 * Internal helper method used for synchronizing the current, absolute state of
 * a transition to a given output array, object literal or number. Supports
 * nested state objects by through recursion.
 *
 * @method  _sync
 * @private
 *
 * @param  {Number|Array|Object} output     Where to write to (in order to avoid
 *                                          object allocation and therefore GC).
 * @param  {Number|Array|Object} input      Input state to proxy onto the
 *                                          output.
 * @return {Number|Array|Object} output     Passed in output object.
 */
Transitionable.prototype._sync = function _sync(output, input) {
    if (typeof input === 'number') output = input;
    else if (input instanceof Array) {
        if (output == null) output = [];
        for (var i = 0, len = input.length; i < len; i++) {
            output[i] = _sync(output[i], input[i]);
        }
    }
    else if (input instanceof Object) {
        if (output == null) output = {};
        for (var key in input) {
            output[key] = _sync(output[key], input[key]);
        }
    }
    return output;
};

/**
 * Get interpolated state of current action at provided time. If the last
 *    action has completed, invoke its callback.
 *
 * @method get
 *
 * @param {Number=} t               Evaluate the curve at a normalized version
 *                                  of this time. If omitted, use current time
 *                                  (Unix epoch time retrieved from Clock).
 * @return {Number|Array.Number}    Beginning state interpolated to this point
 *                                  in time.
 */
Transitionable.prototype.get = function get(t) {
    if (this._queue.length === 0) return this._state;

    t = this._pausedAt ? this._pausedAt : t;
    t = t ? t : this.constructor.Clock.now();

    var progress = (t - this._startedAt) / this._queue[2];
    this._state = this._interpolate(
        this._state,
        this._from,
        this._queue[0],
        this._queue[1](progress > 1 ? 1 : progress),
        this._queue[4]
    );
    var state = this._state;
    if (progress >= 1) {
        this._startedAt = this._startedAt + this._queue[2];
        this._from = this._sync(this._from, this._state);
        this._queue.shift();
        this._queue.shift();
        this._queue.shift();
        var callback = this._queue.shift();
        this._queue.shift();
        if (callback) callback();
    }
    return progress > 1 ? this.get() : state;
};

/**
 * Is there at least one transition pending completion?
 *
 * @method isActive
 *
 * @return {Boolean}    Boolean indicating whether there is at least one pending
 *                      transition. Paused transitions are still being
 *                      considered active.
 */
Transitionable.prototype.isActive = function isActive() {
    return this._queue.length > 0;
};

/**
 * Halt transition at current state and erase all pending actions.
 *
 * @method halt
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.halt = function halt() {
    return this.from(this.get());
};

/**
 * Pause transition. This will not erase any actions.
 *
 * @method pause
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.pause = function pause() {
    this._pausedAt = this.constructor.Clock.now();
    return this;
};

/**
 * Has the current action been paused?
 *
 * @method isPaused
 * @chainable
 *
 * @return {Boolean} if the current action has been paused
 */
Transitionable.prototype.isPaused = function isPaused() {
    return !!this._pausedAt;
};

/**
 * Resume a previously paused transition.
 *
 * @method resume
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.resume = function resume() {
    var diff = this._pausedAt - this._startedAt;
    this._startedAt = this.constructor.Clock.now() - diff;
    this._pausedAt = null;
    return this;
};

/**
 * Cancel all transitions and reset to a stable state
 *
 * @method reset
 * @chainable
 * @deprecated Use `.from` instead!
 *
 * @param {Number|Array.Number|Object.<number, number>} start
 *    stable state to set to
 * @return {Transitionable}                             this
 */
Transitionable.prototype.reset = function(start) {
    return this.from(start);
};

/**
 * Add transition to end state to the queue of pending transitions. Special
 *    Use: calling without a transition resets the object to that state with
 *    no pending actions
 *
 * @method set
 * @chainable
 * @deprecated Use `.to` instead!
 *
 * @param {Number|FamousEngineMatrix|Array.Number|Object.<number, number>} state
 *    end state to which we interpolate
 * @param {transition=} transition object of type {duration: number, curve:
 *    f[0,1] -> [0,1] or name}. If transition is omitted, change will be
 *    instantaneous.
 * @param {function()=} callback Zero-argument function to call on observed
 *    completion (t=1)
 * @return {Transitionable} this
 */
Transitionable.prototype.set = function(state, transition, callback) {
    if (transition == null) {
        this.from(state);
        if (callback) callback();
    }
    else {
        this.to(state, transition.curve, transition.duration, callback, transition.method);
    }
    return this;
};

module.exports = Transitionable;

},{"../core/FamousEngine":9,"./Curves":40}],42:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * A lightweight, featureless EventEmitter.
 *
 * @class CallbackStore
 * @constructor
 */
function CallbackStore () {
    this._events = {};
}

/**
 * Adds a listener for the specified event (= key).
 *
 * @method on
 * @chainable
 *
 * @param  {String}   key       The event type (e.g. `click`).
 * @param  {Function} callback  A callback function to be invoked whenever `key`
 *                              event is being triggered.
 * @return {Function} destroy   A function to call if you want to remove the
 *                              callback.
 */
CallbackStore.prototype.on = function on (key, callback) {
    if (!this._events[key]) this._events[key] = [];
    var callbackList = this._events[key];
    callbackList.push(callback);
    return function () {
        callbackList.splice(callbackList.indexOf(callback), 1);
    };
};

/**
 * Removes a previously added event listener.
 *
 * @method off
 * @chainable
 *
 * @param  {String} key         The event type from which the callback function
 *                              should be removed.
 * @param  {Function} callback  The callback function to be removed from the
 *                              listeners for key.
 * @return {CallbackStore} this
 */
CallbackStore.prototype.off = function off (key, callback) {
    var events = this._events[key];
    if (events) events.splice(events.indexOf(callback), 1);
    return this;
};

/**
 * Invokes all the previously for this key registered callbacks.
 *
 * @method trigger
 * @chainable
 *
 * @param  {String}        key      The event type.
 * @param  {Object}        payload  The event payload (event object).
 * @return {CallbackStore} this
 */
CallbackStore.prototype.trigger = function trigger (key, payload) {
    var events = this._events[key];
    if (events) {
        var i = 0;
        var len = events.length;
        for (; i < len ; i++) events[i](payload);
    }
    return this;
};

module.exports = CallbackStore;

},{}],43:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Deep clone an object.
 *
 * @method  clone
 *
 * @param {Object} b       Object to be cloned.
 * @return {Object} a      Cloned object (deep equality).
 */
var clone = function clone(b) {
    var a;
    if (typeof b === 'object') {
        a = (b instanceof Array) ? [] : {};
        for (var key in b) {
            if (typeof b[key] === 'object' && b[key] !== null) {
                if (b[key] instanceof Array) {
                    a[key] = new Array(b[key].length);
                    for (var i = 0; i < b[key].length; i++) {
                        a[key][i] = clone(b[key][i]);
                    }
                }
                else {
                  a[key] = clone(b[key]);
                }
            }
            else {
                a[key] = b[key];
            }
        }
    }
    else {
        a = b;
    }
    return a;
};

module.exports = clone;

},{}],44:[function(require,module,exports){
'use strict';

/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Takes an object containing keys and values and returns an object
 * comprising two "associate" arrays, one with the keys and the other
 * with the values.
 *
 * @method keyValuesToArrays
 *
 * @param {Object} obj                      Objects where to extract keys and values
 *                                          from.
 * @return {Object}         result
 *         {Array.<String>} result.keys     Keys of `result`, as returned by
 *                                          `Object.keys()`
 *         {Array}          result.values   Values of passed in object.
 */
module.exports = function keyValuesToArrays(obj) {
    var keysArray = [], valuesArray = [];
    var i = 0;
    for(var key in obj) {
        if (obj.hasOwnProperty(key)) {
            keysArray[i] = key;
            valuesArray[i] = obj[key];
            i++;
        }
    }
    return {
        keys: keysArray,
        values: valuesArray
    };
};

},{}],45:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var PREFIXES = ['', '-ms-', '-webkit-', '-moz-', '-o-'];

/**
 * A helper function used for determining the vendor prefixed version of the
 * passed in CSS property.
 *
 * Vendor checks are being conducted in the following order:
 *
 * 1. (no prefix)
 * 2. `-mz-`
 * 3. `-webkit-`
 * 4. `-moz-`
 * 5. `-o-`
 *
 * @method vendorPrefix
 *
 * @param {String} property     CSS property (no camelCase), e.g.
 *                              `border-radius`.
 * @return {String} prefixed    Vendor prefixed version of passed in CSS
 *                              property (e.g. `-webkit-border-radius`).
 */
function vendorPrefix(property) {
    for (var i = 0; i < PREFIXES.length; i++) {
        var prefixed = PREFIXES[i] + property;
        if (document.documentElement.style[prefixed] === '') {
            return prefixed;
        }
    }
    return property;
}

module.exports = vendorPrefix;

},{}],46:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Buffer is a private class that wraps the vertex data that defines
 * the the points of the triangles that webgl draws. Each buffer
 * maps to one attribute of a mesh.
 *
 * @class Buffer
 * @constructor
 *
 * @param {Number} target The bind target of the buffer to update: ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER
 * @param {Object} type Array type to be used in calls to gl.bufferData.
 * @param {WebGLContext} gl The WebGL context that the buffer is hosted by.
 *
 * @return {undefined} undefined
 */
function Buffer(target, type, gl) {
    this.buffer = null;
    this.target = target;
    this.type = type;
    this.data = [];
    this.gl = gl;
}

/**
 * Creates a WebGL buffer if one does not yet exist and binds the buffer to
 * to the context. Runs bufferData with appropriate data.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Buffer.prototype.subData = function subData() {
    var gl = this.gl;
    var data = [];

    // to prevent against maximum call-stack issue.
    for (var i = 0, chunk = 10000; i < this.data.length; i += chunk)
        data = Array.prototype.concat.apply(data, this.data.slice(i, i + chunk));

    this.buffer = this.buffer || gl.createBuffer();
    gl.bindBuffer(this.target, this.buffer);
    gl.bufferData(this.target, new this.type(data), gl.STATIC_DRAW);
};

module.exports = Buffer;

},{}],47:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var INDICES = 'indices';

var Buffer = require('./Buffer');

/**
 * BufferRegistry is a class that manages allocation of buffers to
 * input geometries.
 *
 * @class BufferRegistry
 * @constructor
 *
 * @param {WebGLContext} context WebGL drawing context to be passed to buffers.
 *
 * @return {undefined} undefined
 */
function BufferRegistry(context) {
    this.gl = context;

    this.registry = {};
    this._dynamicBuffers = [];
    this._staticBuffers = [];

    this._arrayBufferMax = 30000;
    this._elementBufferMax = 30000;
}

/**
 * Binds and fills all the vertex data into webgl buffers.  Will reuse buffers if
 * possible.  Populates registry with the name of the buffer, the WebGL buffer
 * object, spacing of the attribute, the attribute's offset within the buffer,
 * and finally the length of the buffer.  This information is later accessed by
 * the root to draw the buffers.
 *
 * @method
 *
 * @param {Number} geometryId Id of the geometry instance that holds the buffers.
 * @param {String} name Key of the input buffer in the geometry.
 * @param {Array} value Flat array containing input data for buffer.
 * @param {Number} spacing The spacing, or itemSize, of the input buffer.
 * @param {Boolean} dynamic Boolean denoting whether a geometry is dynamic or static.
 *
 * @return {undefined} undefined
 */
BufferRegistry.prototype.allocate = function allocate(geometryId, name, value, spacing, dynamic) {
    var vertexBuffers = this.registry[geometryId] || (this.registry[geometryId] = { keys: [], values: [], spacing: [], offset: [], length: [] });

    var j = vertexBuffers.keys.indexOf(name);
    var isIndex = name === INDICES;
    var bufferFound = false;
    var newOffset;
    var offset = 0;
    var length;
    var buffer;
    var k;

    if (j === -1) {
        j = vertexBuffers.keys.length;
        length = isIndex ? value.length : Math.floor(value.length / spacing);

        if (!dynamic) {

            // Use a previously created buffer if available.

            for (k = 0; k < this._staticBuffers.length; k++) {

                if (isIndex === this._staticBuffers[k].isIndex) {
                    newOffset = this._staticBuffers[k].offset + value.length;
                    if ((!isIndex && newOffset < this._arrayBufferMax) || (isIndex && newOffset < this._elementBufferMax)) {
                        buffer = this._staticBuffers[k].buffer;
                        offset = this._staticBuffers[k].offset;
                        this._staticBuffers[k].offset += value.length;
                        bufferFound = true;
                        break;
                    }
                }
            }

            // Create a new static buffer in none were found.

            if (!bufferFound) {
                buffer = new Buffer(
                    isIndex ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER,
                    isIndex ? Uint16Array : Float32Array,
                    this.gl
                );

                this._staticBuffers.push({ buffer: buffer, offset: value.length, isIndex: isIndex });
            }
        }
        else {

            // For dynamic geometries, always create new buffer.

            buffer = new Buffer(
                isIndex ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER,
                isIndex ? Uint16Array : Float32Array,
                this.gl
            );

            this._dynamicBuffers.push({ buffer: buffer, offset: value.length, isIndex: isIndex });
        }

        // Update the registry for the spec with buffer information.

        vertexBuffers.keys.push(name);
        vertexBuffers.values.push(buffer);
        vertexBuffers.spacing.push(spacing);
        vertexBuffers.offset.push(offset);
        vertexBuffers.length.push(length);
    }

    var len = value.length;
    for (k = 0; k < len; k++) {
        vertexBuffers.values[j].data[offset + k] = value[k];
    }
    vertexBuffers.values[j].subData();
};

module.exports = BufferRegistry;

},{"./Buffer":46}],48:[function(require,module,exports){
'use strict';

/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Takes the original rendering contexts' compiler function
 * and augments it with added functionality for parsing and
 * displaying errors.
 *
 * @method
 *
 * @returns {Function} Augmented function
 */
module.exports = function Debug() {
    return _augmentFunction(
        this.gl.compileShader,
        function(shader) {
            if (!this.getShaderParameter(shader, this.COMPILE_STATUS)) {
                var errors = this.getShaderInfoLog(shader);
                var source = this.getShaderSource(shader);
                _processErrors(errors, source);
            }
        }
    );
};

// Takes a function, keeps the reference and replaces it by a closure that
// executes the original function and the provided callback.
function _augmentFunction(func, callback) {
    return function() {
        var res = func.apply(this, arguments);
        callback.apply(this, arguments);
        return res;
    };
}

// Parses errors and failed source code from shaders in order
// to build displayable error blocks.
// Inspired by Jaume Sanchez Elias.
function _processErrors(errors, source) {

    var css = 'body,html{background:#e3e3e3;font-family:monaco,monospace;font-size:14px;line-height:1.7em}' +
              '#shaderReport{left:0;top:0;right:0;box-sizing:border-box;position:absolute;z-index:1000;color:' +
              '#222;padding:15px;white-space:normal;list-style-type:none;margin:50px auto;max-width:1200px}' +
              '#shaderReport li{background-color:#fff;margin:13px 0;box-shadow:0 1px 2px rgba(0,0,0,.15);' +
              'padding:20px 30px;border-radius:2px;border-left:20px solid #e01111}span{color:#e01111;' +
              'text-decoration:underline;font-weight:700}#shaderReport li p{padding:0;margin:0}' +
              '#shaderReport li:nth-child(even){background-color:#f4f4f4}' +
              '#shaderReport li p:first-child{margin-bottom:10px;color:#666}';

    var el = document.createElement('style');
    document.getElementsByTagName('head')[0].appendChild(el);
    el.textContent = css;

    var report = document.createElement('ul');
    report.setAttribute('id', 'shaderReport');
    document.body.appendChild(report);

    var re = /ERROR: [\d]+:([\d]+): (.+)/gmi;
    var lines = source.split('\n');

    var m;
    while ((m = re.exec(errors)) != null) {
        if (m.index === re.lastIndex) re.lastIndex++;
        var li = document.createElement('li');
        var code = '<p><span>ERROR</span> "' + m[2] + '" in line ' + m[1] + '</p>';
        code += '<p><b>' + lines[m[1] - 1].replace(/^[ \t]+/g, '') + '</b></p>';
        li.innerHTML = code;
        report.appendChild(li);
    }
}

},{}],49:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var clone = require('../utilities/clone');
var keyValueToArrays = require('../utilities/keyValueToArrays');

var vertexWrapper = require('../webgl-shaders').vertex;
var fragmentWrapper = require('../webgl-shaders').fragment;
var Debug = require('./Debug');

var VERTEX_SHADER = 35633;
var FRAGMENT_SHADER = 35632;
var identityMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

var header = 'precision mediump float;\n';

var TYPES = {
    undefined: 'float ',
    1: 'float ',
    2: 'vec2 ',
    3: 'vec3 ',
    4: 'vec4 ',
    16: 'mat4 '
};

var inputTypes = {
    u_baseColor: 'vec4',
    u_normals: 'vert',
    u_glossiness: 'vec4',
    u_positionOffset: 'vert'
};

var masks =  {
    vert: 1,
    vec3: 2,
    vec4: 4,
    float: 8
};

/**
 * Uniform keys and values
 */
var uniforms = keyValueToArrays({
    u_perspective: identityMatrix,
    u_view: identityMatrix,
    u_resolution: [0, 0, 0],
    u_transform: identityMatrix,
    u_size: [1, 1, 1],
    u_time: 0,
    u_opacity: 1,
    u_metalness: 0,
    u_glossiness: [0, 0, 0, 0],
    u_baseColor: [1, 1, 1, 1],
    u_normals: [1, 1, 1],
    u_positionOffset: [0, 0, 0],
    u_lightPosition: identityMatrix,
    u_lightColor: identityMatrix,
    u_ambientLight: [0, 0, 0],
    u_flatShading: 0,
    u_numLights: 0
});

/**
 * Attributes keys and values
 */
var attributes = keyValueToArrays({
    a_pos: [0, 0, 0],
    a_texCoord: [0, 0],
    a_normals: [0, 0, 0]
});

/**
 * Varyings keys and values
 */
var varyings = keyValueToArrays({
    v_textureCoordinate: [0, 0],
    v_normal: [0, 0, 0],
    v_position: [0, 0, 0],
    v_eyeVector: [0, 0, 0]
});

/**
 * A class that handles interactions with the WebGL shader program
 * used by a specific context.  It manages creation of the shader program
 * and the attached vertex and fragment shaders.  It is also in charge of
 * passing all uniforms to the WebGLContext.
 *
 * @class Program
 * @constructor
 *
 * @param {WebGL_Context} gl Context to be used to create the shader program
 * @param {Object} options Program options
 *
 * @return {undefined} undefined
 */
function Program(gl, options) {
    this.gl = gl;
    this.textureSlots = 1;
    this.options = options || {};

    this.registeredMaterials = {};
    this.flaggedUniforms = [];
    this.cachedUniforms  = {};
    this.uniformTypes = [];

    this.definitionVec4 = [];
    this.definitionVec3 = [];
    this.definitionFloat = [];
    this.applicationVec3 = [];
    this.applicationVec4 = [];
    this.applicationFloat = [];
    this.applicationVert = [];
    this.definitionVert = [];

    this.resetProgram();
}

/**
 * Determines whether a material has already been registered to
 * the shader program.
 *
 * @method
 *
 * @param {String} name Name of target input of material.
 * @param {Object} material Compiled material object being verified.
 *
 * @return {Program} this Current program.
 */
Program.prototype.registerMaterial = function registerMaterial(name, material) {
    var compiled = material;
    var type = inputTypes[name];
    var mask = masks[type];

    if ((this.registeredMaterials[material._id] & mask) === mask) return this;

    var k;

    for (k in compiled.uniforms) {
        if (uniforms.keys.indexOf(k) === -1) {
            uniforms.keys.push(k);
            uniforms.values.push(compiled.uniforms[k]);
        }
    }

    for (k in compiled.varyings) {
        if (varyings.keys.indexOf(k) === -1) {
            varyings.keys.push(k);
            varyings.values.push(compiled.varyings[k]);
        }
    }

    for (k in compiled.attributes) {
        if (attributes.keys.indexOf(k) === -1) {
            attributes.keys.push(k);
            attributes.values.push(compiled.attributes[k]);
        }
    }

    this.registeredMaterials[material._id] |= mask;

    if (type === 'float') {
        this.definitionFloat.push(material.defines);
        this.definitionFloat.push('float fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationFloat.push('if (int(abs(ID)) == ' + material._id + ') return fa_' + material._id  + '();');
    }

    if (type === 'vec3') {
        this.definitionVec3.push(material.defines);
        this.definitionVec3.push('vec3 fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationVec3.push('if (int(abs(ID.x)) == ' + material._id + ') return fa_' + material._id + '();');
    }

    if (type === 'vec4') {
        this.definitionVec4.push(material.defines);
        this.definitionVec4.push('vec4 fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationVec4.push('if (int(abs(ID.x)) == ' + material._id + ') return fa_' + material._id + '();');
    }

    if (type === 'vert') {
        this.definitionVert.push(material.defines);
        this.definitionVert.push('vec3 fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationVert.push('if (int(abs(ID.x)) == ' + material._id + ') return fa_' + material._id + '();');
    }

    return this.resetProgram();
};

/**
 * Clears all cached uniforms and attribute locations.  Assembles
 * new fragment and vertex shaders and based on material from
 * currently registered materials.  Attaches said shaders to new
 * shader program and upon success links program to the WebGL
 * context.
 *
 * @method
 *
 * @return {Program} Current program.
 */
Program.prototype.resetProgram = function resetProgram() {
    var vertexHeader = [header];
    var fragmentHeader = [header];

    var fragmentSource;
    var vertexSource;
    var program;
    var name;
    var value;
    var i;

    this.uniformLocations   = [];
    this.attributeLocations = {};

    this.uniformTypes = {};

    this.attributeNames = clone(attributes.keys);
    this.attributeValues = clone(attributes.values);

    this.varyingNames = clone(varyings.keys);
    this.varyingValues = clone(varyings.values);

    this.uniformNames = clone(uniforms.keys);
    this.uniformValues = clone(uniforms.values);

    this.flaggedUniforms = [];
    this.cachedUniforms = {};

    fragmentHeader.push('uniform sampler2D u_textures[7];\n');

    if (this.applicationVert.length) {
        vertexHeader.push('uniform sampler2D u_textures[7];\n');
    }

    for(i = 0; i < this.uniformNames.length; i++) {
        name = this.uniformNames[i];
        value = this.uniformValues[i];
        vertexHeader.push('uniform ' + TYPES[value.length] + name + ';\n');
        fragmentHeader.push('uniform ' + TYPES[value.length] + name + ';\n');
    }

    for(i = 0; i < this.attributeNames.length; i++) {
        name = this.attributeNames[i];
        value = this.attributeValues[i];
        vertexHeader.push('attribute ' + TYPES[value.length] + name + ';\n');
    }

    for(i = 0; i < this.varyingNames.length; i++) {
        name = this.varyingNames[i];
        value = this.varyingValues[i];
        vertexHeader.push('varying ' + TYPES[value.length]  + name + ';\n');
        fragmentHeader.push('varying ' + TYPES[value.length] + name + ';\n');
    }

    vertexSource = vertexHeader.join('') + vertexWrapper
        .replace('#vert_definitions', this.definitionVert.join('\n'))
        .replace('#vert_applications', this.applicationVert.join('\n'));

    fragmentSource = fragmentHeader.join('') + fragmentWrapper
        .replace('#vec3_definitions', this.definitionVec3.join('\n'))
        .replace('#vec3_applications', this.applicationVec3.join('\n'))
        .replace('#vec4_definitions', this.definitionVec4.join('\n'))
        .replace('#vec4_applications', this.applicationVec4.join('\n'))
        .replace('#float_definitions', this.definitionFloat.join('\n'))
        .replace('#float_applications', this.applicationFloat.join('\n'));

    program = this.gl.createProgram();

    this.gl.attachShader(
        program,
        this.compileShader(this.gl.createShader(VERTEX_SHADER), vertexSource)
    );

    this.gl.attachShader(
        program,
        this.compileShader(this.gl.createShader(FRAGMENT_SHADER), fragmentSource)
    );

    this.gl.linkProgram(program);

    if (! this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
        console.error('link error: ' + this.gl.getProgramInfoLog(program));
        this.program = null;
    }
    else {
        this.program = program;
        this.gl.useProgram(this.program);
    }

    this.setUniforms(this.uniformNames, this.uniformValues);

    var textureLocation = this.gl.getUniformLocation(this.program, 'u_textures[0]');
    this.gl.uniform1iv(textureLocation, [0, 1, 2, 3, 4, 5, 6]);

    return this;
};

/**
 * Compares the value of the input uniform value against
 * the cached value stored on the Program class.  Updates and
 * creates new entries in the cache when necessary.
 *
 * @method
 * @param {String} targetName Key of uniform spec being evaluated.
 * @param {Number|Array} value Value of uniform spec being evaluated.
 *
 * @return {Boolean} boolean Indicating whether the uniform being set is cached.
 */
Program.prototype.uniformIsCached = function(targetName, value) {
    if(this.cachedUniforms[targetName] == null) {
        if (value.length) {
            this.cachedUniforms[targetName] = new Float32Array(value);
        }
        else {
            this.cachedUniforms[targetName] = value;
        }
        return false;
    }
    else if (value.length) {
        var i = value.length;
        while (i--) {
            if(value[i] !== this.cachedUniforms[targetName][i]) {
                i = value.length;
                while(i--) this.cachedUniforms[targetName][i] = value[i];
                return false;
            }
        }
    }

    else if (this.cachedUniforms[targetName] !== value) {
        this.cachedUniforms[targetName] = value;
        return false;
    }

    return true;
};

/**
 * Handles all passing of uniforms to WebGL drawing context.  This
 * function will find the uniform location and then, based on
 * a type inferred from the javascript value of the uniform, it will call
 * the appropriate function to pass the uniform to WebGL.  Finally,
 * setUniforms will iterate through the passed in shaderChunks (if any)
 * and set the appropriate uniforms to specify which chunks to use.
 *
 * @method
 * @param {Array} uniformNames Array containing the keys of all uniforms to be set.
 * @param {Array} uniformValue Array containing the values of all uniforms to be set.
 *
 * @return {Program} Current program.
 */
Program.prototype.setUniforms = function (uniformNames, uniformValue) {
    var gl = this.gl;
    var location;
    var value;
    var name;
    var len;
    var i;

    if (!this.program) return this;

    len = uniformNames.length;
    for (i = 0; i < len; i++) {
        name = uniformNames[i];
        value = uniformValue[i];

        // Retreive the cached location of the uniform,
        // requesting a new location from the WebGL context
        // if it does not yet exist.

        location = this.uniformLocations[name];

        if (location === null) continue;
        if (location === undefined) {
            location = gl.getUniformLocation(this.program, name);
            this.uniformLocations[name] = location;
        }

        // Check if the value is already set for the
        // given uniform.

        if (this.uniformIsCached(name, value)) continue;

        // Determine the correct function and pass the uniform
        // value to WebGL.

        if (!this.uniformTypes[name]) {
            this.uniformTypes[name] = this.getUniformTypeFromValue(value);
        }

        // Call uniform setter function on WebGL context with correct value

        switch (this.uniformTypes[name]) {
            case 'uniform4fv':  gl.uniform4fv(location, value); break;
            case 'uniform3fv':  gl.uniform3fv(location, value); break;
            case 'uniform2fv':  gl.uniform2fv(location, value); break;
            case 'uniform1fv':  gl.uniform1fv(location, value); break;
            case 'uniform1f' :  gl.uniform1f(location, value); break;
            case 'uniformMatrix3fv': gl.uniformMatrix3fv(location, false, value); break;
            case 'uniformMatrix4fv': gl.uniformMatrix4fv(location, false, value); break;
        }
    }

    return this;
};

/**
 * Infers uniform setter function to be called on the WebGL context, based
 * on an input value.
 *
 * @method
 *
 * @param {Number|Array} value Value from which uniform type is inferred.
 *
 * @return {String} Name of uniform function for given value.
 */
Program.prototype.getUniformTypeFromValue = function getUniformTypeFromValue(value) {
    if (Array.isArray(value) || value instanceof Float32Array) {
        switch (value.length) {
            case 1:  return 'uniform1fv';
            case 2:  return 'uniform2fv';
            case 3:  return 'uniform3fv';
            case 4:  return 'uniform4fv';
            case 9:  return 'uniformMatrix3fv';
            case 16: return 'uniformMatrix4fv';
        }
    }
    else if (!isNaN(parseFloat(value)) && isFinite(value)) {
        return 'uniform1f';
    }

    throw 'cant load uniform "' + name + '" with value:' + JSON.stringify(value);
};

/**
 * Adds shader source to shader and compiles the input shader.  Checks
 * compile status and logs error if necessary.
 *
 * @method
 *
 * @param {Object} shader Program to be compiled.
 * @param {String} source Source to be used in the shader.
 *
 * @return {Object} Compiled shader.
 */
Program.prototype.compileShader = function compileShader(shader, source) {
    var i = 1;

    if (this.options.debug) {
        this.gl.compileShader = Debug.call(this);
    }

    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        console.error('compile error: ' + this.gl.getShaderInfoLog(shader));
        console.error('1: ' + source.replace(/\n/g, function () {
            return '\n' + (i+=1) + ': ';
        }));
    }

    return shader;
};

module.exports = Program;

},{"../utilities/clone":43,"../utilities/keyValueToArrays":44,"../webgl-shaders":56,"./Debug":48}],50:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Texture is a private class that stores image data
 * to be accessed from a shader or used as a render target.
 *
 * @class Texture
 * @constructor
 *
 * @param {GL} gl GL
 * @param {Object} options Options
 *
 * @return {undefined} undefined
 */
function Texture(gl, options) {
    options = options || {};
    this.id = gl.createTexture();
    this.width = options.width || 0;
    this.height = options.height || 0;
    this.mipmap = options.mipmap;
    this.format = options.format || 'RGBA';
    this.type = options.type || 'UNSIGNED_BYTE';
    this.gl = gl;

    this.bind();

    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, options.flipYWebgl || false);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlphaWebgl || false);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl[options.magFilter] || gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[options.minFilter] || gl.NEAREST);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl[options.wrapS] || gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl[options.wrapT] || gl.CLAMP_TO_EDGE);
}

/**
 * Binds this texture as the selected target.
 *
 * @method
 * @return {Object} Current texture instance.
 */
Texture.prototype.bind = function bind() {
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.id);
    return this;
};

/**
 * Erases the texture data in the given texture slot.
 *
 * @method
 * @return {Object} Current texture instance.
 */
Texture.prototype.unbind = function unbind() {
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    return this;
};

/**
 * Replaces the image data in the texture with the given image.
 *
 * @method
 *
 * @param {Image}   img     The image object to upload pixel data from.
 * @return {Object}         Current texture instance.
 */
Texture.prototype.setImage = function setImage(img) {
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl[this.format], this.gl[this.format], this.gl[this.type], img);
    if (this.mipmap) this.gl.generateMipmap(this.gl.TEXTURE_2D);
    return this;
};

/**
 * Replaces the image data in the texture with an array of arbitrary data.
 *
 * @method
 *
 * @param {Array}   input   Array to be set as data to texture.
 * @return {Object}         Current texture instance.
 */
Texture.prototype.setArray = function setArray(input) {
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl[this.format], this.width, this.height, 0, this.gl[this.format], this.gl[this.type], input);
    return this;
};

/**
 * Dumps the rgb-pixel contents of a texture into an array for debugging purposes
 *
 * @method
 *
 * @param {Number} x        x-offset between texture coordinates and snapshot
 * @param {Number} y        y-offset between texture coordinates and snapshot
 * @param {Number} width    x-depth of the snapshot
 * @param {Number} height   y-depth of the snapshot
 *
 * @return {Array}          An array of the pixels contained in the snapshot.
 */
Texture.prototype.readBack = function readBack(x, y, width, height) {
    var gl = this.gl;
    var pixels;
    x = x || 0;
    y = y || 0;
    width = width || this.width;
    height = height || this.height;
    var fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.id, 0);
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
        pixels = new Uint8Array(width * height * 4);
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    }
    return pixels;
};

module.exports = Texture;

},{}],51:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
'use strict';

var Texture = require('./Texture');
var createCheckerboard = require('./createCheckerboard');

/**
 * Handles loading, binding, and resampling of textures for WebGLRenderer.
 *
 * @class TextureManager
 * @constructor
 *
 * @param {WebGL_Context} gl Context used to create and bind textures.
 *
 * @return {undefined} undefined
 */
function TextureManager(gl) {
    this.registry = [];
    this._needsResample = [];

    this._activeTexture = 0;
    this._boundTexture = null;

    this._checkerboard = createCheckerboard();

    this.gl = gl;
}

/**
 * Update function used by WebGLRenderer to queue resamples on
 * registered textures.
 *
 * @method
 *
 * @param {Number}      time    Time in milliseconds according to the compositor.
 * @return {undefined}          undefined
 */
TextureManager.prototype.update = function update(time) {
    var registryLength = this.registry.length;

    for (var i = 1; i < registryLength; i++) {
        var texture = this.registry[i];

        if (texture && texture.isLoaded && texture.resampleRate) {
            if (!texture.lastResample || time - texture.lastResample > texture.resampleRate) {
                if (!this._needsResample[texture.id]) {
                    this._needsResample[texture.id] = true;
                    texture.lastResample = time;
                }
            }
        }
    }
};

/**
 * Creates a spec and creates a texture based on given texture data.
 * Handles loading assets if necessary.
 *
 * @method
 *
 * @param {Object}  input   Object containing texture id, texture data
 *                          and options used to draw texture.
 * @param {Number}  slot    Texture slot to bind generated texture to.
 * @return {undefined}      undefined
 */
TextureManager.prototype.register = function register(input, slot) {
    var _this = this;

    var source = input.data;
    var textureId = input.id;
    var options = input.options || {};
    var texture = this.registry[textureId];
    var spec;

    if (!texture) {

        texture = new Texture(this.gl, options);
        texture.setImage(this._checkerboard);

        // Add texture to registry

        spec = this.registry[textureId] = {
            resampleRate: options.resampleRate || null,
            lastResample: null,
            isLoaded: false,
            texture: texture,
            source: source,
            id: textureId,
            slot: slot
        };

        // Handle array

        if (Array.isArray(source) || source instanceof Uint8Array || source instanceof Float32Array) {
            this.bindTexture(textureId);
            texture.setArray(source);
            spec.isLoaded = true;
        }

        // Handle video

        else if (source instanceof HTMLVideoElement) {
            source.addEventListener('loadeddata', function() {
                _this.bindTexture(textureId);
                texture.setImage(source);

                spec.isLoaded = true;
                spec.source = source;
            });
        }

        // Handle image url

        else if (typeof source === 'string') {
            loadImage(source, function (img) {
                _this.bindTexture(textureId);
                texture.setImage(img);

                spec.isLoaded = true;
                spec.source = img;
            });
        }
    }

    return textureId;
};

/**
 * Loads an image from a string or Image object and executes a callback function.
 *
 * @method
 * @private
 *
 * @param {Object|String} input The input image data to load as an asset.
 * @param {Function} callback The callback function to be fired when the image has finished loading.
 *
 * @return {Object} Image object being loaded.
 */
function loadImage (input, callback) {
    var image = (typeof input === 'string' ? new Image() : input) || {};
        image.crossOrigin = 'anonymous';

    if (!image.src) image.src = input;
    if (!image.complete) {
        image.onload = function () {
            callback(image);
        };
    }
    else {
        callback(image);
    }

    return image;
}

/**
 * Sets active texture slot and binds target texture.  Also handles
 * resampling when necessary.
 *
 * @method
 *
 * @param {Number} id Identifier used to retreive texture spec
 *
 * @return {undefined} undefined
 */
TextureManager.prototype.bindTexture = function bindTexture(id) {
    var spec = this.registry[id];

    if (this._activeTexture !== spec.slot) {
        this.gl.activeTexture(this.gl.TEXTURE0 + spec.slot);
        this._activeTexture = spec.slot;
    }

    if (this._boundTexture !== id) {
        this._boundTexture = id;
        spec.texture.bind();
    }

    if (this._needsResample[spec.id]) {

        // TODO: Account for resampling of arrays.

        spec.texture.setImage(spec.source);
        this._needsResample[spec.id] = false;
    }
};

module.exports = TextureManager;

},{"./Texture":50,"./createCheckerboard":54}],52:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Program = require('./Program');
var BufferRegistry = require('./BufferRegistry');
var sorter = require('./radixSort');
var keyValueToArrays = require('../utilities/keyValueToArrays');
var TextureManager = require('./TextureManager');
var compileMaterial = require('./compileMaterial');

var identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

var globalUniforms = keyValueToArrays({
    'u_numLights': 0,
    'u_ambientLight': new Array(3),
    'u_lightPosition': new Array(3),
    'u_lightColor': new Array(3),
    'u_perspective': new Array(16),
    'u_time': 0,
    'u_view': new Array(16)
});

/**
 * WebGLRenderer is a private class that manages all interactions with the WebGL
 * API. Each frame it receives commands from the compositor and updates its
 * registries accordingly. Subsequently, the draw function is called and the
 * WebGLRenderer issues draw calls for all meshes in its registry.
 *
 * @class WebGLRenderer
 * @constructor
 *
 * @param {Element} canvas The DOM element that GL will paint itself onto.
 * @param {Compositor} compositor Compositor used for querying the time from.
 *
 * @return {undefined} undefined
 */
function WebGLRenderer(canvas, compositor) {
    canvas.classList.add('famous-webgl-renderer');

    this.canvas = canvas;
    this.compositor = compositor;

    var gl = this.gl = this.getWebGLContext(this.canvas);

    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.polygonOffset(0.1, 0.1);
    gl.enable(gl.POLYGON_OFFSET_FILL);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.depthFunc(gl.LEQUAL);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);

    this.meshRegistry = {};
    this.meshRegistryKeys = [];

    this.cutoutRegistry = {};

    this.cutoutRegistryKeys = [];

    /**
     * Lights
     */
    this.numLights = 0;
    this.ambientLightColor = [0, 0, 0];
    this.lightRegistry = {};
    this.lightRegistryKeys = [];
    this.lightPositions = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    this.lightColors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

    this.textureManager = new TextureManager(gl);
    this.texCache = {};
    this.bufferRegistry = new BufferRegistry(gl);
    this.program = new Program(gl, { debug: true });

    this.state = {
        boundArrayBuffer: null,
        boundElementBuffer: null,
        lastDrawn: null,
        enabledAttributes: {},
        enabledAttributesKeys: []
    };

    this.resolutionName = ['u_resolution'];
    this.resolutionValues = [[0, 0, 0]];

    this.cachedSize = [];

    /*
    The projectionTransform has some constant components, i.e. the z scale, and the x and y translation.

    The z scale keeps the final z position of any vertex within the clip's domain by scaling it by an
    arbitrarily small coefficient. This has the advantage of being a useful default in the event of the
    user forgoing a near and far plane, an alien convention in dom space as in DOM overlapping is
    conducted via painter's algorithm.

    The x and y translation transforms the world space origin to the top left corner of the screen.

    The final component (this.projectionTransform[15]) is initialized as 1 because certain projection models,
    e.g. the WC3 specified model, keep the XY plane as the projection hyperplane.
    */
    this.projectionTransform = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -0.000001, 0, -1, 1, 0, 1];

    // TODO: remove this hack

    var cutout = this.cutoutGeometry = {
        spec: {
            id: -1,
            bufferValues: [[-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]],
            bufferNames: ['a_pos'],
            type: 'TRIANGLE_STRIP'
        }
    };

    this.bufferRegistry.allocate(
        this.cutoutGeometry.spec.id,
        cutout.spec.bufferNames[0],
        cutout.spec.bufferValues[0],
        3
    );
}

/**
 * Attempts to retreive the WebGLRenderer context using several
 * accessors. For browser compatability. Throws on error.
 *
 * @method
 *
 * @param {Object} canvas Canvas element from which the context is retreived
 *
 * @return {Object} WebGLContext WebGL context
 */
WebGLRenderer.prototype.getWebGLContext = function getWebGLContext(canvas) {
    var names = ['webgl', 'experimental-webgl', 'webkit-3d', 'moz-webgl'];
    var context;

    for (var i = 0, len = names.length; i < len; i++) {
        try {
            context = canvas.getContext(names[i]);
        }
        catch (error) {
            console.error('Error creating WebGL context: ' + error.toString());
        }
        if (context) return context;
    }

    if (!context) {
        console.error('Could not retrieve WebGL context. Please refer to https://www.khronos.org/webgl/ for requirements');
        return false;
    }
};

/**
 * Adds a new base spec to the light registry at a given path.
 *
 * @method
 *
 * @param {String} path Path used as id of new light in lightRegistry
 *
 * @return {Object} Newly created light spec
 */
WebGLRenderer.prototype.createLight = function createLight(path) {
    this.numLights++;
    this.lightRegistryKeys.push(path);
    this.lightRegistry[path] = {
        color: [0, 0, 0],
        position: [0, 0, 0]
    };
    return this.lightRegistry[path];
};

/**
 * Adds a new base spec to the mesh registry at a given path.
 *
 * @method
 *
 * @param {String} path Path used as id of new mesh in meshRegistry.
 *
 * @return {Object} Newly created mesh spec.
 */
WebGLRenderer.prototype.createMesh = function createMesh(path) {
    this.meshRegistryKeys.push(path);

    var uniforms = keyValueToArrays({
        u_opacity: 1,
        u_transform: identity,
        u_size: [0, 0, 0],
        u_baseColor: [0.5, 0.5, 0.5, 1],
        u_positionOffset: [0, 0, 0],
        u_normals: [0, 0, 0],
        u_flatShading: 0,
        u_glossiness: [0, 0, 0, 0]
    });
    this.meshRegistry[path] = {
        depth: null,
        uniformKeys: uniforms.keys,
        uniformValues: uniforms.values,
        buffers: {},
        geometry: null,
        drawType: null,
        textures: [],
        visible: true
    };
    return this.meshRegistry[path];
};

/**
 * Sets flag on indicating whether to do skip draw phase for
 * cutout mesh at given path.
 *
 * @method
 *
 * @param {String} path Path used as id of target cutout mesh.
 * @param {Boolean} usesCutout Indicates the presence of a cutout mesh
 *
 * @return {undefined} undefined
 */
WebGLRenderer.prototype.setCutoutState = function setCutoutState(path, usesCutout) {
    var cutout = this.getOrSetCutout(path);

    cutout.visible = usesCutout;
};

/**
 * Creates or retreives cutout
 *
 * @method
 *
 * @param {String} path Path used as id of target cutout mesh.
 *
 * @return {Object} Newly created cutout spec.
 */
WebGLRenderer.prototype.getOrSetCutout = function getOrSetCutout(path) {
    if (this.cutoutRegistry[path]) {
        return this.cutoutRegistry[path];
    }
    else {
        var uniforms = keyValueToArrays({
            u_opacity: 0,
            u_transform: identity.slice(),
            u_size: [0, 0, 0],
            u_origin: [0, 0, 0],
            u_baseColor: [0, 0, 0, 1]
        });

        this.cutoutRegistryKeys.push(path);

        this.cutoutRegistry[path] = {
            uniformKeys: uniforms.keys,
            uniformValues: uniforms.values,
            geometry: this.cutoutGeometry.spec.id,
            drawType: this.cutoutGeometry.spec.type,
            visible: true
        };

        return this.cutoutRegistry[path];
    }
};

/**
 * Sets flag on indicating whether to do skip draw phase for
 * mesh at given path.
 *
 * @method
 * @param {String} path Path used as id of target mesh.
 * @param {Boolean} visibility Indicates the visibility of target mesh.
 *
 * @return {undefined} undefined
 */
WebGLRenderer.prototype.setMeshVisibility = function setMeshVisibility(path, visibility) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    mesh.visible = visibility;
};

/**
 * Deletes a mesh from the meshRegistry.
 *
 * @method
 * @param {String} path Path used as id of target mesh.
 *
 * @return {undefined} undefined
 */
WebGLRenderer.prototype.removeMesh = function removeMesh(path) {
    var keyLocation = this.meshRegistryKeys.indexOf(path);
    this.meshRegistryKeys.splice(keyLocation, 1);
    this.meshRegistry[path] = null;
};

/**
 * Creates or retreives cutout
 *
 * @method
 * @param {String} path Path used as id of cutout in cutout registry.
 * @param {String} uniformName Identifier used to upload value
 * @param {Array} uniformValue Value of uniform data
 *
 * @return {undefined} undefined
 */
WebGLRenderer.prototype.setCutoutUniform = function setCutoutUniform(path, uniformName, uniformValue) {
    var cutout = this.getOrSetCutout(path);

    var index = cutout.uniformKeys.indexOf(uniformName);

    if (uniformValue.length) {
        for (var i = 0, len = uniformValue.length; i < len; i++) {
            cutout.uniformValues[index][i] = uniformValue[i];
        }
    }
    else {
        cutout.uniformValues[index] = uniformValue;
    }
};

/**
 * Edits the options field on a mesh
 *
 * @method
 * @param {String} path Path used as id of target mesh
 * @param {Object} options Map of draw options for mesh
 *
 * @return {undefined} undefined
**/
WebGLRenderer.prototype.setMeshOptions = function(path, options) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    mesh.options = options;
    return this;
};

/**
 * Changes the color of the fixed intensity lighting in the scene
 *
 * @method
 *
 * @param {String} path Path used as id of light
 * @param {Number} r red channel
 * @param {Number} g green channel
 * @param {Number} b blue channel
 *
 * @return {undefined} undefined
**/
WebGLRenderer.prototype.setAmbientLightColor = function setAmbientLightColor(path, r, g, b) {
    this.ambientLightColor[0] = r;
    this.ambientLightColor[1] = g;
    this.ambientLightColor[2] = b;
    return this;
};

/**
 * Changes the location of the light in the scene
 *
 * @method
 *
 * @param {String} path Path used as id of light
 * @param {Number} x x position
 * @param {Number} y y position
 * @param {Number} z z position
 *
 * @return {undefined} undefined
**/
WebGLRenderer.prototype.setLightPosition = function setLightPosition(path, x, y, z) {
    var light = this.lightRegistry[path] || this.createLight(path);

    light.position[0] = x;
    light.position[1] = y;
    light.position[2] = z;
    return this;
};

/**
 * Changes the color of a dynamic intensity lighting in the scene
 *
 * @method
 *
 * @param {String} path Path used as id of light in light Registry.
 * @param {Number} r red channel
 * @param {Number} g green channel
 * @param {Number} b blue channel
 *
 * @return {undefined} undefined
**/
WebGLRenderer.prototype.setLightColor = function setLightColor(path, r, g, b) {
    var light = this.lightRegistry[path] || this.createLight(path);

    light.color[0] = r;
    light.color[1] = g;
    light.color[2] = b;
    return this;
};

/**
 * Compiles material spec into program shader
 *
 * @method
 *
 * @param {String} path Path used as id of cutout in cutout registry.
 * @param {String} name Name that the rendering input the material is bound to
 * @param {Object} material Material spec
 *
 * @return {undefined} undefined
**/
WebGLRenderer.prototype.handleMaterialInput = function handleMaterialInput(path, name, material) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);
    material = compileMaterial(material, mesh.textures.length);

    // Set uniforms to enable texture!

    mesh.uniformValues[mesh.uniformKeys.indexOf(name)][0] = -material._id;

    // Register textures!

    var i = material.textures.length;
    while (i--) {
        mesh.textures.push(
            this.textureManager.register(material.textures[i], mesh.textures.length + i)
        );
    }

    // Register material!

    this.program.registerMaterial(name, material);

    return this.updateSize();
};

/**
 * Changes the geometry data of a mesh
 *
 * @method
 *
 * @param {String} path Path used as id of cutout in cutout registry.
 * @param {Object} geometry Geometry object containing vertex data to be drawn
 * @param {Number} drawType Primitive identifier
 * @param {Boolean} dynamic Whether geometry is dynamic
 *
 * @return {undefined} undefined
**/
WebGLRenderer.prototype.setGeometry = function setGeometry(path, geometry, drawType, dynamic) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    mesh.geometry = geometry;
    mesh.drawType = drawType;
    mesh.dynamic = dynamic;

    return this;
};

/**
 * Uploads a new value for the uniform data when the mesh is being drawn
 *
 * @method
 *
 * @param {String} path Path used as id of mesh in mesh registry
 * @param {String} uniformName Identifier used to upload value
 * @param {Array} uniformValue Value of uniform data
 *
 * @return {undefined} undefined
**/
WebGLRenderer.prototype.setMeshUniform = function setMeshUniform(path, uniformName, uniformValue) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    var index = mesh.uniformKeys.indexOf(uniformName);

    if (index === -1) {
        mesh.uniformKeys.push(uniformName);
        mesh.uniformValues.push(uniformValue);
    }
    else {
        mesh.uniformValues[index] = uniformValue;
    }
};

/**
 * Triggers the 'draw' phase of the WebGLRenderer. Iterates through registries
 * to set uniforms, set attributes and issue draw commands for renderables.
 *
 * @method
 *
 * @param {String} path Path used as id of mesh in mesh registry
 * @param {Number} geometryId Id of geometry in geometry registry
 * @param {String} bufferName Attribute location name
 * @param {Array} bufferValue Vertex data
 * @param {Number} bufferSpacing The dimensions of the vertex
 * @param {Boolean} isDynamic Whether geometry is dynamic
 *
 * @return {undefined} undefined
 */
WebGLRenderer.prototype.bufferData = function bufferData(path, geometryId, bufferName, bufferValue, bufferSpacing, isDynamic) {
    this.bufferRegistry.allocate(geometryId, bufferName, bufferValue, bufferSpacing, isDynamic);

    return this;
};

/**
 * Triggers the 'draw' phase of the WebGLRenderer. Iterates through registries
 * to set uniforms, set attributes and issue draw commands for renderables.
 *
 * @method
 *
 * @param {Object} renderState Parameters provided by the compositor, that affect the rendering of all renderables.
 *
 * @return {undefined} undefined
 */
WebGLRenderer.prototype.draw = function draw(renderState) {
    var time = this.compositor.getTime();

    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    this.textureManager.update(time);

    this.meshRegistryKeys = sorter(this.meshRegistryKeys, this.meshRegistry);

    this.setGlobalUniforms(renderState);
    this.drawCutouts();
    this.drawMeshes();
};

/**
 * Iterates through and draws all registered meshes. This includes
 * binding textures, handling draw options, setting mesh uniforms
 * and drawing mesh buffers.
 *
 * @method
 *
 * @return {undefined} undefined
 */
WebGLRenderer.prototype.drawMeshes = function drawMeshes() {
    var gl = this.gl;
    var buffers;
    var mesh;

    for(var i = 0; i < this.meshRegistryKeys.length; i++) {
        mesh = this.meshRegistry[this.meshRegistryKeys[i]];
        buffers = this.bufferRegistry.registry[mesh.geometry];

        if (!mesh.visible) continue;

        if (mesh.uniformValues[0] < 1) {
            gl.depthMask(false);
            gl.enable(gl.BLEND);
        }
        else {
            gl.depthMask(true);
            gl.disable(gl.BLEND);
        }

        if (!buffers) continue;

        var j = mesh.textures.length;
        while (j--) this.textureManager.bindTexture(mesh.textures[j]);

        if (mesh.options) this.handleOptions(mesh.options, mesh);

        this.program.setUniforms(mesh.uniformKeys, mesh.uniformValues);
        this.drawBuffers(buffers, mesh.drawType, mesh.geometry);

        if (mesh.options) this.resetOptions(mesh.options);
    }
};

/**
 * Iterates through and draws all registered cutout meshes. Blending
 * is disabled, cutout uniforms are set and finally buffers are drawn.
 *
 * @method
 *
 * @return {undefined} undefined
 */
WebGLRenderer.prototype.drawCutouts = function drawCutouts() {
    var cutout;
    var buffers;
    var len = this.cutoutRegistryKeys.length;

    if (!len) return;

    this.gl.disable(this.gl.CULL_FACE);
    this.gl.enable(this.gl.BLEND);
    this.gl.depthMask(true);

    for (var i = 0; i < len; i++) {
        cutout = this.cutoutRegistry[this.cutoutRegistryKeys[i]];
        buffers = this.bufferRegistry.registry[cutout.geometry];

        if (!cutout.visible) continue;

        this.program.setUniforms(cutout.uniformKeys, cutout.uniformValues);
        this.drawBuffers(buffers, cutout.drawType, cutout.geometry);
    }

    this.gl.enable(this.gl.CULL_FACE);
};

/**
 * Sets uniforms to be shared by all meshes.
 *
 * @method
 *
 * @param {Object} renderState Draw state options passed down from compositor.
 *
 * @return {undefined} undefined
 */
WebGLRenderer.prototype.setGlobalUniforms = function setGlobalUniforms(renderState) {
    var light;
    var stride;

    for (var i = 0, len = this.lightRegistryKeys.length; i < len; i++) {
        light = this.lightRegistry[this.lightRegistryKeys[i]];
        stride = i * 4;

        // Build the light positions' 4x4 matrix

        this.lightPositions[0 + stride] = light.position[0];
        this.lightPositions[1 + stride] = light.position[1];
        this.lightPositions[2 + stride] = light.position[2];

        // Build the light colors' 4x4 matrix

        this.lightColors[0 + stride] = light.color[0];
        this.lightColors[1 + stride] = light.color[1];
        this.lightColors[2 + stride] = light.color[2];
    }

    globalUniforms.values[0] = this.numLights;
    globalUniforms.values[1] = this.ambientLightColor;
    globalUniforms.values[2] = this.lightPositions;
    globalUniforms.values[3] = this.lightColors;

    /*
     * Set time and projection uniforms
     * projecting world space into a 2d plane representation of the canvas.
     * The x and y scale (this.projectionTransform[0] and this.projectionTransform[5] respectively)
     * convert the projected geometry back into clipspace.
     * The perpective divide (this.projectionTransform[11]), adds the z value of the point
     * multiplied by the perspective divide to the w value of the point. In the process
     * of converting from homogenous coordinates to NDC (normalized device coordinates)
     * the x and y values of the point are divided by w, which implements perspective.
     */
    this.projectionTransform[0] = 1 / (this.cachedSize[0] * 0.5);
    this.projectionTransform[5] = -1 / (this.cachedSize[1] * 0.5);
    this.projectionTransform[11] = renderState.perspectiveTransform[11];

    globalUniforms.values[4] = this.projectionTransform;
    globalUniforms.values[5] = this.compositor.getTime() * 0.001;
    globalUniforms.values[6] = renderState.viewTransform;

    this.program.setUniforms(globalUniforms.keys, globalUniforms.values);
};

/**
 * Loads the buffers and issues the draw command for a geometry.
 *
 * @method
 *
 * @param {Object} vertexBuffers All buffers used to draw the geometry.
 * @param {Number} mode Enumerator defining what primitive to draw
 * @param {Number} id ID of geometry being drawn.
 *
 * @return {undefined} undefined
 */
WebGLRenderer.prototype.drawBuffers = function drawBuffers(vertexBuffers, mode, id) {
    var gl = this.gl;
    var length = 0;
    var attribute;
    var location;
    var spacing;
    var offset;
    var buffer;
    var iter;
    var j;
    var i;

    iter = vertexBuffers.keys.length;
    for (i = 0; i < iter; i++) {
        attribute = vertexBuffers.keys[i];

        // Do not set vertexAttribPointer if index buffer.

        if (attribute === 'indices') {
            j = i; continue;
        }

        // Retreive the attribute location and make sure it is enabled.

        location = this.program.attributeLocations[attribute];

        if (location === -1) continue;
        if (location === undefined) {
            location = gl.getAttribLocation(this.program.program, attribute);
            this.program.attributeLocations[attribute] = location;
            if (location === -1) continue;
        }

        if (!this.state.enabledAttributes[attribute]) {
            gl.enableVertexAttribArray(location);
            this.state.enabledAttributes[attribute] = true;
            this.state.enabledAttributesKeys.push(attribute);
        }

        // Retreive buffer information used to set attribute pointer.

        buffer = vertexBuffers.values[i];
        spacing = vertexBuffers.spacing[i];
        offset = vertexBuffers.offset[i];
        length = vertexBuffers.length[i];

        // Skip bindBuffer if buffer is currently bound.

        if (this.state.boundArrayBuffer !== buffer) {
            gl.bindBuffer(buffer.target, buffer.buffer);
            this.state.boundArrayBuffer = buffer;
        }

        if (this.state.lastDrawn !== id) {
            gl.vertexAttribPointer(location, spacing, gl.FLOAT, gl.FALSE, 0, 4 * offset);
        }
    }

    // Disable any attributes that not currently being used.

    var len = this.state.enabledAttributesKeys.length;
    for (i = 0; i < len; i++) {
        var key = this.state.enabledAttributesKeys[i];
        if (this.state.enabledAttributes[key] && vertexBuffers.keys.indexOf(key) === -1) {
            gl.disableVertexAttribArray(this.program.attributeLocations[key]);
            this.state.enabledAttributes[key] = false;
        }
    }

    if (length) {

        // If index buffer, use drawElements.

        if (j !== undefined) {
            buffer = vertexBuffers.values[j];
            offset = vertexBuffers.offset[j];
            spacing = vertexBuffers.spacing[j];
            length = vertexBuffers.length[j];

            // Skip bindBuffer if buffer is currently bound.

            if (this.state.boundElementBuffer !== buffer) {
                gl.bindBuffer(buffer.target, buffer.buffer);
                this.state.boundElementBuffer = buffer;
            }

            gl.drawElements(gl[mode], length, gl.UNSIGNED_SHORT, 2 * offset);
        }
        else {
            gl.drawArrays(gl[mode], 0, length);
        }
    }

    this.state.lastDrawn = id;
};


/**
 * Updates the width and height of parent canvas, sets the viewport size on
 * the WebGL context and updates the resolution uniform for the shader program.
 * Size is retreived from the container object of the renderer.
 *
 * @method
 *
 * @param {Array} size width, height and depth of canvas
 *
 * @return {undefined} undefined
 */
WebGLRenderer.prototype.updateSize = function updateSize(size) {
    if (size) {
        var pixelRatio = window.devicePixelRatio || 1;
        var displayWidth = ~~(size[0] * pixelRatio);
        var displayHeight = ~~(size[1] * pixelRatio);
        this.canvas.width = displayWidth;
        this.canvas.height = displayHeight;
        this.gl.viewport(0, 0, displayWidth, displayHeight);

        this.cachedSize[0] = size[0];
        this.cachedSize[1] = size[1];
        this.cachedSize[2] = (size[0] > size[1]) ? size[0] : size[1];
        this.resolutionValues[0] = this.cachedSize;
    }

    this.program.setUniforms(this.resolutionName, this.resolutionValues);

    return this;
};

/**
 * Updates the state of the WebGL drawing context based on custom parameters
 * defined on a mesh.
 *
 * @method
 *
 * @param {Object} options Draw state options to be set to the context.
 * @param {Mesh} mesh Associated Mesh
 *
 * @return {undefined} undefined
 */
WebGLRenderer.prototype.handleOptions = function handleOptions(options, mesh) {
    var gl = this.gl;
    if (!options) return;

    if (options.blending) gl.enable(gl.BLEND);

    if (options.side === 'double') {
        this.gl.cullFace(this.gl.FRONT);
        this.drawBuffers(this.bufferRegistry.registry[mesh.geometry], mesh.drawType, mesh.geometry);
        this.gl.cullFace(this.gl.BACK);
    }

    if (options.side === 'back') gl.cullFace(gl.FRONT);
};

/**
 * Resets the state of the WebGL drawing context to default values.
 *
 * @method
 *
 * @param {Object} options Draw state options to be set to the context.
 *
 * @return {undefined} undefined
 */
WebGLRenderer.prototype.resetOptions = function resetOptions(options) {
    var gl = this.gl;
    if (!options) return;
    if (options.blending) gl.disable(gl.BLEND);
    if (options.side === 'back') gl.cullFace(gl.BACK);
};

module.exports = WebGLRenderer;

},{"../utilities/keyValueToArrays":44,"./BufferRegistry":47,"./Program":49,"./TextureManager":51,"./compileMaterial":53,"./radixSort":55}],53:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
'use strict';

var types = {
    1: 'float ',
    2: 'vec2 ',
    3: 'vec3 ',
    4: 'vec4 '
};

/**
 * Traverses material to create a string of glsl code to be applied in
 * the vertex or fragment shader.
 *
 * @method
 * @protected
 *
 * @param {Object} material Material to be compiled.
 * @param {Number} textureSlot Next available texture slot for Mesh.
 *
 * @return {undefined} undefined
 */
function compileMaterial(material, textureSlot) {
    var glsl = '';
    var uniforms = {};
    var varyings = {};
    var attributes = {};
    var defines = [];
    var textures = [];

    _traverse(material, function (node, depth) {
        if (! node.chunk) return;

        var type = types[_getOutputLength(node)];
        var label = _makeLabel(node);
        var output = _processGLSL(node.chunk.glsl, node.inputs, textures.length + textureSlot);

        glsl += type + label + ' = ' + output + '\n ';

        if (node.uniforms) _extend(uniforms, node.uniforms);
        if (node.varyings) _extend(varyings, node.varyings);
        if (node.attributes) _extend(attributes, node.attributes);
        if (node.chunk.defines) defines.push(node.chunk.defines);
        if (node.texture) textures.push(node.texture);
    });

    return {
        _id: material._id,
        glsl: glsl + 'return ' + _makeLabel(material) + ';',
        defines: defines.join('\n'),
        uniforms: uniforms,
        varyings: varyings,
        attributes: attributes,
        textures: textures
    };
}

// Recursively iterates over a material's inputs, invoking a given callback
// with the current material
function _traverse(material, callback) {
	var inputs = material.inputs;
    var len = inputs && inputs.length;
    var idx = -1;

    while (++idx < len) _traverse(inputs[idx], callback);

    callback(material);

    return material;
}

// Helper function used to infer length of the output
// from a given material node.
function _getOutputLength(node) {

    // Handle constant values

    if (typeof node === 'number') return 1;
    if (Array.isArray(node)) return node.length;

    // Handle materials

    var output = node.chunk.output;
    if (typeof output === 'number') return output;

    // Handle polymorphic output

    var key = node.inputs.map(function recurse(node) {
        return _getOutputLength(node);
    }).join(',');

    return output[key];
}

// Helper function to run replace inputs and texture tags with
// correct glsl.
function _processGLSL(str, inputs, textureSlot) {
    return str
        .replace(/%\d/g, function (s) {
            return _makeLabel(inputs[s[1]-1]);
        })
        .replace(/\$TEXTURE/, 'u_textures[' + textureSlot + ']');
}

// Helper function used to create glsl definition of the
// input material node.
function _makeLabel (n) {
    if (Array.isArray(n)) return _arrayToVec(n);
    if (typeof n === 'object') return 'fa_' + (n._id);
    else return n.toFixed(6);
}

// Helper to copy the properties of an object onto another object.
function _extend (a, b) {
	for (var k in b) a[k] = b[k];
}

// Helper to create glsl vector representation of a javascript array.
function _arrayToVec(array) {
    var len = array.length;
    return 'vec' + len + '(' + array.join(',')  + ')';
}

module.exports = compileMaterial;

},{}],54:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

// Generates a checkerboard pattern to be used as a placeholder texture while an
// image loads over the network.
function createCheckerBoard() {
    var context = document.createElement('canvas').getContext('2d');
    context.canvas.width = context.canvas.height = 128;
    for (var y = 0; y < context.canvas.height; y += 16) {
        for (var x = 0; x < context.canvas.width; x += 16) {
            context.fillStyle = (x ^ y) & 16 ? '#FFF' : '#DDD';
            context.fillRect(x, y, 16, 16);
        }
    }

    return context.canvas;
}

module.exports = createCheckerBoard;

},{}],55:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
'use strict';

var radixBits = 11,
    maxRadix = 1 << (radixBits),
    radixMask = maxRadix - 1,
    buckets = new Array(maxRadix * Math.ceil(64 / radixBits)),
    msbMask = 1 << ((32 - 1) % radixBits),
    lastMask = (msbMask << 1) - 1,
    passCount = ((32 / radixBits) + 0.999999999999999) | 0,
    maxOffset = maxRadix * (passCount - 1),
    normalizer = Math.pow(20, 6);

var buffer = new ArrayBuffer(4);
var floatView = new Float32Array(buffer, 0, 1);
var intView = new Int32Array(buffer, 0, 1);

// comparator pulls relevant sorting keys out of mesh
function comp(list, registry, i) {
    var key = list[i];
    var item = registry[key];
    return (item.depth ? item.depth : registry[key].uniformValues[1][14]) + normalizer;
}

//mutator function records mesh's place in previous pass
function mutator(list, registry, i, value) {
    var key = list[i];
    registry[key].depth = intToFloat(value) - normalizer;
    return key;
}

//clean function removes mutator function's record
function clean(list, registry, i) {
    registry[list[i]].depth = null;
}

//converts a javascript float to a 32bit integer using an array buffer
//of size one
function floatToInt(k) {
    floatView[0] = k;
    return intView[0];
}
//converts a 32 bit integer to a regular javascript float using an array buffer
//of size one
function intToFloat(k) {
    intView[0] = k;
    return floatView[0];
}

//sorts a list of mesh IDs according to their z-depth
function radixSort(list, registry) {
    var pass = 0;
    var out = [];

    var i, j, k, n, div, offset, swap, id, sum, tsum, size;

    passCount = ((32 / radixBits) + 0.999999999999999) | 0;

    for (i = 0, n = maxRadix * passCount; i < n; i++) buckets[i] = 0;

    for (i = 0, n = list.length; i < n; i++) {
        div = floatToInt(comp(list, registry, i));
        div ^= div >> 31 | 0x80000000;
        for (j = 0, k = 0; j < maxOffset; j += maxRadix, k += radixBits) {
            buckets[j + (div >>> k & radixMask)]++;
        }
        buckets[j + (div >>> k & lastMask)]++;
    }

    for (j = 0; j <= maxOffset; j += maxRadix) {
        for (id = j, sum = 0; id < j + maxRadix; id++) {
            tsum = buckets[id] + sum;
            buckets[id] = sum - 1;
            sum = tsum;
        }
    }
    if (--passCount) {
        for (i = 0, n = list.length; i < n; i++) {
            div = floatToInt(comp(list, registry, i));
            out[++buckets[div & radixMask]] = mutator(list, registry, i, div ^= div >> 31 | 0x80000000);
        }
        
        swap = out;
        out = list;
        list = swap;
        while (++pass < passCount) {
            for (i = 0, n = list.length, offset = pass * maxRadix, size = pass * radixBits; i < n; i++) {
                div = floatToInt(comp(list, registry, i));
                out[++buckets[offset + (div >>> size & radixMask)]] = list[i];
            }

            swap = out;
            out = list;
            list = swap;
        }
    }

    for (i = 0, n = list.length, offset = pass * maxRadix, size = pass * radixBits; i < n; i++) {
        div = floatToInt(comp(list, registry, i));
        out[++buckets[offset + (div >>> size & lastMask)]] = mutator(list, registry, i, div ^ (~div >> 31 | 0x80000000));
        clean(list, registry, i);
    }

    return out;
}

module.exports = radixSort;

},{}],56:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';



var shaders = {
    vertex: "#define GLSLIFY 1\n/**\n * The MIT License (MIT)\n * \n * Copyright (c) 2015 Famous Industries Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * The MIT License (MIT)\n * \n * Copyright (c) 2015 Famous Industries Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Calculates transpose inverse matrix from transform\n * \n * @method random\n * @private\n *\n *\n */\n\n\nmat3 getNormalMatrix_1_0(in mat4 t) {\n   mat3 matNorm;\n   mat4 a = t;\n\n   float a00 = a[0][0], a01 = a[0][1], a02 = a[0][2], a03 = a[0][3],\n   a10 = a[1][0], a11 = a[1][1], a12 = a[1][2], a13 = a[1][3],\n   a20 = a[2][0], a21 = a[2][1], a22 = a[2][2], a23 = a[2][3],\n   a30 = a[3][0], a31 = a[3][1], a32 = a[3][2], a33 = a[3][3],\n   b00 = a00 * a11 - a01 * a10,\n   b01 = a00 * a12 - a02 * a10,\n   b02 = a00 * a13 - a03 * a10,\n   b03 = a01 * a12 - a02 * a11,\n   b04 = a01 * a13 - a03 * a11,\n   b05 = a02 * a13 - a03 * a12,\n   b06 = a20 * a31 - a21 * a30,\n   b07 = a20 * a32 - a22 * a30,\n   b08 = a20 * a33 - a23 * a30,\n   b09 = a21 * a32 - a22 * a31,\n   b10 = a21 * a33 - a23 * a31,\n   b11 = a22 * a33 - a23 * a32,\n\n   det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n   det = 1.0 / det;\n\n   matNorm[0][0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n   matNorm[0][1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n   matNorm[0][2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n   matNorm[1][0] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n   matNorm[1][1] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n   matNorm[1][2] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n   matNorm[2][0] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n   matNorm[2][1] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n   matNorm[2][2] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n   return matNorm;\n}\n\n\n\n/**\n * The MIT License (MIT)\n * \n * Copyright (c) 2015 Famous Industries Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Calculates a matrix that creates the identity when multiplied by m\n * \n * @method inverse\n * @private\n *\n *\n */\n\n\nfloat inverse_2_1(float m) {\n    return 1.0 / m;\n}\n\nmat2 inverse_2_1(mat2 m) {\n    return mat2(m[1][1],-m[0][1],\n               -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse_2_1(mat3 m) {\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n    float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n    float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n    float b01 =  a22 * a11 - a12 * a21;\n    float b11 = -a22 * a10 + a12 * a20;\n    float b21 =  a21 * a10 - a11 * a20;\n\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n                b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n                b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse_2_1(mat4 m) {\n    float\n        a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n        a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n        a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n        a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32,\n\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    return mat4(\n        a11 * b11 - a12 * b10 + a13 * b09,\n        a02 * b10 - a01 * b11 - a03 * b09,\n        a31 * b05 - a32 * b04 + a33 * b03,\n        a22 * b04 - a21 * b05 - a23 * b03,\n        a12 * b08 - a10 * b11 - a13 * b07,\n        a00 * b11 - a02 * b08 + a03 * b07,\n        a32 * b02 - a30 * b05 - a33 * b01,\n        a20 * b05 - a22 * b02 + a23 * b01,\n        a10 * b10 - a11 * b08 + a13 * b06,\n        a01 * b08 - a00 * b10 - a03 * b06,\n        a30 * b04 - a31 * b02 + a33 * b00,\n        a21 * b02 - a20 * b04 - a23 * b00,\n        a11 * b07 - a10 * b09 - a12 * b06,\n        a00 * b09 - a01 * b07 + a02 * b06,\n        a31 * b01 - a30 * b03 - a32 * b00,\n        a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\n\n/**\n * The MIT License (MIT)\n * \n * Copyright (c) 2015 Famous Industries Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Reflects a matrix over its main diagonal.\n * \n * @method transpose\n * @private\n *\n *\n */\n\n\nfloat transpose_3_2(float m) {\n    return m;\n}\n\nmat2 transpose_3_2(mat2 m) {\n    return mat2(m[0][0], m[1][0],\n                m[0][1], m[1][1]);\n}\n\nmat3 transpose_3_2(mat3 m) {\n    return mat3(m[0][0], m[1][0], m[2][0],\n                m[0][1], m[1][1], m[2][1],\n                m[0][2], m[1][2], m[2][2]);\n}\n\nmat4 transpose_3_2(mat4 m) {\n    return mat4(m[0][0], m[1][0], m[2][0], m[3][0],\n                m[0][1], m[1][1], m[2][1], m[3][1],\n                m[0][2], m[1][2], m[2][2], m[3][2],\n                m[0][3], m[1][3], m[2][3], m[3][3]);\n}\n\n\n\n\n/**\n * Converts vertex from modelspace to screenspace using transform\n * information from context.\n *\n * @method applyTransform\n * @private\n *\n *\n */\n\nvec4 applyTransform(vec4 pos) {\n    //TODO: move this multiplication to application code. \n\n    /**\n     * Currently multiplied in the vertex shader to avoid consuming the complexity of holding an additional\n     * transform as state on the mesh object in WebGLRenderer. Multiplies the object's transformation from object space\n     * to world space with its transformation from world space to eye space.\n     */\n    mat4 MVMatrix = u_view * u_transform;\n\n    //TODO: move the origin, sizeScale and y axis inversion to application code in order to amortize redundant per-vertex calculations.\n\n    /**\n     * The transform uniform should be changed to the result of the transformation chain:\n     *\n     * view * modelTransform * invertYAxis * sizeScale * origin\n     *\n     * which could be simplified to:\n     *\n     * view * modelTransform * convertToDOMSpace\n     *\n     * where convertToDOMSpace represents the transform matrix:\n     *\n     *                           size.x 0       0       size.x \n     *                           0      -size.y 0       size.y\n     *                           0      0       1       0\n     *                           0      0       0       1\n     *\n     */\n\n    /**\n     * Assuming a unit volume, moves the object space origin [0, 0, 0] to the \"top left\" [1, -1, 0], the DOM space origin.\n     * Later in the transformation chain, the projection transform negates the rigidbody translation.\n     * Equivalent to (but much faster than) multiplying a translation matrix \"origin\"\n     *\n     *                           1 0 0 1 \n     *                           0 1 0 -1\n     *                           0 0 1 0\n     *                           0 0 0 1\n     *\n     * in the transform chain: projection * view * modelTransform * invertYAxis * sizeScale * origin * positionVector.\n     */\n    pos.x += 1.0;\n    pos.y -= 1.0;\n\n    /**\n     * Assuming a unit volume, scales an object to the amount of pixels in the size uniform vector's specified dimensions.\n     * Later in the transformation chain, the projection transform transforms the point into clip space by scaling\n     * by the inverse of the canvas' resolution.\n     * Equivalent to (but much faster than) multiplying a scale matrix \"sizeScale\"\n     *\n     *                           size.x 0      0      0 \n     *                           0      size.y 0      0\n     *                           0      0      size.z 0\n     *                           0      0      0      1\n     *\n     * in the transform chain: projection * view * modelTransform * invertYAxis * sizeScale * origin * positionVector.\n     */\n    pos.xyz *= u_size * 0.5;\n\n    /**\n     * Inverts the object space's y axis in order to match DOM space conventions. \n     * Later in the transformation chain, the projection transform reinverts the y axis to convert to clip space.\n     * Equivalent to (but much faster than) multiplying a scale matrix \"invertYAxis\"\n     *\n     *                           1 0 0 0 \n     *                           0 -1 0 0\n     *                           0 0 1 0\n     *                           0 0 0 1\n     *\n     * in the transform chain: projection * view * modelTransform * invertYAxis * sizeScale * origin * positionVector.\n     */\n    pos.y *= -1.0;\n\n    /**\n     * Exporting the vertex's position as a varying, in DOM space, to be used for lighting calculations. This has to be in DOM space\n     * since light position and direction is derived from the scene graph, calculated in DOM space.\n     */\n\n    v_position = (MVMatrix * pos).xyz;\n\n    /**\n    * Exporting the eye vector (a vector from the center of the screen) as a varying, to be used for lighting calculations.\n    * In clip space deriving the eye vector is a matter of simply taking the inverse of the position, as the position is a vector\n    * from the center of the screen. However, since our points are represented in DOM space,\n    * the position is a vector from the top left corner of the screen, so some additional math is needed (specifically, subtracting\n    * the position from the center of the screen, i.e. half the resolution of the canvas).\n    */\n\n    v_eyeVector = (u_resolution * 0.5) - v_position;\n\n    /**\n     * Transforming the position (currently represented in dom space) into view space (with our dom space view transform)\n     * and then projecting the point into raster both by applying a perspective transformation and converting to clip space\n     * (the perspective matrix is a combination of both transformations, therefore it's probably more apt to refer to it as a\n     * projection transform).\n     */\n\n    pos = u_perspective * MVMatrix * pos;\n\n    return pos;\n}\n\n/**\n * Placeholder for positionOffset chunks to be templated in.\n * Used for mesh deformation.\n *\n * @method calculateOffset\n * @private\n *\n *\n */\n#vert_definitions\nvec3 calculateOffset(vec3 ID) {\n    #vert_applications\n    return vec3(0.0);\n}\n\n/**\n * Writes the position of the vertex onto the screen.\n * Passes texture coordinate and normal attributes as varyings\n * and passes the position attribute through position pipeline.\n *\n * @method main\n * @private\n *\n *\n */\nvoid main() {\n    v_textureCoordinate = a_texCoord;\n    vec3 invertedNormals = a_normals + (u_normals.x < 0.0 ? calculateOffset(u_normals) * 2.0 - 1.0 : vec3(0.0));\n    invertedNormals.y *= -1.0;\n    v_normal = transpose_3_2(mat3(inverse_2_1(u_transform))) * invertedNormals;\n    vec3 offsetPos = a_pos + calculateOffset(u_positionOffset);\n    gl_Position = applyTransform(vec4(offsetPos, 1.0));\n}\n",
    fragment: "#define GLSLIFY 1\n/**\n * The MIT License (MIT)\n * \n * Copyright (c) 2015 Famous Industries Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * The MIT License (MIT)\n * \n * Copyright (c) 2015 Famous Industries Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Placeholder for fragmentShader  chunks to be templated in.\n * Used for normal mapping, gloss mapping and colors.\n * \n * @method applyMaterial\n * @private\n *\n *\n */\n\n#float_definitions\nfloat applyMaterial_1_0(float ID) {\n    #float_applications\n    return 1.;\n}\n\n#vec3_definitions\nvec3 applyMaterial_1_0(vec3 ID) {\n    #vec3_applications\n    return vec3(0);\n}\n\n#vec4_definitions\nvec4 applyMaterial_1_0(vec4 ID) {\n    #vec4_applications\n\n    return vec4(0);\n}\n\n\n\n/**\n * The MIT License (MIT)\n * \n * Copyright (c) 2015 Famous Industries Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Calculates the intensity of light on a surface.\n *\n * @method applyLight\n * @private\n *\n */\nvec4 applyLight_2_1(in vec4 baseColor, in vec3 normal, in vec4 glossiness, int numLights, vec3 ambientColor, vec3 eyeVector, mat4 lightPosition, mat4 lightColor, vec3 v_position) {\n    vec3 diffuse = vec3(0.0);\n    bool hasGlossiness = glossiness.a > 0.0;\n    bool hasSpecularColor = length(glossiness.rgb) > 0.0;\n\n    for(int i = 0; i < 4; i++) {\n        if (i >= numLights) break;\n        vec3 lightDirection = normalize(lightPosition[i].xyz - v_position);\n        float lambertian = max(dot(lightDirection, normal), 0.0);\n\n        if (lambertian > 0.0) {\n            diffuse += lightColor[i].rgb * baseColor.rgb * lambertian;\n            if (hasGlossiness) {\n                vec3 halfVector = normalize(lightDirection + eyeVector);\n                float specularWeight = pow(max(dot(halfVector, normal), 0.0), glossiness.a);\n                vec3 specularColor = hasSpecularColor ? glossiness.rgb : lightColor[i].rgb;\n                diffuse += specularColor * specularWeight * lambertian;\n            }\n        }\n\n    }\n\n    return vec4(ambientColor + diffuse, baseColor.a);\n}\n\n\n\n\n\n/**\n * Writes the color of the pixel onto the screen\n *\n * @method main\n * @private\n *\n *\n */\nvoid main() {\n    vec4 material = u_baseColor.r >= 0.0 ? u_baseColor : applyMaterial_1_0(u_baseColor);\n\n    /**\n     * Apply lights only if flat shading is false\n     * and at least one light is added to the scene\n     */\n    bool lightsEnabled = (u_flatShading == 0.0) && (u_numLights > 0.0 || length(u_ambientLight) > 0.0);\n\n    vec3 normal = normalize(v_normal);\n    vec4 glossiness = u_glossiness.x < 0.0 ? applyMaterial_1_0(u_glossiness) : u_glossiness;\n\n    vec4 color = lightsEnabled ?\n    applyLight_2_1(material, normalize(v_normal), glossiness,\n               int(u_numLights),\n               u_ambientLight * u_baseColor.rgb,\n               normalize(v_eyeVector),\n               u_lightPosition,\n               u_lightColor,   \n               v_position)\n    : material;\n\n    gl_FragColor = color;\n    gl_FragColor.a *= u_opacity;   \n}\n"
};

module.exports = shaders;

},{}],57:[function(require,module,exports){
module.exports={
   sections: [{
       id: 'Home',
       tweetNumber: 50
   }, {
       id: 'Discover',
       tweetNumber: 50
   }, {
       id: 'Connect',
       tweetNumber: 50
   }, {
       id: 'Me',
       tweetNumber: 25
   }],

    usernames: ['@LouieBlooRaspberry','@PonchoPunch','@SirIsaacLime','@StrawberryShortKook','@AlexandertheGrape', '@LittleOrphanOrange'],
    begin: ['Walk towards ', 'Jump on ' ,'Sing to ', 'Dance with ', 'Stare down ', 'Pick up ', 'Hold hands with ', 'Walk around ', 'Shake hands with ', 'Talk to ', 'Point at ', 'Read to ', 'High five ', 'Wave to ' ],
    middle: ['a duck ', 'some fish ', 'a zebra ', 'nine honey badgers ', 'an old gorilla ', 'a ham sandwich ', 'a peanut ', 'Nicolas Cage ', 'a sock ', 'a pillow ', '12 fish ','a potato ', 'your neighbor ', 'a snail '],
    end: ['quickly','and don\'t look back','without shoes', 'and clap your hands', 'and pat your belly', 'and do a jig', 'tomorrow', 'while eating ice cream', 'in the dark', 'at the park', 'with a friend', 'down by the bay', 'in the car', 'and yell'],
    hashtags: ['#harrystyles', '#live', '#boredom', '#mylife', '#hiphop', '#texas', '#november', '#scary', '#best',' #snowman', '#shuffle', '#squats', '#selfie' ]


};


},{}],58:[function(require,module,exports){
'use strict';

var data = require('./Data');
var NavButton = require('./NavButton');
var Node = require('famous/core/Node');

// the number of sections in the app
var numSections = data.sections.length;

// the footer will hold the nav buttons
function Footer() {
    // subclass Node
    Node.call(this);

    // object to store the buttons
    this.buttons = {};

    // for every section create a NavButton
    // and set its size and align
    data.sections.forEach((function (section, i) {
        this.buttons[section.id] = this.addChild(new NavButton(section.id)).setProportionalSize(1 / numSections).setAlign(i / numSections);
    }).bind(this));
}

// subclass Node
Footer.prototype = Object.create(Node.prototype);

module.exports = Footer;

},{"./Data":57,"./NavButton":60,"famous/core/Node":10}],59:[function(require,module,exports){
'use strict';

var Node = require('famous/core/Node');
var DOMElement = require('famous/dom-renderables/DOMElement');
var Align = require('famous/components/Align');

function Header() {
    Node.call(this);
    this.el = new DOMElement(this, {
        classes: ['header']
    });

    this.title = this.addChild();
    this.titleEl = new DOMElement(this.title).setProperty('textAlign', 'center').setProperty('lineHeight', '100px').setProperty('fontSize', '30px');

    this.titleAlign = new Align(this.title);
}

Header.prototype = Object.create(Node.prototype);

Header.prototype.onReceive = function onReceive(event, payload) {
    if (event === 'changeSection') this.changeSection(payload.to);
};

Header.prototype.changeSection = function changeSection(to) {
    // -1 in Y will put the title directly above its parent
    this.titleAlign.set(0, -1, 0, { duration: 250 }, (function () {
        // while the title is offscreen
        // change the content
        this.titleEl.setContent(to);

        // align 0, 0, 0 places the title back into its parent
        // exactly
        this.titleAlign.set(0, 0, 0, { duration: 250 });
    }).bind(this));
};

module.exports = Header;

},{"famous/components/Align":1,"famous/core/Node":10,"famous/dom-renderables/DOMElement":18}],60:[function(require,module,exports){
'use strict';

var Node = require('famous/core/Node');
var DOMElement = require('famous/dom-renderables/DOMElement');

// The nav button class will show the name of a section
// and emit a click event when clicked
function NavButton(id, status) {
    // Subclass node
    Node.call(this);

    // make and style an element
    this.el = makeEl(this);

    // hold the id of the section
    // this NavButton points to.
    this.id = id;

    // set the content of the element
    // to the target section.
    this.el.setContent(id);

    this.addUIEvent('click');
}

NavButton.prototype = Object.create(Node.prototype);

// overwrite onReceive to respond to the changeSection event
NavButton.prototype.onReceive = function onReceive(event, payload) {
    if (event === 'changeSection') {
        // swap on/off depend if this button points
        // to the apps current section
        if (payload.to === this.getId()) this.on();else this.off();
    }
};

// apply the on class
NavButton.prototype.on = function on() {
    this.el.removeClass('off').addClass('on');
};

// apply the off class
NavButton.prototype.off = function off() {
    this.el.removeClass('on').addClass('off');
};

NavButton.prototype.getId = function getId() {
    return this.id;
};

// make and style an element
function makeEl(node) {
    return new DOMElement(node, {
        properties: {
            textAlign: 'center',
            lineHeight: '100px',
            fontSize: '18px',
            cursor: 'pointer'
        },
        classes: ['navigation']
    });
};

module.exports = NavButton;

},{"famous/core/Node":10,"famous/dom-renderables/DOMElement":18}],61:[function(require,module,exports){
'use strict';

var data = require('./Data');
var Node = require('famous/core/Node');
var DOMElement = require('famous/dom-renderables/DOMElement');
var Tweet = require('./Tweet');

function Section(i) {
    // subclass Node
    Node.call(this);

    // create and style a new DOMElement
    this.el = new DOMElement(this).setProperty('overflow-y', 'scroll').setProperty('overflow-x', 'hidden');

    // create the tweets in the section.
    this.tweets = createTweets.call(this, i);
}

Section.prototype = Object.create(Node.prototype);

function createTweets(id) {
    var result = [];
    var numberOfTweets = data.sections[id].tweetNumber;
    var tweet;

    // create an array of length equal to the number of tweets and then
    // map over it to create an array of tweets.
    for (var i = 0; i < numberOfTweets; i++) {
        // this node will be 100px tall and positioned after the previous one
        // in the array
        tweet = this.addChild().setSizeMode('default', 'absolute').setAbsoluteSize(null, 100).setPosition(0, 100 * i).addChild(new Tweet());

        result.push(tweet);
    }

    return result;
}

module.exports = Section;

},{"./Data":57,"./Tweet":63,"famous/core/Node":10,"famous/dom-renderables/DOMElement":18}],62:[function(require,module,exports){
'use strict';

var data = require('./Data');
var Section = require('./Section');
var Node = require('famous/core/Node');
var Align = require('famous/components/Align');
var DOMElement = require('famous/dom-renderables/DOMElement');

// The swapper will hold the sections and swap between them
// on events
function Swapper() {
    // subclass Node
    Node.call(this);

    // create a new dom element
    this.el = new DOMElement(this);

    // store the current section
    this.currentSection = null;

    // create the sections
    this.sections = createSections.call(this);
}

// subclass Node
Swapper.prototype = Object.create(Node.prototype);

Swapper.prototype.changeSection = function changeSection(to) {
    // Swap out any section that isn't the new section
    // and swap in the new section
    data.sections.forEach((function (section) {
        if (section.id === to)
            // 500 millisecond transition
            this.sections[section.id].align.set(0, 0, 0, {
                duration: 500
            });else
            // 1 in x will put the top left corner of the
            // section directly off the screen
            this.sections[section.id].align.set(1, 0, 0, {
                duration: 500
            });
    }).bind(this));

    this.currentSection = to;
};

// overwrite onReceive to intercept events in the scene graph
Swapper.prototype.onReceive = function onReceive(event, payload) {
    if (event === 'changeSection') this.changeSection(payload.to);
};

function createSections() {
    var result = {};

    // iterate over all the sections in our data
    data.sections.forEach((function (section, i) {
        var child = this.addChild();
        result[section.id] = {
            align: new Align(child),
            section: child.addChild(new Section(i))
        };
    }).bind(this));

    return result;
}

module.exports = Swapper;

},{"./Data":57,"./Section":61,"famous/components/Align":1,"famous/core/Node":10,"famous/dom-renderables/DOMElement":18}],63:[function(require,module,exports){
'use strict';

var Node = require('famous/core/Node');
var DOMElement = require('famous/dom-renderables/DOMElement');
var data = require('./Data');

// The tweet class that will render a particular tweet
function Tweet() {
    // subclass Node
    Node.call(this);

    // create a new DOMElement and style it.
    this.el = new DOMElement(this).setProperty('backgroundColor', getRandomColor()).setProperty('boxSizing', 'border-box').setProperty('lineHeight', '100px').setProperty('borderBottom', '1px solid black').setProperty('font-size', '12px').setContent(getRandomMessage());
}

// subclass Node
Tweet.prototype = Object.create(Node.prototype);

// Pick a random element from an array
function random(array) {
    return array[Math.random() * array.length | 0];
}

// create Random message
function getRandomMessage() {
    return '<b>' + random(data.usernames) + ':</b>' + random(data.begin) + random(data.middle) + random(data.end) + ' ' + random(data.hashtags) + ' ' + random(data.hashtags);
}

// Create a random hex color
function getRandomColor() {
    // trick to create a range.
    return '#' + Array.apply(null, Array(6)).map(function (_, i) {
        return random('0123456789ABCDEF');
    }).join('');
}

module.exports = Tweet;

},{"./Data":57,"famous/core/Node":10,"famous/dom-renderables/DOMElement":18}],64:[function(require,module,exports){
'use strict';

var Node = require('famous/core/Node');
var data = require('./Data');
var Header = require('./Header');
var Footer = require('./Footer');
var Swapper = require('./Swapper');

function Twitterus(mount) {
    // Extend Node
    Node.call(this);

    this.currentSection = data.sections[0].id;

    makeHeader(this);
    makeFooter(this);
    makeSwapper(this);
}

// Extend the prototype
Twitterus.prototype = Object.create(Node.prototype);

// Overwrite on mount to emit the changeSection event the moment
// twitter is added to the scene graph.
Twitterus.prototype.onMount = function onMount(parent, id) {
    this.emit('changeSection', { from: null, to: this.currentSection });
};

// Overwrite the onReceive method to intercept events flowing within
// the scene graph
Twitterus.prototype.onReceive = function onReceive(event, payload) {

    // if the event is click then we know
    // that a NavButton was clicked
    // (NavButtons are the only element)
    // With the click event.
    if (event === 'click') {

        // get the id of the nav button
        var to = payload.node.getId();

        // emit the changeSection event to the subtree
        this.emit('changeSection', {
            from: this.currentSection,
            to: to
        });

        // set the current section
        this.currentSection = to;
    }
};

function makeHeader(node) {
    // the header will be positioned defaultly
    // along the top of its parent.
    // It will be the complete width of its parent
    // and 100 pixels tall.
    node.addChild().setSizeMode('default', 'absolute').setAbsoluteSize(null, 100).addChild(new Header());
}

// make the swapper
function makeSwapper(node) {
    // the swapper will be 200 pixels smaller than
    // its parent in Y and otherwise the same size.
    // It will be position 100 pixels below its parent
    // such that it clears the header
    node.addChild().setDifferentialSize(null, -200, null).setPosition(0, 100).addChild(new Swapper());
}

// make the footer
function makeFooter(node) {
    // the footer will be aligned
    // to the bottom of its parent.
    // Like the header it will be
    // 100px tall and the complete width.
    // note how we use MountPoint and Align
    // together to line up the bottom of the footer
    // with the bottom of the parent
    node.addChild().setSizeMode('default', 'absolute').setAbsoluteSize(null, 100).setMountPoint(0, 1).setAlign(0, 1).addChild(new Footer());
}

module.exports = Twitterus;

},{"./Data":57,"./Footer":58,"./Header":59,"./Swapper":62,"famous/core/Node":10}],65:[function(require,module,exports){
'use strict';

var Twitterus = require('./Twitterus');
var FamousEngine = require('famous/core/FamousEngine');
FamousEngine.init();
//create the app and pass in the target element
var twitterus = FamousEngine.createScene().addChild(new Twitterus());

},{"./Twitterus":64,"famous/core/FamousEngine":9}]},{},[65])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9jb21wb25lbnRzL0FsaWduLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9jb21wb25lbnRzL0NhbWVyYS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvY29tcG9uZW50cy9Qb3NpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvY29yZS9DaGFubmVsLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9jb3JlL0Nsb2NrLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9jb3JlL0NvbW1hbmRzLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9jb3JlL0Rpc3BhdGNoLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9jb3JlL0V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9jb3JlL0ZhbW91c0VuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvY29yZS9Ob2RlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9jb3JlL1BhdGguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL2NvcmUvUGF0aFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9jb3JlL1NjZW5lLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9jb3JlL1NpemUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL2NvcmUvU2l6ZVN5c3RlbS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvY29yZS9UcmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL2NvcmUvVHJhbnNmb3JtU3lzdGVtLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9kb20tcmVuZGVyYWJsZXMvRE9NRWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9ET01SZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9FbGVtZW50Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL2RvbS1yZW5kZXJlcnMvTWF0aC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9Wb2lkRWxlbWVudHMuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL2RvbS1yZW5kZXJlcnMvZXZlbnRzL0NvbXBvc2l0aW9uRXZlbnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL2RvbS1yZW5kZXJlcnMvZXZlbnRzL0V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9kb20tcmVuZGVyZXJzL2V2ZW50cy9FdmVudE1hcC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9ldmVudHMvRm9jdXNFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9ldmVudHMvSW5wdXRFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9ldmVudHMvS2V5Ym9hcmRFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9ldmVudHMvTW91c2VFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9ldmVudHMvVG91Y2hFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9ldmVudHMvVUlFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvZG9tLXJlbmRlcmVycy9ldmVudHMvV2hlZWxFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvcG9seWZpbGxzL2FuaW1hdGlvbkZyYW1lLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9wb2x5ZmlsbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL3JlbmRlci1sb29wcy9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9yZW5kZXJlcnMvQ29tcG9zaXRvci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvcmVuZGVyZXJzL0NvbnRleHQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL3JlbmRlcmVycy9VSU1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL3JlbmRlcmVycy9pbmplY3QtY3NzLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy90cmFuc2l0aW9ucy9DdXJ2ZXMuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL3RyYW5zaXRpb25zL1RyYW5zaXRpb25hYmxlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy91dGlsaXRpZXMvQ2FsbGJhY2tTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvdXRpbGl0aWVzL2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy91dGlsaXRpZXMva2V5VmFsdWVUb0FycmF5cy5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvdXRpbGl0aWVzL3ZlbmRvclByZWZpeC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtcmVuZGVyZXJzL0J1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtcmVuZGVyZXJzL0J1ZmZlclJlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1yZW5kZXJlcnMvRGVidWcuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL3dlYmdsLXJlbmRlcmVycy9Qcm9ncmFtLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1yZW5kZXJlcnMvVGV4dHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtcmVuZGVyZXJzL1RleHR1cmVNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy93ZWJnbC1yZW5kZXJlcnMvV2ViR0xSZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtcmVuZGVyZXJzL2NvbXBpbGVNYXRlcmlhbC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtcmVuZGVyZXJzL2NyZWF0ZUNoZWNrZXJib2FyZC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtcmVuZGVyZXJzL3JhZGl4U29ydC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvd2ViZ2wtc2hhZGVycy9pbmRleC5qcyIsInNyYy90d2l0dGVydXMvRGF0YS5qc29uIiwiL1VzZXJzL21vcmdhbnRoZXBsYW50L0Rlc2t0b3AvdHdhdHRlcnVzL3NyYy90d2l0dGVydXMvRm9vdGVyLmpzIiwiL1VzZXJzL21vcmdhbnRoZXBsYW50L0Rlc2t0b3AvdHdhdHRlcnVzL3NyYy90d2l0dGVydXMvSGVhZGVyLmpzIiwiL1VzZXJzL21vcmdhbnRoZXBsYW50L0Rlc2t0b3AvdHdhdHRlcnVzL3NyYy90d2l0dGVydXMvTmF2QnV0dG9uLmpzIiwiL1VzZXJzL21vcmdhbnRoZXBsYW50L0Rlc2t0b3AvdHdhdHRlcnVzL3NyYy90d2l0dGVydXMvU2VjdGlvbi5qcyIsIi9Vc2Vycy9tb3JnYW50aGVwbGFudC9EZXNrdG9wL3R3YXR0ZXJ1cy9zcmMvdHdpdHRlcnVzL1N3YXBwZXIuanMiLCIvVXNlcnMvbW9yZ2FudGhlcGxhbnQvRGVza3RvcC90d2F0dGVydXMvc3JjL3R3aXR0ZXJ1cy9Ud2VldC5qcyIsIi9Vc2Vycy9tb3JnYW50aGVwbGFudC9EZXNrdG9wL3R3YXR0ZXJ1cy9zcmMvdHdpdHRlcnVzL1R3aXR0ZXJ1cy5qcyIsIi9Vc2Vycy9tb3JnYW50aGVwbGFudC9EZXNrdG9wL3R3YXR0ZXJ1cy9zcmMvdHdpdHRlcnVzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNud0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3B0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3QxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEJBLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM3QixJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdkMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7OztBQUd2QyxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQzs7O0FBR3ZDLFNBQVMsTUFBTSxHQUFJOztBQUVmLFFBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7OztBQUdoQixRQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQzs7OztBQUlsQixRQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFBLFVBQVUsT0FBTyxFQUFFLENBQUMsRUFBRTtBQUN4QyxZQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUNuQyxtQkFBbUIsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQ3BDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUM7S0FDN0QsQ0FBQSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0NBQ2pCOzs7QUFHRCxNQUFNLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDOztBQUVqRCxNQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQzs7Ozs7QUMzQnhCLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3ZDLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO0FBQzlELElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDOztBQUUvQyxTQUFTLE1BQU0sR0FBSTtBQUNmLFFBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDaEIsUUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLEVBQUU7QUFDM0IsZUFBTyxFQUFFLENBQUMsUUFBUSxDQUFDO0tBQ3RCLENBQUMsQ0FBQzs7QUFFSCxRQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUM3QixRQUFJLENBQUMsT0FBTyxHQUFHLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQyxDQUNsQyxXQUFXLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUNsQyxXQUFXLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDOztBQUUxRSxRQUFJLENBQUMsVUFBVSxHQUFHLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUMzQzs7QUFFRCxNQUFNLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDOztBQUVqRCxNQUFNLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxTQUFTLFNBQVMsQ0FBRSxLQUFLLEVBQUUsT0FBTyxFQUFFO0FBQzdELFFBQUksS0FBSyxLQUFLLGVBQWUsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztDQUNqRSxDQUFDOztBQUVGLE1BQU0sQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFNBQVMsYUFBYSxDQUFFLEVBQUUsRUFBRTs7QUFFekQsUUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUMsRUFBRSxDQUFBLFlBQVk7OztBQUd2RCxZQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7OztBQUk1QixZQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUMsQ0FBQyxDQUFDO0tBQ2pELENBQUEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztDQUNqQixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDOzs7OztBQ3JDeEIsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDdkMsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7Ozs7QUFJOUQsU0FBUyxTQUFTLENBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRTs7QUFFNUIsUUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzs7O0FBR2hCLFFBQUksQ0FBQyxFQUFFLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDOzs7O0FBSXZCLFFBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDOzs7O0FBSWIsUUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7O0FBRXZCLFFBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDNUI7O0FBRUQsU0FBUyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQzs7O0FBR3BELFNBQVMsQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFNBQVMsU0FBUyxDQUFFLEtBQUssRUFBRSxPQUFPLEVBQUU7QUFDaEUsUUFBSSxLQUFLLEtBQUssZUFBZSxFQUFFOzs7QUFHM0IsWUFBSSxPQUFPLENBQUMsRUFBRSxLQUFLLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsS0FDdEMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ25CO0NBQ0osQ0FBQzs7O0FBR0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUFFLEdBQUcsU0FBUyxFQUFFLEdBQUk7QUFDcEMsUUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQzdDLENBQUM7OztBQUdGLFNBQVMsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFJO0FBQ3RDLFFBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUM3QyxDQUFDOztBQUVGLFNBQVMsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFNBQVMsS0FBSyxHQUFJO0FBQzFDLFdBQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQztDQUNsQixDQUFDOzs7QUFHRixTQUFTLE1BQU0sQ0FBRSxJQUFJLEVBQUU7QUFDbkIsV0FBTyxJQUFJLFVBQVUsQ0FBQyxJQUFJLEVBQUU7QUFDeEIsa0JBQVUsRUFBRTtBQUNSLHFCQUFTLEVBQUUsUUFBUTtBQUNuQixzQkFBVSxFQUFFLE9BQU87QUFDbkIsb0JBQVEsRUFBRSxNQUFNO0FBQ2hCLGtCQUFNLEVBQUUsU0FBUztTQUNwQjtBQUNELGVBQU8sRUFBRSxDQUFDLFlBQVksQ0FBQztLQUMxQixDQUFDLENBQUM7Q0FDTixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDOzs7OztBQzlEM0IsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzdCLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3ZDLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO0FBQzlELElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzs7QUFFL0IsU0FBUyxPQUFPLENBQUUsQ0FBQyxFQUFFOztBQUVqQixRQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOzs7QUFHaEIsUUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLFFBQVEsQ0FBQyxDQUNuQyxXQUFXLENBQUMsWUFBWSxFQUFFLFFBQVEsQ0FBQyxDQUFDOzs7QUFHbkUsUUFBSSxDQUFDLE1BQU0sR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztDQUM1Qzs7QUFFRCxPQUFPLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDOztBQUVsRCxTQUFTLFlBQVksQ0FBRSxFQUFFLEVBQUU7QUFDdkIsUUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ2hCLFFBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDO0FBQ25ELFFBQUksS0FBSyxDQUFDOzs7O0FBSVYsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUcsQ0FBQyxHQUFHLGNBQWMsRUFBRyxDQUFDLEVBQUUsRUFBRTs7O0FBR3ZDLGFBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQ1YsV0FBVyxDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FDbEMsZUFBZSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FDMUIsV0FBVyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQ3ZCLFFBQVEsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLENBQUM7O0FBRW5DLGNBQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDdEI7O0FBRUQsV0FBTyxNQUFNLENBQUM7Q0FDakI7O0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7Ozs7O0FDekN6QixJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDN0IsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ25DLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3ZDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0FBQy9DLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDOzs7O0FBSTlELFNBQVMsT0FBTyxHQUFJOztBQUVoQixRQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOzs7QUFHaEIsUUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7O0FBRy9CLFFBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDOzs7QUFHM0IsUUFBSSxDQUFDLFFBQVEsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQzdDOzs7QUFHRCxPQUFPLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDOztBQUVsRCxPQUFPLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxTQUFTLGFBQWEsQ0FBRSxFQUFFLEVBQUU7OztBQUcxRCxRQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFBLFVBQVUsT0FBTyxFQUFFO0FBQ3JDLFlBQUksT0FBTyxDQUFDLEVBQUUsS0FBSyxFQUFFOztBQUVqQixnQkFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUN6Qyx3QkFBUSxFQUFFLEdBQUc7YUFDaEIsQ0FBQyxDQUFDOzs7QUFJSCxnQkFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUN6Qyx3QkFBUSxFQUFFLEdBQUc7YUFDaEIsQ0FBQyxDQUFDO0tBQ1YsQ0FBQSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOztBQUVkLFFBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDO0NBQzVCLENBQUM7OztBQUdGLE9BQU8sQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFNBQVMsU0FBUyxDQUFFLEtBQUssRUFBRSxPQUFPLEVBQUU7QUFDOUQsUUFBSSxLQUFLLEtBQUssZUFBZSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0NBQ2pFLENBQUM7O0FBRUYsU0FBUyxjQUFjLEdBQUk7QUFDdkIsUUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDOzs7QUFHaEIsUUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQSxVQUFVLE9BQU8sRUFBRSxDQUFDLEVBQUU7QUFDeEMsWUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQzVCLGNBQU0sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEdBQUc7QUFDakIsaUJBQUssRUFBRSxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUM7QUFDdkIsbUJBQU8sRUFBRSxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzFDLENBQUE7S0FDSixDQUFBLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7O0FBRWQsV0FBTyxNQUFNLENBQUM7Q0FDakI7O0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7Ozs7O0FDakV6QixJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUN2QyxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsbUNBQW1DLENBQUMsQ0FBQztBQUM5RCxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7OztBQUc3QixTQUFTLEtBQUssR0FBSTs7QUFFZCxRQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOzs7QUFHaEIsUUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsaUJBQWlCLEVBQUUsY0FBYyxFQUFFLENBQUMsQ0FDaEQsV0FBVyxDQUFDLFdBQVcsRUFBRSxZQUFZLENBQUMsQ0FDdEMsV0FBVyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FDbEMsV0FBVyxDQUFDLGNBQWMsRUFBRSxpQkFBaUIsQ0FBQyxDQUM5QyxXQUFXLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUNoQyxVQUFVLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO0NBQ2pFOzs7QUFHRCxLQUFLLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7QUFHaEQsU0FBUyxNQUFNLENBQUUsS0FBSyxFQUFFO0FBQ3BCLFdBQU8sS0FBSyxDQUFDLEFBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUUsQ0FBQyxDQUFDLENBQUM7Q0FDbEQ7OztBQUdELFNBQVMsZ0JBQWdCLEdBQUk7QUFDekIsV0FBTyxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FDOUIsT0FBTyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUNyRSxHQUFHLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztDQUNwRTs7O0FBR0QsU0FBUyxjQUFjLEdBQUc7O0FBRXRCLFdBQU8sR0FBRyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDekQsZUFBTyxNQUFNLENBQUMsa0JBQWtCLENBQUMsQ0FBQztLQUNyQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0NBQ2Y7O0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7Ozs7O0FDekN2QixJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUN2QyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDN0IsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ2pDLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNqQyxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7O0FBRW5DLFNBQVMsU0FBUyxDQUFDLEtBQUssRUFBRTs7QUFFdEIsUUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFaEIsUUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQzs7QUFFMUMsY0FBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pCLGNBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNqQixlQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDckI7OztBQUdELFNBQVMsQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7Ozs7QUFJcEQsU0FBUyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsU0FBUyxPQUFPLENBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRTtBQUN6RCxRQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxFQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUMsQ0FBQyxDQUFDO0NBQ3BFLENBQUM7Ozs7QUFJRixTQUFTLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxTQUFTLFNBQVMsQ0FBRSxLQUFLLEVBQUUsT0FBTyxFQUFFOzs7Ozs7QUFNaEUsUUFBSSxLQUFLLEtBQUssT0FBTyxFQUFFOzs7QUFHbkIsWUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQzs7O0FBRzlCLFlBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFO0FBQ3ZCLGdCQUFJLEVBQUUsSUFBSSxDQUFDLGNBQWM7QUFDekIsY0FBRSxFQUFFLEVBQUU7U0FDVCxDQUFDLENBQUM7OztBQUdILFlBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDO0tBQzVCO0NBQ0osQ0FBQzs7QUFFRixTQUFTLFVBQVUsQ0FBQyxJQUFJLEVBQUU7Ozs7O0FBS3RCLFFBQUksQ0FBQyxRQUFRLEVBQUUsQ0FDVixXQUFXLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUNsQyxlQUFlLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUMxQixRQUFRLENBQUMsSUFBSSxNQUFNLEVBQUUsQ0FBQyxDQUFDO0NBQy9COzs7QUFHRCxTQUFTLFdBQVcsQ0FBRSxJQUFJLEVBQUU7Ozs7O0FBS3hCLFFBQUksQ0FBQyxRQUFRLEVBQUUsQ0FDVixtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQ3JDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQ25CLFFBQVEsQ0FBQyxJQUFJLE9BQU8sRUFBRSxDQUFDLENBQUM7Q0FDaEM7OztBQUdELFNBQVMsVUFBVSxDQUFFLElBQUksRUFBRTs7Ozs7Ozs7QUFRdkIsUUFBSSxDQUFDLFFBQVEsRUFBRSxDQUNWLFdBQVcsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQ2xDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQzFCLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQ25CLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQ2QsUUFBUSxDQUFDLElBQUksTUFBTSxFQUFFLENBQUMsQ0FBQztDQUMvQjs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQzs7Ozs7QUMxRjNCLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN2QyxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsMEJBQTBCLENBQUMsQ0FBQztBQUN0RCxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUM7O0FBRXJCLElBQUksU0FBUyxHQUFHLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxTQUFTLEVBQUUsQ0FBQyxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoJy4vUG9zaXRpb24nKTtcblxuLyoqXG4gKiBBbGlnbiBpcyBhIGNvbXBvbmVudCBkZXNpZ25lZCB0byBhbGxvdyBmb3Igc21vb3RoIHR3ZWVuaW5nXG4gKiBvZiB0aGUgYWxpZ25tZW50IG9mIGEgbm9kZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50LlxuICpcbiAqIEBjbGFzcyBBbGlnblxuICogQGF1Z21lbnRzIFBvc2l0aW9uXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdGhhdCB0aGUgQWxpZ24gY29tcG9uZW50IHdpbGwgYmUgYXR0YWNoZWQgdG9cbiAqL1xuZnVuY3Rpb24gQWxpZ24obm9kZSkge1xuICAgIFBvc2l0aW9uLmNhbGwodGhpcywgbm9kZSk7XG5cbiAgICB2YXIgaW5pdGlhbCA9IG5vZGUuZ2V0QWxpZ24oKTtcblxuICAgIHRoaXMuX3guc2V0KGluaXRpYWxbMF0pO1xuICAgIHRoaXMuX3kuc2V0KGluaXRpYWxbMV0pO1xuICAgIHRoaXMuX3ouc2V0KGluaXRpYWxbMl0pO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgQWxpZ24gY29tcG9uZW50XG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gTmFtZSBvZiB0aGUgY29tcG9uZW50XG4gKi9cbkFsaWduLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnQWxpZ24nO1xufTtcblxuQWxpZ24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQb3NpdGlvbi5wcm90b3R5cGUpO1xuQWxpZ24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWxpZ247XG5cbi8qKlxuICogV2hlbiB0aGUgbm9kZSB0aGlzIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0byB1cGRhdGVzLCB1cGRhdGUgdGhlIHZhbHVlXG4gKiBvZiB0aGUgTm9kZSdzIGFsaWduLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5BbGlnbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMuX25vZGUuc2V0QWxpZ24odGhpcy5feC5nZXQoKSwgdGhpcy5feS5nZXQoKSwgdGhpcy5fei5nZXQoKSk7XG4gICAgdGhpcy5fY2hlY2tVcGRhdGUoKTtcbn07XG5cbkFsaWduLnByb3RvdHlwZS5vblVwZGF0ZSA9IEFsaWduLnByb3RvdHlwZS51cGRhdGU7XG5cbm1vZHVsZS5leHBvcnRzID0gQWxpZ247XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbWFuZHMnKTtcblxuLyoqXG4gKiBDYW1lcmEgaXMgYSBjb21wb25lbnQgdGhhdCBpcyByZXNwb25zaWJsZSBmb3Igc2VuZGluZyBpbmZvcm1hdGlvbiB0byB0aGUgcmVuZGVyZXIgYWJvdXQgd2hlcmVcbiAqIHRoZSBjYW1lcmEgaXMgaW4gdGhlIHNjZW5lLiAgVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gc2V0IHRoZSB0eXBlIG9mIHByb2plY3Rpb24sIHRoZSBmb2NhbCBkZXB0aCxcbiAqIGFuZCBvdGhlciBwcm9wZXJ0aWVzIHRvIGFkanVzdCB0aGUgd2F5IHRoZSBzY2VuZXMgYXJlIHJlbmRlcmVkLlxuICpcbiAqIEBjbGFzcyBDYW1lcmFcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgdG8gd2hpY2ggdGhlIGluc3RhbmNlIG9mIENhbWVyYSB3aWxsIGJlIGEgY29tcG9uZW50IG9mXG4gKi9cbmZ1bmN0aW9uIENhbWVyYShub2RlKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5fcHJvamVjdGlvblR5cGUgPSBDYW1lcmEuT1JUSE9HUkFQSElDX1BST0pFQ1RJT047XG4gICAgdGhpcy5fZm9jYWxEZXB0aCA9IDA7XG4gICAgdGhpcy5fbmVhciA9IDA7XG4gICAgdGhpcy5fZmFyID0gMDtcbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pO1xuICAgIHRoaXMuX3ZpZXdEaXJ0eSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlcnNwZWN0aXZlRGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLnNldEZsYXQoKTtcbn1cblxuQ2FtZXJhLkZSVVNUVU1fUFJPSkVDVElPTiA9IDA7XG5DYW1lcmEuUElOSE9MRV9QUk9KRUNUSU9OID0gMTtcbkNhbWVyYS5PUlRIT0dSQVBISUNfUFJPSkVDVElPTiA9IDI7XG5cbi8qKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gTmFtZSBvZiB0aGUgY29tcG9uZW50XG4gKi9cbkNhbWVyYS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0NhbWVyYSc7XG59O1xuXG4vKipcbiAqIEdldHMgb2JqZWN0IGNvbnRhaW5pbmcgc2VyaWFsaXplZCBkYXRhIGZvciB0aGUgY29tcG9uZW50XG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHN0YXRlIG9mIHRoZSBjb21wb25lbnRcbiAqL1xuQ2FtZXJhLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBvbmVudDogdGhpcy50b1N0cmluZygpLFxuICAgICAgICBwcm9qZWN0aW9uVHlwZTogdGhpcy5fcHJvamVjdGlvblR5cGUsXG4gICAgICAgIGZvY2FsRGVwdGg6IHRoaXMuX2ZvY2FsRGVwdGgsXG4gICAgICAgIG5lYXI6IHRoaXMuX25lYXIsXG4gICAgICAgIGZhcjogdGhpcy5fZmFyXG4gICAgfTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIHN0YXRlIGJhc2VkIG9uIHNvbWUgc2VyaWFsaXplZCBkYXRhXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBhbiBvYmplY3QgZGVmaW5pbmcgd2hhdCB0aGUgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCBzaG91bGQgYmVcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBzdGF0dXMgb2YgdGhlIHNldFxuICovXG5DYW1lcmEucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy50b1N0cmluZygpID09PSBzdGF0ZS5jb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5zZXQoc3RhdGUucHJvamVjdGlvblR5cGUsIHN0YXRlLmZvY2FsRGVwdGgsIHN0YXRlLm5lYXIsIHN0YXRlLmZhcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaW50ZXJuYWxzIG9mIHRoZSBjb21wb25lbnRcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgYW4gaWQgY29ycmVzcG9uZGluZyB0byB0aGUgdHlwZSBvZiBwcm9qZWN0aW9uIHRvIHVzZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIHRoZSBkZXB0aCBmb3IgdGhlIHBpbmhvbGUgcHJvamVjdGlvbiBtb2RlbFxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgdGhlIGRpc3RhbmNlIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIGZvciBhIGZydXN0dW0gcHJvamVjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciB0aGUgZGlzdGFuY2Ugb2YgdGhlIGZhciBjbGlwcGluZyBwbGFuZSBmb3IgYSBmcnVzdHVtIHByb2plY3Rpb25cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBzdGF0dXMgb2YgdGhlIHNldFxuICovXG5DYW1lcmEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCh0eXBlLCBkZXB0aCwgbmVhciwgZmFyKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9wcm9qZWN0aW9uVHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fZm9jYWxEZXB0aCA9IGRlcHRoO1xuICAgIHRoaXMuX25lYXIgPSBuZWFyO1xuICAgIHRoaXMuX2ZhciA9IGZhcjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjYW1lcmEgZGVwdGggZm9yIGEgcGluaG9sZSBwcm9qZWN0aW9uIG1vZGVsXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgQ2FtZXJhIGFuZCB0aGUgb3JpZ2luXG4gKlxuICogQHJldHVybiB7Q2FtZXJhfSB0aGlzXG4gKi9cbkNhbWVyYS5wcm90b3R5cGUuc2V0RGVwdGggPSBmdW5jdGlvbiBzZXREZXB0aChkZXB0aCkge1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5faWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fcGVyc3BlY3RpdmVEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fcHJvamVjdGlvblR5cGUgPSBDYW1lcmEuUElOSE9MRV9QUk9KRUNUSU9OO1xuICAgIHRoaXMuX2ZvY2FsRGVwdGggPSBkZXB0aDtcbiAgICB0aGlzLl9uZWFyID0gMDtcbiAgICB0aGlzLl9mYXIgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgb2JqZWN0IGNvbnRhaW5pbmcgc2VyaWFsaXplZCBkYXRhIGZvciB0aGUgY29tcG9uZW50XG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIGRpc3RhbmNlIGZyb20gdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdG8gdGhlIGNhbWVyYVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBkaXN0YW5jZSBmcm9tIHRoZSBmYXIgY2xpcHBpbmcgcGxhbmUgdG8gdGhlIGNhbWVyYVxuICpcbiAqIEByZXR1cm4ge0NhbWVyYX0gdGhpc1xuICovXG5DYW1lcmEucHJvdG90eXBlLnNldEZydXN0dW0gPSBmdW5jdGlvbiBzZXRGcnVzdHVtKG5lYXIsIGZhcikge1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5faWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9wcm9qZWN0aW9uVHlwZSA9IENhbWVyYS5GUlVTVFVNX1BST0pFQ1RJT047XG4gICAgdGhpcy5fZm9jYWxEZXB0aCA9IDA7XG4gICAgdGhpcy5fbmVhciA9IG5lYXI7XG4gICAgdGhpcy5fZmFyID0gZmFyO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgQ2FtZXJhIHRvIGhhdmUgb3J0aG9ncmFwaGljIHByb2plY3Rpb25cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7Q2FtZXJhfSB0aGlzXG4gKi9cbkNhbWVyYS5wcm90b3R5cGUuc2V0RmxhdCA9IGZ1bmN0aW9uIHNldEZsYXQoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3BlcnNwZWN0aXZlRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3Byb2plY3Rpb25UeXBlID0gQ2FtZXJhLk9SVEhPR1JBUEhJQ19QUk9KRUNUSU9OO1xuICAgIHRoaXMuX2ZvY2FsRGVwdGggPSAwO1xuICAgIHRoaXMuX25lYXIgPSAwO1xuICAgIHRoaXMuX2ZhciA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV2hlbiB0aGUgbm9kZSB0aGlzIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0byB1cGRhdGVzLCB0aGUgQ2FtZXJhIHdpbGxcbiAqIHNlbmQgbmV3IGNhbWVyYSBpbmZvcm1hdGlvbiB0byB0aGUgQ29tcG9zaXRvciB0byB1cGRhdGUgdGhlIHJlbmRlcmluZ1xuICogb2YgdGhlIHNjZW5lLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5DYW1lcmEucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24gb25VcGRhdGUoKSB7XG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHBhdGggPSB0aGlzLl9ub2RlLmdldExvY2F0aW9uKCk7XG5cbiAgICB0aGlzLl9ub2RlXG4gICAgICAgIC5zZW5kRHJhd0NvbW1hbmQoQ29tbWFuZHMuV0lUSClcbiAgICAgICAgLnNlbmREcmF3Q29tbWFuZChwYXRoKTtcblxuICAgIGlmICh0aGlzLl9wZXJzcGVjdGl2ZURpcnR5KSB7XG4gICAgICAgIHRoaXMuX3BlcnNwZWN0aXZlRGlydHkgPSBmYWxzZTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuX3Byb2plY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICBjYXNlIENhbWVyYS5GUlVTVFVNX1BST0pFQ1RJT046XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQoQ29tbWFuZHMuRlJVU1RSVU1fUFJPSkVDVElPTik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fbmVhcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fZmFyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ2FtZXJhLlBJTkhPTEVfUFJPSkVDVElPTjpcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZChDb21tYW5kcy5QSU5IT0xFX1BST0pFQ1RJT04pO1xuICAgICAgICAgICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX2ZvY2FsRGVwdGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDYW1lcmEuT1JUSE9HUkFQSElDX1BST0pFQ1RJT046XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQoQ29tbWFuZHMuT1JUSE9HUkFQSElDX1BST0pFQ1RJT04pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3ZpZXdEaXJ0eSkge1xuICAgICAgICB0aGlzLl92aWV3RGlydHkgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZChDb21tYW5kcy5DSEFOR0VfVklFV19UUkFOU0ZPUk0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzBdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsxXSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMl0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzNdKTtcblxuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVs1XSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bNl0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzddKTtcblxuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzhdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVs5XSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTBdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsxMV0pO1xuXG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTJdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsxM10pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzE0XSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTVdKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFdoZW4gdGhlIHRyYW5zZm9ybSBvZiB0aGUgbm9kZSB0aGlzIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0b1xuICogY2hhbmdlcywgaGF2ZSB0aGUgQ2FtZXJhIHVwZGF0ZSBpdHMgcHJvamVjdGlvbiBtYXRyaXggYW5kXG4gKiBpZiBuZWVkZWQsIGZsYWcgdG8gbm9kZSB0byB1cGRhdGUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybSBhbiBhcnJheSBkZW5vdGluZyB0aGUgdHJhbnNmb3JtIG1hdHJpeCBvZiB0aGUgbm9kZVxuICpcbiAqIEByZXR1cm4ge0NhbWVyYX0gdGhpc1xuICovXG5DYW1lcmEucHJvdG90eXBlLm9uVHJhbnNmb3JtQ2hhbmdlID0gZnVuY3Rpb24gb25UcmFuc2Zvcm1DaGFuZ2UodHJhbnNmb3JtKSB7XG4gICAgdmFyIGEgPSB0cmFuc2Zvcm07XG4gICAgdGhpcy5fdmlld0RpcnR5ID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5faWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgZGV0ID0gMS8oYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2KTtcblxuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FtZXJhO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRyYW5zaXRpb25hYmxlID0gcmVxdWlyZSgnLi4vdHJhbnNpdGlvbnMvVHJhbnNpdGlvbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgUG9zaXRpb24gY29tcG9uZW50IHNlcnZlcyBhcyBhIHdheSB0byB0d2VlbiB0byB0cmFuc2xhdGlvbiBvZiBhIE5vZGUuXG4gKiAgSXQgaXMgYWxzbyB0aGUgYmFzZSBjbGFzcyBmb3IgdGhlIG90aGVyIGNvcmUgY29tcG9uZW50cyB0aGF0IGludGVyYWN0XG4gKiB3aXRoIHRoZSBWZWMzIHByb3BlcnRpZXMgb24gdGhlIE5vZGVcbiAqXG4gKiBAY2xhc3MgUG9zaXRpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0aGF0IHRoZSBQb3NpdGlvbiBjb21wb25lbnQgd2lsbCBiZSBhdHRhY2hlZCB0b1xuICovXG5mdW5jdGlvbiBQb3NpdGlvbihub2RlKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgXG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgIFxuICAgIHZhciBpbml0aWFsUG9zaXRpb24gPSBub2RlLmdldFBvc2l0aW9uKCk7XG5cbiAgICB0aGlzLl94ID0gbmV3IFRyYW5zaXRpb25hYmxlKGluaXRpYWxQb3NpdGlvblswXSk7XG4gICAgdGhpcy5feSA9IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsUG9zaXRpb25bMV0pO1xuICAgIHRoaXMuX3ogPSBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbFBvc2l0aW9uWzJdKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIFBvc2l0aW9uIGNvbXBvbmVudFxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGNvbXBvbmVudFxuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1Bvc2l0aW9uJztcbn07XG5cbi8qKlxuICogR2V0cyBvYmplY3QgY29udGFpbmluZyBzdHJpbmdpZmllZCBjb25zdHJ1Y3RvciwgYW5kIGNvcnJlc3BvbmRpbmcgZGltZW5zaW9uYWwgdmFsdWVzXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBjb21wb25lbnRcbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9uZW50OiB0aGlzLnRvU3RyaW5nKCksXG4gICAgICAgIHg6IHRoaXMuX3guZ2V0KCksXG4gICAgICAgIHk6IHRoaXMuX3kuZ2V0KCksXG4gICAgICAgIHo6IHRoaXMuX3ouZ2V0KClcbiAgICB9O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHRyYW5zbGF0aW9uIG9mIHRoZSBOb2RlXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBPYmplY3QgLS0gY29tcG9uZW50OiBzdHJpbmdpZmllZCBjb25zdHJ1Y3RvciwgeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlclxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHN0YXR1cyBvZiB0aGUgc2V0XG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMudG9TdHJpbmcoKSA9PT0gc3RhdGUuY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuc2V0KHN0YXRlLngsIHN0YXRlLnksIHN0YXRlLnopO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIFggdHJhbnNsYXRpb25cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgTm9kZSdzIHRyYW5zbGF0aW9uIGFsb25nIGl0cyB4LWF4aXNcbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICAgIHJldHVybiB0aGlzLl94LmdldCgpO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIFkgdHJhbnNsYXRpb25cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgTm9kZSdzIHRyYW5zbGF0aW9uIGFsb25nIGl0cyBZLWF4aXNcbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuICAgIHJldHVybiB0aGlzLl95LmdldCgpO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIHogdHJhbnNsYXRpb25cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgTm9kZSdzIHRyYW5zbGF0aW9uIGFsb25nIGl0cyB6LWF4aXNcbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLmdldFogPSBmdW5jdGlvbiBnZXRaKCkge1xuICAgIHJldHVybiB0aGlzLl96LmdldCgpO1xufTtcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgUG9zaXRpb24gaXMgY3VycmVudGx5IGNoYW5naW5nXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBQb3NpdGlvbiBpcyBjaGFuZ2luZyB0aGUgTm9kZSdzIHBvc2l0aW9uXG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl94LmlzQWN0aXZlKCkgfHwgdGhpcy5feS5pc0FjdGl2ZSgpIHx8IHRoaXMuX3ouaXNBY3RpdmUoKTtcbn07XG5cbi8qKlxuICogRGVjaWRlIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBuZWVkcyB0byBiZSB1cGRhdGVkIG9uIHRoZSBuZXh0IHRpY2suXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUuX2NoZWNrVXBkYXRlID0gZnVuY3Rpb24gX2NoZWNrVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sodGhpcy5faWQpO1xuICAgIGVsc2UgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBXaGVuIHRoZSBub2RlIHRoaXMgY29tcG9uZW50IGlzIGF0dGFjaGVkIHRvIHVwZGF0ZXMsIHVwZGF0ZSB0aGUgdmFsdWVcbiAqIG9mIHRoZSBOb2RlJ3MgcG9zaXRpb25cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fbm9kZS5zZXRQb3NpdGlvbih0aGlzLl94LmdldCgpLCB0aGlzLl95LmdldCgpLCB0aGlzLl96LmdldCgpKTtcbiAgICB0aGlzLl9jaGVja1VwZGF0ZSgpO1xufTtcblxuUG9zaXRpb24ucHJvdG90eXBlLm9uVXBkYXRlID0gUG9zaXRpb24ucHJvdG90eXBlLnVwZGF0ZTtcblxuLyoqIFxuICogU2V0dGVyIGZvciBYIHBvc2l0aW9uXG4gKlxuICogQG1ldGhvZFxuICogXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsIHVzZWQgdG8gc2V0IHggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb24gb3B0aW9ucyBmb3IgdGhlIHRyYW5zaXRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgc2V0dGluZyBYIFxuICpcbiAqIEByZXR1cm4ge1Bvc2l0aW9ufSB0aGlzXG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5zZXRYID0gZnVuY3Rpb24gc2V0WCh2YWwsIHRyYW5zaXRpb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3guc2V0KHZhbCwgdHJhbnNpdGlvbiwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqIFxuICogU2V0dGVyIGZvciBZIHBvc2l0aW9uXG4gKlxuICogQG1ldGhvZFxuICogXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsIHVzZWQgdG8gc2V0IHkgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb24gb3B0aW9ucyBmb3IgdGhlIHRyYW5zaXRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgc2V0dGluZyBZIFxuICpcbiAqIEByZXR1cm4ge1Bvc2l0aW9ufSB0aGlzXG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5zZXRZID0gZnVuY3Rpb24gc2V0WSh2YWwsIHRyYW5zaXRpb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3kuc2V0KHZhbCwgdHJhbnNpdGlvbiwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqIFxuICogU2V0dGVyIGZvciBaIHBvc2l0aW9uXG4gKlxuICogQG1ldGhvZFxuICogXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsIHVzZWQgdG8gc2V0IHogY29vcmRpbmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb24gb3B0aW9ucyBmb3IgdGhlIHRyYW5zaXRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgc2V0dGluZyBaIFxuICpcbiAqIEByZXR1cm4ge1Bvc2l0aW9ufSB0aGlzXG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5zZXRaID0gZnVuY3Rpb24gc2V0Wih2YWwsIHRyYW5zaXRpb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3ouc2V0KHZhbCwgdHJhbnNpdGlvbiwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogXG4gKiBTZXR0ZXIgZm9yIFgsIFksIGFuZCBaIHBvc2l0aW9uc1xuICpcbiAqIEBtZXRob2RcbiAqIFxuICogQHBhcmFtIHtOdW1iZXJ9IHggdXNlZCB0byBzZXQgeCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge051bWJlcn0geSB1c2VkIHRvIHNldCB5IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IHVzZWQgdG8gc2V0IHogY29vcmRpbmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb24gb3B0aW9ucyBmb3IgdGhlIHRyYW5zaXRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgc2V0dGluZyBYIFxuICpcbiAqIEByZXR1cm4ge1Bvc2l0aW9ufSB0aGlzXG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoeCwgeSwgeiwgdHJhbnNpdGlvbiwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHhDYWxsYmFjaztcbiAgICB2YXIgeUNhbGxiYWNrO1xuICAgIHZhciB6Q2FsbGJhY2s7XG5cbiAgICBpZiAoeiAhPSBudWxsKSB7XG4gICAgICAgIHpDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgeUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICB4Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBpZiAoeCAhPSBudWxsKSB0aGlzLl94LnNldCh4LCB0cmFuc2l0aW9uLCB4Q2FsbGJhY2spO1xuICAgIGlmICh5ICE9IG51bGwpIHRoaXMuX3kuc2V0KHksIHRyYW5zaXRpb24sIHlDYWxsYmFjayk7XG4gICAgaWYgKHogIT0gbnVsbCkgdGhpcy5fei5zZXQoeiwgdHJhbnNpdGlvbiwgekNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdG9wcyB0cmFuc2l0aW9uIG9mIFBvc2l0aW9uIGNvbXBvbmVudFxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtQb3NpdGlvbn0gdGhpc1xuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUuaGFsdCA9IGZ1bmN0aW9uIGhhbHQoKSB7XG4gICAgdGhpcy5feC5oYWx0KCk7XG4gICAgdGhpcy5feS5oYWx0KCk7XG4gICAgdGhpcy5fei5oYWx0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvc2l0aW9uO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoYW5uZWxzIGFyZSBiZWluZyB1c2VkIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBVSSBUaHJlYWQgd2hlbiBydW5uaW5nIGluXG4gKiBhIFdlYiBXb3JrZXIgb3Igd2l0aCB0aGUgVUlNYW5hZ2VyLyBDb21wb3NpdG9yIHdoZW4gcnVubmluZyBpbiBzaW5nbGVcbiAqIHRocmVhZGVkIG1vZGUgKG5vIFdlYiBXb3JrZXIpLlxuICpcbiAqIEBjbGFzcyBDaGFubmVsXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ2hhbm5lbCgpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYud2luZG93ICE9PSBzZWxmKSB7XG4gICAgICAgIHRoaXMuX2VudGVyV29ya2VyTW9kZSgpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIENhbGxlZCBkdXJpbmcgY29uc3RydWN0aW9uLiBTdWJzY3JpYmVzIGZvciBgbWVzc2FnZWAgZXZlbnQgYW5kIHJvdXRlcyBhbGxcbiAqIGZ1dHVyZSBgc2VuZE1lc3NhZ2VgIG1lc3NhZ2VzIHRvIHRoZSBNYWluIFRocmVhZCAoXCJVSSBUaHJlYWRcIikuXG4gKlxuICogUHJpbWFyaWx5IHVzZWQgZm9yIHRlc3RpbmcuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkNoYW5uZWwucHJvdG90eXBlLl9lbnRlcldvcmtlck1vZGUgPSBmdW5jdGlvbiBfZW50ZXJXb3JrZXJNb2RlKCkge1xuICAgIHRoaXMuX3dvcmtlck1vZGUgPSB0cnVlO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gb25tZXNzYWdlKGV2KSB7XG4gICAgICAgIF90aGlzLm9uTWVzc2FnZShldi5kYXRhKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogTWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiBieSBgRmFtb3VzYC5cbiAqIEFzc2lnbmVkIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgZm9yIGV2ZXJ5IHJlY2VpdmVkIG1lc3NhZ2UuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQG92ZXJyaWRlXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuQ2hhbm5lbC5wcm90b3R5cGUub25NZXNzYWdlID0gbnVsbDtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIFVJTWFuYWdlci5cbiAqXG4gKiBAcGFyYW0gIHtBbnl9ICAgIG1lc3NhZ2UgQXJiaXRyYXJ5IG1lc3NhZ2Ugb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkNoYW5uZWwucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gc2VuZE1lc3NhZ2UgKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5fd29ya2VyTW9kZSkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNZWFudCB0byBiZSBvdmVycmlkZW4gYnkgdGhlIFVJTWFuYWdlciB3aGVuIHJ1bm5pbmcgaW4gdGhlIFVJIFRocmVhZC5cbiAqIFVzZWQgZm9yIHByZXNlcnZpbmcgQVBJIGNvbXBhdGliaWxpdHkgd2l0aCBXZWIgV29ya2Vycy5cbiAqIFdoZW4gcnVubmluZyBpbiBXZWIgV29ya2VyIG1vZGUsIHRoaXMgcHJvcGVydHkgd29uJ3QgYmUgbXV0YXRlZC5cbiAqXG4gKiBBc3NpZ25lZCBtZXRob2Qgd2lsbCBiZSBpbnZva2VkIGZvciBldmVyeSBtZXNzYWdlIHBvc3RlZCBieSBgZmFtb3VzLWNvcmVgLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBvdmVycmlkZVxuICovXG5DaGFubmVsLnByb3RvdHlwZS5vbm1lc3NhZ2UgPSBudWxsO1xuXG4vKipcbiAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbWFuYWdlciBvZiB0aGlzIGNoYW5uZWwgKHRoZSBgRmFtb3VzYCBzaW5nbGV0b24pIGJ5XG4gKiBpbnZva2luZyBgb25NZXNzYWdlYC5cbiAqIFVzZWQgZm9yIHByZXNlcnZpbmcgQVBJIGNvbXBhdGliaWxpdHkgd2l0aCBXZWIgV29ya2Vycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGFsaWFzIG9uTWVzc2FnZVxuICpcbiAqIEBwYXJhbSB7QW55fSBtZXNzYWdlIGEgbWVzc2FnZSB0byBzZW5kIG92ZXIgdGhlIGNoYW5uZWxcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5DaGFubmVsLnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5vbk1lc3NhZ2UobWVzc2FnZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5uZWw7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRXF1aXZhbGVudCBvZiBhbiBFbmdpbmUgaW4gdGhlIFdvcmtlciBUaHJlYWQuIFVzZWQgdG8gc3luY2hyb25pemUgYW5kIG1hbmFnZVxuICogdGltZSBhY3Jvc3MgZGlmZmVyZW50IFRocmVhZHMuXG4gKlxuICogQGNsYXNzICBDbG9ja1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDbG9jayAoKSB7XG4gICAgdGhpcy5fdGltZSA9IDA7XG4gICAgdGhpcy5fZnJhbWUgPSAwO1xuICAgIHRoaXMuX3RpbWVyUXVldWUgPSBbXTtcbiAgICB0aGlzLl91cGRhdGluZ0luZGV4ID0gMDtcblxuICAgIHRoaXMuX3NjYWxlID0gMTtcbiAgICB0aGlzLl9zY2FsZWRUaW1lID0gdGhpcy5fdGltZTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzY2FsZSBhdCB3aGljaCB0aGUgY2xvY2sgdGltZSBpcyBwYXNzaW5nLlxuICogVXNlZnVsIGZvciBzbG93LW1vdGlvbiBvciBmYXN0LWZvcndhcmQgZWZmZWN0cy5cbiAqXG4gKiBgMWAgbWVhbnMgbm8gdGltZSBzY2FsaW5nIChcInJlYWx0aW1lXCIpLFxuICogYDJgIG1lYW5zIHRoZSBjbG9jayB0aW1lIGlzIHBhc3NpbmcgdHdpY2UgYXMgZmFzdCxcbiAqIGAwLjVgIG1lYW5zIHRoZSBjbG9jayB0aW1lIGlzIHBhc3NpbmcgdHdvIHRpbWVzIHNsb3dlciB0aGFuIHRoZSBcImFjdHVhbFwiXG4gKiB0aW1lIGF0IHdoaWNoIHRoZSBDbG9jayBpcyBiZWluZyB1cGRhdGVkIHZpYSBgLnN0ZXBgLlxuICpcbiAqIEluaXRhbGx5IHRoZSBjbG9jayB0aW1lIGlzIG5vdCBiZWluZyBzY2FsZWQgKGZhY3RvciBgMWApLlxuICpcbiAqIEBtZXRob2QgIHNldFNjYWxlXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlICAgIFRoZSBzY2FsZSBhdCB3aGljaCB0aGUgY2xvY2sgdGltZSBpcyBwYXNzaW5nLlxuICpcbiAqIEByZXR1cm4ge0Nsb2NrfSB0aGlzXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uIHNldFNjYWxlIChzY2FsZSkge1xuICAgIHRoaXMuX3NjYWxlID0gc2NhbGU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgIGdldFNjYWxlXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZSAgICBUaGUgc2NhbGUgYXQgd2hpY2ggdGhlIGNsb2NrIHRpbWUgaXMgcGFzc2luZy5cbiAqL1xuQ2xvY2sucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9zY2FsZTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgY2xvY2sgdGltZS5cbiAqXG4gKiBAbWV0aG9kICBzdGVwXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lIGhpZ2ggcmVzb2x1dGlvbiB0aW1lc3RhbXAgdXNlZCBmb3IgaW52b2tpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYHVwZGF0ZWAgbWV0aG9kIG9uIGFsbCByZWdpc3RlcmVkIG9iamVjdHNcbiAqIEByZXR1cm4ge0Nsb2NrfSAgICAgICB0aGlzXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gc3RlcCAodGltZSkge1xuICAgIHRoaXMuX2ZyYW1lKys7XG5cbiAgICB0aGlzLl9zY2FsZWRUaW1lID0gdGhpcy5fc2NhbGVkVGltZSArICh0aW1lIC0gdGhpcy5fdGltZSkqdGhpcy5fc2NhbGU7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RpbWVyUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVyUXVldWVbaV0odGhpcy5fc2NhbGVkVGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyUXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnRlcm5hbCBjbG9jayB0aW1lLlxuICpcbiAqIEBtZXRob2QgIG5vd1xuICpcbiAqIEByZXR1cm4gIHtOdW1iZXJ9IHRpbWUgaGlnaCByZXNvbHV0aW9uIHRpbWVzdGFtcCB1c2VkIGZvciBpbnZva2luZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICBgdXBkYXRlYCBtZXRob2Qgb24gYWxsIHJlZ2lzdGVyZWQgb2JqZWN0c1xuICovXG5DbG9jay5wcm90b3R5cGUubm93ID0gZnVuY3Rpb24gbm93ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NhbGVkVGltZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW50ZXJuYWwgY2xvY2sgdGltZS5cbiAqXG4gKiBAbWV0aG9kICBnZXRUaW1lXG4gKiBAZGVwcmVjYXRlZCBVc2UgI25vdyBpbnN0ZWFkXG4gKlxuICogQHJldHVybiAge051bWJlcn0gdGltZSBoaWdoIHJlc29sdXRpb24gdGltZXN0YW1wIHVzZWQgZm9yIGludm9raW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgIGB1cGRhdGVgIG1ldGhvZCBvbiBhbGwgcmVnaXN0ZXJlZCBvYmplY3RzXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5nZXRUaW1lID0gQ2xvY2sucHJvdG90eXBlLm5vdztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZnJhbWVzIGVsYXBzZWQgc28gZmFyLlxuICpcbiAqIEBtZXRob2QgZ2V0RnJhbWVcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGZyYW1lc1xuICovXG5DbG9jay5wcm90b3R5cGUuZ2V0RnJhbWUgPSBmdW5jdGlvbiBnZXRGcmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZyYW1lO1xufTtcblxuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lLlxuICogQWZ0ZXIgYSBzZXQgZHVyYXRpb24gaGFzIHBhc3NlZCwgaXQgZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uIGFuZFxuICogcmVtb3ZlcyBpdCBhcyBhIGxpc3RlbmVyIHRvICdwcmVyZW5kZXInLlxuICpcbiAqIEBtZXRob2Qgc2V0VGltZW91dFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIHJ1biBhZnRlciBhIHNwZWNpZmllZCBkdXJhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5IG1pbGxpc2Vjb25kcyBmcm9tIG5vdyB0byBleGVjdXRlIHRoZSBmdW5jdGlvblxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aW1lciBmdW5jdGlvbiB1c2VkIGZvciBDbG9jayNjbGVhclRpbWVyXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBkZWxheSkge1xuICAgIHZhciBwYXJhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBzdGFydGVkQXQgPSB0aGlzLl90aW1lO1xuICAgIHZhciB0aW1lciA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgaWYgKHRpbWUgLSBzdGFydGVkQXQgPj0gZGVsYXkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIHBhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLl90aW1lclF1ZXVlLnB1c2godGltZXIpO1xuICAgIHJldHVybiB0aW1lcjtcbn07XG5cblxuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lLlxuICogIEFmdGVyIGEgc2V0IGR1cmF0aW9uIGhhcyBwYXNzZWQsIGl0IGV4ZWN1dGVzIHRoZSBmdW5jdGlvbiBhbmRcbiAqICByZXNldHMgdGhlIGV4ZWN1dGlvbiB0aW1lLlxuICpcbiAqIEBtZXRob2Qgc2V0SW50ZXJ2YWxcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBydW4gYWZ0ZXIgYSBzcGVjaWZpZWQgZHVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSBpbnRlcnZhbCB0byBleGVjdXRlIGZ1bmN0aW9uIGluIG1pbGxpc2Vjb25kc1xuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aW1lciBmdW5jdGlvbiB1c2VkIGZvciBDbG9jayNjbGVhclRpbWVyXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIHNldEludGVydmFsKGNhbGxiYWNrLCBkZWxheSkge1xuICAgIHZhciBwYXJhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBzdGFydGVkQXQgPSB0aGlzLl90aW1lO1xuICAgIHZhciB0aW1lciA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgaWYgKHRpbWUgLSBzdGFydGVkQXQgPj0gZGVsYXkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIHBhcmFtcyk7XG4gICAgICAgICAgICBzdGFydGVkQXQgPSB0aW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuX3RpbWVyUXVldWUucHVzaCh0aW1lcik7XG4gICAgcmV0dXJuIHRpbWVyO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHByZXZpb3VzbHkgdmlhIGBDbG9jayNzZXRUaW1lb3V0YCBvciBgQ2xvY2sjc2V0SW50ZXJ2YWxgXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCBjbGVhclRpbWVyXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IHRpbWVyICBwcmV2aW91c2x5IGJ5IGBDbG9jayNzZXRUaW1lb3V0YCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgQ2xvY2sjc2V0SW50ZXJ2YWxgIHJldHVybmVkIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtDbG9ja30gICAgICAgICAgICAgIHRoaXNcbiAqL1xuQ2xvY2sucHJvdG90eXBlLmNsZWFyVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl90aW1lclF1ZXVlLmluZGV4T2YodGltZXIpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5fdGltZXJRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvY2s7XG5cbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB0aGUgY29tbWFuZHMgaW4gb3VyIGNvbW1hbmQgcXVldWUuXG4gKi9cbnZhciBDb21tYW5kcyA9IHtcbiAgICBJTklUX0RPTTogMCxcbiAgICBET01fUkVOREVSX1NJWkU6IDEsXG4gICAgQ0hBTkdFX1RSQU5TRk9STTogMixcbiAgICBDSEFOR0VfU0laRTogMyxcbiAgICBDSEFOR0VfUFJPUEVSVFk6IDQsXG4gICAgQ0hBTkdFX0NPTlRFTlQ6IDUsXG4gICAgQ0hBTkdFX0FUVFJJQlVURTogNixcbiAgICBBRERfQ0xBU1M6IDcsXG4gICAgUkVNT1ZFX0NMQVNTOiA4LFxuICAgIFNVQlNDUklCRTogOSxcbiAgICBHTF9TRVRfRFJBV19PUFRJT05TOiAxMCxcbiAgICBHTF9BTUJJRU5UX0xJR0hUOiAxMSxcbiAgICBHTF9MSUdIVF9QT1NJVElPTjogMTIsXG4gICAgR0xfTElHSFRfQ09MT1I6IDEzLFxuICAgIE1BVEVSSUFMX0lOUFVUOiAxNCxcbiAgICBHTF9TRVRfR0VPTUVUUlk6IDE1LFxuICAgIEdMX1VOSUZPUk1TOiAxNixcbiAgICBHTF9CVUZGRVJfREFUQTogMTcsXG4gICAgR0xfQ1VUT1VUX1NUQVRFOiAxOCxcbiAgICBHTF9NRVNIX1ZJU0lCSUxJVFk6IDE5LFxuICAgIEdMX1JFTU9WRV9NRVNIOiAyMCxcbiAgICBQSU5IT0xFX1BST0pFQ1RJT046IDIxLFxuICAgIE9SVEhPR1JBUEhJQ19QUk9KRUNUSU9OOiAyMixcbiAgICBDSEFOR0VfVklFV19UUkFOU0ZPUk06IDIzLFxuICAgIFdJVEg6IDI0LFxuICAgIEZSQU1FOiAyNSxcbiAgICBFTkdJTkU6IDI2LFxuICAgIFNUQVJUOiAyNyxcbiAgICBTVE9QOiAyOCxcbiAgICBUSU1FOiAyOSxcbiAgICBUUklHR0VSOiAzMCxcbiAgICBORUVEX1NJWkVfRk9SOiAzMSxcbiAgICBET006IDMyLFxuICAgIFJFQURZOiAzMyxcbiAgICBBTExPV19ERUZBVUxUOiAzNCxcbiAgICBQUkVWRU5UX0RFRkFVTFQ6IDM1XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1hbmRzO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL0V2ZW50Jyk7XG52YXIgUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbi8qKlxuICogVGhlIERpc3BhdGNoIGNsYXNzIGlzIHVzZWQgdG8gcHJvcG9nYXRlIGV2ZW50cyBkb3duIHRoZVxuICogc2NlbmUgZ3JhcGguXG4gKlxuICogQGNsYXNzIERpc3BhdGNoXG4gKiBAcGFyYW0ge1NjZW5lfSBjb250ZXh0IFRoZSBjb250ZXh0IG9uIHdoaWNoIGl0IG9wZXJhdGVzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRGlzcGF0Y2ggKCkge1xuICAgIHRoaXMuX25vZGVzID0ge307IC8vIGEgY29udGFpbmVyIGZvciBjb25zdGFudCB0aW1lIGxvb2t1cCBvZiBub2Rlc1xuXG4gICAgdGhpcy5fcXVldWUgPSBbXTsgLy8gVGhlIHF1ZXVlIGlzIHVzZWQgZm9yIHR3byBwdXJwb3Nlc1xuICAgICAgICAgICAgICAgICAgICAgIC8vIDEuIEl0IGlzIHVzZWQgdG8gbGlzdCBpbmRpY2llcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyAgICBOb2RlcyBwYXRoIHdoaWNoIGFyZSB0aGVuIHVzZWQgdG8gbG9va3VwXG4gICAgICAgICAgICAgICAgICAgICAgLy8gICAgYSBub2RlIGluIHRoZSBzY2VuZSBncmFwaC5cbiAgICAgICAgICAgICAgICAgICAgICAvLyAyLiBJdCBpcyB1c2VkIHRvIGFzc2lzdCBkaXNwYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vICAgIHN1Y2ggdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBkbyBhIGJyZWFkdGggZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICAvLyAgICB0cmF2ZXJzYWwgb2YgdGhlIHNjZW5lIGdyYXBoLlxufVxuXG4vKipcbiAqIFByb3RlY3RlZCBtZXRob2QgdGhhdCBzZXRzIHRoZSB1cGRhdGVyIGZvciB0aGUgZGlzcGF0Y2guIFRoZSB1cGRhdGVyIHdpbGxcbiAqIGFsbW9zdCBjZXJ0YWlubHkgYmUgdGhlIEZhbW91c0VuZ2luZSBjbGFzcy5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJvdGVjdGVkXG4gKlxuICogQHBhcmFtIHtGYW1vdXNFbmdpbmV9IHVwZGF0ZXIgVGhlIHVwZGF0ZXIgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgc2NlbmUgZ3JhcGhcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5EaXNwYXRjaC5wcm90b3R5cGUuX3NldFVwZGF0ZXIgPSBmdW5jdGlvbiBfc2V0VXBkYXRlciAodXBkYXRlcikge1xuICAgIHRoaXMuX3VwZGF0ZXIgPSB1cGRhdGVyO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuX25vZGVzKSB0aGlzLl9ub2Rlc1trZXldLl9zZXRVcGRhdGVyKHVwZGF0ZXIpO1xufTtcblxuLyoqXG4gKiBFbnF1ZSB0aGUgY2hpbGRyZW4gb2YgYSBub2RlIHdpdGhpbiB0aGUgZGlzcGF0Y2hlci4gRG9lcyBub3QgY2xlYXJcbiAqIHRoZSBkaXNwYXRjaGVycyBxdWV1ZSBmaXJzdC5cbiAqXG4gKiBAbWV0aG9kIGFkZENoaWxkcmVuVG9RdWV1ZVxuICogQHJldHVybiB7dm9pZH1cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgZnJvbSB3aGljaCB0byBhZGQgY2hpbGRyZW4gdG8gdGhlIHF1ZXVlXG4gKi9cbkRpc3BhdGNoLnByb3RvdHlwZS5hZGRDaGlsZHJlblRvUXVldWUgPSBmdW5jdGlvbiBhZGRDaGlsZHJlblRvUXVldWUgKG5vZGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgdmFyIGNoaWxkO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZCkgdGhpcy5fcXVldWUucHVzaChjaGlsZCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IGl0ZW0gaW4gdGhlIERpc3BhdGNoJ3MgcXVldWUuXG4gKlxuICogQG1ldGhvZCBuZXh0XG4gKiBAcmV0dXJuIHtOb2RlfSBuZXh0IG5vZGUgaW4gdGhlIHF1ZXVlXG4gKi9cbkRpc3BhdGNoLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gbmV4dCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5leHQgbm9kZSBpbiB0aGUgcXVldWUsIGJ1dCBhbHNvIGFkZHMgaXRzIGNoaWxkcmVuIHRvXG4gKiB0aGUgZW5kIG9mIHRoZSBxdWV1ZS4gQ29udGludWFsbHkgY2FsbGluZyB0aGlzIG1ldGhvZCB3aWxsIHJlc3VsdFxuICogaW4gYSBicmVhZHRoIGZpcnN0IHRyYXZlcnNhbCBvZiB0aGUgcmVuZGVyIHRyZWUuXG4gKlxuICogQG1ldGhvZCBicmVhZHRoRmlyc3ROZXh0XG4gKiBAcmV0dXJuIHtOb2RlIHwgdW5kZWZpbmVkfSB0aGUgbmV4dCBub2RlIGluIHRoZSB0cmF2ZXJzYWwgaWYgb25lIGV4aXN0c1xuICovXG5EaXNwYXRjaC5wcm90b3R5cGUuYnJlYWR0aEZpcnN0TmV4dCA9IGZ1bmN0aW9uIGJyZWFkdGhGaXJzdE5leHQgKCkge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKCFjaGlsZCkgcmV0dXJuIHZvaWQgMDsgXG4gICAgdGhpcy5hZGRDaGlsZHJlblRvUXVldWUoY2hpbGQpO1xuICAgIHJldHVybiBjaGlsZDtcbn07XG5cbi8qKlxuICogQ2FsbHMgdGhlIG9uTW91bnQgbWV0aG9kIGZvciB0aGUgbm9kZSBhdCBhIGdpdmVuIHBhdGggYW5kXG4gKiBwcm9wZXJseSByZWdpc3RlcnMgYWxsIG9mIHRoYXQgbm9kZXMgY2hpbGRyZW4gdG8gdGhlaXIgcHJvcGVyXG4gKiBwYXRocy4gVGhyb3dzIGlmIHRoYXQgcGF0aCBkb2Vzbid0IGhhdmUgYSBub2RlIHJlZ2lzdGVyZWQgYXNcbiAqIGEgcGFyZW50IG9yIGlmIHRoZXJlIGlzIG5vIG5vZGUgcmVnaXN0ZXJlZCBhdCB0aGF0IHBhdGguXG4gKlxuICogQG1ldGhvZCBtb3VudFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGF0IHdoaWNoIHRvIGJlZ2luIG1vdW50aW5nXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgdGhlIG5vZGUgdGhhdCB3YXMgbW91bnRlZFxuICpcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbkRpc3BhdGNoLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uIG1vdW50IChwYXRoLCBub2RlKSB7XG4gICAgaWYgKCFub2RlKSB0aHJvdyBuZXcgRXJyb3IoJ0Rpc3BhdGNoOiBubyBub2RlIHBhc3NlZCB0byBtb3VudCBhdDogJyArIHBhdGgpO1xuICAgIGlmICh0aGlzLl9ub2Rlc1twYXRoXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaXNwYXRjaDogdGhlcmUgaXMgYSBub2RlIGFscmVhZHkgcmVnaXN0ZXJlZCBhdDogJyArIHBhdGgpO1xuXG4gICAgbm9kZS5fc2V0VXBkYXRlcih0aGlzLl91cGRhdGVyKTtcbiAgICB0aGlzLl9ub2Rlc1twYXRoXSA9IG5vZGU7XG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoVXRpbHMucGFyZW50KHBhdGgpO1xuXG4gICAgLy8gc2NlbmVzIGFyZSB0aGVpciBvd24gcGFyZW50c1xuICAgIHZhciBwYXJlbnQgPSAhcGFyZW50UGF0aCA/IG5vZGUgOiB0aGlzLl9ub2Rlc1twYXJlbnRQYXRoXTtcblxuICAgIGlmICghcGFyZW50KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1BhcmVudCB0byBwYXRoOiAnICsgcGF0aCArXG4gICAgICAgICAgICAgICAgJyBkb2VzblxcJ3QgZXhpc3QgYXQgZXhwZWN0ZWQgcGF0aDogJyArIHBhcmVudFBhdGhcbiAgICAgICAgKTtcblxuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IG5vZGUuZ2V0Q29tcG9uZW50cygpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBpZiAocGFyZW50LmlzTW91bnRlZCgpKSBub2RlLl9zZXRNb3VudGVkKHRydWUsIHBhdGgpO1xuICAgIGlmIChwYXJlbnQuaXNTaG93bigpKSBub2RlLl9zZXRTaG93bih0cnVlKTtcblxuICAgIGlmIChwYXJlbnQuaXNNb3VudGVkKCkpIHtcbiAgICAgICAgbm9kZS5fc2V0UGFyZW50KHBhcmVudCk7XG4gICAgICAgIGlmIChub2RlLm9uTW91bnQpIG5vZGUub25Nb3VudChwYXRoKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uTW91bnQpXG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vbk1vdW50KG5vZGUsIGkpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0gJiYgY2hpbGRyZW5baV0ubW91bnQpIGNoaWxkcmVuW2ldLm1vdW50KHBhdGggKyAnLycgKyBpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkcmVuW2ldKSB0aGlzLm1vdW50KHBhdGggKyAnLycgKyBpLCBjaGlsZHJlbltpXSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudC5pc1Nob3duKCkpIHtcbiAgICAgICAgaWYgKG5vZGUub25TaG93KSBub2RlLm9uU2hvdygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uU2hvdylcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uU2hvdygpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2FsbHMgdGhlIG9uRGlzbW91bnQgbWV0aG9kIGZvciB0aGUgbm9kZSBhdCBhIGdpdmVuIHBhdGhcbiAqIGFuZCBkZXJlZ2lzdGVycyBhbGwgb2YgdGhhdCBub2RlcyBjaGlsZHJlbi4gVGhyb3dzIGlmIHRoZXJlXG4gKiBpcyBubyBub2RlIHJlZ2lzdGVyZWQgYXQgdGhhdCBwYXRoLlxuICpcbiAqIEBtZXRob2QgZGlzbW91bnRcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggYXQgd2hpY2ggdG8gYmVnaW4gZGlzbW91bnRpbmdcbiAqL1xuRGlzcGF0Y2gucHJvdG90eXBlLmRpc21vdW50ID0gZnVuY3Rpb24gZGlzbW91bnQgKHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGVzW3BhdGhdO1xuXG4gICAgaWYgKCFub2RlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ05vIG5vZGUgcmVnaXN0ZXJlZCB0byBwYXRoOiAnICsgcGF0aFxuICAgICAgICApO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIHZhciBjb21wb25lbnRzID0gbm9kZS5nZXRDb21wb25lbnRzKCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcblxuICAgIGlmIChub2RlLmlzU2hvd24oKSkge1xuICAgICAgICBub2RlLl9zZXRTaG93bihmYWxzZSk7XG4gICAgICAgIGlmIChub2RlLm9uSGlkZSkgbm9kZS5vbkhpZGUoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vbkhpZGUpXG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vbkhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5pc01vdW50ZWQoKSkge1xuICAgICAgICBpZiAobm9kZS5vbkRpc21vdW50KSBub2RlLm9uRGlzbW91bnQocGF0aCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXSAmJiBjaGlsZHJlbltpXS5kaXNtb3VudCkgY2hpbGRyZW5baV0uZGlzbW91bnQoKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkcmVuW2ldKSB0aGlzLmRpc21vdW50KHBhdGggKyAnLycgKyBpKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uRGlzbW91bnQpXG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vbkRpc21vdW50KCk7XG5cbiAgICAgICAgbm9kZS5fc2V0TW91bnRlZChmYWxzZSk7XG4gICAgICAgIG5vZGUuX3NldFBhcmVudChudWxsKTtcbiAgICB9XG5cbiAgICB0aGlzLl9ub2Rlc1twYXRoXSA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSB0aGUgbm9kZSByZWdpc3RlcmVkIHRvIHRoZSBnaXZlbiBwYXRoLCBvciBub25lXG4gKiBpZiBubyBub2RlIGV4aXN0cyBhdCB0aGF0IHBhdGguXG4gKlxuICogQG1ldGhvZCBnZXROb2RlXG4gKiBAcmV0dXJuIHtOb2RlIHwgdm9pZH0gbm9kZSBhdCB0aGUgZ2l2ZW4gcGF0aFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGF0IHdoaWNoIHRvIGxvb2sgdXAgdGhlIG5vZGVcbiAqL1xuRGlzcGF0Y2gucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbiBnZXROb2RlIChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzW3BhdGhdO1xufTtcblxuLyoqXG4gKiBJc3N1ZXMgdGhlIG9uU2hvdyBtZXRob2QgdG8gdGhlIG5vZGUgcmVnaXN0ZXJlZCBhdCB0aGUgZ2l2ZW4gcGF0aCxcbiAqIGFuZCBzaG93cyB0aGUgZW50aXJlIHN1YnRyZWUgYmVsb3cgdGhhdCBub2RlLiBUaHJvd3MgaWYgbm8gbm9kZVxuICogaXMgcmVnaXN0ZXJlZCB0byB0aGlzIHBhdGguXG4gKlxuICogQG1ldGhvZCBzaG93XG4gKiBAcmV0dXJuIHt2b2lkfVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoIG9mIHRoZSBub2RlIHRvIHNob3dcbiAqL1xuRGlzcGF0Y2gucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93IChwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9ub2Rlc1twYXRoXTtcblxuICAgIGlmICghbm9kZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdObyBub2RlIHJlZ2lzdGVyZWQgdG8gcGF0aDogJyArIHBhdGhcbiAgICAgICAgKTtcblxuICAgIGlmIChub2RlLm9uU2hvdykgbm9kZS5vblNob3coKTtcblxuICAgIHRoaXMuYWRkQ2hpbGRyZW5Ub1F1ZXVlKG5vZGUpO1xuICAgIHZhciBjaGlsZDtcblxuICAgIHdoaWxlICgoY2hpbGQgPSB0aGlzLmJyZWFkdGhGaXJzdE5leHQoKSkpXG4gICAgICAgIHRoaXMuc2hvdyhjaGlsZC5nZXRMb2NhdGlvbigpKTtcblxufTtcblxuLyoqXG4gKiBJc3N1ZXMgdGhlIG9uSGlkZSBtZXRob2QgdG8gdGhlIG5vZGUgcmVnaXN0ZXJlZCBhdCB0aGUgZ2l2ZW4gcGF0aCxcbiAqIGFuZCBoaWRlcyB0aGUgZW50aXJlIHN1YnRyZWUgYmVsb3cgdGhhdCBub2RlLiBUaHJvd3MgaWYgbm8gbm9kZVxuICogaXMgcmVnaXN0ZXJlZCB0byB0aGlzIHBhdGguXG4gKlxuICogQG1ldGhvZCBoaWRlXG4gKiBAcmV0dXJuIHt2b2lkfVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoIG9mIHRoZSBub2RlIHRvIGhpZGVcbiAqL1xuRGlzcGF0Y2gucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiBoaWRlIChwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9ub2Rlc1twYXRoXTtcblxuICAgIGlmICghbm9kZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdObyBub2RlIHJlZ2lzdGVyZWQgdG8gcGF0aDogJyArIHBhdGhcbiAgICAgICAgKTtcblxuICAgIGlmIChub2RlLm9uSGlkZSkgbm9kZS5vbkhpZGUoKTtcblxuICAgIHRoaXMuYWRkQ2hpbGRyZW5Ub1F1ZXVlKG5vZGUpO1xuICAgIHZhciBjaGlsZDtcblxuICAgIHdoaWxlICgoY2hpbGQgPSB0aGlzLmJyZWFkdGhGaXJzdE5leHQoKSkpXG4gICAgICAgIHRoaXMuaGlkZShjaGlsZC5nZXRMb2NhdGlvbigpKTtcblxufTtcblxuLyoqXG4gKiBsb29rdXBOb2RlIHRha2VzIGEgcGF0aCBhbmQgcmV0dXJucyB0aGUgbm9kZSBhdCB0aGUgbG9jYXRpb24gc3BlY2lmaWVkXG4gKiBieSB0aGUgcGF0aCwgaWYgb25lIGV4aXN0cy4gSWYgbm90LCBpdCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbG9jYXRpb24gVGhlIGxvY2F0aW9uIG9mIHRoZSBub2RlIHNwZWNpZmllZCBieSBpdHMgcGF0aFxuICpcbiAqIEByZXR1cm4ge05vZGUgfCB1bmRlZmluZWR9IFRoZSBub2RlIGF0IHRoZSByZXF1ZXN0ZWQgcGF0aFxuICovXG5EaXNwYXRjaC5wcm90b3R5cGUubG9va3VwTm9kZSA9IGZ1bmN0aW9uIGxvb2t1cE5vZGUgKGxvY2F0aW9uKSB7XG4gICAgaWYgKCFsb2NhdGlvbikgdGhyb3cgbmV3IEVycm9yKCdsb29rdXBOb2RlIG11c3QgYmUgY2FsbGVkIHdpdGggYSBwYXRoJyk7XG5cbiAgICB0aGlzLl9xdWV1ZS5sZW5ndGggPSAwO1xuICAgIHZhciBwYXRoID0gdGhpcy5fcXVldWU7XG5cbiAgICBfc3BsaXRUbyhsb2NhdGlvbiwgcGF0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aC5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBwYXRoW2ldID0gdGhpcy5fbm9kZXNbcGF0aFtpXV07XG5cbiAgICByZXR1cm4gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xufTtcblxuLyoqXG4gKiBkaXNwYXRjaCB0YWtlcyBhbiBldmVudCBuYW1lIGFuZCBhIHBheWxvYWQgYW5kIGRpc3BhdGNoZXMgaXQgdG8gdGhlXG4gKiBlbnRpcmUgc2NlbmUgZ3JhcGggYmVsb3cgdGhlIG5vZGUgdGhhdCB0aGUgZGlzcGF0Y2hlciBpcyBvbi4gVGhlIG5vZGVzXG4gKiByZWNlaXZlIHRoZSBldmVudHMgaW4gYSBicmVhZHRoIGZpcnN0IHRyYXZlcnNhbCwgbWVhbmluZyB0aGF0IHBhcmVudHNcbiAqIGhhdmUgdGhlIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIHRoZSBldmVudCBiZWZvcmUgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggcGF0aCBvZiB0aGUgbm9kZSB0byBzZW5kIHRoZSBldmVudCB0b1xuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWUgb2YgdGhlIGV2ZW50XG4gKiBAcGFyYW0ge0FueX0gcGF5bG9hZCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnRcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5EaXNwYXRjaC5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCAocGF0aCwgZXZlbnQsIHBheWxvYWQpIHtcbiAgICBpZiAoIXBhdGgpIHRocm93IG5ldyBFcnJvcignZGlzcGF0Y2ggcmVxdWlyZXMgYSBwYXRoIGFzIGl0XFwncyBmaXJzdCBhcmd1bWVudCcpO1xuICAgIGlmICghZXZlbnQpIHRocm93IG5ldyBFcnJvcignZGlzcGF0Y2ggcmVxdWlyZXMgYW4gZXZlbnQgbmFtZSBhcyBpdFxcJ3Mgc2Vjb25kIGFyZ3VtZW50Jyk7XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGVzW3BhdGhdO1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHJlZ2lzdGVyZWQgYXQgcGF0aDogJyArIHBhdGgpO1xuXG4gICAgdGhpcy5hZGRDaGlsZHJlblRvUXVldWUobm9kZSk7XG4gICAgdmFyIGNoaWxkO1xuXG4gICAgd2hpbGUgKChjaGlsZCA9IHRoaXMuYnJlYWR0aEZpcnN0TmV4dCgpKSlcbiAgICAgICAgaWYgKGNoaWxkLm9uUmVjZWl2ZSlcbiAgICAgICAgICAgIGNoaWxkLm9uUmVjZWl2ZShldmVudCwgcGF5bG9hZCk7XG5cbn07XG5cbi8qKlxuICogZGlzcGF0Y2hVSWV2ZW50IHRha2VzIGEgcGF0aCwgYW4gZXZlbnQgbmFtZSwgYW5kIGEgcGF5bG9hZCBhbmQgZGlzcGF0Y2hlcyB0aGVtIGluXG4gKiBhIG1hbm5lciBhbm9sb2dvdXMgdG8gRE9NIGJ1YmJsaW5nLiBJdCBmaXJzdCB0cmF2ZXJzZXMgZG93biB0byB0aGUgbm9kZSBzcGVjaWZpZWQgYXRcbiAqIHRoZSBwYXRoLiBUaGF0IG5vZGUgcmVjZWl2ZXMgdGhlIGV2ZW50IGZpcnN0LCBhbmQgdGhlbiBldmVyeSBhbmNlc3RvciByZWNlaXZlcyB0aGUgZXZlbnRcbiAqIHVudGlsIHRoZSBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgdGhlIGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7QW55fSBwYXlsb2FkIHRoZSBwYXlsb2FkXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRGlzcGF0Y2gucHJvdG90eXBlLmRpc3BhdGNoVUlFdmVudCA9IGZ1bmN0aW9uIGRpc3BhdGNoVUlFdmVudCAocGF0aCwgZXZlbnQsIHBheWxvYWQpIHtcbiAgICBpZiAoIXBhdGgpIHRocm93IG5ldyBFcnJvcignZGlzcGF0Y2hVSUV2ZW50IG5lZWRzIGEgdmFsaWQgcGF0aCB0byBkaXNwYXRjaCB0bycpO1xuICAgIGlmICghZXZlbnQpIHRocm93IG5ldyBFcnJvcignZGlzcGF0Y2hVSUV2ZW50IG5lZWRzIGFuIGV2ZW50IG5hbWUgYXMgaXRzIHNlY29uZCBhcmd1bWVudCcpO1xuICAgIHZhciBub2RlO1xuXG4gICAgRXZlbnQuY2FsbChwYXlsb2FkKTtcbiAgICBub2RlID0gdGhpcy5nZXROb2RlKHBhdGgpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnQ7XG4gICAgICAgIHZhciBjb21wb25lbnRzO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbjtcblxuICAgICAgICBwYXlsb2FkLm5vZGUgPSBub2RlO1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5vblJlY2VpdmUpIG5vZGUub25SZWNlaXZlKGV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSBub2RlLmdldENvbXBvbmVudHMoKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25SZWNlaXZlKVxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uUmVjZWl2ZShldmVudCwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGlmIChwYXlsb2FkLnByb3BhZ2F0aW9uU3RvcHBlZCkgYnJlYWs7XG4gICAgICAgICAgICBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gbm9kZSkgcmV0dXJuO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogX3NwbGl0VG8gaXMgYSBwcml2YXRlIG1ldGhvZCB3aGljaCB0YWtlcyBhIHBhdGggYW5kIHNwbGl0cyBpdCBhdCBldmVyeSAnLydcbiAqIHB1c2hpbmcgdGhlIHJlc3VsdCBpbnRvIHRoZSBzdXBwbGllZCBhcnJheS4gVGhpcyBpcyBhIGRlc3RydWN0aXZlIGNoYW5nZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0aGUgc3BlY2lmaWVkIHBhdGhcbiAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldCB0aGUgYXJyYXkgdG8gd2hpY2ggdGhlIHJlc3VsdCBzaG91bGQgYmUgd3JpdHRlblxuICpcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgdGFyZ2V0IGFmdGVyIGhhdmluZyBiZWVuIHdyaXR0ZW4gdG9cbiAqL1xuZnVuY3Rpb24gX3NwbGl0VG8gKHN0cmluZywgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IDA7IC8vIGNsZWFycyB0aGUgYXJyYXkgZmlyc3QuXG4gICAgdmFyIGxhc3QgPSAwO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMCA7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cmluZ1tpXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChzdHJpbmcuc3Vic3RyaW5nKGxhc3QsIGkpKTtcbiAgICAgICAgICAgIGxhc3QgPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpIC0gbGFzdCA+IDApIHRhcmdldC5wdXNoKHN0cmluZy5zdWJzdHJpbmcobGFzdCwgaSkpO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRGlzcGF0Y2goKTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIEV2ZW50IGNsYXNzIGFkZHMgdGhlIHN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvbmFsaXR5XG4gKiB0byB0aGUgVUlFdmVudHMgd2l0aGluIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAY29uc3RydWN0b3IgRXZlbnRcbiAqL1xuZnVuY3Rpb24gRXZlbnQgKCkge1xuICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wUHJvcGFnYXRpb24gPSBzdG9wUHJvcGFnYXRpb247XG59XG5cbi8qKlxuICogc3RvcFByb3BhZ2F0aW9uIGVuZHMgdGhlIGJ1YmJsaW5nIG9mIHRoZSBldmVudCBpbiB0aGVcbiAqIHNjZW5lIGdyYXBoLlxuICpcbiAqIEBtZXRob2Qgc3RvcFByb3BhZ2F0aW9uXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uICgpIHtcbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XG5cbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENsb2NrID0gcmVxdWlyZSgnLi9DbG9jaycpO1xudmFyIFNjZW5lID0gcmVxdWlyZSgnLi9TY2VuZScpO1xudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuL0NoYW5uZWwnKTtcbnZhciBEaXNwYXRjaCA9IHJlcXVpcmUoJy4vRGlzcGF0Y2gnKTtcbnZhciBVSU1hbmFnZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlcnMvVUlNYW5hZ2VyJyk7XG52YXIgQ29tcG9zaXRvciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVycy9Db21wb3NpdG9yJyk7XG52YXIgUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcCA9IHJlcXVpcmUoJy4uL3JlbmRlci1sb29wcy9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wJyk7XG52YXIgVHJhbnNmb3JtU3lzdGVtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm1TeXN0ZW0nKTtcbnZhciBTaXplU3lzdGVtID0gcmVxdWlyZSgnLi9TaXplU3lzdGVtJyk7XG52YXIgQ29tbWFuZHMgPSByZXF1aXJlKCcuL0NvbW1hbmRzJyk7XG5cbnZhciBFTkdJTkVfU1RBUlQgPSBbQ29tbWFuZHMuRU5HSU5FLCBDb21tYW5kcy5TVEFSVF07XG52YXIgRU5HSU5FX1NUT1AgPSBbQ29tbWFuZHMuRU5HSU5FLCBDb21tYW5kcy5TVE9QXTtcbnZhciBUSU1FX1VQREFURSA9IFtDb21tYW5kcy5USU1FLCBudWxsXTtcblxuLyoqXG4gKiBGYW1vdXMgaGFzIHR3byByZXNwb25zaWJpbGl0aWVzLCBvbmUgdG8gYWN0IGFzIHRoZSBoaWdoZXN0IGxldmVsXG4gKiB1cGRhdGVyIGFuZCBhbm90aGVyIHRvIHNlbmQgbWVzc2FnZXMgb3ZlciB0byB0aGUgcmVuZGVyZXJzLiBJdCBpc1xuICogYSBzaW5nbGV0b24uXG4gKlxuICogQGNsYXNzIEZhbW91c0VuZ2luZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZhbW91c0VuZ2luZSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgRGlzcGF0Y2guX3NldFVwZGF0ZXIodGhpcyk7XG5cbiAgICB0aGlzLl91cGRhdGVRdWV1ZSA9IFtdOyAvLyBUaGUgdXBkYXRlUXVldWUgaXMgYSBwbGFjZSB3aGVyZSBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBwbGFjZSB0aGVtc2VsdmVzIGluIG9yZGVyIHRvIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlZCBvbiB0aGUgZnJhbWUuXG5cbiAgICB0aGlzLl9uZXh0VXBkYXRlUXVldWUgPSBbXTsgLy8gdGhlIG5leHRVcGRhdGVRdWV1ZSBpcyB1c2VkIHRvIHF1ZXVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgZm9yIHRoZSBuZXh0IHRpY2suXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcHJldmVudHMgaW5maW5pdGUgbG9vcHMgd2hlcmUgZHVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuIHVwZGF0ZSBhIG5vZGUgY29udGludW91c2x5IHB1dHMgaXRzZWxmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhY2sgaW4gdGhlIHVwZGF0ZSBxdWV1ZS5cblxuICAgIHRoaXMuX3NjZW5lcyA9IHt9OyAvLyBhIGhhc2ggb2YgYWxsIG9mIHRoZSBzY2VuZXMncyB0aGF0IHRoZSBGYW1vdXNFbmdpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyByZXNwb25zaWJsZSBmb3IuXG5cbiAgICB0aGlzLl9tZXNzYWdlcyA9IFRJTUVfVVBEQVRFOyAgIC8vIGEgcXVldWUgb2YgYWxsIG9mIHRoZSBkcmF3IGNvbW1hbmRzIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZW5kIHRvIHRoZSB0aGUgcmVuZGVyZXJzIHRoaXMgZnJhbWUuXG5cbiAgICB0aGlzLl9pblVwZGF0ZSA9IGZhbHNlOyAvLyB3aGVuIHRoZSBmYW1vdXMgaXMgdXBkYXRpbmcgdGhpcyBpcyB0cnVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCByZXF1ZXN0cyBmb3IgdXBkYXRlcyB3aWxsIGdldCBwdXQgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dFVwZGF0ZVF1ZXVlXG5cbiAgICB0aGlzLl9jbG9jayA9IG5ldyBDbG9jaygpOyAvLyBhIGNsb2NrIHRvIGtlZXAgdHJhY2sgb2YgdGltZSBmb3IgdGhlIHNjZW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JhcGguXG5cblxuICAgIHRoaXMuX2NoYW5uZWwgPSBuZXcgQ2hhbm5lbCgpO1xuICAgIHRoaXMuX2NoYW5uZWwub25NZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgX3RoaXMuaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9O1xufVxuXG5cbi8qKlxuICogQW4gaW5pdCBzY3JpcHQgdGhhdCBpbml0aWFsaXplcyB0aGUgRmFtb3VzRW5naW5lIHdpdGggb3B0aW9uc1xuICogb3IgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhIHNldCBvZiBvcHRpb25zIGNvbnRhaW5pbmcgYSBjb21wb3NpdG9yIGFuZCBhIHJlbmRlciBsb29wXG4gKlxuICogQHJldHVybiB7RmFtb3VzRW5naW5lfSB0aGlzXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge1xuICAgIHRoaXMuY29tcG9zaXRvciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wb3NpdG9yIHx8IG5ldyBDb21wb3NpdG9yKCk7XG4gICAgdGhpcy5yZW5kZXJMb29wID0gb3B0aW9ucyAmJiBvcHRpb25zLnJlbmRlckxvb3AgfHwgbmV3IFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AoKTtcbiAgICB0aGlzLnVpTWFuYWdlciA9IG5ldyBVSU1hbmFnZXIodGhpcy5nZXRDaGFubmVsKCksIHRoaXMuY29tcG9zaXRvciwgdGhpcy5yZW5kZXJMb29wKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY2hhbm5lbCB0aGF0IHRoZSBlbmdpbmUgd2lsbCB1c2UgdG8gY29tbXVuaWNhdGUgdG9cbiAqIHRoZSByZW5kZXJlcnMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7Q2hhbm5lbH0gY2hhbm5lbCAgICAgVGhlIGNoYW5uZWwgdG8gYmUgdXNlZCBmb3IgY29tbXVuaWNhdGluZyB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBgVUlNYW5hZ2VyYC8gYENvbXBvc2l0b3JgLlxuICpcbiAqIEByZXR1cm4ge0ZhbW91c0VuZ2luZX0gdGhpc1xuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLnNldENoYW5uZWwgPSBmdW5jdGlvbiBzZXRDaGFubmVsKGNoYW5uZWwpIHtcbiAgICB0aGlzLl9jaGFubmVsID0gY2hhbm5lbDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY2hhbm5lbCB0aGF0IHRoZSBlbmdpbmUgaXMgY3VycmVudGx5IHVzaW5nXG4gKiB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSByZW5kZXJlcnMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0NoYW5uZWx9IGNoYW5uZWwgICAgVGhlIGNoYW5uZWwgdG8gYmUgdXNlZCBmb3IgY29tbXVuaWNhdGluZyB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBgVUlNYW5hZ2VyYC8gYENvbXBvc2l0b3JgLlxuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLmdldENoYW5uZWwgPSBmdW5jdGlvbiBnZXRDaGFubmVsICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbm5lbDtcbn07XG5cbi8qKlxuICogX3VwZGF0ZSBpcyB0aGUgYm9keSBvZiB0aGUgdXBkYXRlIGxvb3AuIFRoZSBmcmFtZSBjb25zaXN0cyBvZlxuICogcHVsbGluZyBpbiBhcHBlbmRpbmcgdGhlIG5leHRVcGRhdGVRdWV1ZSB0byB0aGUgY3VycmVudFVwZGF0ZSBxdWV1ZVxuICogdGhlbiBtb3ZpbmcgdGhyb3VnaCB0aGUgdXBkYXRlUXVldWUgYW5kIGNhbGxpbmcgb25VcGRhdGUgd2l0aCB0aGUgY3VycmVudFxuICogdGltZSBvbiBhbGwgbm9kZXMuIFdoaWxlIF91cGRhdGUgaXMgY2FsbGVkIF9pblVwZGF0ZSBpcyBzZXQgdG8gdHJ1ZSBhbmRcbiAqIGFsbCByZXF1ZXN0cyB0byBiZSBwbGFjZWQgaW4gdGhlIHVwZGF0ZSBxdWV1ZSB3aWxsIGJlIGZvcndhcmRlZCB0byB0aGVcbiAqIG5leHRVcGRhdGVRdWV1ZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZSAoKSB7XG4gICAgdGhpcy5faW5VcGRhdGUgPSB0cnVlO1xuICAgIHZhciB0aW1lID0gdGhpcy5fY2xvY2subm93KCk7XG4gICAgdmFyIG5leHRRdWV1ZSA9IHRoaXMuX25leHRVcGRhdGVRdWV1ZTtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl91cGRhdGVRdWV1ZTtcbiAgICB2YXIgaXRlbTtcblxuICAgIHRoaXMuX21lc3NhZ2VzWzFdID0gdGltZTtcblxuICAgIFNpemVTeXN0ZW0udXBkYXRlKCk7XG4gICAgVHJhbnNmb3JtU3lzdGVtLm9uVXBkYXRlKCk7XG5cbiAgICB3aGlsZSAobmV4dFF1ZXVlLmxlbmd0aCkgcXVldWUudW5zaGlmdChuZXh0UXVldWUucG9wKCkpO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBpdGVtID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS51cGRhdGUpIGl0ZW0udXBkYXRlKHRpbWUpO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uVXBkYXRlKSBpdGVtLm9uVXBkYXRlKHRpbWUpO1xuICAgIH1cblxuICAgIHRoaXMuX2luVXBkYXRlID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIHJlcXVlc3RVcGRhdGVzIHRha2VzIGEgY2xhc3MgdGhhdCBoYXMgYW4gb25VcGRhdGUgbWV0aG9kIGFuZCBwdXRzIGl0XG4gKiBpbnRvIHRoZSB1cGRhdGVRdWV1ZSB0byBiZSB1cGRhdGVkIGF0IHRoZSBuZXh0IGZyYW1lLlxuICogSWYgRmFtb3VzRW5naW5lIGlzIGN1cnJlbnRseSBpbiBhbiB1cGRhdGUsIHJlcXVlc3RVcGRhdGVcbiAqIHBhc3NlcyBpdHMgYXJndW1lbnQgdG8gcmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2suXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0ZXIgYW4gb2JqZWN0IHdpdGggYW4gb25VcGRhdGUgbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5yZXF1ZXN0VXBkYXRlID0gZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZSAocmVxdWVzdGVyKSB7XG4gICAgaWYgKCFyZXF1ZXN0ZXIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdyZXF1ZXN0VXBkYXRlIG11c3QgYmUgY2FsbGVkIHdpdGggYSBjbGFzcyB0byBiZSB1cGRhdGVkJ1xuICAgICAgICApO1xuXG4gICAgaWYgKHRoaXMuX2luVXBkYXRlKSB0aGlzLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHJlcXVlc3Rlcik7XG4gICAgZWxzZSB0aGlzLl91cGRhdGVRdWV1ZS5wdXNoKHJlcXVlc3Rlcik7XG59O1xuXG4vKipcbiAqIHJlcXVlc3RVcGRhdGVPbk5leHRUaWNrIGlzIHJlcXVlc3RzIGFuIHVwZGF0ZSBvbiB0aGUgbmV4dCBmcmFtZS5cbiAqIElmIEZhbW91c0VuZ2luZSBpcyBub3QgY3VycmVudGx5IGluIGFuIHVwZGF0ZSB0aGFuIGl0IGlzIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50XG4gKiB0byByZXF1ZXN0VXBkYXRlLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzIHdoZXJlXG4gKiBhIGNsYXNzIGlzIHVwZGF0ZWQgb24gdGhlIGZyYW1lIGJ1dCBuZWVkcyB0byBiZSB1cGRhdGVkIGFnYWluIG5leHQgZnJhbWUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0ZXIgYW4gb2JqZWN0IHdpdGggYW4gb25VcGRhdGUgbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayA9IGZ1bmN0aW9uIHJlcXVlc3RVcGRhdGVPbk5leHRUaWNrIChyZXF1ZXN0ZXIpIHtcbiAgICB0aGlzLl9uZXh0VXBkYXRlUXVldWUucHVzaChyZXF1ZXN0ZXIpO1xufTtcblxuLyoqXG4gKiBwb3N0TWVzc2FnZSBzZW5kcyBhIG1lc3NhZ2UgcXVldWUgaW50byBGYW1vdXNFbmdpbmUgdG8gYmUgcHJvY2Vzc2VkLlxuICogVGhlc2UgbWVzc2FnZXMgd2lsbCBiZSBpbnRlcnByZXRlZCBhbmQgc2VudCBpbnRvIHRoZSBzY2VuZSBncmFwaFxuICogYXMgZXZlbnRzIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbWVzc2FnZXMgYW4gYXJyYXkgb2YgY29tbWFuZHMuXG4gKlxuICogQHJldHVybiB7RmFtb3VzRW5naW5lfSB0aGlzXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UgKG1lc3NhZ2VzKSB7XG4gICAgaWYgKCFtZXNzYWdlcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ29uTWVzc2FnZSBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIG1lc3NhZ2VzJ1xuICAgICAgICApO1xuXG4gICAgdmFyIGNvbW1hbmQ7XG5cbiAgICB3aGlsZSAobWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb21tYW5kID0gbWVzc2FnZXMuc2hpZnQoKTtcbiAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLldJVEg6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVXaXRoKG1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuRlJBTUU6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVGcmFtZShtZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjZWl2ZWQgdW5rbm93biBjb21tYW5kOiAnICsgY29tbWFuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIGhhbmRsZVdpdGggaXMgYSBtZXRob2QgdGhhdCB0YWtlcyBhbiBhcnJheSBvZiBtZXNzYWdlcyBmb2xsb3dpbmcgdGhlXG4gKiBXSVRIIGNvbW1hbmQuIEl0J2xsIHRoZW4gaXNzdWUgdGhlIG5leHQgY29tbWFuZHMgdG8gdGhlIHBhdGggc3BlY2lmaWVkXG4gKiBieSB0aGUgV0lUSCBjb21tYW5kLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBtZXNzYWdlcyBhcnJheSBvZiBtZXNzYWdlcy5cbiAqXG4gKiBAcmV0dXJuIHtGYW1vdXNFbmdpbmV9IHRoaXNcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5oYW5kbGVXaXRoID0gZnVuY3Rpb24gaGFuZGxlV2l0aCAobWVzc2FnZXMpIHtcbiAgICB2YXIgcGF0aCA9IG1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgdmFyIGNvbW1hbmQgPSBtZXNzYWdlcy5zaGlmdCgpO1xuICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICBjYXNlIENvbW1hbmRzLlRSSUdHRVI6IC8vIHRoZSBUUklHR0VSIGNvbW1hbmQgc2VuZHMgYSBVSUV2ZW50IHRvIHRoZSBzcGVjaWZpZWQgcGF0aFxuICAgICAgICAgICAgdmFyIHR5cGUgPSBtZXNzYWdlcy5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIGV2ID0gbWVzc2FnZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIERpc3BhdGNoLmRpc3BhdGNoVUlFdmVudChwYXRoLCB0eXBlLCBldik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjZWl2ZWQgdW5rbm93biBjb21tYW5kOiAnICsgY29tbWFuZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBoYW5kbGVGcmFtZSBpcyBjYWxsZWQgd2hlbiB0aGUgcmVuZGVyZXJzIGlzc3VlIGEgRlJBTUUgY29tbWFuZCB0b1xuICogRmFtb3VzRW5naW5lLiBGYW1vdXNFbmdpbmUgd2lsbCB0aGVuIHN0ZXAgdXBkYXRpbmcgdGhlIHNjZW5lIGdyYXBoIHRvIHRoZSBjdXJyZW50IHRpbWUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IG1lc3NhZ2VzIGFycmF5IG9mIG1lc3NhZ2VzLlxuICpcbiAqIEByZXR1cm4ge0ZhbW91c0VuZ2luZX0gdGhpc1xuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLmhhbmRsZUZyYW1lID0gZnVuY3Rpb24gaGFuZGxlRnJhbWUgKG1lc3NhZ2VzKSB7XG4gICAgaWYgKCFtZXNzYWdlcykgdGhyb3cgbmV3IEVycm9yKCdoYW5kbGVGcmFtZSBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIG1lc3NhZ2VzJyk7XG4gICAgaWYgKCFtZXNzYWdlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignRlJBTUUgbXVzdCBiZSBzZW50IHdpdGggYSB0aW1lJyk7XG5cbiAgICB0aGlzLnN0ZXAobWVzc2FnZXMuc2hpZnQoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIHN0ZXAgdXBkYXRlcyB0aGUgY2xvY2sgYW5kIHRoZSBzY2VuZSBncmFwaCBhbmQgdGhlbiBzZW5kcyB0aGUgZHJhdyBjb21tYW5kc1xuICogdGhhdCBhY2N1bXVsYXRlZCBpbiB0aGUgdXBkYXRlIHRvIHRoZSByZW5kZXJlcnMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIGN1cnJlbnQgZW5naW5lIHRpbWVcbiAqXG4gKiBAcmV0dXJuIHtGYW1vdXNFbmdpbmV9IHRoaXNcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gc3RlcCAodGltZSkge1xuICAgIGlmICh0aW1lID09IG51bGwpIHRocm93IG5ldyBFcnJvcignc3RlcCBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgdGltZScpO1xuXG4gICAgdGhpcy5fY2xvY2suc3RlcCh0aW1lKTtcbiAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgIGlmICh0aGlzLl9tZXNzYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fY2hhbm5lbC5zZW5kTWVzc2FnZSh0aGlzLl9tZXNzYWdlcyk7XG4gICAgICAgIHdoaWxlICh0aGlzLl9tZXNzYWdlcy5sZW5ndGggPiAyKSB0aGlzLl9tZXNzYWdlcy5wb3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogcmV0dXJucyB0aGUgY29udGV4dCBvZiBhIHBhcnRpY3VsYXIgcGF0aC4gVGhlIGNvbnRleHQgaXMgbG9va2VkIHVwIGJ5IHRoZSBzZWxlY3RvclxuICogcG9ydGlvbiBvZiB0aGUgcGF0aCBhbmQgaXMgbGlzdGVkIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzdHJpbmcgdG8gdGhlIGZpcnN0XG4gKiAnLycuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciB0aGUgcGF0aCB0byBsb29rIHVwIHRoZSBjb250ZXh0IGZvci5cbiAqXG4gKiBAcmV0dXJuIHtDb250ZXh0IHwgVW5kZWZpbmVkfSB0aGUgY29udGV4dCBpZiBmb3VuZCwgZWxzZSB1bmRlZmluZWQuXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldENvbnRleHQgKHNlbGVjdG9yKSB7XG4gICAgaWYgKCFzZWxlY3RvcikgdGhyb3cgbmV3IEVycm9yKCdnZXRDb250ZXh0IG11c3QgYmUgY2FsbGVkIHdpdGggYSBzZWxlY3RvcicpO1xuXG4gICAgdmFyIGluZGV4ID0gc2VsZWN0b3IuaW5kZXhPZignLycpO1xuICAgIHNlbGVjdG9yID0gaW5kZXggPT09IC0xID8gc2VsZWN0b3IgOiBzZWxlY3Rvci5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3NjZW5lc1tzZWxlY3Rvcl07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGNsb2NrIHVzZWQgYnkgdGhlIEZhbW91c0VuZ2luZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7Q2xvY2t9IEZhbW91c0VuZ2luZSdzIGNsb2NrXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuZ2V0Q2xvY2sgPSBmdW5jdGlvbiBnZXRDbG9jayAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb2NrO1xufTtcblxuLyoqXG4gKiBFbnF1ZXVlcyBhIG1lc3NhZ2UgdG8gYmUgdHJhbnNmZXJlZCB0byB0aGUgcmVuZGVyZXJzLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge0FueX0gY29tbWFuZCBEcmF3IENvbW1hbmRcbiAqXG4gKiBAcmV0dXJuIHtGYW1vdXNFbmdpbmV9IHRoaXNcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5tZXNzYWdlID0gZnVuY3Rpb24gbWVzc2FnZSAoY29tbWFuZCkge1xuICAgIHRoaXMuX21lc3NhZ2VzLnB1c2goY29tbWFuZCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzY2VuZSB1bmRlciB3aGljaCBhIHNjZW5lIGdyYXBoIGNvdWxkIGJlIGJ1aWx0LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgYSBkb20gc2VsZWN0b3IgZm9yIHdoZXJlIHRoZSBzY2VuZSBzaG91bGQgYmUgcGxhY2VkXG4gKlxuICogQHJldHVybiB7U2NlbmV9IGEgbmV3IGluc3RhbmNlIG9mIFNjZW5lLlxuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLmNyZWF0ZVNjZW5lID0gZnVuY3Rpb24gY3JlYXRlU2NlbmUgKHNlbGVjdG9yKSB7XG4gICAgc2VsZWN0b3IgPSBzZWxlY3RvciB8fCAnYm9keSc7XG5cbiAgICBpZiAodGhpcy5fc2NlbmVzW3NlbGVjdG9yXSkgdGhpcy5fc2NlbmVzW3NlbGVjdG9yXS5kaXNtb3VudCgpO1xuICAgIHRoaXMuX3NjZW5lc1tzZWxlY3Rvcl0gPSBuZXcgU2NlbmUoc2VsZWN0b3IsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9zY2VuZXNbc2VsZWN0b3JdO1xufTtcblxuLyoqXG4gKiBJbnRyb2R1Y2UgYW4gYWxyZWFkeSBpbnN0YW50aWF0ZWQgc2NlbmUgdG8gdGhlIGVuZ2luZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgdGhlIHNjZW5lIHRvIHJlaW50cm9kdWNlIHRvIHRoZSBlbmdpbmVcbiAqXG4gKiBAcmV0dXJuIHtGYW1vdXNFbmdpbmV9IHRoaXNcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5hZGRTY2VuZSA9IGZ1bmN0aW9uIGFkZFNjZW5lIChzY2VuZSkge1xuICAgIHZhciBzZWxlY3RvciA9IHNjZW5lLl9zZWxlY3RvcjtcblxuICAgIHZhciBjdXJyZW50ID0gdGhpcy5fc2NlbmVzW3NlbGVjdG9yXTtcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBzY2VuZSkgY3VycmVudC5kaXNtb3VudCgpO1xuICAgIGlmICghc2NlbmUuaXNNb3VudGVkKCkpIHNjZW5lLm1vdW50KCk7XG4gICAgdGhpcy5fc2NlbmVzW3NlbGVjdG9yXSA9IHNjZW5lO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBzY2VuZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgdGhlIHNjZW5lIHRvIHJlbW92ZSBmcm9tIHRoZSBlbmdpbmVcbiAqXG4gKiBAcmV0dXJuIHtGYW1vdXNFbmdpbmV9IHRoaXNcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5yZW1vdmVTY2VuZSA9IGZ1bmN0aW9uIHJlbW92ZVNjZW5lIChzY2VuZSkge1xuICAgIHZhciBzZWxlY3RvciA9IHNjZW5lLl9zZWxlY3RvcjtcblxuICAgIHZhciBjdXJyZW50ID0gdGhpcy5fc2NlbmVzW3NlbGVjdG9yXTtcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50ID09PSBzY2VuZSkge1xuICAgICAgICBpZiAoc2NlbmUuaXNNb3VudGVkKCkpIHNjZW5lLmRpc21vdW50KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zY2VuZXNbc2VsZWN0b3JdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnRzIHRoZSBlbmdpbmUgcnVubmluZyBpbiB0aGUgTWFpbi1UaHJlYWQuXG4gKiBUaGlzIGVmZmVjdHMgKipldmVyeSoqIHVwZGF0ZWFibGUgbWFuYWdlZCBieSB0aGUgRW5naW5lLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtGYW1vdXNFbmdpbmV9IHRoaXNcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5zdGFydFJlbmRlckxvb3AgPSBmdW5jdGlvbiBzdGFydFJlbmRlckxvb3AoKSB7XG4gICAgdGhpcy5fY2hhbm5lbC5zZW5kTWVzc2FnZShFTkdJTkVfU1RBUlQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdG9wcyB0aGUgZW5naW5lIHJ1bm5pbmcgaW4gdGhlIE1haW4tVGhyZWFkLlxuICogVGhpcyBlZmZlY3RzICoqZXZlcnkqKiB1cGRhdGVhYmxlIG1hbmFnZWQgYnkgdGhlIEVuZ2luZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7RmFtb3VzRW5naW5lfSB0aGlzXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuc3RvcFJlbmRlckxvb3AgPSBmdW5jdGlvbiBzdG9wUmVuZGVyTG9vcCgpIHtcbiAgICB0aGlzLl9jaGFubmVsLnNlbmRNZXNzYWdlKEVOR0lORV9TVE9QKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQG1ldGhvZFxuICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBGYW1vdXNFbmdpbmUjc3RhcnRSZW5kZXJMb29wfSBpbnN0ZWFkIVxuICpcbiAqIEByZXR1cm4ge0ZhbW91c0VuZ2luZX0gdGhpc1xuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLnN0YXJ0RW5naW5lID0gZnVuY3Rpb24gc3RhcnRFbmdpbmUoKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgICAnRmFtb3VzRW5naW5lLnN0YXJ0RW5naW5lIGlzIGRlcHJlY2F0ZWQhIFVzZSAnICtcbiAgICAgICAgJ0ZhbW91c0VuZ2luZS5zdGFydFJlbmRlckxvb3AgaW5zdGVhZCEnXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5zdGFydFJlbmRlckxvb3AoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZFxuICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBGYW1vdXNFbmdpbmUjc3RvcFJlbmRlckxvb3B9IGluc3RlYWQhXG4gKlxuICogQHJldHVybiB7RmFtb3VzRW5naW5lfSB0aGlzXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuc3RvcEVuZ2luZSA9IGZ1bmN0aW9uIHN0b3BFbmdpbmUoKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgICAnRmFtb3VzRW5naW5lLnN0b3BFbmdpbmUgaXMgZGVwcmVjYXRlZCEgVXNlICcgK1xuICAgICAgICAnRmFtb3VzRW5naW5lLnN0b3BSZW5kZXJMb29wIGluc3RlYWQhJ1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuc3RvcFJlbmRlckxvb3AoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEZhbW91c0VuZ2luZSgpO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2hpbnQgLVcwNzkgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2l6ZVN5c3RlbSA9IHJlcXVpcmUoJy4vU2l6ZVN5c3RlbScpO1xudmFyIERpc3BhdGNoID0gcmVxdWlyZSgnLi9EaXNwYXRjaCcpO1xudmFyIFRyYW5zZm9ybVN5c3RlbSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtU3lzdGVtJyk7XG52YXIgU2l6ZSA9IHJlcXVpcmUoJy4vU2l6ZScpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbi8qKlxuICogTm9kZXMgZGVmaW5lIGhpZXJhcmNoeSBhbmQgZ2VvbWV0cmljYWwgdHJhbnNmb3JtYXRpb25zLiBUaGV5IGNhbiBiZSBtb3ZlZFxuICogKHRyYW5zbGF0ZWQpLCBzY2FsZWQgYW5kIHJvdGF0ZWQuXG4gKlxuICogQSBOb2RlIGlzIGVpdGhlciBtb3VudGVkIG9yIHVubW91bnRlZC4gVW5tb3VudGVkIG5vZGVzIGFyZSBkZXRhY2hlZCBmcm9tIHRoZVxuICogc2NlbmUgZ3JhcGguIFVubW91bnRlZCBub2RlcyBoYXZlIG5vIHBhcmVudCBub2RlLCB3aGlsZSBlYWNoIG1vdW50ZWQgbm9kZSBoYXNcbiAqIGV4YWN0bHkgb25lIHBhcmVudC4gTm9kZXMgaGF2ZSBhbiBhcmJpdGFyeSBudW1iZXIgb2YgY2hpbGRyZW4sIHdoaWNoIGNhbiBiZVxuICogZHluYW1pY2FsbHkgYWRkZWQgdXNpbmcge0BsaW5rIE5vZGUjYWRkQ2hpbGR9LlxuICpcbiAqIEVhY2ggTm9kZSBoYXMgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBgY29tcG9uZW50c2AuIFRob3NlIGNvbXBvbmVudHMgY2FuXG4gKiBzZW5kIGBkcmF3YCBjb21tYW5kcyB0byB0aGUgcmVuZGVyZXIgb3IgbXV0YXRlIHRoZSBub2RlIGl0c2VsZiwgaW4gd2hpY2ggY2FzZVxuICogdGhleSBkZWZpbmUgYmVoYXZpb3IgaW4gdGhlIG1vc3QgZXhwbGljaXQgd2F5LiBDb21wb25lbnRzIHRoYXQgc2VuZCBgZHJhd2BcbiAqIGNvbW1hbmRzIGFyZSBjb25zaWRlcmVkIGByZW5kZXJhYmxlc2AuIEZyb20gdGhlIG5vZGUncyBwZXJzcGVjdGl2ZSwgdGhlcmUgaXNcbiAqIG5vIGRpc3RpbmN0aW9uIGJldHdlZW4gbm9kZXMgdGhhdCBzZW5kIGRyYXcgY29tbWFuZHMgYW5kIG5vZGVzIHRoYXQgZGVmaW5lXG4gKiBiZWhhdmlvci5cbiAqXG4gKiBCZWNhdXNlIG9mIHRoZSBmYWN0IHRoYXQgTm9kZXMgdGhlbXNlbGYgYXJlIHZlcnkgdW5vcGluaW90ZWQgKHRoZXkgZG9uJ3RcbiAqIFwicmVuZGVyXCIgdG8gYW55dGhpbmcpLCB0aGV5IGFyZSBvZnRlbiBiZWluZyBzdWJjbGFzc2VkIGluIG9yZGVyIHRvIGFkZCBlLmcuXG4gKiBjb21wb25lbnRzIGF0IGluaXRpYWxpemF0aW9uIHRvIHRoZW0uIEJlY2F1c2Ugb2YgdGhpcyBmbGV4aWJpbGl0eSwgdGhleSBtaWdodFxuICogYXMgd2VsbCBoYXZlIGJlZW4gY2FsbGVkIGBFbnRpdGllc2AuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGNyZWF0ZSB0aHJlZSBkZXRhY2hlZCAodW5tb3VudGVkKSBub2Rlc1xuICogdmFyIHBhcmVudCA9IG5ldyBOb2RlKCk7XG4gKiB2YXIgY2hpbGQxID0gbmV3IE5vZGUoKTtcbiAqIHZhciBjaGlsZDIgPSBuZXcgTm9kZSgpO1xuICpcbiAqIC8vIGJ1aWxkIGFuIHVubW91bnRlZCBzdWJ0cmVlIChwYXJlbnQgaXMgc3RpbGwgZGV0YWNoZWQpXG4gKiBwYXJlbnQuYWRkQ2hpbGQoY2hpbGQxKTtcbiAqIHBhcmVudC5hZGRDaGlsZChjaGlsZDIpO1xuICpcbiAqIC8vIG1vdW50IHBhcmVudCBieSBhZGRpbmcgaXQgdG8gdGhlIGNvbnRleHRcbiAqIHZhciBjb250ZXh0ID0gRmFtb3VzLmNyZWF0ZUNvbnRleHQoXCJib2R5XCIpO1xuICogY29udGV4dC5hZGRDaGlsZChwYXJlbnQpO1xuICpcbiAqIEBjbGFzcyBOb2RlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTm9kZSAoKSB7XG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX2luVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fbW91bnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Nob3duID0gZmFsc2U7XG4gICAgdGhpcy5fdXBkYXRlciA9IG51bGw7XG4gICAgdGhpcy5fb3BhY2l0eSA9IDE7XG4gICAgdGhpcy5fVUlFdmVudHMgPSBbXTtcblxuICAgIHRoaXMuX3VwZGF0ZVF1ZXVlID0gW107XG4gICAgdGhpcy5fbmV4dFVwZGF0ZVF1ZXVlID0gW107XG5cbiAgICB0aGlzLl9mcmVlZENvbXBvbmVudEluZGljaWVzID0gW107XG4gICAgdGhpcy5fY29tcG9uZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fZnJlZWRDaGlsZEluZGljaWVzID0gW107XG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcblxuICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG5cbiAgICB0aGlzLl9pZCA9IG51bGw7XG5cbiAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IG51bGw7XG4gICAgdGhpcy5fc2l6ZUlEID0gbnVsbDtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLklOSVRfREVGQVVMVF9DT01QT05FTlRTKSB0aGlzLl9pbml0KCk7XG59XG5cbk5vZGUuUkVMQVRJVkVfU0laRSA9IDA7XG5Ob2RlLkFCU09MVVRFX1NJWkUgPSAxO1xuTm9kZS5SRU5ERVJfU0laRSA9IDI7XG5Ob2RlLkRFRkFVTFRfU0laRSA9IDA7XG5Ob2RlLklOSVRfREVGQVVMVF9DT01QT05FTlRTID0gdHJ1ZTtcblxuLyoqXG4gKiBQcm90ZWN0ZWQgbWV0aG9kLiBJbml0aWFsaXplcyBhIG5vZGUgd2l0aCBhIGRlZmF1bHQgVHJhbnNmb3JtIGFuZCBTaXplIGNvbXBvbmVudFxuICpcbiAqIEBtZXRob2RcbiAqIEBwcm90ZWN0ZWRcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5Ob2RlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIF9pbml0ICgpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IHRoaXMuYWRkQ29tcG9uZW50KG5ldyBUcmFuc2Zvcm0oKSk7XG4gICAgdGhpcy5fc2l6ZUlEID0gdGhpcy5hZGRDb21wb25lbnQobmV3IFNpemUoKSk7XG59O1xuXG4vKipcbiAqIFByb3RlY3RlZCBtZXRob2QuIFNldHMgdGhlIHBhcmVudCBvZiB0aGlzIG5vZGUgc3VjaCB0aGF0IGl0IGNhbiBiZSBsb29rZWQgdXAuXG4gKlxuICogQG1ldGhvZFxuICogXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudCBUaGUgbm9kZSB0byBzZXQgYXMgdGhlIHBhcmVudCBvZiB0aGlzXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWQ7XG4gKi9cbk5vZGUucHJvdG90eXBlLl9zZXRQYXJlbnQgPSBmdW5jdGlvbiBfc2V0UGFyZW50IChwYXJlbnQpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5nZXRDaGlsZHJlbigpLmluZGV4T2YodGhpcykgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX3BhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xufTtcblxuLyoqXG4gKiBQcm90ZWN0ZWQgbWV0aG9kLiBTZXRzIHRoZSBtb3VudCBzdGF0ZSBvZiB0aGUgbm9kZS4gU2hvdWxkIG9ubHkgYmUgY2FsbGVkXG4gKiBieSB0aGUgZGlzcGF0Y2hcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBtb3VudGVkIHdoZXRoZXIgb3Igbm90IHRoZSBOb2RlIGlzIG1vdW50ZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCB0aGF0IHRoZSBub2RlIHdpbGwgYmUgbW91bnRlZCB0b1xuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbk5vZGUucHJvdG90eXBlLl9zZXRNb3VudGVkID0gZnVuY3Rpb24gX3NldE1vdW50ZWQgKG1vdW50ZWQsIHBhdGgpIHtcbiAgICB0aGlzLl9tb3VudGVkID0gbW91bnRlZDtcbiAgICB0aGlzLl9pZCA9IHBhdGggPyBwYXRoIDogbnVsbDtcbn07XG5cbi8qKlxuICogUHJvdGVjdGVkIG1ldGhvZCwgc2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgTm9kZSBpcyBzaG93bi4gU2hvdWxkIG9ubHlcbiAqIGJlIGNhbGxlZCBieSB0aGUgZGlzcGF0Y2hcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBzaG93biB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBzaG93blxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbk5vZGUucHJvdG90eXBlLl9zZXRTaG93biA9IGZ1bmN0aW9uIF9zZXRTaG93biAoc2hvd24pIHtcbiAgICB0aGlzLl9zaG93biA9IHNob3duO1xufTtcblxuLyoqXG4gKiBQcm90ZWN0ZWQgbWV0aG9kLiBTZXRzIHRoZSB1cGRhdGVyIG9mIHRoZSBub2RlLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge0ZhbW91c0VuZ2luZX0gdXBkYXRlciB0aGUgVXBkYXRlciBvZiB0aGUgbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5Ob2RlLnByb3RvdHlwZS5fc2V0VXBkYXRlciA9IGZ1bmN0aW9uIF9zZXRVcGRhdGVyICh1cGRhdGVyKSB7XG4gICAgdGhpcy5fdXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3VwZGF0ZXIucmVxdWVzdFVwZGF0ZSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBub2RlJ3MgbG9jYXRpb24gaW4gdGhlIHNjZW5lIGdyYXBoIGhpZXJhcmNoeS5cbiAqIEEgbG9jYXRpb24gb2YgYGJvZHkvMC8xYCBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgdGhlIGZvbGxvd2luZyBzY2VuZSBncmFwaFxuICogaGllcmFyY2h5IChpZ25vcmluZyBzaWJsaW5ncyBvZiBhbmNlc3RvcnMgYW5kIGFkZGl0aW9uYWwgY2hpbGQgbm9kZXMpOlxuICpcbiAqIGBDb250ZXh0OmJvZHlgIC0+IGBOb2RlOjBgIC0+IGBOb2RlOjFgLCB3aGVyZSBgTm9kZToxYCBpcyB0aGUgbm9kZSB0aGVcbiAqIGBnZXRMb2NhdGlvbmAgbWV0aG9kIGhhcyBiZWVuIGludm9rZWQgb24uXG4gKlxuICogQG1ldGhvZCBnZXRMb2NhdGlvblxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gbG9jYXRpb24gKHBhdGgpLCBlLmcuIGBib2R5LzAvMWBcbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xufTtcblxuLyoqXG4gKiBAYWxpYXMgZ2V0SWRcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBwYXRoIG9mIHRoZSBOb2RlXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldElkID0gTm9kZS5wcm90b3R5cGUuZ2V0TG9jYXRpb247XG5cbi8qKlxuICogR2xvYmFsbHkgZGlzcGF0Y2hlcyB0aGUgZXZlbnQgdXNpbmcgdGhlIERpc3BhdGNoLiBBbGwgZGVzY2VuZGVudCBub2RlcyB3aWxsXG4gKiByZWNlaXZlIHRoZSBkaXNwYXRjaGVkIGV2ZW50LlxuICpcbiAqIEBtZXRob2QgZW1pdFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnQgICBFdmVudCB0eXBlLlxuICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkIEV2ZW50IG9iamVjdCB0byBiZSBkaXNwYXRjaGVkLlxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQgKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgRGlzcGF0Y2guZGlzcGF0Y2godGhpcy5nZXRMb2NhdGlvbigpLCBldmVudCwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBUSElTIFdJTEwgQkUgREVQUkVDQVRFRFxuTm9kZS5wcm90b3R5cGUuc2VuZERyYXdDb21tYW5kID0gZnVuY3Rpb24gc2VuZERyYXdDb21tYW5kIChtZXNzYWdlKSB7XG4gICAgdGhpcy5fdXBkYXRlci5tZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIHRoZSBOb2RlLCBpbmNsdWRpbmcgYWxsIHByZXZpb3VzbHkgYWRkZWQgY29tcG9uZW50cy5cbiAqXG4gKiBAbWV0aG9kIGdldFZhbHVlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSAgICAgU2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbm9kZSwgaW5jbHVkaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlICgpIHtcbiAgICB2YXIgbnVtYmVyT2ZDaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgICB2YXIgbnVtYmVyT2ZDb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuIFxuICAgIHZhciB2YWx1ZSA9IHtcbiAgICAgICAgbG9jYXRpb246IHRoaXMuZ2V0SWQoKSxcbiAgICAgICAgc3BlYzoge1xuICAgICAgICAgICAgbG9jYXRpb246IHRoaXMuZ2V0SWQoKSxcbiAgICAgICAgICAgIHNob3dTdGF0ZToge1xuICAgICAgICAgICAgICAgIG1vdW50ZWQ6IHRoaXMuaXNNb3VudGVkKCksXG4gICAgICAgICAgICAgICAgc2hvd246IHRoaXMuaXNTaG93bigpLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMuZ2V0T3BhY2l0eSgpIHx8IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvZmZzZXRzOiB7XG4gICAgICAgICAgICAgICAgbW91bnRQb2ludDogWzAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIGFsaWduOiBbMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBbMCwgMCwgMF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2ZWN0b3JzOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFswLCAwLCAwXSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogWzAsIDAsIDAsIDFdLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBbMSwgMSwgMV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICAgICAgc2l6ZU1vZGU6IFswLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBwcm9wb3J0aW9uYWw6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgICAgICBkaWZmZXJlbnRpYWw6IFswLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZTogWzAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIHJlbmRlcjogWzAsIDAsIDBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFVJRXZlbnRzOiB0aGlzLl9VSUV2ZW50cyxcbiAgICAgICAgY29tcG9uZW50czogW10sXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH07XG4gICAgXG4gICAgaWYgKHZhbHVlLmxvY2F0aW9uKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm1TeXN0ZW0uZ2V0KHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHZhciBzaXplID0gU2l6ZVN5c3RlbS5nZXQodGhpcy5nZXRJZCgpKTtcblxuICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IDMgOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlLnNwZWMub2Zmc2V0cy5tb3VudFBvaW50W2ldID0gdHJhbnNmb3JtLm9mZnNldHMubW91bnRQb2ludFtpXTtcbiAgICAgICAgICAgIHZhbHVlLnNwZWMub2Zmc2V0cy5hbGlnbltpXSA9IHRyYW5zZm9ybS5vZmZzZXRzLmFsaWduW2ldO1xuICAgICAgICAgICAgdmFsdWUuc3BlYy5vZmZzZXRzLm9yaWdpbltpXSA9IHRyYW5zZm9ybS5vZmZzZXRzLm9yaWdpbltpXTtcbiAgICAgICAgICAgIHZhbHVlLnNwZWMudmVjdG9ycy5wb3NpdGlvbltpXSA9IHRyYW5zZm9ybS52ZWN0b3JzLnBvc2l0aW9uW2ldO1xuICAgICAgICAgICAgdmFsdWUuc3BlYy52ZWN0b3JzLnJvdGF0aW9uW2ldID0gdHJhbnNmb3JtLnZlY3RvcnMucm90YXRpb25baV07XG4gICAgICAgICAgICB2YWx1ZS5zcGVjLnZlY3RvcnMuc2NhbGVbaV0gPSB0cmFuc2Zvcm0udmVjdG9ycy5zY2FsZVtpXTtcbiAgICAgICAgICAgIHZhbHVlLnNwZWMuc2l6ZS5zaXplTW9kZVtpXSA9IHNpemUuc2l6ZU1vZGVbaV07XG4gICAgICAgICAgICB2YWx1ZS5zcGVjLnNpemUucHJvcG9ydGlvbmFsW2ldID0gc2l6ZS5wcm9wb3J0aW9uYWxTaXplW2ldO1xuICAgICAgICAgICAgdmFsdWUuc3BlYy5zaXplLmRpZmZlcmVudGlhbFtpXSA9IHNpemUuZGlmZmVyZW50aWFsU2l6ZVtpXTtcbiAgICAgICAgICAgIHZhbHVlLnNwZWMuc2l6ZS5hYnNvbHV0ZVtpXSA9IHNpemUuYWJzb2x1dGVTaXplW2ldO1xuICAgICAgICAgICAgdmFsdWUuc3BlYy5zaXplLnJlbmRlcltpXSA9IHNpemUucmVuZGVyU2l6ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlLnNwZWMudmVjdG9ycy5yb3RhdGlvblszXSA9IHRyYW5zZm9ybS52ZWN0b3JzLnJvdGF0aW9uWzNdO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBudW1iZXJPZkNoaWxkcmVuIDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW5baV0gJiYgdGhpcy5fY2hpbGRyZW5baV0uZ2V0VmFsdWUpXG4gICAgICAgICAgICB2YWx1ZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2NoaWxkcmVuW2ldLmdldFZhbHVlKCkpO1xuXG4gICAgZm9yIChpID0gMCA7IGkgPCBudW1iZXJPZkNvbXBvbmVudHMgOyBpKyspXG4gICAgICAgIGlmICh0aGlzLl9jb21wb25lbnRzW2ldICYmIHRoaXMuX2NvbXBvbmVudHNbaV0uZ2V0VmFsdWUpXG4gICAgICAgICAgICB2YWx1ZS5jb21wb25lbnRzLnB1c2godGhpcy5fY29tcG9uZW50c1tpXS5nZXRWYWx1ZSgpKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogU2ltaWxhciB0byB7QGxpbmsgTm9kZSNnZXRWYWx1ZX0sIGJ1dCByZXR1cm5zIHRoZSBhY3R1YWwgXCJjb21wdXRlZFwiIHZhbHVlLiBFLmcuXG4gKiBhIHByb3BvcnRpb25hbCBzaXplIG9mIDAuNSBtaWdodCByZXNvbHZlIGludG8gYSBcImNvbXB1dGVkXCIgc2l6ZSBvZiAyMDBweFxuICogKGFzc3VtaW5nIHRoZSBwYXJlbnQgaGFzIGEgd2lkdGggb2YgNDAwcHgpLlxuICpcbiAqIEBtZXRob2QgZ2V0Q29tcHV0ZWRWYWx1ZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gICAgIFNlcmlhbGl6ZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5vZGUsIGluY2x1ZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4sIGV4Y2x1ZGluZyBjb21wb25lbnRzLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRDb21wdXRlZFZhbHVlID0gZnVuY3Rpb24gZ2V0Q29tcHV0ZWRWYWx1ZSAoKSB7XG4gICAgY29uc29sZS53YXJuKCdOb2RlLmdldENvbXB1dGVkVmFsdWUgaXMgZGVwcmljYXRlZC4gVXNlIE5vZGUuZ2V0VmFsdWUgaW5zdGVhZCcpO1xuICAgIHZhciBudW1iZXJPZkNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgdmFyIHZhbHVlID0ge1xuICAgICAgICBsb2NhdGlvbjogdGhpcy5nZXRJZCgpLFxuICAgICAgICBjb21wdXRlZFZhbHVlczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLmlzTW91bnRlZCgpID8gVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLmdldExvY2FsVHJhbnNmb3JtKCkgOiBudWxsLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5pc01vdW50ZWQoKSA/IFNpemVTeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuZ2V0KCkgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBudW1iZXJPZkNoaWxkcmVuIDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW5baV0gJiYgdGhpcy5fY2hpbGRyZW5baV0uZ2V0Q29tcHV0ZWRWYWx1ZSlcbiAgICAgICAgICAgIHZhbHVlLmNoaWxkcmVuLnB1c2godGhpcy5fY2hpbGRyZW5baV0uZ2V0Q29tcHV0ZWRWYWx1ZSgpKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGFsbCBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBub2RlLlxuICpcbiAqIEBtZXRob2QgZ2V0Q2hpbGRyZW5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48Tm9kZT59ICAgQW4gYXJyYXkgb2YgY2hpbGRyZW4uXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Q2hpbGRyZW4gKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgbm9kZS4gVW5tb3VudGVkIG5vZGVzIGRvIG5vdCBoYXZlIGFcbiAqIHBhcmVudCBub2RlLlxuICpcbiAqIEBtZXRob2QgZ2V0UGFyZW50XG4gKlxuICogQHJldHVybiB7Tm9kZX0gICAgICAgUGFyZW50IG5vZGUuXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uIGdldFBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbn07XG5cbi8qKlxuICogU2NoZWR1bGVzIHRoZSB7QGxpbmsgTm9kZSN1cGRhdGV9IGZ1bmN0aW9uIG9mIHRoZSBub2RlIHRvIGJlIGludm9rZWQgb24gdGhlXG4gKiBuZXh0IGZyYW1lIChpZiBubyB1cGRhdGUgZHVyaW5nIHRoaXMgZnJhbWUgaGFzIGJlZW4gc2NoZWR1bGVkIGFscmVhZHkpLlxuICogSWYgdGhlIG5vZGUgaXMgY3VycmVudGx5IGJlaW5nIHVwZGF0ZWQgKHdoaWNoIG1lYW5zIG9uZSBvZiB0aGUgcmVxdWVzdGVyc1xuICogaW52b2tlZCByZXF1ZXN0c1VwZGF0ZSB3aGlsZSBiZWluZyB1cGRhdGVkIGl0c2VsZiksIGFuIHVwZGF0ZSB3aWxsIGJlXG4gKiBzY2hlZHVsZWQgb24gdGhlIG5leHQgZnJhbWUuXG4gKlxuICogQG1ldGhvZCByZXF1ZXN0VXBkYXRlXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSByZXF1ZXN0ZXIgICBJZiB0aGUgcmVxdWVzdGVyIGhhcyBhbiBgb25VcGRhdGVgIG1ldGhvZCwgaXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBpbnZva2VkIGR1cmluZyB0aGUgbmV4dCB1cGRhdGUgcGhhc2Ugb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5vZGUuXG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5yZXF1ZXN0VXBkYXRlID0gZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZSAocmVxdWVzdGVyKSB7XG4gICAgaWYgKHRoaXMuX2luVXBkYXRlIHx8ICF0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayhyZXF1ZXN0ZXIpO1xuICAgIHRoaXMuX3VwZGF0ZVF1ZXVlLnB1c2gocmVxdWVzdGVyKTtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2NoZWR1bGVzIGFuIHVwZGF0ZSBvbiB0aGUgbmV4dCB0aWNrLiBTaW1pbGFyaWx5IHRvXG4gKiB7QGxpbmsgTm9kZSNyZXF1ZXN0VXBkYXRlfSwgYHJlcXVlc3RVcGRhdGVPbk5leHRUaWNrYCBzY2hlZHVsZXMgdGhlIG5vZGUnc1xuICogYG9uVXBkYXRlYCBmdW5jdGlvbiB0byBiZSBpbnZva2VkIG9uIHRoZSBmcmFtZSBhZnRlciB0aGUgbmV4dCBpbnZvY2F0aW9uIG9uXG4gKiB0aGUgbm9kZSdzIG9uVXBkYXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBtZXRob2QgcmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2tcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHJlcXVlc3RlciAgIElmIHRoZSByZXF1ZXN0ZXIgaGFzIGFuIGBvblVwZGF0ZWAgbWV0aG9kLCBpdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGludm9rZWQgZHVyaW5nIHRoZSBuZXh0IHVwZGF0ZSBwaGFzZSBvZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrID0gZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sgKHJlcXVlc3Rlcikge1xuICAgIHRoaXMuX25leHRVcGRhdGVRdWV1ZS5wdXNoKHJlcXVlc3Rlcik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgbm9kZSBpcyBtb3VudGVkLiBVbm1vdW50ZWQgbm9kZXMgYXJlIGRldGFjaGVkIGZyb20gdGhlIHNjZW5lXG4gKiBncmFwaC5cbiAqXG4gKiBAbWV0aG9kIGlzTW91bnRlZFxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBub2RlIGlzIG1vdW50ZWQgb3Igbm90LlxuICovXG5Ob2RlLnByb3RvdHlwZS5pc01vdW50ZWQgPSBmdW5jdGlvbiBpc01vdW50ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9tb3VudGVkO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIG5vZGUgaXMgdmlzaWJsZSAoXCJzaG93blwiKS5cbiAqXG4gKiBAbWV0aG9kIGlzU2hvd25cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgbm9kZSBpcyB2aXNpYmxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAoXCJzaG93blwiKSBvciBub3QuXG4gKi9cbk5vZGUucHJvdG90eXBlLmlzU2hvd24gPSBmdW5jdGlvbiBpc1Nob3duICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hvd247XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIG5vZGUncyByZWxhdGl2ZSBvcGFjaXR5LlxuICogVGhlIG9wYWNpdHkgbmVlZHMgdG8gYmUgd2l0aGluIFswLCAxXSwgd2hlcmUgMCBpbmRpY2F0ZXMgYSBjb21wbGV0ZWx5XG4gKiB0cmFuc3BhcmVudCwgdGhlcmVmb3JlIGludmlzaWJsZSBub2RlLCB3aGVyZWFzIGFuIG9wYWNpdHkgb2YgMSBtZWFucyB0aGVcbiAqIG5vZGUgaXMgY29tcGxldGVseSBzb2xpZC5cbiAqXG4gKiBAbWV0aG9kIGdldE9wYWNpdHlcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgUmVsYXRpdmUgb3BhY2l0eSBvZiB0aGUgbm9kZS5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0T3BhY2l0eSA9IGZ1bmN0aW9uIGdldE9wYWNpdHkgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcGFjaXR5O1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBub2RlJ3MgcHJldmlvdXNseSBzZXQgbW91bnQgcG9pbnQuXG4gKlxuICogQG1ldGhvZCBnZXRNb3VudFBvaW50XG4gKlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAgIEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgbW91bnQgcG9pbnQuXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldE1vdW50UG9pbnQgPSBmdW5jdGlvbiBnZXRNb3VudFBvaW50ICgpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5JTklUX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3RyYW5zZm9ybUlEKS5nZXRNb3VudFBvaW50KCk7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN5c3RlbS5nZXQodGhpcy5nZXRMb2NhdGlvbigpKS5nZXRNb3VudFBvaW50KCk7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHRyYW5zZm9ybSBjb21wb25lbnQnKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbm9kZSdzIHByZXZpb3VzbHkgc2V0IGFsaWduLlxuICpcbiAqIEBtZXRob2QgZ2V0QWxpZ25cbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9ICAgQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBhbGlnbi5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0QWxpZ24gPSBmdW5jdGlvbiBnZXRBbGlnbiAoKSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IuSU5JVF9ERUZBVUxUX0NPTVBPTkVOVFMpXG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCh0aGlzLl90cmFuc2Zvcm1JRCkuZ2V0QWxpZ24oKTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLmdldEFsaWduKCk7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHRyYW5zZm9ybSBjb21wb25lbnQnKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbm9kZSdzIHByZXZpb3VzbHkgc2V0IG9yaWdpbi5cbiAqXG4gKiBAbWV0aG9kIGdldE9yaWdpblxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gICBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIG9yaWdpbi5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0T3JpZ2luID0gZnVuY3Rpb24gZ2V0T3JpZ2luICgpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5JTklUX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3RyYW5zZm9ybUlEKS5nZXRPcmlnaW4oKTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLmdldE9yaWdpbigpO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSB0cmFuc2Zvcm0gY29tcG9uZW50Jyk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIG5vZGUncyBwcmV2aW91c2x5IHNldCBwb3NpdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGdldFBvc2l0aW9uXG4gKlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAgIEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24uXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0UG9zaXRpb24gKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLklOSVRfREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQodGhpcy5fdHJhbnNmb3JtSUQpLmdldFBvc2l0aW9uKCk7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN5c3RlbS5nZXQodGhpcy5nZXRMb2NhdGlvbigpKS5nZXRQb3NpdGlvbigpO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSB0cmFuc2Zvcm0gY29tcG9uZW50Jyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5vZGUncyBjdXJyZW50IHJvdGF0aW9uXG4gKlxuICogQG1ldGhvZCBnZXRSb3RhdGlvblxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gYW4gYXJyYXkgb2YgZm91ciB2YWx1ZXMsIHNob3dpbmcgdGhlIHJvdGF0aW9uIGFzIGEgcXVhdGVybmlvblxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFJvdGF0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5JTklUX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3RyYW5zZm9ybUlEKS5nZXRSb3RhdGlvbigpO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1TeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuZ2V0Um90YXRpb24oKTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgdHJhbnNmb3JtIGNvbXBvbmVudCcpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY2FsZSBvZiB0aGUgbm9kZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IGFuIGFycmF5IHNob3dpbmcgdGhlIGN1cnJlbnQgc2NhbGUgdmVjdG9yXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGUgKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLklOSVRfREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQodGhpcy5fdHJhbnNmb3JtSUQpLmdldFNjYWxlKCk7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN5c3RlbS5nZXQodGhpcy5nZXRMb2NhdGlvbigpKS5nZXRTY2FsZSgpO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSB0cmFuc2Zvcm0gY29tcG9uZW50Jyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBtb2RlIG9mIHRoZSBub2RlXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gYW4gYXJyYXkgb2YgbnVtYmVycyBzaG93aW5nIHRoZSBjdXJyZW50IHNpemUgbW9kZVxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRTaXplTW9kZSA9IGZ1bmN0aW9uIGdldFNpemVNb2RlICgpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5JTklUX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3NpemVJRCkuZ2V0U2l6ZU1vZGUoKTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICByZXR1cm4gU2l6ZVN5c3RlbS5nZXQodGhpcy5nZXRMb2NhdGlvbigpKS5nZXRTaXplTW9kZSgpO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSBzaXplIGNvbXBvbmVudCcpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHByb3BvcnRpb25hbCBzaXplXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gYSB2ZWN0b3IgMyBzaG93aW5nIHRoZSBjdXJyZW50IHByb3BvcnRpb25hbCBzaXplXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFByb3BvcnRpb25hbFNpemUgPSBmdW5jdGlvbiBnZXRQcm9wb3J0aW9uYWxTaXplICgpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5JTklUX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3NpemVJRCkuZ2V0UHJvcG9ydGlvbmFsKCk7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgcmV0dXJuIFNpemVTeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuZ2V0UHJvcG9ydGlvbmFsKCk7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHNpemUgY29tcG9uZW50Jyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGRpZmZlcmVudGlhbCBzaXplIG9mIHRoZSBub2RlXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gYSB2ZWN0b3IgMyBzaG93aW5nIHRoZSBjdXJyZW50IGRpZmZlcmVudGlhbCBzaXplXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldERpZmZlcmVudGlhbFNpemUgPSBmdW5jdGlvbiBnZXREaWZmZXJlbnRpYWxTaXplICgpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5JTklUX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3NpemVJRCkuZ2V0RGlmZmVyZW50aWFsKCk7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgcmV0dXJuIFNpemVTeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuZ2V0RGlmZmVyZW50aWFsKCk7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHNpemUgY29tcG9uZW50Jyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFic29sdXRlIHNpemUgb2YgdGhlIG5vZGVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSBhIHZlY3RvciAzIHNob3dpbmcgdGhlIGN1cnJlbnQgYWJzb2x1dGUgc2l6ZSBvZiB0aGUgbm9kZVxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRBYnNvbHV0ZVNpemUgPSBmdW5jdGlvbiBnZXRBYnNvbHV0ZVNpemUgKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLklOSVRfREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQodGhpcy5fc2l6ZUlEKS5nZXRBYnNvbHV0ZSgpO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIHJldHVybiBTaXplU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLmdldEFic29sdXRlKCk7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHNpemUgY29tcG9uZW50Jyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgUmVuZGVyIFNpemUgb2YgdGhlIG5vZGUuIE5vdGUgdGhhdCB0aGUgcmVuZGVyIHNpemVcbiAqIGlzIGFzeW5jaHJvbm91cyAod2lsbCBhbHdheXMgYmUgb25lIGZyYW1lIGJlaGluZCkgYW5kIG5lZWRzIHRvIGJlIGV4cGxpY2l0ZWx5XG4gKiBjYWxjdWxhdGVkIGJ5IHNldHRpbmcgdGhlIHByb3BlciBzaXplIG1vZGUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gYSB2ZWN0b3IgMyBzaG93aW5nIHRoZSBjdXJyZW50IHJlbmRlciBzaXplXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFJlbmRlclNpemUgPSBmdW5jdGlvbiBnZXRSZW5kZXJTaXplICgpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5JTklUX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3NpemVJRCkuZ2V0UmVuZGVyKCk7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgcmV0dXJuIFNpemVTeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuZ2V0UmVuZGVyKCk7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHNpemUgY29tcG9uZW50Jyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVybmFsIHNpemUgb2YgdGhlIG5vZGVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSBhIHZlY3RvciAzIG9mIHRoZSBmaW5hbCBjYWxjdWxhdGVkIHNpZGUgb2YgdGhlIG5vZGVcbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUgKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLklOSVRfREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQodGhpcy5fc2l6ZUlEKS5nZXQoKTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICByZXR1cm4gU2l6ZVN5c3RlbS5nZXQodGhpcy5nZXRMb2NhdGlvbigpKS5nZXQoKTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgc2l6ZSBjb21wb25lbnQnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCB3b3JsZCB0cmFuc2Zvcm0gb2YgdGhlIG5vZGVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSBhIDE2IHZhbHVlIHRyYW5zZm9ybVxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBnZXRUcmFuc2Zvcm0gKCkge1xuICAgIHJldHVybiBUcmFuc2Zvcm1TeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGlzdCBvZiB0aGUgVUkgRXZlbnRzIHRoYXQgYXJlIGN1cnJlbnRseSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdWJzY3JpYmVkIFVJIGV2ZW50IG9mIHRoaXMgbm9kZVxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRVSUV2ZW50cyA9IGZ1bmN0aW9uIGdldFVJRXZlbnRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fVUlFdmVudHM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXcgY2hpbGQgdG8gdGhpcyBub2RlLiBJZiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgd2l0aCBubyBhcmd1bWVudCBpdCB3aWxsXG4gKiBjcmVhdGUgYSBuZXcgbm9kZSwgaG93ZXZlciBpdCBjYW4gYWxzbyBiZSBjYWxsZWQgd2l0aCBhbiBleGlzdGluZyBub2RlIHdoaWNoIGl0IHdpbGxcbiAqIGFwcGVuZCB0byB0aGUgbm9kZSB0aGF0IHRoaXMgbWV0aG9kIGlzIGJlaW5nIGNhbGxlZCBvbi4gUmV0dXJucyB0aGUgbmV3IG9yIHBhc3NlZCBpbiBub2RlLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge05vZGUgfCB2b2lkfSBjaGlsZCB0aGUgbm9kZSB0byBhcHBlbmRlZCBvciBubyBub2RlIHRvIGNyZWF0ZSBhIG5ldyBub2RlLlxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoZSBhcHBlbmRlZCBub2RlLlxuICovXG5Ob2RlLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkIChjaGlsZCkge1xuICAgIHZhciBpbmRleCA9IGNoaWxkID8gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihjaGlsZCkgOiAtMTtcbiAgICBjaGlsZCA9IGNoaWxkID8gY2hpbGQgOiBuZXcgTm9kZSgpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICBpbmRleCA9IHRoaXMuX2ZyZWVkQ2hpbGRJbmRpY2llcy5sZW5ndGggP1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZyZWVkQ2hpbGRJbmRpY2llcy5wb3AoKSA6IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgICB0aGlzLl9jaGlsZHJlbltpbmRleF0gPSBjaGlsZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgY2hpbGQubW91bnQodGhpcy5nZXRMb2NhdGlvbigpICsgJy8nICsgaW5kZXgpO1xuXG4gICAgcmV0dXJuIGNoaWxkO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgY2hpbGQgbm9kZSBmcm9tIGFub3RoZXIgbm9kZS4gVGhlIHBhc3NlZCBpbiBub2RlIG11c3QgYmVcbiAqIGEgY2hpbGQgb2YgdGhlIG5vZGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgdXBvbi5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOb2RlfSBjaGlsZCBub2RlIHRvIGJlIHJlbW92ZWRcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSB3YXMgc3VjY2Vzc2Z1bGx5IHJlbW92ZWRcbiAqL1xuTm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZCAoY2hpbGQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcblxuICAgIGlmIChpbmRleCA+IC0gMSkge1xuICAgICAgICB0aGlzLl9mcmVlZENoaWxkSW5kaWNpZXMucHVzaChpbmRleCk7XG5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW5baW5kZXhdID0gbnVsbDtcblxuICAgICAgICBpZiAoY2hpbGQuaXNNb3VudGVkKCkpIGNoaWxkLmRpc21vdW50KCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcignTm9kZSBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIG5vZGUnKTtcbn07XG5cbi8qKlxuICogRWFjaCBjb21wb25lbnQgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSBwZXIgbm9kZS5cbiAqXG4gKiBAbWV0aG9kIGFkZENvbXBvbmVudFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgICAgQSBjb21wb25lbnQgdG8gYmUgYWRkZWQuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGluZGV4ICAgICAgIFRoZSBpbmRleCBhdCB3aGljaCB0aGUgY29tcG9uZW50IGhhcyBiZWVuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWQuIEluZGljZXMgYXJlbid0IG5lY2Vzc2FyaWx5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNlY3V0aXZlLlxuICovXG5Ob2RlLnByb3RvdHlwZS5hZGRDb21wb25lbnQgPSBmdW5jdGlvbiBhZGRDb21wb25lbnQgKGNvbXBvbmVudCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2NvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLl9mcmVlZENvbXBvbmVudEluZGljaWVzLmxlbmd0aCA/IHRoaXMuX2ZyZWVkQ29tcG9uZW50SW5kaWNpZXMucG9wKCkgOiB0aGlzLl9jb21wb25lbnRzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50c1tpbmRleF0gPSBjb21wb25lbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNNb3VudGVkKCkgJiYgY29tcG9uZW50Lm9uTW91bnQpXG4gICAgICAgICAgICBjb21wb25lbnQub25Nb3VudCh0aGlzLCBpbmRleCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTaG93bigpICYmIGNvbXBvbmVudC5vblNob3cpXG4gICAgICAgICAgICBjb21wb25lbnQub25TaG93KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xufTtcblxuLyoqXG4gKiBAbWV0aG9kICBnZXRDb21wb25lbnRcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4ICAgSW5kZXggYXQgd2hpY2ggdGhlIGNvbXBvbmVudCBoYXMgYmVlbiByZWdpc3RlcmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKHVzaW5nIGBOb2RlI2FkZENvbXBvbmVudGApLlxuICogQHJldHVybiB7Kn0gICAgICAgICAgICAgIFRoZSBjb21wb25lbnQgcmVnaXN0ZXJlZCBhdCB0aGUgcGFzc2VkIGluIGluZGV4IChpZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGFueSkuXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldENvbXBvbmVudCA9IGZ1bmN0aW9uIGdldENvbXBvbmVudCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1tpbmRleF07XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IHZpYSB7QGxpbmsgTm9kZSNhZGRDb21wb25lbnR9IGFkZGVkIGNvbXBvbmVudC5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNvbXBvbmVudFxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gY29tcG9uZW50ICAgQW4gY29tcG9uZW50IHRoYXQgaGFzIHByZXZpb3VzbHkgYmVlbiBhZGRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2luZyB7QGxpbmsgTm9kZSNhZGRDb21wb25lbnR9LlxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUucmVtb3ZlQ29tcG9uZW50ID0gZnVuY3Rpb24gcmVtb3ZlQ29tcG9uZW50IChjb21wb25lbnQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9jb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2ZyZWVkQ29tcG9uZW50SW5kaWNpZXMucHVzaChpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmlzU2hvd24oKSAmJiBjb21wb25lbnQub25IaWRlKVxuICAgICAgICAgICAgY29tcG9uZW50Lm9uSGlkZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzTW91bnRlZCgpICYmIGNvbXBvbmVudC5vbkRpc21vdW50KVxuICAgICAgICAgICAgY29tcG9uZW50Lm9uRGlzbW91bnQoKTtcblxuICAgICAgICB0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBub2RlJ3Mgc3Vic2NyaXB0aW9uIHRvIGEgcGFydGljdWxhciBVSUV2ZW50LiBBbGwgY29tcG9uZW50cyBcbiAqIG9uIHRoZSBub2RlIHdpbGwgaGF2ZSB0aGUgb3Bwb3J0dW5pdHkgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZGVwZW5kaW5nXG4gKiBvbiB0aGlzIGV2ZW50LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbk5vZGUucHJvdG90eXBlLnJlbW92ZVVJRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVVSUV2ZW50IChldmVudE5hbWUpIHtcbiAgICB2YXIgVUlFdmVudHMgPSB0aGlzLmdldFVJRXZlbnRzKCk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHZhciBjb21wb25lbnQ7XG5cbiAgICB2YXIgaW5kZXggPSBVSUV2ZW50cy5pbmRleE9mKGV2ZW50TmFtZSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBVSUV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQub25SZW1vdmVVSUV2ZW50KSBjb21wb25lbnQub25SZW1vdmVVSUV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXMgYSBub2RlIHRvIGEgVUkgRXZlbnQuIEFsbCBjb21wb25lbnRzIG9uIHRoZSBub2RlXG4gKiB3aWxsIGhhdmUgdGhlIG9wcG9ydHVuaXR5IHRvIGJlZ2luIGxpc3RlbmluZyB0byB0aGF0IGV2ZW50XG4gKiBhbmQgYWxlcnRpbmcgdGhlIHNjZW5lIGdyYXBoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbk5vZGUucHJvdG90eXBlLmFkZFVJRXZlbnQgPSBmdW5jdGlvbiBhZGRVSUV2ZW50IChldmVudE5hbWUpIHtcbiAgICB2YXIgVUlFdmVudHMgPSB0aGlzLmdldFVJRXZlbnRzKCk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHZhciBjb21wb25lbnQ7XG5cbiAgICB2YXIgYWRkZWQgPSBVSUV2ZW50cy5pbmRleE9mKGV2ZW50TmFtZSkgIT09IC0xO1xuICAgIGlmICghYWRkZWQpIHtcbiAgICAgICAgVUlFdmVudHMucHVzaChldmVudE5hbWUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQub25BZGRVSUV2ZW50KSBjb21wb25lbnQub25BZGRVSUV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIGZvciB0aGUgTm9kZSB0byByZXF1ZXN0IGFuIHVwZGF0ZSBmb3IgaXRzZWxmLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSB3aGV0aGVyIG9yIG5vdCB0byBmb3JjZSB0aGUgdXBkYXRlXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuTm9kZS5wcm90b3R5cGUuX3JlcXVlc3RVcGRhdGUgPSBmdW5jdGlvbiBfcmVxdWVzdFVwZGF0ZSAoZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UgfHwgIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZXIpXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVyLnJlcXVlc3RVcGRhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gc2V0IGFuIG9wdGlvbmFsIHZhbHVlIGluIGFuIGFycmF5LCBhbmRcbiAqIHJlcXVlc3QgYW4gdXBkYXRlIGlmIHRoaXMgY2hhbmdlcyB0aGUgdmFsdWUgb2YgdGhlIGFycmF5LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2ZWMgdGhlIGFycmF5IHRvIGluc2VydCB0aGUgdmFsdWUgaW50b1xuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IHRoZSBpbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIHZhbHVlXG4gKiBAcGFyYW0ge0FueX0gdmFsIHRoZSB2YWx1ZSB0byBwb3RlbnRpYWxseSBpbnNlcnQgKGlmIG5vdCBudWxsIG9yIHVuZGVmaW5lZClcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCBhIG5ldyB2YWx1ZSB3YXMgaW5zZXJ0ZWQuXG4gKi9cbk5vZGUucHJvdG90eXBlLl92ZWNPcHRpb25hbFNldCA9IGZ1bmN0aW9uIF92ZWNPcHRpb25hbFNldCAodmVjLCBpbmRleCwgdmFsKSB7XG4gICAgaWYgKHZhbCAhPSBudWxsICYmIHZlY1tpbmRleF0gIT09IHZhbCkge1xuICAgICAgICB2ZWNbaW5kZXhdID0gdmFsO1xuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2hvd3MgdGhlIG5vZGUsIHdoaWNoIGlzIHRvIHNheSwgY2FsbHMgb25TaG93IG9uIGFsbCBvZiB0aGVcbiAqIG5vZGUncyBjb21wb25lbnRzLiBSZW5kZXJhYmxlIGNvbXBvbmVudHMgY2FuIHRoZW4gaXNzdWUgdGhlXG4gKiBkcmF3IGNvbW1hbmRzIG5lY2Vzc2FyeSB0byBiZSBzaG93bi5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyAoKSB7XG4gICAgRGlzcGF0Y2guc2hvdyh0aGlzLmdldExvY2F0aW9uKCkpO1xuICAgIHRoaXMuX3Nob3duID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSGlkZXMgdGhlIG5vZGUsIHdoaWNoIGlzIHRvIHNheSwgY2FsbHMgb25IaWRlIG9uIGFsbCBvZiB0aGVcbiAqIG5vZGUncyBjb21wb25lbnRzLiBSZW5kZXJhYmxlIGNvbXBvbmVudHMgY2FuIHRoZW4gaXNzdWVcbiAqIHRoZSBkcmF3IGNvbW1hbmRzIG5lY2Vzc2FyeSB0byBiZSBoaWRkZW5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gaGlkZSAoKSB7XG4gICAgRGlzcGF0Y2guaGlkZSh0aGlzLmdldExvY2F0aW9uKCkpO1xuICAgIHRoaXMuX3Nob3duID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGFsaWduIHZhbHVlIG9mIHRoZSBub2RlLiBXaWxsIGNhbGwgb25BbGlnbkNoYW5nZVxuICogb24gYWxsIG9mIHRoZSBOb2RlJ3MgY29tcG9uZW50cy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggQWxpZ24gdmFsdWUgaW4gdGhlIHggZGltZW5zaW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgQWxpZ24gdmFsdWUgaW4gdGhlIHkgZGltZW5zaW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogQWxpZ24gdmFsdWUgaW4gdGhlIHogZGltZW5zaW9uLlxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0QWxpZ24gPSBmdW5jdGlvbiBzZXRBbGlnbiAoeCwgeSwgeikge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLklOSVRfREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICB0aGlzLmdldENvbXBvbmVudCh0aGlzLl90cmFuc2Zvcm1JRCkuc2V0QWxpZ24oeCwgeSwgeik7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLnNldEFsaWduKHgsIHksIHopO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSB0cmFuc2Zvcm0gY29tcG9uZW50Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1vdW50IHBvaW50IHZhbHVlIG9mIHRoZSBub2RlLiBXaWxsIGNhbGwgb25Nb3VudFBvaW50Q2hhbmdlXG4gKiBvbiBhbGwgb2YgdGhlIG5vZGUncyBjb21wb25lbnRzLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBNb3VudFBvaW50IHZhbHVlIGluIHggZGltZW5zaW9uXG4gKiBAcGFyYW0ge051bWJlcn0geSBNb3VudFBvaW50IHZhbHVlIGluIHkgZGltZW5zaW9uXG4gKiBAcGFyYW0ge051bWJlcn0geiBNb3VudFBvaW50IHZhbHVlIGluIHogZGltZW5zaW9uXG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5zZXRNb3VudFBvaW50ID0gZnVuY3Rpb24gc2V0TW91bnRQb2ludCAoeCwgeSwgeikge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLklOSVRfREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICB0aGlzLmdldENvbXBvbmVudCh0aGlzLl90cmFuc2Zvcm1JRCkuc2V0TW91bnRQb2ludCh4LCB5LCB6KTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICBUcmFuc2Zvcm1TeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuc2V0TW91bnRQb2ludCh4LCB5LCB6KTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgdHJhbnNmb3JtIGNvbXBvbmVudCcpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBvcmlnaW4gdmFsdWUgb2YgdGhlIG5vZGUuIFdpbGwgY2FsbCBvbk9yaWdpbkNoYW5nZVxuICogb24gYWxsIG9mIHRoZSBub2RlJ3MgY29tcG9uZW50cy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggT3JpZ2luIHZhbHVlIGluIHggZGltZW5zaW9uXG4gKiBAcGFyYW0ge051bWJlcn0geSBPcmlnaW4gdmFsdWUgaW4geSBkaW1lbnNpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IE9yaWdpbiB2YWx1ZSBpbiB6IGRpbWVuc2lvblxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0T3JpZ2luID0gZnVuY3Rpb24gc2V0T3JpZ2luICh4LCB5LCB6KSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IuSU5JVF9ERUZBVUxUX0NPTVBPTkVOVFMpXG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3RyYW5zZm9ybUlEKS5zZXRPcmlnaW4oeCwgeSwgeik7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLnNldE9yaWdpbih4LCB5LCB6KTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgdHJhbnNmb3JtIGNvbXBvbmVudCcpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZS4gV2lsbCBjYWxsIG9uUG9zaXRpb25DaGFuZ2VcbiAqIG9uIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFBvc2l0aW9uIGluIHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFBvc2l0aW9uIGluIHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFBvc2l0aW9uIGluIHpcbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9zaXRpb24gKHgsIHksIHopIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5JTklUX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnQodGhpcy5fdHJhbnNmb3JtSUQpLnNldFBvc2l0aW9uKHgsIHksIHopO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIFRyYW5zZm9ybVN5c3RlbS5nZXQodGhpcy5nZXRMb2NhdGlvbigpKS5zZXRQb3NpdGlvbih4LCB5LCB6KTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgdHJhbnNmb3JtIGNvbXBvbmVudCcpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByb3RhdGlvbiBvZiB0aGUgbm9kZS4gV2lsbCBjYWxsIG9uUm90YXRpb25DaGFuZ2VcbiAqIG9uIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHMuIFRoaXMgbWV0aG9kIHRha2VzIGVpdGhlclxuICogRXVsZXIgYW5nbGVzIG9yIGEgcXVhdGVybmlvbi4gSWYgdGhlIGZvdXJ0aCBhcmd1bWVudCBpcyB1bmRlZmluZWRcbiAqIEV1bGVyIGFuZ2xlcyBhcmUgYXNzdW1lZC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggRWl0aGVyIHRoZSByb3RhdGlvbiBhcm91bmQgdGhlIHggYXhpcyBvciB0aGUgbWFnbml0dWRlIGluIHggb2YgdGhlIGF4aXMgb2Ygcm90YXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0geSBFaXRoZXIgdGhlIHJvdGF0aW9uIGFyb3VuZCB0aGUgeSBheGlzIG9yIHRoZSBtYWduaXR1ZGUgaW4geSBvZiB0aGUgYXhpcyBvZiByb3RhdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IEVpdGhlciB0aGUgcm90YXRpb24gYXJvdW5kIHRoZSB6IGF4aXMgb3IgdGhlIG1hZ25pdHVkZSBpbiB6IG9mIHRoZSBheGlzIG9mIHJvdGF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ8dW5kZWZpbmVkfSB3IHRoZSBhbW91bnQgb2Ygcm90YXRpb24gYXJvdW5kIHRoZSBheGlzIG9mIHJvdGF0aW9uLCBpZiBhIHF1YXRlcm5pb24gaXMgc3BlY2lmaWVkLlxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0Um90YXRpb24gPSBmdW5jdGlvbiBzZXRSb3RhdGlvbiAoeCwgeSwgeiwgdykge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLklOSVRfREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICB0aGlzLmdldENvbXBvbmVudCh0aGlzLl90cmFuc2Zvcm1JRCkuc2V0Um90YXRpb24oeCwgeSwgeiwgdyk7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLnNldFJvdGF0aW9uKHgsIHksIHosIHcpO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSB0cmFuc2Zvcm0gY29tcG9uZW50Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNjYWxlIG9mIHRoZSBub2RlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxIGluIGFsbCBkaW1lbnNpb25zLlxuICogVGhlIG5vZGUncyBjb21wb25lbnRzIHdpbGwgaGF2ZSBvblNjYWxlQ2hhbmdlZCBjYWxsZWQgb24gdGhlbS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggU2NhbGUgdmFsdWUgaW4geFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgU2NhbGUgdmFsdWUgaW4geVxuICogQHBhcmFtIHtOdW1iZXJ9IHogU2NhbGUgdmFsdWUgaW4gelxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0U2NhbGUgPSBmdW5jdGlvbiBzZXRTY2FsZSAoeCwgeSwgeikge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLklOSVRfREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICB0aGlzLmdldENvbXBvbmVudCh0aGlzLl90cmFuc2Zvcm1JRCkuc2V0U2NhbGUoeCwgeSwgeik7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLnNldFNjYWxlKHgsIHksIHopO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSB0cmFuc2Zvcm0gY29tcG9uZW50Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBvcGFjaXR5IG9mIHRoaXMgbm9kZS4gQWxsIG9mIHRoZSBub2RlJ3NcbiAqIGNvbXBvbmVudHMgd2lsbCBoYXZlIG9uT3BhY2l0eUNoYW5nZSBjYWxsZWQgb24gdGhlbS9cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbCBWYWx1ZSBvZiB0aGUgb3BhY2l0eS4gMSBpcyB0aGUgZGVmYXVsdC5cbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldE9wYWNpdHkgPSBmdW5jdGlvbiBzZXRPcGFjaXR5ICh2YWwpIHtcbiAgICBpZiAodmFsICE9PSB0aGlzLl9vcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuX29wYWNpdHkgPSB2YWw7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uT3BhY2l0eUNoYW5nZSkgaXRlbS5vbk9wYWNpdHlDaGFuZ2UodmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc2l6ZSBtb2RlIGJlaW5nIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBub2RlJ3MgZmluYWwgd2lkdGgsIGhlaWdodFxuICogYW5kIGRlcHRoLlxuICogU2l6ZSBtb2RlcyBhcmUgYSB3YXkgdG8gZGVmaW5lIHRoZSB3YXkgdGhlIG5vZGUncyBzaXplIGlzIGJlaW5nIGNhbGN1bGF0ZWQuXG4gKiBTaXplIG1vZGVzIGFyZSBlbnVtcyBzZXQgb24gdGhlIHtAbGluayBTaXplfSBjb25zdHJ1Y3RvciAoYW5kIGFsaWFzZWQgb25cbiAqIHRoZSBOb2RlKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogbm9kZS5zZXRTaXplTW9kZShOb2RlLlJFTEFUSVZFX1NJWkUsIE5vZGUuQUJTT0xVVEVfU0laRSwgTm9kZS5BQlNPTFVURV9TSVpFKTtcbiAqIC8vIEluc3RlYWQgb2YgbnVsbCwgYW55IHByb3BvcnRpb25hbCBoZWlnaHQgb3IgZGVwdGggY2FuIGJlIHBhc3NlZCBpbiwgc2luY2VcbiAqIC8vIGl0IHdvdWxkIGJlIGlnbm9yZWQgaW4gYW55IGNhc2UuXG4gKiBub2RlLnNldFByb3BvcnRpb25hbFNpemUoMC41LCBudWxsLCBudWxsKTtcbiAqIG5vZGUuc2V0QWJzb2x1dGVTaXplKG51bGwsIDEwMCwgMjAwKTtcbiAqXG4gKiBAbWV0aG9kIHNldFNpemVNb2RlXG4gKlxuICogQHBhcmFtIHtTaXplTW9kZX0geCAgICBUaGUgc2l6ZSBtb2RlIGJlaW5nIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBzaXplIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHggZGlyZWN0aW9uIChcIndpZHRoXCIpLlxuICogQHBhcmFtIHtTaXplTW9kZX0geSAgICBUaGUgc2l6ZSBtb2RlIGJlaW5nIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBzaXplIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHkgZGlyZWN0aW9uIChcImhlaWdodFwiKS5cbiAqIEBwYXJhbSB7U2l6ZU1vZGV9IHogICAgVGhlIHNpemUgbW9kZSBiZWluZyB1c2VkIGZvciBkZXRlcm1pbmluZyB0aGUgc2l6ZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICB6IGRpcmVjdGlvbiAoXCJkZXB0aFwiKS5cbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldFNpemVNb2RlID0gZnVuY3Rpb24gc2V0U2l6ZU1vZGUgKHgsIHksIHopIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5JTklUX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnQodGhpcy5fc2l6ZUlEKS5zZXRTaXplTW9kZSh4LCB5LCB6KTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICBTaXplU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLnNldFNpemVNb2RlKHgsIHksIHopO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSBzaXplIGNvbXBvbmVudCcpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBIHByb3BvcnRpb25hbCBzaXplIGRlZmluZXMgdGhlIG5vZGUncyBkaW1lbnNpb25zIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnRzXG4gKiBmaW5hbCBzaXplLlxuICogUHJvcG9ydGlvbmFsIHNpemVzIG5lZWQgdG8gYmUgd2l0aGluIHRoZSByYW5nZSBvZiBbMCwgMV0uXG4gKlxuICogQG1ldGhvZCBzZXRQcm9wb3J0aW9uYWxTaXplXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggICAgeC1TaXplIGluIHBpeGVscyAoXCJ3aWR0aFwiKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5ICAgIHktU2l6ZSBpbiBwaXhlbHMgKFwiaGVpZ2h0XCIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogICAgei1TaXplIGluIHBpeGVscyAoXCJkZXB0aFwiKS5cbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldFByb3BvcnRpb25hbFNpemUgPSBmdW5jdGlvbiBzZXRQcm9wb3J0aW9uYWxTaXplICh4LCB5LCB6KSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IuSU5JVF9ERUZBVUxUX0NPTVBPTkVOVFMpXG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3NpemVJRCkuc2V0UHJvcG9ydGlvbmFsKHgsIHksIHopO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIFNpemVTeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuc2V0UHJvcG9ydGlvbmFsKHgsIHksIHopO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSBzaXplIGNvbXBvbmVudCcpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEaWZmZXJlbnRpYWwgc2l6aW5nIGNhbiBiZSB1c2VkIHRvIGFkZCBvciBzdWJ0cmFjdCBhbiBhYnNvbHV0ZSBzaXplIGZyb20gYW5cbiAqIG90aGVyd2lzZSBwcm9wb3J0aW9uYWxseSBzaXplZCBub2RlLlxuICogRS5nLiBhIGRpZmZlcmVudGlhbCB3aWR0aCBvZiBgLTEwYCBhbmQgYSBwcm9wb3J0aW9uYWwgd2lkdGggb2YgYDAuNWAgaXNcbiAqIGJlaW5nIGludGVycHJldGVkIGFzIHNldHRpbmcgdGhlIG5vZGUncyBzaXplIHRvIDUwJSBvZiBpdHMgcGFyZW50J3Mgd2lkdGhcbiAqICptaW51cyogMTAgcGl4ZWxzLlxuICpcbiAqIEBtZXRob2Qgc2V0RGlmZmVyZW50aWFsU2l6ZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4ICAgIHgtU2l6ZSB0byBiZSBhZGRlZCB0byB0aGUgcmVsYXRpdmVseSBzaXplZCBub2RlIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICBwaXhlbHMgKFwid2lkdGhcIikuXG4gKiBAcGFyYW0ge051bWJlcn0geSAgICB5LVNpemUgdG8gYmUgYWRkZWQgdG8gdGhlIHJlbGF0aXZlbHkgc2l6ZWQgbm9kZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzIChcImhlaWdodFwiKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6ICAgIHotU2l6ZSB0byBiZSBhZGRlZCB0byB0aGUgcmVsYXRpdmVseSBzaXplZCBub2RlIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICBwaXhlbHMgKFwiZGVwdGhcIikuXG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5zZXREaWZmZXJlbnRpYWxTaXplID0gZnVuY3Rpb24gc2V0RGlmZmVyZW50aWFsU2l6ZSAoeCwgeSwgeikge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLklOSVRfREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICB0aGlzLmdldENvbXBvbmVudCh0aGlzLl9zaXplSUQpLnNldERpZmZlcmVudGlhbCh4LCB5LCB6KTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICBTaXplU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLnNldERpZmZlcmVudGlhbCh4LCB5LCB6KTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgc2l6ZSBjb21wb25lbnQnKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbm9kZSdzIHNpemUgaW4gcGl4ZWxzLCBpbmRlcGVuZGVudCBvZiBpdHMgcGFyZW50LlxuICpcbiAqIEBtZXRob2Qgc2V0QWJzb2x1dGVTaXplXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggeC1TaXplIGluIHBpeGVscyAoXCJ3aWR0aFwiKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IHktU2l6ZSBpbiBwaXhlbHMgKFwiaGVpZ2h0XCIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogei1TaXplIGluIHBpeGVscyAoXCJkZXB0aFwiKS5cbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldEFic29sdXRlU2l6ZSA9IGZ1bmN0aW9uIHNldEFic29sdXRlU2l6ZSAoeCwgeSwgeikge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLklOSVRfREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICB0aGlzLmdldENvbXBvbmVudCh0aGlzLl9zaXplSUQpLnNldEFic29sdXRlKHgsIHksIHopO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIFNpemVTeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuc2V0QWJzb2x1dGUoeCwgeSwgeik7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHNpemUgY29tcG9uZW50Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1ldGhvZCBmb3IgZ2V0dGluZyB0aGUgY3VycmVudCBmcmFtZS4gV2lsbCBiZSBkZXByZWNhdGVkLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGN1cnJlbnQgZnJhbWVcbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0RnJhbWUgPSBmdW5jdGlvbiBnZXRGcmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZXIuZ2V0RnJhbWUoKTtcbn07XG5cbi8qKlxuICogcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgY29tcG9uZW50cyBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpc1xuICogbm9kZS5cbiAqXG4gKiBAbWV0aG9kIGdldENvbXBvbmVudHNcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gbGlzdCBvZiBjb21wb25lbnRzLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRDb21wb25lbnRzID0gZnVuY3Rpb24gZ2V0Q29tcG9uZW50cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHM7XG59O1xuXG4vKipcbiAqIEVudGVycyB0aGUgbm9kZSdzIHVwZGF0ZSBwaGFzZSB3aGlsZSB1cGRhdGluZyBpdHMgb3duIHNwZWMgYW5kIHVwZGF0aW5nIGl0cyBjb21wb25lbnRzLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lICAgIGhpZ2gtcmVzb2x1dGlvbiB0aW1lc3RhbXAsIHVzdWFsbHkgcmV0cmlldmVkIHVzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKHRpbWUpe1xuICAgIHRoaXMuX2luVXBkYXRlID0gdHJ1ZTtcbiAgICB2YXIgbmV4dFF1ZXVlID0gdGhpcy5fbmV4dFVwZGF0ZVF1ZXVlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3VwZGF0ZVF1ZXVlO1xuICAgIHZhciBpdGVtO1xuXG4gICAgaWYgKHRoaXMub25VcGRhdGUpIHRoaXMub25VcGRhdGUoKTtcblxuICAgIHdoaWxlIChuZXh0UXVldWUubGVuZ3RoKSBxdWV1ZS51bnNoaWZ0KG5leHRRdWV1ZS5wb3AoKSk7XG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9jb21wb25lbnRzW3F1ZXVlLnNoaWZ0KCldO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uVXBkYXRlKSBpdGVtLm9uVXBkYXRlKHRpbWUpO1xuICAgIH1cblxuICAgIHRoaXMuX2luVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLmlzTW91bnRlZCgpKSB7XG4gICAgICAgIC8vIGxhc3QgdXBkYXRlXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lkID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fbmV4dFVwZGF0ZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl91cGRhdGVyLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1vdW50cyB0aGUgbm9kZSBhbmQgdGhlcmVmb3JlIGl0cyBzdWJ0cmVlIGJ5IHNldHRpbmcgaXQgYXMgYSBjaGlsZCBvZiB0aGVcbiAqIHBhc3NlZCBpbiBwYXJlbnQuXG4gKlxuICogQG1ldGhvZCBtb3VudFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCB1bmlxdWUgcGF0aCBvZiBub2RlIChlLmcuIGBib2R5LzAvMWApXG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uIG1vdW50IChwYXRoKSB7XG4gICAgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBpcyBhbHJlYWR5IG1vdW50ZWQgYXQ6ICcgKyB0aGlzLmdldExvY2F0aW9uKCkpO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IuSU5JVF9ERUZBVUxUX0NPTVBPTkVOVFMpe1xuICAgICAgICBUcmFuc2Zvcm1TeXN0ZW0ucmVnaXN0ZXJUcmFuc2Zvcm1BdFBhdGgocGF0aCwgdGhpcy5nZXRDb21wb25lbnQodGhpcy5fdHJhbnNmb3JtSUQpKTtcbiAgICAgICAgU2l6ZVN5c3RlbS5yZWdpc3RlclNpemVBdFBhdGgocGF0aCwgdGhpcy5nZXRDb21wb25lbnQodGhpcy5fc2l6ZUlEKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBUcmFuc2Zvcm1TeXN0ZW0ucmVnaXN0ZXJUcmFuc2Zvcm1BdFBhdGgocGF0aCk7XG4gICAgICAgIFNpemVTeXN0ZW0ucmVnaXN0ZXJTaXplQXRQYXRoKHBhdGgpO1xuICAgIH1cbiAgICBEaXNwYXRjaC5tb3VudChwYXRoLCB0aGlzKTtcblxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuXG59O1xuXG4vKipcbiAqIERpc21vdW50cyAoZGV0YWNoZXMpIHRoZSBub2RlIGZyb20gdGhlIHNjZW5lIGdyYXBoIGJ5IHJlbW92aW5nIGl0IGFzIGFcbiAqIGNoaWxkIG9mIGl0cyBwYXJlbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuZGlzbW91bnQgPSBmdW5jdGlvbiBkaXNtb3VudCAoKSB7XG4gICAgaWYgKCF0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgaXMgbm90IG1vdW50ZWQnKTtcblxuICAgIHZhciBwYXRoID0gdGhpcy5nZXRMb2NhdGlvbigpO1xuXG4gICAgVHJhbnNmb3JtU3lzdGVtLmRlcmVnaXN0ZXJUcmFuc2Zvcm1BdFBhdGgocGF0aCk7XG4gICAgU2l6ZVN5c3RlbS5kZXJlZ2lzdGVyU2l6ZUF0UGF0aChwYXRoKTtcbiAgICBEaXNwYXRjaC5kaXNtb3VudChwYXRoKTtcblxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgdXRpbGl0aWVzIGZvciBoYW5kbGluZyBwYXRocy5cbiAqXG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gUGF0aFV0aWxzICgpIHtcbn1cblxuLyoqXG4gKiBkZXRlcm1pbmVzIGlmIHRoZSBwYXNzZWQgaW4gcGF0aCBoYXMgYSB0cmFpbGluZyBzbGFzaC4gUGF0aHMgb2YgdGhlIGZvcm1cbiAqICdib2R5LzAvMS8nIHJldHVybiB0cnVlLCB3aGlsZSBwYXRocyBvZiB0aGUgZm9ybSAnYm9keS8wLzEnIHJldHVybiBmYWxzZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGhcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgcGF0aCBoYXMgYSB0cmFpbGluZyBzbGFzaFxuICovXG5QYXRoVXRpbHMucHJvdG90eXBlLmhhc1RyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbiBoYXNUcmFpbGluZ1NsYXNoIChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZXB0aCBpbiB0aGUgdHJlZSB0aGlzIHBhdGggcmVwcmVzZW50cy4gRXNzZW50aWFsbHkgY291bnRzXG4gKiB0aGUgc2xhc2hlcyBpZ25vcmluZyBhIHRyYWlsaW5nIHNsYXNoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIGRlcHRoIGluIHRoZSB0cmVlIHRoYXQgdGhpcyBwYXRoIHJlcHJlc2VudHNcbiAqL1xuUGF0aFV0aWxzLnByb3RvdHlwZS5kZXB0aCA9IGZ1bmN0aW9uIGRlcHRoIChwYXRoKSB7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgdmFyIGxlbiA9IHRoaXMuaGFzVHJhaWxpbmdTbGFzaChwYXRoKSA/IGxlbmd0aCAtIDEgOiBsZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSBjb3VudCArPSBwYXRoW2ldID09PSAnLycgPyAxIDogMDtcbiAgICByZXR1cm4gY291bnQ7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoaXMgcGF0aCBpbiByZWxhdGlvbiB0byBpdHMgc2libGluZ3MuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgaW5kZXggb2YgdGhpcyBwYXRoIGluIHJlbGF0aW9uIHRvIGl0cyBzaWJsaW5ncy5cbiAqL1xuUGF0aFV0aWxzLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uIGluZGV4IChwYXRoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBsZW4gPSB0aGlzLmhhc1RyYWlsaW5nU2xhc2gocGF0aCkgPyBsZW5ndGggLSAxIDogbGVuZ3RoO1xuICAgIHdoaWxlIChsZW4tLSkgaWYgKHBhdGhbbGVuXSA9PT0gJy8nKSBicmVhaztcbiAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQocGF0aC5zdWJzdHJpbmcobGVuICsgMSkpO1xuICAgIHJldHVybiBpc05hTihyZXN1bHQpID8gMCA6IHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHBhdGggYXQgYSBwYXJ0aWN1bGFyIGJyZWFkdGggaW4gcmVsYXRpb25zaGlwXG4gKiB0byBpdHMgc2libGluZ3NcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCB0aGUgYnJlYWR0aCBhdCB3aGljaCB0byBmaW5kIHRoZSBpbmRleFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gaW5kZXggYXQgdGhlIHBhcnRpY3VsYXIgZGVwdGhcbiAqL1xuUGF0aFV0aWxzLnByb3RvdHlwZS5pbmRleEF0RGVwdGggPSBmdW5jdGlvbiBpbmRleEF0RGVwdGggKHBhdGgsIGRlcHRoKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGlmIChwYXRoW2ldID09PSAnLycpIGluZGV4Kys7XG4gICAgICAgIGlmIChpbmRleCA9PT0gZGVwdGgpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZyhpID8gaSArIDEgOiBpKTtcbiAgICAgICAgICAgIGluZGV4ID0gcGF0aC5pbmRleE9mKCcvJyk7XG4gICAgICAgICAgICBwYXRoID0gaW5kZXggPT09IC0xID8gcGF0aCA6IHBhdGguc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQocGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gaXNOYU4oaW5kZXgpID8gcGF0aCA6IGluZGV4O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSBwYXRoIG9mIHRoZSBwYXNzZWQgaW4gcGF0aCdzIHBhcmVudC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGhcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBwYXRoIG9mIHRoZSBwYXNzZWQgaW4gcGF0aCdzIHBhcmVudFxuICovXG5QYXRoVXRpbHMucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uIHBhcmVudCAocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxhc3RJbmRleE9mKCcvJywgcGF0aC5sZW5ndGggLSAyKSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIGZpcnN0IGFyZ3VtZW50IHBhdGggaXMgdGhlIGRpcmVjdCBjaGlsZFxuICogb2YgdGhlIHNlY29uZCBhcmd1bWVudCBwYXRoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY2hpbGQgdGhlIHBhdGggdGhhdCBtYXkgYmUgYSBjaGlsZFxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGF0aCB0aGF0IG1heSBiZSBhIHBhcmVudFxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBmaXJzdCBhcmd1bWVudCBwYXRoIGlzIGEgY2hpbGQgb2YgdGhlIHNlY29uZCBhcmd1bWVudCBwYXRoXG4gKi9cblBhdGhVdGlscy5wcm90b3R5cGUuaXNDaGlsZE9mID0gZnVuY3Rpb24gaXNDaGlsZE9mIChjaGlsZCwgcGFyZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEZXNjZW5kZW50T2YoY2hpbGQsIHBhcmVudCkgJiYgdGhpcy5kZXB0aChjaGlsZCkgPT09IHRoaXMuZGVwdGgocGFyZW50KSArIDE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZmlyc3QgYXJndW1lbnQgcGF0aCBpcyBhIGRlc2NlbmRlbnQgb2YgdGhlIHNlY29uZCBhcmd1bWVudCBwYXRoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY2hpbGQgcG90ZW50aWFsIGRlc2NlbmRlbnQgcGF0aFxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCBwb3RlbnRpYWwgYW5jZXN0b3IgcGF0aFxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBwYXRoIGlzIGEgZGVzY2VuZGVudFxuICovXG5QYXRoVXRpbHMucHJvdG90eXBlLmlzRGVzY2VuZGVudE9mID0gZnVuY3Rpb24gaXNEZXNjZW5kZW50T2YoY2hpbGQsIHBhcmVudCkge1xuICAgIGlmIChjaGlsZCA9PT0gcGFyZW50KSByZXR1cm4gZmFsc2U7XG4gICAgY2hpbGQgPSB0aGlzLmhhc1RyYWlsaW5nU2xhc2goY2hpbGQpID8gY2hpbGQgOiBjaGlsZCArICcvJztcbiAgICBwYXJlbnQgPSB0aGlzLmhhc1RyYWlsaW5nU2xhc2gocGFyZW50KSA/IHBhcmVudCA6IHBhcmVudCArICcvJztcbiAgICByZXR1cm4gdGhpcy5kZXB0aChwYXJlbnQpIDwgdGhpcy5kZXB0aChjaGlsZCkgJiYgY2hpbGQuaW5kZXhPZihwYXJlbnQpID09PSAwO1xufTtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSBzZWxlY3RvciBwb3J0aW9uIG9mIHRoZSBwYXRoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aFxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHNlbGVjdG9yIHBvcnRpb24gb2YgdGhlIHBhdGguXG4gKi9cblBhdGhVdGlscy5wcm90b3R5cGUuZ2V0U2VsZWN0b3IgPSBmdW5jdGlvbiBnZXRTZWxlY3RvcihwYXRoKSB7XG4gICAgdmFyIGluZGV4ID0gcGF0aC5pbmRleE9mKCcvJyk7XG4gICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IHBhdGggOiBwYXRoLnN1YnN0cmluZygwLCBpbmRleCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBQYXRoVXRpbHMoKTtcblxuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2hpbnQgLVcwNzkgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGFzc29jaWF0ZSBhbnkgaXRlbSB3aXRoIGEgcGF0aC5cbiAqIEl0ZW1zIGFuZCBwYXRocyBhcmUga2VwdCBpbiBmbGF0IGFycmF5cyBmb3IgZWFzeSBpdGVyYXRpb25cbiAqIGFuZCBhIG1lbW8gaXMgdXNlZCB0byBwcm92aWRlIGNvbnN0YW50IHRpbWUgbG9va3VwLlxuICpcbiAqIEBjbGFzc1xuICpcbiAqL1xuZnVuY3Rpb24gUGF0aFN0b3JlICgpIHtcbiAgICB0aGlzLml0ZW1zID0gW107XG4gICAgdGhpcy5wYXRocyA9IFtdO1xuICAgIHRoaXMubWVtbyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc29jaWF0ZXMgYW4gaXRlbSB3aXRoIHRoZSBnaXZlbiBwYXRoLiBFcnJvcnMgaWYgYW4gaXRlbVxuICogYWxyZWFkeSBleGlzdHMgYXQgdGhlIGdpdmVuIHBhdGguXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIGF0IHdoaWNoIHRvIGluc2VydCB0aGUgaXRlbVxuICogQHBhcmFtIHtBbnl9IGl0ZW0gVGhlIGl0ZW0gdG8gYXNzb2NpYXRlIHdpdGggdGhlIGdpdmVuIHBhdGguXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuUGF0aFN0b3JlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKHBhdGgsIGl0ZW0pIHtcbiAgICB2YXIgcGF0aHMgPSB0aGlzLnBhdGhzO1xuICAgIHZhciBpbmRleCA9IHBhdGhzLmluZGV4T2YocGF0aCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdGVtIGFscmVhZHkgZXhpc3RzIGF0IHBhdGg6ICcgKyBwYXRoKTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgdGFyZ2V0RGVwdGggPSBQYXRoVXRpbHMuZGVwdGgocGF0aCk7XG4gICAgdmFyIHRhcmdldEluZGV4ID0gUGF0aFV0aWxzLmluZGV4KHBhdGgpO1xuXG4gICAgLy8gVGhlIGl0ZW0gd2lsbCBiZSBpbnNlcnRlZCBhdCBhIHBvaW50IGluIHRoZSBhcnJheVxuICAgIC8vIHN1Y2ggdGhhdCBpdCBpcyB3aXRoaW4gaXRzIG93biBicmVhZHRoIGluIHRoZSB0cmVlXG4gICAgLy8gdGhhdCB0aGUgcGF0aHMgcmVwcmVzZW50XG4gICAgd2hpbGUgKFxuICAgICAgICBwYXRoc1tpXSAmJlxuICAgICAgICB0YXJnZXREZXB0aCA+PSBQYXRoVXRpbHMuZGVwdGgocGF0aHNbaV0pXG4gICAgKSBpKys7XG5cbiAgICAvLyBUaGUgaXRlbSB3aWxsIGJlIHNvcnRlZCB3aXRoaW4gaXRzIGJyZWFkdGggYnkgaW5kZXhcbiAgICAvLyBpbiByZWdhcmQgdG8gaXRzIHNpYmxpbmdzLlxuICAgIHdoaWxlIChcbiAgICAgICAgcGF0aHNbaV0gJiZcbiAgICAgICAgdGFyZ2V0RGVwdGggPT09IFBhdGhVdGlscy5kZXB0aChwYXRoc1tpXSkgJiZcbiAgICAgICAgdGFyZ2V0SW5kZXggPCBQYXRoVXRpbHMuaW5kZXgocGF0aHNbaV0pXG4gICAgKSBpKys7XG5cbiAgICAvLyBpbnNlcnQgdGhlIGl0ZW1zIGluIHRoZSBwYXRoXG4gICAgcGF0aHMuc3BsaWNlKGksIDAsIHBhdGgpO1xuICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIDAsIGl0ZW0pO1xuXG4gICAgLy8gc3RvcmUgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHBhdGggYW5kIGluZGV4IGluIHRoZSBtZW1vXG4gICAgdGhpcy5tZW1vW3BhdGhdID0gaTtcblxuICAgIC8vIGFsbCBpdGVtcyBiZWhpbmQgdGhlIGluc2VydGVkIGl0ZW0gYXJlIG5vdyBubyBsb25nZXJcbiAgICAvLyBhY2N1cmF0ZWx5IHN0b3JlZCBpbiB0aGUgbWVtby4gVGh1cyB0aGUgbWVtbyBtdXN0IGJlIGNsZWFyZWQgZm9yXG4gICAgLy8gdGhlc2UgaXRlbXMuXG4gICAgZm9yICh2YXIgbGVuID0gdGhpcy5wYXRocy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICB0aGlzLm1lbW9bdGhpcy5wYXRoc1tpXV0gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSB0aGUgaXRlbSBmcm9tIHRoZSBzdG9yZSBhdCB0aGUgZ2l2ZW4gcGF0aC5cbiAqIEVycm9ycyBpZiBubyBpdGVtIGV4aXN0cyBhdCB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIHBhdGggYXQgd2hpY2ggdG8gcmVtb3ZlIHRoZSBpdGVtLlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblBhdGhTdG9yZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChwYXRoKSB7XG4gICAgdmFyIHBhdGhzID0gdGhpcy5wYXRocztcbiAgICB2YXIgaW5kZXggPSB0aGlzLm1lbW9bcGF0aF0gPyB0aGlzLm1lbW9bcGF0aF0gOiBwYXRocy5pbmRleE9mKHBhdGgpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlbW92ZS4gTm8gaXRlbSBleGlzdHMgYXQgcGF0aDogJyArIHBhdGgpO1xuXG4gICAgcGF0aHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLml0ZW1zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICB0aGlzLm1lbW9bcGF0aF0gPSBudWxsO1xuXG4gICAgZm9yICh2YXIgbGVuID0gdGhpcy5wYXRocy5sZW5ndGggOyBpbmRleCA8IGxlbiA7IGluZGV4KyspXG4gICAgICAgIHRoaXMubWVtb1t0aGlzLnBhdGhzW2luZGV4XV0gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVtIHN0b3JlZCBhdCB0aGUgY3VycmVudCBwYXRoLiBSZXR1cm5zIHVuZGVmaW5lZFxuICogaWYgbm8gaXRlbSBpcyBzdG9yZWQgYXQgdGhhdCBwYXRoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBsb29rdXAgdGhlIGl0ZW0gZm9yXG4gKlxuICogQHJldHVybiB7QW55IHwgdW5kZWZpbmVkfSB0aGUgaXRlbSBzdG9yZWQgb3IgdW5kZWZpbmVkXG4gKi9cblBhdGhTdG9yZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChwYXRoKSB7XG4gICAgaWYgKHRoaXMubWVtb1twYXRoXSkgcmV0dXJuIHRoaXMuaXRlbXNbdGhpcy5tZW1vW3BhdGhdXTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMucGF0aHMuaW5kZXhPZihwYXRoKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB2b2lkIDA7XG5cbiAgICB0aGlzLm1lbW9bcGF0aF0gPSBpbmRleDtcblxuICAgIHJldHVybiB0aGlzLml0ZW1zW2luZGV4XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgaXRlbXMgY3VycmVudGx5IHN0b3JlZCBpbiB0aGlzXG4gKiBQYXRoU3RvcmUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBpdGVtcyBjdXJyZW50bHkgc3RvcmVkXG4gKi9cblBhdGhTdG9yZS5wcm90b3R5cGUuZ2V0SXRlbXMgPSBmdW5jdGlvbiBnZXRJdGVtcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBhdGhzIGN1cnJlbnRseSBzdG9yZWQgaW4gdGhpc1xuICogUGF0aFN0b3JlLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gcGF0aHMgY3VycmVudGx5IHN0b3JlZFxuICovXG5QYXRoU3RvcmUucHJvdG90eXBlLmdldFBhdGhzID0gZnVuY3Rpb24gZ2V0UGF0aHMgKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGhzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXRoU3RvcmU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKmpzaGludCAtVzA3OSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XG52YXIgRGlzcGF0Y2ggPSByZXF1aXJlKCcuL0Rpc3BhdGNoJyk7XG52YXIgQ29tbWFuZHMgPSByZXF1aXJlKCcuL0NvbW1hbmRzJyk7XG52YXIgVHJhbnNmb3JtU3lzdGVtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm1TeXN0ZW0nKTtcbnZhciBTaXplU3lzdGVtID0gcmVxdWlyZSgnLi9TaXplU3lzdGVtJyk7XG5cbi8qKlxuICogU2NlbmUgaXMgdGhlIGJvdHRvbSBvZiB0aGUgc2NlbmUgZ3JhcGguIEl0IGlzIGl0cyBvd25cbiAqIHBhcmVudCBhbmQgcHJvdmlkZXMgdGhlIGdsb2JhbCB1cGRhdGVyIHRvIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAY2xhc3MgU2NlbmVcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBhIHN0cmluZyB3aGljaCBpcyBhIGRvbSBzZWxlY3RvclxuICogICAgICAgICAgICAgICAgIHNpZ25pZnlpbmcgd2hpY2ggZG9tIGVsZW1lbnQgdGhlIGNvbnRleHRcbiAqICAgICAgICAgICAgICAgICBzaG91bGQgYmUgc2V0IHVwb25cbiAqIEBwYXJhbSB7RmFtb3VzfSB1cGRhdGVyIGEgY2xhc3Mgd2hpY2ggY29uZm9ybXMgdG8gRmFtb3VzJyBpbnRlcmZhY2VcbiAqICAgICAgICAgICAgICAgICBpdCBuZWVkcyB0byBiZSBhYmxlIHRvIHNlbmQgbWV0aG9kcyB0b1xuICogICAgICAgICAgICAgICAgIHRoZSByZW5kZXJlcnMgYW5kIHVwZGF0ZSBub2RlcyBpbiB0aGUgc2NlbmUgZ3JhcGhcbiAqL1xuZnVuY3Rpb24gU2NlbmUgKHNlbGVjdG9yLCB1cGRhdGVyKSB7XG4gICAgaWYgKCFzZWxlY3RvcikgdGhyb3cgbmV3IEVycm9yKCdTY2VuZSBuZWVkcyB0byBiZSBjcmVhdGVkIHdpdGggYSBET00gc2VsZWN0b3InKTtcbiAgICBpZiAoIXVwZGF0ZXIpIHRocm93IG5ldyBFcnJvcignU2NlbmUgbmVlZHMgdG8gYmUgY3JlYXRlZCB3aXRoIGEgY2xhc3MgbGlrZSBGYW1vdXMnKTtcblxuICAgIE5vZGUuY2FsbCh0aGlzKTsgICAgICAgICAvLyBTY2VuZSBpbmhlcml0cyBmcm9tIG5vZGVcblxuICAgIHRoaXMuX2dsb2JhbFVwZGF0ZXIgPSB1cGRhdGVyOyAvLyBUaGUgdXBkYXRlciB0aGF0IHdpbGwgYm90aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZW5kIG1lc3NhZ2VzIHRvIHRoZSByZW5kZXJlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHVwZGF0ZSBkaXJ0eSBub2Rlc1xuXG4gICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjsgLy8gcmVmZXJlbmNlIHRvIHRoZSBET00gc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHJlcHJlc2VudHMgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgZG9tIHRoYXQgdGhpcyBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5oYWJpdHNcblxuICAgIHRoaXMubW91bnQoc2VsZWN0b3IpOyAvLyBNb3VudCB0aGUgY29udGV4dCB0byBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGl0IGlzIGl0cyBvd24gcGFyZW50KVxuXG4gICAgdGhpcy5fZ2xvYmFsVXBkYXRlciAgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgYSByZXF1ZXN0IGZvciB0aGUgZG9tXG4gICAgICAgIC5tZXNzYWdlKENvbW1hbmRzLk5FRURfU0laRV9GT1IpICAvLyBzaXplIG9mIHRoZSBjb250ZXh0IHNvIHRoYXRcbiAgICAgICAgLm1lc3NhZ2Uoc2VsZWN0b3IpOyAgICAgICAgICAgICAgIC8vIHRoZSBzY2VuZSBncmFwaCBoYXMgYSB0b3RhbCBzaXplXG5cbiAgICB0aGlzLnNob3coKTsgLy8gdGhlIGNvbnRleHQgYmVnaW5zIHNob3duIChpdCdzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgZG9tKVxufVxuXG4vLyBTY2VuZSBpbmhlcml0cyBmcm9tIG5vZGVcblNjZW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xuU2NlbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NlbmU7XG5cbi8qKlxuICogU2NlbmUgZ2V0VXBkYXRlciBmdW5jdGlvbiByZXR1cm5zIHRoZSBwYXNzZWQgaW4gdXBkYXRlclxuICpcbiAqIEByZXR1cm4ge0ZhbW91c30gdGhlIHVwZGF0ZXIgZm9yIHRoaXMgU2NlbmVcbiAqL1xuU2NlbmUucHJvdG90eXBlLmdldFVwZGF0ZXIgPSBmdW5jdGlvbiBnZXRVcGRhdGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlcjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2VsZWN0b3IgdGhhdCB0aGUgY29udGV4dCB3YXMgaW5zdGFudGlhdGVkIHdpdGhcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGRvbSBzZWxlY3RvclxuICovXG5TY2VuZS5wcm90b3R5cGUuZ2V0U2VsZWN0b3IgPSBmdW5jdGlvbiBnZXRTZWxlY3RvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdG9yO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaXNwYXRjaGVyIG9mIHRoZSBjb250ZXh0LiBVc2VkIHRvIHNlbmQgZXZlbnRzXG4gKiB0byB0aGUgbm9kZXMgaW4gdGhlIHNjZW5lIGdyYXBoLlxuICpcbiAqIEByZXR1cm4ge0Rpc3BhdGNofSB0aGUgU2NlbmUncyBEaXNwYXRjaFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuU2NlbmUucHJvdG90eXBlLmdldERpc3BhdGNoID0gZnVuY3Rpb24gZ2V0RGlzcGF0Y2ggKCkge1xuICAgIGNvbnNvbGUud2FybignU2NlbmUjZ2V0RGlzcGF0Y2ggaXMgZGVwcmVjYXRlZCwgcmVxdWlyZSB0aGUgZGlzcGF0Y2ggZGlyZWN0bHknKTtcbiAgICByZXR1cm4gRGlzcGF0Y2g7XG59O1xuXG4vKipcbiAqIFJlY2VpdmVzIGFuIGV2ZW50LiBJZiB0aGUgZXZlbnQgaXMgJ0NPTlRFWFRfUkVTSVpFJyBpdCBzZXRzIHRoZSBzaXplIG9mIHRoZSBzY2VuZVxuICogZ3JhcGggdG8gdGhlIHBheWxvYWQsIHdoaWNoIG11c3QgYmUgYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBhdCBsZWFzdFxuICogbGVuZ3RoIHRocmVlIHJlcHJlc2VudGluZyB0aGUgcGl4ZWwgc2l6ZSBpbiAzIGRpbWVuc2lvbnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IHRoZSBuYW1lIG9mIHRoZSBldmVudCBiZWluZyByZWNlaXZlZFxuICogQHBhcmFtIHsqfSBwYXlsb2FkIHRoZSBvYmplY3QgYmVpbmcgc2VudFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblNjZW5lLnByb3RvdHlwZS5vblJlY2VpdmUgPSBmdW5jdGlvbiBvblJlY2VpdmUgKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgLy8gVE9ETzogSW4gdGhlIGZ1dHVyZSB0aGUgZG9tIGVsZW1lbnQgdGhhdCB0aGUgY29udGV4dCBpcyBhdHRhY2hlZCB0b1xuICAgIC8vIHNob3VsZCBoYXZlIGEgcmVwcmVzZW50YXRpb24gYXMgYSBjb21wb25lbnQuIEl0IHdvdWxkIGJlIHJlbmRlciBzaXplZFxuICAgIC8vIGFuZCB0aGUgY29udGV4dCB3b3VsZCByZWNlaXZlIGl0cyBzaXplIHRoZSBzYW1lIHdheSB0aGF0IGFueSByZW5kZXIgc2l6ZVxuICAgIC8vIGNvbXBvbmVudCByZWNlaXZlcyBpdHMgc2l6ZS5cbiAgICBpZiAoZXZlbnQgPT09ICdDT05URVhUX1JFU0laRScpIHtcbiAgICAgICAgaWYgKHBheWxvYWQubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ0NPTlRFWFRfUkVTSVpFXFwncyBwYXlsb2FkIG5lZWRzIHRvIGJlIGF0IGxlYXN0IGEgcGFpcicgK1xuICAgICAgICAgICAgICAgICAgICAnIG9mIHBpeGVsIHNpemVzJ1xuICAgICAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnNldFNpemVNb2RlKCdhYnNvbHV0ZScsICdhYnNvbHV0ZScsICdhYnNvbHV0ZScpO1xuICAgICAgICB0aGlzLnNldEFic29sdXRlU2l6ZShwYXlsb2FkWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkWzJdID8gcGF5bG9hZFsyXSA6IDApO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZXIubWVzc2FnZShDb21tYW5kcy5XSVRIKS5tZXNzYWdlKHRoaXMuX3NlbGVjdG9yKS5tZXNzYWdlKENvbW1hbmRzLlJFQURZKTtcbiAgICB9XG59O1xuXG5cblNjZW5lLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uIG1vdW50IChwYXRoKSB7XG4gICAgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NlbmUgaXMgYWxyZWFkeSBtb3VudGVkIGF0OiAnICsgdGhpcy5nZXRMb2NhdGlvbigpKTtcbiAgICBEaXNwYXRjaC5tb3VudChwYXRoLCB0aGlzKTtcbiAgICB0aGlzLl9pZCA9IHBhdGg7XG4gICAgdGhpcy5fbW91bnRlZCA9IHRydWU7XG4gICAgdGhpcy5fcGFyZW50ID0gdGhpcztcbiAgICBUcmFuc2Zvcm1TeXN0ZW0ucmVnaXN0ZXJUcmFuc2Zvcm1BdFBhdGgocGF0aCk7XG4gICAgU2l6ZVN5c3RlbS5yZWdpc3RlclNpemVBdFBhdGgocGF0aCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjZW5lO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgT05FUyA9IFsxLCAxLCAxXTtcbnZhciBaRVJPUyA9IFswLCAwLCAwXTtcblxuLyoqXG4gKiBUaGUgU2l6ZSBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgcHJvY2Vzc2luZyBTaXplIGZyb20gYSBub2RlXG4gKiBAY29uc3RydWN0b3IgU2l6ZVxuICpcbiAqIEBwYXJhbSB7U2l6ZX0gcGFyZW50IHRoZSBwYXJlbnQgc2l6ZVxuICovXG5mdW5jdGlvbiBTaXplIChwYXJlbnQpIHtcblxuICAgIHRoaXMuZmluYWxTaXplID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICB0aGlzLnNpemVDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLnNpemVNb2RlID0gbmV3IFVpbnQ4QXJyYXkoMyk7XG4gICAgdGhpcy5zaXplTW9kZUNoYW5nZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuYWJzb2x1dGVTaXplID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICB0aGlzLmFic29sdXRlU2l6ZUNoYW5nZWQgPSBmYWxzZTtcblxuICAgIHRoaXMucHJvcG9ydGlvbmFsU2l6ZSA9IG5ldyBGbG9hdDMyQXJyYXkoT05FUyk7XG4gICAgdGhpcy5wcm9wb3J0aW9uYWxTaXplQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5kaWZmZXJlbnRpYWxTaXplID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICB0aGlzLmRpZmZlcmVudGlhbFNpemVDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLnJlbmRlclNpemUgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgIHRoaXMucmVuZGVyU2l6ZUNoYW5nZWQgPSBmYWxzZTtcblxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50ICE9IG51bGwgPyBwYXJlbnQgOiBudWxsO1xufVxuXG4vLyBhbiBlbnVtZXJhdGlvbiBvZiB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIHNpemUgbW9kZXNcblNpemUuUkVMQVRJVkUgPSAwO1xuU2l6ZS5BQlNPTFVURSA9IDE7XG5TaXplLlJFTkRFUiA9IDI7XG5TaXplLkRFRkFVTFQgPSBTaXplLlJFTEFUSVZFO1xuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHdoaWNoIHNldHMgYSB2YWx1ZSB3aXRoaW4gYW4gYXJyYXlcbiAqIGFuZCByZXBvcnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2ZWMgVGhlIGFycmF5IHRvIHNldCB0aGUgdmFsdWUgaW5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc2V0IHRoZSB2YWx1ZVxuICogQHBhcmFtIHtBbnl9IHZhbCBJZiB0aGUgdmFsIGlzIHVuZGVmaW5lZCBvciBudWxsLCBvciBpZiB0aGUgdmFsdWVcbiAqICAgICAgICAgICAgICAgICAgaXMgdGhlIHNhbWUgYXMgd2hhdCBpcyBhbHJlYWR5IHRoZXJlLCB0aGVuIG5vdGhpbmdcbiAqICAgICAgICAgICAgICAgICAgaXMgc2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJldHVybnMgdHJ1ZSBpZiBhbnl0aGluZyBjaGFuZ2VkXG4gKi9cbmZ1bmN0aW9uIF92ZWNPcHRpb25hbFNldCAodmVjLCBpbmRleCwgdmFsKSB7XG4gICAgaWYgKHZhbCAhPSBudWxsICYmIHZlY1tpbmRleF0gIT09IHZhbCkge1xuICAgICAgICB2ZWNbaW5kZXhdID0gdmFsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHdoaWNoIHNldHMgdGhyZWUgdmFsdWVzIHdpdGhpbiBhbiBhcnJheSBvZiB0aHJlZVxuICogdXNpbmcgX3ZlY09wdGlvbmFsU2V0LiBSZXR1cm5zIHdoZXRoZXIgYW55dGhpbmcgaGFzIGNoYW5nZWQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZlYyBUaGUgYXJyYXkgdG8gc2V0IHRoZSB2YWx1ZXMgb2ZcbiAqIEBwYXJhbSB7QW55fSB4IFRoZSBmaXJzdCB2YWx1ZSB0byBzZXQgd2l0aGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtBbnl9IHkgVGhlIHNlY29uZCB2YWx1ZSB0byBzZXQgd2l0aGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtBbnl9IHogVGhlIHRoaXJkIHZhbHVlIHRvIHNldCB3aXRoaW4gdGhlIGFycmF5XG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBhbnl0aGluZyBoYXMgY2hhbmdlZFxuICovXG5mdW5jdGlvbiBzZXRWZWMgKHZlYywgeCwgeSwgeikge1xuICAgIHZhciBwcm9wYWdhdGUgPSBmYWxzZTtcblxuICAgIHByb3BhZ2F0ZSA9IF92ZWNPcHRpb25hbFNldCh2ZWMsIDAsIHgpIHx8IHByb3BhZ2F0ZTtcbiAgICBwcm9wYWdhdGUgPSBfdmVjT3B0aW9uYWxTZXQodmVjLCAxLCB5KSB8fCBwcm9wYWdhdGU7XG4gICAgcHJvcGFnYXRlID0gX3ZlY09wdGlvbmFsU2V0KHZlYywgMiwgeikgfHwgcHJvcGFnYXRlO1xuXG4gICAgcmV0dXJuIHByb3BhZ2F0ZTtcbn1cblxuLyoqXG4gKiBQcml2YXRlIG1ldGhvZCB0byBhbGxvdyBmb3IgcG9seW1vcnBoaXNtIGluIHRoZSBzaXplIG1vZGUgc3VjaCB0aGF0IHN0cmluZ3NcbiAqIG9yIHRoZSBudW1iZXJzIGZyb20gdGhlIGVudW1lcmF0aW9uIGNhbiBiZSB1c2VkLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbCBUaGUgU2l6ZSBtb2RlIHRvIHJlc29sdmUuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgcmVzb2x2ZWQgc2l6ZSBtb2RlIGZyb20gdGhlIGVudW1lcmF0aW9uLlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2l6ZU1vZGUgKHZhbCkge1xuICAgIGlmICh2YWwuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICBzd2l0Y2ggKHZhbC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdyZWxhdGl2ZSc6XG4gICAgICAgICAgICBjYXNlICdkZWZhdWx0JzogcmV0dXJuIFNpemUuUkVMQVRJVkU7XG4gICAgICAgICAgICBjYXNlICdhYnNvbHV0ZSc6IHJldHVybiBTaXplLkFCU09MVVRFO1xuICAgICAgICAgICAgY2FzZSAncmVuZGVyJzogcmV0dXJuIFNpemUuUkVOREVSO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHNpemUgbW9kZTogJyArIHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsIDwgMCB8fCB2YWwgPiBTaXplLlJFTkRFUikgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHNpemUgbW9kZTogJyArIHZhbCk7XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBwYXJlbnQgb2YgdGhpcyBzaXplLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1NpemV9IHBhcmVudCBUaGUgcGFyZW50IHNpemUgY29tcG9uZW50XG4gKlxuICogQHJldHVybiB7U2l6ZX0gdGhpc1xuICovXG5TaXplLnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbiBzZXRQYXJlbnQgKHBhcmVudCkge1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgb2YgdGhpcyBzaXplLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJucyB7U2l6ZXx1bmRlZmluZWR9IHRoZSBwYXJlbnQgaWYgb25lIGV4aXN0c1xuICovXG5TaXplLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiBnZXRQYXJlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBtb2RlIG9mIHRoaXMgc2l6ZSByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCB0aGUgc2l6ZSBtb2RlIHRvIHVzZSBmb3IgdGhlIHdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0geSB0aGUgc2l6ZSBtb2RlIHRvIHVzZSBmb3IgdGhlIGhlaWdodFxuICogQHBhcmFtIHtOdW1iZXJ9IHogdGhlIHNpemUgbW9kZSB0byB1c2UgZm9yIHRoZSBkZXB0aFxuICpcbiAqIEByZXR1cm4ge2FycmF5fSBhcnJheSBvZiBzaXplIG1vZGVzXG4gKi9cblNpemUucHJvdG90eXBlLnNldFNpemVNb2RlID0gZnVuY3Rpb24gc2V0U2l6ZU1vZGUgKHgsIHksIHopIHtcbiAgICBpZiAoeCAhPSBudWxsKSB4ID0gcmVzb2x2ZVNpemVNb2RlKHgpO1xuICAgIGlmICh5ICE9IG51bGwpIHkgPSByZXNvbHZlU2l6ZU1vZGUoeSk7XG4gICAgaWYgKHogIT0gbnVsbCkgeiA9IHJlc29sdmVTaXplTW9kZSh6KTtcbiAgICB0aGlzLnNpemVNb2RlQ2hhbmdlZCA9IHNldFZlYyh0aGlzLnNpemVNb2RlLCB4LCB5LCB6KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2l6ZSBtb2RlIG9mIHRoaXMgY29tcG9uZW50LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gdGhlIGN1cnJlbnQgc2l6ZSBtb2RlIG9mIHRoZSB0aGlzLlxuICovXG5TaXplLnByb3RvdHlwZS5nZXRTaXplTW9kZSA9IGZ1bmN0aW9uIGdldFNpemVNb2RlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplTW9kZTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgYWJzb2x1dGUgc2l6ZSBvZiB0aGlzIHNpemUgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGRpbWVuc2lvbiBvZiB0aGUgYWJzb2x1dGUgc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgZGltZW5zaW9uIG9mIHRoZSBhYnNvbHV0ZSBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0geiBUaGUgeiBkaW1lbnNpb24gb2YgdGhlIGFic29sdXRlIHNpemVcbiAqXG4gKiBAcmV0dXJuIHtTaXplfSB0aGlzXG4gKi9cblNpemUucHJvdG90eXBlLnNldEFic29sdXRlID0gZnVuY3Rpb24gc2V0QWJzb2x1dGUgKHgsIHksIHopIHtcbiAgICB0aGlzLmFic29sdXRlU2l6ZUNoYW5nZWQgPSBzZXRWZWModGhpcy5hYnNvbHV0ZVNpemUsIHgsIHksIHopO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBhYnNvbHV0ZSBzaXplIG9mIHRoaXMgc2l6ZSByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHthcnJheX0gYXJyYXkgb2YgYWJzb2x1dGUgc2l6ZVxuICovXG5TaXplLnByb3RvdHlwZS5nZXRBYnNvbHV0ZSA9IGZ1bmN0aW9uIGdldEFic29sdXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5hYnNvbHV0ZVNpemU7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHByb3BvcnRpb25hbCBzaXplIG9mIHRoaXMgc2l6ZSByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggZGltZW5zaW9uIG9mIHRoZSBwcm9wb3J0aW9uYWwgc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgZGltZW5zaW9uIG9mIHRoZSBwcm9wb3J0aW9uYWwgc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHogVGhlIHogZGltZW5zaW9uIG9mIHRoZSBwcm9wb3J0aW9uYWwgc2l6ZVxuICpcbiAqIEByZXR1cm4ge1NpemV9IHRoaXNcbiAqL1xuU2l6ZS5wcm90b3R5cGUuc2V0UHJvcG9ydGlvbmFsID0gZnVuY3Rpb24gc2V0UHJvcG9ydGlvbmFsICh4LCB5LCB6KSB7XG4gICAgdGhpcy5wcm9wb3J0aW9uYWxTaXplQ2hhbmdlZCA9IHNldFZlYyh0aGlzLnByb3BvcnRpb25hbFNpemUsIHgsIHksIHopO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wb3Rpb25hbCBzaXplIG9mIHRoaXMgc2l6ZSByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHthcnJheX0gYXJyYXkgb2YgcHJvcG9ydGlvbmFsIHNpemVcbiAqL1xuU2l6ZS5wcm90b3R5cGUuZ2V0UHJvcG9ydGlvbmFsID0gZnVuY3Rpb24gZ2V0UHJvcG9ydGlvbmFsICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wb3J0aW9uYWxTaXplO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkaWZmZXJlbnRpYWwgc2l6ZSBvZiB0aGlzIHNpemUgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGRpbWVuc2lvbiBvZiB0aGUgZGlmZmVyZW50aWFsIHNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGRpbWVuc2lvbiBvZiB0aGUgZGlmZmVyZW50aWFsIHNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGRpbWVuc2lvbiBvZiB0aGUgZGlmZmVyZW50aWFsIHNpemVcbiAqXG4gKiBAcmV0dXJuIHtTaXplfSB0aGlzXG4gKi9cblNpemUucHJvdG90eXBlLnNldERpZmZlcmVudGlhbCA9IGZ1bmN0aW9uIHNldERpZmZlcmVudGlhbCAoeCwgeSwgeikge1xuICAgIHRoaXMuZGlmZmVyZW50aWFsU2l6ZUNoYW5nZWQgPSBzZXRWZWModGhpcy5kaWZmZXJlbnRpYWxTaXplLCB4LCB5LCB6KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgZGlmZmVyZW50aWFsIHNpemUgb2YgdGhpcyBzaXplIHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge2FycmF5fSBhcnJheSBvZiBkaWZmZXJlbnRpYWwgc2l6ZVxuICovXG5TaXplLnByb3RvdHlwZS5nZXREaWZmZXJlbnRpYWwgPSBmdW5jdGlvbiBnZXREaWZmZXJlbnRpYWwgKCkge1xuICAgIHJldHVybiB0aGlzLmRpZmZlcmVudGlhbFNpemU7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBzaXplIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBkaW1lbnNpb24gb2YgdGhlIHNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGRpbWVuc2lvbiBvZiB0aGUgc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHogVGhlIHogZGltZW5zaW9uIG9mIHRoZSBzaXplXG4gKlxuICogQHJldHVybiB7U2l6ZX0gdGhpc1xuICovXG5TaXplLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU2l6ZTtcbn07XG5cbi8qKlxuICogZnJvbVNwZWNXaXRoUGFyZW50IHRha2VzIHRoZSBwYXJlbnQgbm9kZSdzIHNpemUsIHRoZSB0YXJnZXQgbm9kZSdzIHNwZWMsXG4gKiBhbmQgYSB0YXJnZXQgYXJyYXkgdG8gd3JpdGUgdG8uIFVzaW5nIHRoZSBub2RlJ3Mgc2l6ZSBtb2RlIGl0IGNhbGN1bGF0ZXNcbiAqIGEgZmluYWwgc2l6ZSBmb3IgdGhlIG5vZGUgZnJvbSB0aGUgbm9kZSdzIHNwZWMuIFJldHVybnMgd2hldGhlciBvciBub3RcbiAqIHRoZSBmaW5hbCBzaXplIGhhcyBjaGFuZ2VkIGZyb20gaXRzIGxhc3QgdmFsdWUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgdGhlIG5vZGUncyBjb21wb25lbnRzXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2l6ZSBvZiB0aGUgbm9kZSBoYXMgY2hhbmdlZC5cbiAqL1xuU2l6ZS5wcm90b3R5cGUuZnJvbUNvbXBvbmVudHMgPSBmdW5jdGlvbiBmcm9tQ29tcG9uZW50cyAoY29tcG9uZW50cykge1xuICAgIHZhciBtb2RlID0gdGhpcy5zaXplTW9kZTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5maW5hbFNpemU7XG4gICAgdmFyIHBhcmVudFNpemUgPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmdldCgpIDogWkVST1M7XG4gICAgdmFyIHByZXY7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgbGVuID0gY29tcG9uZW50cy5sZW5ndGg7XG4gICAgdmFyIGo7XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgMyA7IGkrKykge1xuICAgICAgICBwcmV2ID0gdGFyZ2V0W2ldO1xuICAgICAgICBzd2l0Y2ggKG1vZGVbaV0pIHtcbiAgICAgICAgICAgIGNhc2UgU2l6ZS5SRUxBVElWRTpcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBwYXJlbnRTaXplW2ldICogdGhpcy5wcm9wb3J0aW9uYWxTaXplW2ldICsgdGhpcy5kaWZmZXJlbnRpYWxTaXplW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTaXplLkFCU09MVVRFOlxuICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IHRoaXMuYWJzb2x1dGVTaXplW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTaXplLlJFTkRFUjpcbiAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlO1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbiA7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5nZXRSZW5kZXJTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBjb21wb25lbnQuZ2V0UmVuZGVyU2l6ZSgpW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gdGFyZ2V0W2ldIDwgY2FuZGlkYXRlIHx8IHRhcmdldFtpXSA9PT0gMCA/IGNhbmRpZGF0ZSA6IHRhcmdldFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBwcmV2ICE9PSB0YXJnZXRbaV07XG4gICAgfVxuICAgIHRoaXMuc2l6ZUNoYW5nZWQgPSBjaGFuZ2VkO1xuICAgIHJldHVybiBjaGFuZ2VkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaXplO1xuXG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUGF0aFN0b3JlID0gcmVxdWlyZSgnLi9QYXRoU3RvcmUnKTtcbnZhciBTaXplID0gcmVxdWlyZSgnLi9TaXplJyk7XG52YXIgRGlzcGF0Y2ggPSByZXF1aXJlKCcuL0Rpc3BhdGNoJyk7XG52YXIgUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbi8qKlxuICogVGhlIHNpemUgc3lzdGVtIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHNpemUgdGhyb3VnaG91dCB0aGUgc2NlbmUgZ3JhcGguXG4gKiBJdCBob2xkcyBzaXplIGNvbXBvbmVudHMgYW5kIG9wZXJhdGVzIHVwb24gdGhlbS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU2l6ZVN5c3RlbSAoKSB7XG4gICAgdGhpcy5wYXRoU3RvcmUgPSBuZXcgUGF0aFN0b3JlKCk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgc2l6ZSBjb21wb25lbnQgdG8gYSBnaXZlIHBhdGguIEEgc2l6ZSBjb21wb25lbnQgY2FuIGJlIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50XG4gKiBvciBhIGRlZmF1bHQgb25lIHdpbGwgYmUgY3JlYXRlZC4gVGhyb3dzIGlmIG5vIHNpemUgY29tcG9uZW50IGhhcyBiZWVuIGFkZGVkIGF0IHRoZSBwYXJlbnQgcGF0aC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIHBhdGggYXQgd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIHNpemUgY29tcG9uZW50XG4gKiBAcGFyYW0ge1NpemUgfCB1bmRlZmluZWR9IHNpemUgVGhlIHNpemUgY29tcG9uZW50IHRvIGJlIHJlZ2lzdGVyZWQgb3IgdW5kZWZpbmVkLlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblNpemVTeXN0ZW0ucHJvdG90eXBlLnJlZ2lzdGVyU2l6ZUF0UGF0aCA9IGZ1bmN0aW9uIHJlZ2lzdGVyU2l6ZUF0UGF0aCAocGF0aCwgc2l6ZSkge1xuICAgIGlmICghUGF0aFV0aWxzLmRlcHRoKHBhdGgpKSByZXR1cm4gdGhpcy5wYXRoU3RvcmUuaW5zZXJ0KHBhdGgsIHNpemUgPyBzaXplIDogbmV3IFNpemUoKSk7XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXRoU3RvcmUuZ2V0KFBhdGhVdGlscy5wYXJlbnQocGF0aCkpO1xuXG4gICAgaWYgKCFwYXJlbnQpIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdObyBwYXJlbnQgc2l6ZSByZWdpc3RlcmVkIGF0IGV4cGVjdGVkIHBhdGg6ICcgKyBQYXRoVXRpbHMucGFyZW50KHBhdGgpXG4gICAgKTtcblxuICAgIGlmIChzaXplKSBzaXplLnNldFBhcmVudChwYXJlbnQpO1xuXG4gICAgdGhpcy5wYXRoU3RvcmUuaW5zZXJ0KHBhdGgsIHNpemUgPyBzaXplIDogbmV3IFNpemUocGFyZW50KSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHNpemUgY29tcG9uZW50IGZyb20gdGhlIGdpdmVuIHBhdGguIFdpbGwgdGhyb3cgaWYgbm8gY29tcG9uZW50IGlzIGF0IHRoYXRcbiAqIHBhdGhcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIHBhdGggYXQgd2hpY2ggdG8gcmVtb3ZlIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblNpemVTeXN0ZW0ucHJvdG90eXBlLmRlcmVnaXN0ZXJTaXplQXRQYXRoID0gZnVuY3Rpb24gZGVyZWdpc3RlclNpemVBdFBhdGgocGF0aCkge1xuICAgIHRoaXMucGF0aFN0b3JlLnJlbW92ZShwYXRoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2l6ZSBjb21wb25lbnQgc3RvcmVkIGF0IGEgZ2l2ZW4gcGF0aC4gUmV0dXJucyB1bmRlZmluZWQgaWYgbm9cbiAqIHNpemUgY29tcG9uZW50IGlzIHJlZ2lzdGVyZWQgdG8gdGhhdCBwYXRoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCBhdCB3aGljaCB0byBnZXQgdGhlIHNpemUgY29tcG9uZW50LlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblNpemVTeXN0ZW0ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAocGF0aCkge1xuICAgIHJldHVybiB0aGlzLnBhdGhTdG9yZS5nZXQocGF0aCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHNpemVzIGluIHRoZSBzY2VuZSBncmFwaC4gQ2FsbGVkIGludGVybmFsbHkgYnkgdGhlIGZhbW91cyBlbmdpbmUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblNpemVTeXN0ZW0ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgdmFyIHNpemVzID0gdGhpcy5wYXRoU3RvcmUuZ2V0SXRlbXMoKTtcbiAgICB2YXIgcGF0aHMgPSB0aGlzLnBhdGhTdG9yZS5nZXRQYXRocygpO1xuICAgIHZhciBub2RlO1xuICAgIHZhciBzaXplO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGNvbXBvbmVudHM7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzaXplcy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBEaXNwYXRjaC5nZXROb2RlKHBhdGhzW2ldKTtcbiAgICAgICAgY29tcG9uZW50cyA9IG5vZGUuZ2V0Q29tcG9uZW50cygpO1xuICAgICAgICBpZiAoIW5vZGUpIGNvbnRpbnVlO1xuICAgICAgICBzaXplID0gc2l6ZXNbaV07XG4gICAgICAgIGlmIChzaXplLnNpemVNb2RlQ2hhbmdlZCkgc2l6ZU1vZGVDaGFuZ2VkKG5vZGUsIGNvbXBvbmVudHMsIHNpemUpO1xuICAgICAgICBpZiAoc2l6ZS5hYnNvbHV0ZVNpemVDaGFuZ2VkKSBhYnNvbHV0ZVNpemVDaGFuZ2VkKG5vZGUsIGNvbXBvbmVudHMsIHNpemUpO1xuICAgICAgICBpZiAoc2l6ZS5wcm9wb3J0aW9uYWxTaXplQ2hhbmdlZCkgcHJvcG9ydGlvbmFsU2l6ZUNoYW5nZWQobm9kZSwgY29tcG9uZW50cywgc2l6ZSk7XG4gICAgICAgIGlmIChzaXplLmRpZmZlcmVudGlhbFNpemVDaGFuZ2VkKSBkaWZmZXJlbnRpYWxTaXplQ2hhbmdlZChub2RlLCBjb21wb25lbnRzLCBzaXplKTtcbiAgICAgICAgaWYgKHNpemUucmVuZGVyU2l6ZUNoYW5nZWQpIHJlbmRlclNpemVDaGFuZ2VkKG5vZGUsIGNvbXBvbmVudHMsIHNpemUpO1xuICAgICAgICBpZiAoc2l6ZS5mcm9tQ29tcG9uZW50cyhjb21wb25lbnRzKSkgc2l6ZUNoYW5nZWQobm9kZSwgY29tcG9uZW50cywgc2l6ZSk7XG4gICAgfVxufTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzXG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gYWxlcnQgdGhlIG5vZGUgYW5kIGNvbXBvbmVudHMgdGhhdCBzaXplIG1vZGUgY2hhbmdlZC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBvdGVudGlhbGx5IGNhbGwgc2l6ZU1vZGVDaGFuZ2VkIG9uXG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRzIGEgbGlzdCBvZiB0aGUgbm9kZXMnIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSB0aGUgc2l6ZSBjbGFzcyBmb3IgdGhlIE5vZGVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBzaXplTW9kZUNoYW5nZWQgKG5vZGUsIGNvbXBvbmVudHMsIHNpemUpIHtcbiAgICB2YXIgc2l6ZU1vZGUgPSBzaXplLmdldFNpemVNb2RlKCk7XG4gICAgdmFyIHggPSBzaXplTW9kZVswXTtcbiAgICB2YXIgeSA9IHNpemVNb2RlWzFdO1xuICAgIHZhciB6ID0gc2l6ZU1vZGVbMl07XG4gICAgaWYgKG5vZGUub25TaXplTW9kZUNoYW5nZSkgbm9kZS5vblNpemVNb2RlQ2hhbmdlKHgsIHksIHopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25TaXplTW9kZUNoYW5nZSlcbiAgICAgICAgICAgIGNvbXBvbmVudHNbaV0ub25TaXplTW9kZUNoYW5nZSh4LCB5LCB6KTtcbiAgICBzaXplLnNpemVNb2RlQ2hhbmdlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHRvIGFsZXJ0IHRoZSBub2RlIGFuZCBjb21wb25lbnRzIHRoYXQgYWJzb2x1dGVTaXplIGNoYW5nZWQuXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwb3RlbnRpYWxseSBjYWxsIG9uQWJzb2x1dGVTaXplQ2hhbmdlIG9uXG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRzIGEgbGlzdCBvZiB0aGUgbm9kZXMnIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSB0aGUgc2l6ZSBjbGFzcyBmb3IgdGhlIE5vZGVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBhYnNvbHV0ZVNpemVDaGFuZ2VkIChub2RlLCBjb21wb25lbnRzLCBzaXplKSB7XG4gICAgdmFyIGFic29sdXRlU2l6ZSA9IHNpemUuZ2V0QWJzb2x1dGUoKTtcbiAgICB2YXIgeCA9IGFic29sdXRlU2l6ZVswXTtcbiAgICB2YXIgeSA9IGFic29sdXRlU2l6ZVsxXTtcbiAgICB2YXIgeiA9IGFic29sdXRlU2l6ZVsyXTtcbiAgICBpZiAobm9kZS5vbkFic29sdXRlU2l6ZUNoYW5nZSkgbm9kZS5vbkFic29sdXRlU2l6ZUNoYW5nZSh4LCB5LCB6KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uQWJzb2x1dGVTaXplQ2hhbmdlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vbkFic29sdXRlU2l6ZUNoYW5nZSh4LCB5LCB6KTtcbiAgICBzaXplLmFic29sdXRlU2l6ZUNoYW5nZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBQcml2YXRlIG1ldGhvZCB0byBhbGVydCB0aGUgbm9kZSBhbmQgY29tcG9uZW50cyB0aGF0IHRoZSBwcm9wb3J0aW9uYWwgc2l6ZSBjaGFuZ2VkLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcG90ZW50aWFsbHkgY2FsbCBvblByb3BvcnRpb25hbFNpemVDaGFuZ2Ugb25cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgYSBsaXN0IG9mIHRoZSBub2RlcycgY29tcG9uZW50c1xuICogQHBhcmFtIHtTaXplfSBzaXplIHRoZSBzaXplIGNsYXNzIGZvciB0aGUgTm9kZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHByb3BvcnRpb25hbFNpemVDaGFuZ2VkIChub2RlLCBjb21wb25lbnRzLCBzaXplKSB7XG4gICAgdmFyIHByb3BvcnRpb25hbFNpemUgPSBzaXplLmdldFByb3BvcnRpb25hbCgpO1xuICAgIHZhciB4ID0gcHJvcG9ydGlvbmFsU2l6ZVswXTtcbiAgICB2YXIgeSA9IHByb3BvcnRpb25hbFNpemVbMV07XG4gICAgdmFyIHogPSBwcm9wb3J0aW9uYWxTaXplWzJdO1xuICAgIGlmIChub2RlLm9uUHJvcG9ydGlvbmFsU2l6ZUNoYW5nZSkgbm9kZS5vblByb3BvcnRpb25hbFNpemVDaGFuZ2UoeCwgeSwgeik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vblByb3BvcnRpb25hbFNpemVDaGFuZ2UpXG4gICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uUHJvcG9ydGlvbmFsU2l6ZUNoYW5nZSh4LCB5LCB6KTtcbiAgICBzaXplLnByb3BvcnRpb25hbFNpemVDaGFuZ2VkID0gZmFsc2U7XG59XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gYWxlcnQgdGhlIG5vZGUgYW5kIGNvbXBvbmVudHMgdGhhdCBkaWZmZXJlbnRpYWwgc2l6ZSBjaGFuZ2VkLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcG90ZW50aWFsbHkgY2FsbCBvbkRpZmZlcmVudGlhbFNpemUgb25cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgYSBsaXN0IG9mIHRoZSBub2RlcycgY29tcG9uZW50c1xuICogQHBhcmFtIHtTaXplfSBzaXplIHRoZSBzaXplIGNsYXNzIGZvciB0aGUgTm9kZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGRpZmZlcmVudGlhbFNpemVDaGFuZ2VkIChub2RlLCBjb21wb25lbnRzLCBzaXplKSB7XG4gICAgdmFyIGRpZmZlcmVudGlhbFNpemUgPSBzaXplLmdldERpZmZlcmVudGlhbCgpO1xuICAgIHZhciB4ID0gZGlmZmVyZW50aWFsU2l6ZVswXTtcbiAgICB2YXIgeSA9IGRpZmZlcmVudGlhbFNpemVbMV07XG4gICAgdmFyIHogPSBkaWZmZXJlbnRpYWxTaXplWzJdO1xuICAgIGlmIChub2RlLm9uRGlmZmVyZW50aWFsU2l6ZUNoYW5nZSkgbm9kZS5vbkRpZmZlcmVudGlhbFNpemVDaGFuZ2UoeCwgeSwgeik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vbkRpZmZlcmVudGlhbFNpemVDaGFuZ2UpXG4gICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uRGlmZmVyZW50aWFsU2l6ZUNoYW5nZSh4LCB5LCB6KTtcbiAgICBzaXplLmRpZmZlcmVudGlhbFNpemVDaGFuZ2VkID0gZmFsc2U7XG59XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gYWxlcnQgdGhlIG5vZGUgYW5kIGNvbXBvbmVudHMgdGhhdCByZW5kZXIgc2l6ZSBjaGFuZ2VkLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcG90ZW50aWFsbHkgY2FsbCBvblJlbmRlclNpemVDaGFuZ2Ugb25cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgYSBsaXN0IG9mIHRoZSBub2RlcycgY29tcG9uZW50c1xuICogQHBhcmFtIHtTaXplfSBzaXplIHRoZSBzaXplIGNsYXNzIGZvciB0aGUgTm9kZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNpemVDaGFuZ2VkIChub2RlLCBjb21wb25lbnRzLCBzaXplKSB7XG4gICAgdmFyIHJlbmRlclNpemUgPSBzaXplLmdldFJlbmRlclNpemUoKTtcbiAgICB2YXIgeCA9IHJlbmRlclNpemVbMF07XG4gICAgdmFyIHkgPSByZW5kZXJTaXplWzFdO1xuICAgIHZhciB6ID0gcmVuZGVyU2l6ZVsyXTtcbiAgICBpZiAobm9kZS5vblJlbmRlclNpemVDaGFuZ2UpIG5vZGUub25SZW5kZXJTaXplQ2hhbmdlKHgsIHksIHopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25SZW5kZXJTaXplQ2hhbmdlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vblJlbmRlclNpemVDaGFuZ2UoeCwgeSwgeik7XG4gICAgc2l6ZS5yZW5kZXJTaXplQ2hhbmdlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHRvIGFsZXJ0IHRoZSBub2RlIGFuZCBjb21wb25lbnRzIHRoYXQgdGhlIHNpemUgY2hhbmdlZC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBvdGVudGlhbGx5IGNhbGwgb25TaXplQ2hhbmdlIG9uXG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRzIGEgbGlzdCBvZiB0aGUgbm9kZXMnIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSB0aGUgc2l6ZSBjbGFzcyBmb3IgdGhlIE5vZGVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBzaXplQ2hhbmdlZCAobm9kZSwgY29tcG9uZW50cywgc2l6ZSkge1xuICAgIHZhciBmaW5hbFNpemUgPSBzaXplLmdldCgpO1xuICAgIHZhciB4ID0gZmluYWxTaXplWzBdO1xuICAgIHZhciB5ID0gZmluYWxTaXplWzFdO1xuICAgIHZhciB6ID0gZmluYWxTaXplWzJdO1xuICAgIGlmIChub2RlLm9uU2l6ZUNoYW5nZSkgbm9kZS5vblNpemVDaGFuZ2UoeCwgeSwgeik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vblNpemVDaGFuZ2UpXG4gICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uU2l6ZUNoYW5nZSh4LCB5LCB6KTtcbiAgICBzaXplLnNpemVDaGFuZ2VkID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNpemVTeXN0ZW0oKTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFFVQVQgPSBbMCwgMCwgMCwgMV07XG52YXIgT05FUyA9IFsxLCAxLCAxXTtcblxuLyoqXG4gKiBUaGUgdHJhbnNmb3JtIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciBjYWxjdWxhdGluZyB0aGUgdHJhbnNmb3JtIG9mIGEgcGFydGljdWxhclxuICogbm9kZSBmcm9tIHRoZSBkYXRhIG9uIHRoZSBub2RlIGFuZCBpdHMgcGFyZW50XG4gKlxuICogQGNvbnN0cnVjdG9yIFRyYW5zZm9ybVxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSBwYXJlbnQgdGhlIHBhcmVudCBUcmFuc2Zvcm1cbiAqL1xuZnVuY3Rpb24gVHJhbnNmb3JtIChwYXJlbnQpIHtcbiAgICB0aGlzLmxvY2FsID0gbmV3IEZsb2F0MzJBcnJheShUcmFuc2Zvcm0uSURFTlQpO1xuICAgIHRoaXMuZ2xvYmFsID0gbmV3IEZsb2F0MzJBcnJheShUcmFuc2Zvcm0uSURFTlQpO1xuICAgIHRoaXMub2Zmc2V0cyA9IHtcbiAgICAgICAgYWxpZ246IG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gICAgICAgIGFsaWduQ2hhbmdlZDogZmFsc2UsXG4gICAgICAgIG1vdW50UG9pbnQ6IG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gICAgICAgIG1vdW50UG9pbnRDaGFuZ2VkOiBmYWxzZSxcbiAgICAgICAgb3JpZ2luOiBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICAgICAgICBvcmlnaW5DaGFuZ2VkOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy52ZWN0b3JzID0ge1xuICAgICAgICBwb3NpdGlvbjogbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgICAgICAgcG9zaXRpb25DaGFuZ2VkOiBmYWxzZSxcbiAgICAgICAgcm90YXRpb246IG5ldyBGbG9hdDMyQXJyYXkoUVVBVCksXG4gICAgICAgIHJvdGF0aW9uQ2hhbmdlZDogZmFsc2UsXG4gICAgICAgIHNjYWxlOiBuZXcgRmxvYXQzMkFycmF5KE9ORVMpLFxuICAgICAgICBzY2FsZUNoYW5nZWQ6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLl9sYXN0RXVsZXJWYWxzID0gWzAsIDAsIDBdO1xuICAgIHRoaXMuX2xhc3RFdWxlciA9IGZhbHNlO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50ID8gcGFyZW50IDogbnVsbDtcbiAgICB0aGlzLmJyZWFrUG9pbnQgPSBmYWxzZTtcbn1cblxuVHJhbnNmb3JtLklERU5UID0gWyAxLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAwLCAxLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAwLCAwLCAxLCAwLFxuICAgICAgICAgICAgICAgICAgICAwLCAwLCAwLCAxIF07XG5cblRyYW5zZm9ybS5XT1JMRF9DSEFOR0VEID0gMTtcblRyYW5zZm9ybS5MT0NBTF9DSEFOR0VEID0gMjtcblxuLyoqXG4gKiByZXNldHMgdGhlIHRyYW5zZm9ybSBzdGF0ZSBzdWNoIHRoYXQgaXQgbm8gbG9uZ2VyIGhhcyBhIHBhcmVudFxuICogYW5kIGlzIG5vdCBhIGJyZWFrcG9pbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuYnJlYWtQb2ludCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBzZXRzIHRoZSBwYXJlbnQgb2YgdGhpcyB0cmFuc2Zvcm0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSBwYXJlbnQgVGhlIHRyYW5zZm9ybSBjbGFzcyB0aGF0IHBhcmVudHMgdGhpcyBjbGFzc1xuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gc2V0UGFyZW50IChwYXJlbnQpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbn07XG5cbi8qKlxuICogcmV0dXJucyB0aGUgcGFyZW50IG9mIHRoaXMgdHJhbnNmb3JtXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge1RyYW5zZm9ybSB8IG51bGx9IHRoZSBwYXJlbnQgb2YgdGhpcyB0cmFuc2Zvcm0gaWYgb25lIGV4aXN0c1xuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uIGdldFBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50O1xufTtcblxuLyoqXG4gKiBNYWtlcyB0aGlzIHRyYW5zZm9ybSBhIGJyZWFrcG9pbnQuIFRoaXMgd2lsbCBjYXVzZSBpdCB0byBjYWxjdWxhdGVcbiAqIGJvdGggYSBsb2NhbCAocmVsYXRpdmUgdG8gdGhlIG5lYXJlc3QgYW5jZXN0b3IgYnJlYWtwb2ludCkgYW5kIGEgd29ybGRcbiAqIG1hdHJpeCAocmVsYXRpdmUgdG8gdGhlIHNjZW5lKS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRCcmVha1BvaW50ID0gZnVuY3Rpb24gc2V0QnJlYWtQb2ludCAoKSB7XG4gICAgdGhpcy5icmVha1BvaW50ID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRyYW5zZm9ybSBpcyBhIGJyZWFrcG9pbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyB0cmFuc2Zvcm0gaXMgYSBicmVha3BvaW50XG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuaXNCcmVha1BvaW50ID0gZnVuY3Rpb24gaXNCcmVha1BvaW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5icmVha1BvaW50O1xufTtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSBsb2NhbCB0cmFuc2Zvcm1cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSBsb2NhbCB0cmFuc2Zvcm1cbiAqL1xuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIGdldExvY2FsVHJhbnNmb3JtICgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbDtcbn07XG5cbi8qKlxuICogcmV0dXJucyB0aGUgd29ybGQgdHJhbnNmb3JtLiBSZXF1aXJlcyB0aGF0IHRoaXMgdHJhbnNmb3JtIGlzIGEgYnJlYWtwb2ludC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSB3b3JsZCB0cmFuc2Zvcm0uXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBnZXRXb3JsZFRyYW5zZm9ybSAoKSB7XG4gICAgaWYgKCF0aGlzLmlzQnJlYWtQb2ludCgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdHJhbnNmb3JtIGlzIG5vdCBjYWxjdWxhdGluZyB3b3JsZCB0cmFuc2Zvcm1zJyk7XG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIG5vZGUgYW5kIGNhbGN1bGF0ZXMgdGhlIHByb3BlciB0cmFuc2Zvcm0gZnJvbSBpdC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIHRoZSBub2RlIHRvIGNhbGN1bGF0ZSB0aGUgdHJhbnNmb3JtIGZyb21cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZSAobm9kZSkge1xuICAgIGlmICghdGhpcy5wYXJlbnQgfHwgdGhpcy5wYXJlbnQuaXNCcmVha1BvaW50KCkpXG4gICAgICAgIHJldHVybiBmcm9tTm9kZShub2RlLCB0aGlzKTtcbiAgICBlbHNlIHJldHVybiBmcm9tTm9kZVdpdGhQYXJlbnQobm9kZSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIEEgcHJpdmF0ZSBtZXRob2QgdG8gcG90ZW50aWFsbHkgc2V0IGEgdmFsdWUgd2l0aGluIGFuXG4gKiBhcnJheS4gV2lsbCBzZXQgdGhlIHZhbHVlIGlmIGEgdmFsdWUgd2FzIGdpdmVuXG4gKiBmb3IgdGhlIHRoaXJkIGFyZ3VtZW50IGFuZCBpZiB0aGF0IHZhbHVlIGlzIGRpZmZlcmVudFxuICogdGhhbiB0aGUgdmFsdWUgdGhhdCBpcyBjdXJyZW50bHkgaW4gdGhlIGFycmF5IGF0IHRoZSBnaXZlbiBpbmRleC5cbiAqIFJldHVybnMgdHJ1ZSBpZiBhIHZhbHVlIHdhcyBzZXQgYW5kIGZhbHNlIGlmIG5vdC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVjIFRoZSBhcnJheSB0byBzZXQgdGhlIHZhbHVlIHdpdGhpblxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzZXQgdGhlIHZhbHVlXG4gKiBAcGFyYW0ge0FueX0gdmFsIFRoZSB2YWx1ZSB0byBwb3RlbnRpYWxseSBzZXQgaW4gdGhlIGFycmF5XG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgYSB2YWx1ZSB3YXMgc2V0XG4gKi9cbmZ1bmN0aW9uIF92ZWNPcHRpb25hbFNldCAodmVjLCBpbmRleCwgdmFsKSB7XG4gICAgaWYgKHZhbCAhPSBudWxsICYmIHZlY1tpbmRleF0gIT09IHZhbCkge1xuICAgICAgICB2ZWNbaW5kZXhdID0gdmFsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHByaXZhdGUgbWV0aG9kIHRvIHNldCB2YWx1ZXMgd2l0aGluIGFuIGFycmF5LlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgYXJyYXkgaGFzIGJlZW4gY2hhbmdlZC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVjIFRoZSB2ZWN0b3IgdG8gYmUgb3BlcmF0ZWQgdXBvblxuICogQHBhcmFtIHtOdW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB4IFRoZSB4IHZhbHVlIG9mIHRoZSB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0geSBUaGUgeSB2YWx1ZSBvZiB0aGUgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IHogVGhlIHogdmFsdWUgb2YgdGhlIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB3IHRoZSB3IHZhbHVlIG9mIHRoZSB2ZWN0b3JcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgYXJyYXkgd2FzIGNoYW5nZWRcbiAqL1xuZnVuY3Rpb24gc2V0VmVjICh2ZWMsIHgsIHksIHosIHcpIHtcbiAgICB2YXIgcHJvcGFnYXRlID0gZmFsc2U7XG5cbiAgICBwcm9wYWdhdGUgPSBfdmVjT3B0aW9uYWxTZXQodmVjLCAwLCB4KSB8fCBwcm9wYWdhdGU7XG4gICAgcHJvcGFnYXRlID0gX3ZlY09wdGlvbmFsU2V0KHZlYywgMSwgeSkgfHwgcHJvcGFnYXRlO1xuICAgIHByb3BhZ2F0ZSA9IF92ZWNPcHRpb25hbFNldCh2ZWMsIDIsIHopIHx8IHByb3BhZ2F0ZTtcbiAgICBpZiAodyAhPSBudWxsKVxuICAgICAgICBwcm9wYWdhdGUgPSBfdmVjT3B0aW9uYWxTZXQodmVjLCAzLCB3KSB8fCBwcm9wYWdhdGU7XG5cbiAgICByZXR1cm4gcHJvcGFnYXRlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHBvc2l0aW9uIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gdGhlIHBvc2l0aW9uIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVjdG9ycy5wb3NpdGlvbjtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcG9zaXRpb24gY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGRpbWVuc2lvbiBvZiB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGRpbWVuc2lvbiBvZiB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGRpbWVuc2lvbiBvZiB0aGUgcG9zaXRpb25cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9zaXRpb24gKHgsIHksIHopIHtcbiAgICB0aGlzLnZlY3RvcnMucG9zaXRpb25DaGFuZ2VkID0gc2V0VmVjKHRoaXMudmVjdG9ycy5wb3NpdGlvbiwgeCwgeSwgeik7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHJvdGF0aW9uIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLiBXaWxsIHJldHVybiBhIHF1YXRlcm5pb24uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gdGhlIHF1YXRlcm5pb24gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zZm9ybSdzIHJvdGF0aW9uXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiBnZXRSb3RhdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVjdG9ycy5yb3RhdGlvbjtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcm90YXRpb24gY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uIENhbiB0YWtlIGVpdGhlciBFdWxlclxuICogYW5nbGVzIG9yIGEgcXVhdGVybmlvbi5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHJvdGF0aW9uIGFib3V0IHRoZSB4IGF4aXMgb3IgdGhlIGV4dGVudCBpbiB0aGUgeCBkaW1lbnNpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSByb3RhdGlvbiBhYm91dCB0aGUgeSBheGlzIG9yIHRoZSBleHRlbnQgaW4gdGhlIHkgZGltZW5zaW9uXG4gKiBAcGFyYW0ge051bWJlcn0geiBUaGUgcm90YXRpb24gYWJvdXQgdGhlIHogYXhpcyBvciB0aGUgZXh0ZW50IGluIHRoZSB6IGRpbWVuc2lvblxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIHJvdGF0aW9uIGFib3V0IHRoZSBwcm9jZWVkaW5nIHZlY3RvclxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0Um90YXRpb24gPSBmdW5jdGlvbiBzZXRSb3RhdGlvbiAoeCwgeSwgeiwgdykge1xuICAgIHZhciBxdWF0ID0gdGhpcy52ZWN0b3JzLnJvdGF0aW9uO1xuICAgIHZhciBxeCwgcXksIHF6LCBxdztcblxuICAgIGlmICh3ICE9IG51bGwpIHtcbiAgICAgICAgcXggPSB4O1xuICAgICAgICBxeSA9IHk7XG4gICAgICAgIHF6ID0gejtcbiAgICAgICAgcXcgPSB3O1xuICAgICAgICB0aGlzLl9sYXN0RXVsZXJWYWxzWzBdID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdEV1bGVyVmFsc1sxXSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhc3RFdWxlclZhbHNbMl0gPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXN0RXVsZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh4ID09IG51bGwgfHwgeSA9PSBudWxsIHx8IHogPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RFdWxlcikge1xuICAgICAgICAgICAgICAgIHggPSB4ID09IG51bGwgPyB0aGlzLl9sYXN0RXVsZXJWYWxzWzBdIDogeDtcbiAgICAgICAgICAgICAgICB5ID0geSA9PSBudWxsID8gdGhpcy5fbGFzdEV1bGVyVmFsc1sxXSA6IHk7XG4gICAgICAgICAgICAgICAgeiA9IHogPT0gbnVsbCA/IHRoaXMuX2xhc3RFdWxlclZhbHNbMl0gOiB6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwID0gLTIgKiAocXVhdFsxXSAqIHF1YXRbMl0gLSBxdWF0WzNdICogcXVhdFswXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3ApID4gMC45OTk5OSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0geSA9PSBudWxsID8gTWF0aC5QSSAqIDAuNSAqIHNwIDogeTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHggPT0gbnVsbCA/IE1hdGguYXRhbjIoLXF1YXRbMF0gKiBxdWF0WzJdICsgcXVhdFszXSAqIHF1YXRbMV0sIDAuNSAtIHF1YXRbMV0gKiBxdWF0WzFdIC0gcXVhdFsyXSAqIHF1YXRbMl0pIDogeDtcbiAgICAgICAgICAgICAgICAgICAgeiA9IHogPT0gbnVsbCA/IDAgOiB6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkgPT0gbnVsbCA/IE1hdGguYXNpbihzcCkgOiB5O1xuICAgICAgICAgICAgICAgICAgICB4ID0geCA9PSBudWxsID8gTWF0aC5hdGFuMihxdWF0WzBdICogcXVhdFsyXSArIHF1YXRbM10gKiBxdWF0WzFdLCAwLjUgLSBxdWF0WzBdICogcXVhdFswXSAtIHF1YXRbMV0gKiBxdWF0WzFdKSA6IHg7XG4gICAgICAgICAgICAgICAgICAgIHogPSB6ID09IG51bGwgPyBNYXRoLmF0YW4yKHF1YXRbMF0gKiBxdWF0WzFdICsgcXVhdFszXSAqIHF1YXRbMl0sIDAuNSAtIHF1YXRbMF0gKiBxdWF0WzBdIC0gcXVhdFsyXSAqIHF1YXRbMl0pIDogejtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHggPSB4ICogMC41O1xuICAgICAgICB2YXIgaHkgPSB5ICogMC41O1xuICAgICAgICB2YXIgaHogPSB6ICogMC41O1xuXG4gICAgICAgIHZhciBzeCA9IE1hdGguc2luKGh4KTtcbiAgICAgICAgdmFyIHN5ID0gTWF0aC5zaW4oaHkpO1xuICAgICAgICB2YXIgc3ogPSBNYXRoLnNpbihoeik7XG4gICAgICAgIHZhciBjeCA9IE1hdGguY29zKGh4KTtcbiAgICAgICAgdmFyIGN5ID0gTWF0aC5jb3MoaHkpO1xuICAgICAgICB2YXIgY3ogPSBNYXRoLmNvcyhoeik7XG5cbiAgICAgICAgdmFyIHN5c3ogPSBzeSAqIHN6O1xuICAgICAgICB2YXIgY3lzeiA9IGN5ICogc3o7XG4gICAgICAgIHZhciBzeWN6ID0gc3kgKiBjejtcbiAgICAgICAgdmFyIGN5Y3ogPSBjeSAqIGN6O1xuXG4gICAgICAgIHF4ID0gc3ggKiBjeWN6ICsgY3ggKiBzeXN6O1xuICAgICAgICBxeSA9IGN4ICogc3ljeiAtIHN4ICogY3lzejtcbiAgICAgICAgcXogPSBjeCAqIGN5c3ogKyBzeCAqIHN5Y3o7XG4gICAgICAgIHF3ID0gY3ggKiBjeWN6IC0gc3ggKiBzeXN6O1xuXG4gICAgICAgIHRoaXMuX2xhc3RFdWxlciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xhc3RFdWxlclZhbHNbMF0gPSB4O1xuICAgICAgICB0aGlzLl9sYXN0RXVsZXJWYWxzWzFdID0geTtcbiAgICAgICAgdGhpcy5fbGFzdEV1bGVyVmFsc1syXSA9IHo7XG4gICAgfVxuXG4gICAgdGhpcy52ZWN0b3JzLnJvdGF0aW9uQ2hhbmdlZCA9IHNldFZlYyhxdWF0LCBxeCwgcXksIHF6LCBxdyk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHNjYWxlIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gdGhlIHNjYWxlIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0U2NhbGUgPSBmdW5jdGlvbiBnZXRTY2FsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVjdG9ycy5zY2FsZTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc2NhbGUgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0geCBUaGUgeCBkaW1lbnNpb24gb2YgdGhlIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IHkgVGhlIHkgZGltZW5zaW9uIG9mIHRoZSBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB6IFRoZSB6IGRpbWVuc2lvbiBvZiB0aGUgc2NhbGVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24gc2V0U2NhbGUgKHgsIHksIHopIHtcbiAgICB0aGlzLnZlY3RvcnMuc2NhbGVDaGFuZ2VkID0gc2V0VmVjKHRoaXMudmVjdG9ycy5zY2FsZSwgeCwgeSwgeik7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGFsaWduIHZhbHVlIG9mIHRoZSB0cmFuc2Zvcm1cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSB0aGUgYWxpZ24gdmFsdWUgb2YgdGhlIHRyYW5zZm9ybVxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldEFsaWduID0gZnVuY3Rpb24gZ2V0QWxpZ24gKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldHMuYWxpZ247XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGFsaWduIHZhbHVlIG9mIHRoZSB0cmFuc2Zvcm0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0geCBUaGUgeCBkaW1lbnNpb24gb2YgdGhlIGFsaWduXG4gKiBAcGFyYW0ge051bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IHkgVGhlIHkgZGltZW5zaW9uIG9mIHRoZSBhbGlnblxuICogQHBhcmFtIHtOdW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB6IFRoZSB6IGRpbWVuc2lvbiBvZiB0aGUgYWxpZ25cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldEFsaWduID0gZnVuY3Rpb24gc2V0QWxpZ24gKHgsIHksIHopIHtcbiAgICB0aGlzLm9mZnNldHMuYWxpZ25DaGFuZ2VkID0gc2V0VmVjKHRoaXMub2Zmc2V0cy5hbGlnbiwgeCwgeSwgeiAhPSBudWxsID8geiAtIDAuNSA6IHopO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtb3VudCBwb2ludCB2YWx1ZSBvZiB0aGUgdHJhbnNmb3JtLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IHRoZSBtb3VudCBwb2ludCBvZiB0aGUgdHJhbnNmb3JtXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0TW91bnRQb2ludCA9IGZ1bmN0aW9uIGdldE1vdW50UG9pbnQgKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldHMubW91bnRQb2ludDtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbW91bnQgcG9pbnQgdmFsdWUgb2YgdGhlIHRyYW5zZm9ybS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB4IHRoZSB4IGRpbWVuc2lvbiBvZiB0aGUgbW91bnQgcG9pbnRcbiAqIEBwYXJhbSB7TnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0geSB0aGUgeSBkaW1lbnNpb24gb2YgdGhlIG1vdW50IHBvaW50XG4gKiBAcGFyYW0ge051bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IHogdGhlIHogZGltZW5zaW9uIG9mIHRoZSBtb3VudCBwb2ludFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0TW91bnRQb2ludCA9IGZ1bmN0aW9uIHNldE1vdW50UG9pbnQgKHgsIHksIHopIHtcbiAgICB0aGlzLm9mZnNldHMubW91bnRQb2ludENoYW5nZWQgPSBzZXRWZWModGhpcy5vZmZzZXRzLm1vdW50UG9pbnQsIHgsIHksIHogIT0gbnVsbCA/IHogLSAwLjUgOiB6KTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgb3JpZ2luIG9mIHRoZSB0cmFuc2Zvcm0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gdGhlIG9yaWdpblxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldE9yaWdpbiA9IGZ1bmN0aW9uIGdldE9yaWdpbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0cy5vcmlnaW47XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG9yaWdpbiBvZiB0aGUgdHJhbnNmb3JtLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IHggdGhlIHggZGltZW5zaW9uIG9mIHRoZSBvcmlnaW5cbiAqIEBwYXJhbSB7TnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0geSB0aGUgeSBkaW1lbnNpb24gb2YgdGhlIG9yaWdpblxuICogQHBhcmFtIHtOdW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB6IHRoZSB6IGRpbWVuc2lvbiBvZiB0aGUgb3JpZ2luXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRPcmlnaW4gPSBmdW5jdGlvbiBzZXRPcmlnaW4gKHgsIHksIHopIHtcbiAgICB0aGlzLm9mZnNldHMub3JpZ2luQ2hhbmdlZCA9IHNldFZlYyh0aGlzLm9mZnNldHMub3JpZ2luLCB4LCB5LCB6ICE9IG51bGwgPyB6IC0gMC41IDogeik7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHdvcmxkIGZvciB0aGlzIHBhcnRpY3VsYXIgdHJhbnNmb3JtLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkTWF0cml4ID0gZnVuY3Rpb24gY2FsY3VsYXRlV29ybGRNYXRyaXggKCkge1xuICAgIHZhciBuZWFyZXN0QnJlYWtQb2ludCA9IHRoaXMucGFyZW50O1xuXG4gICAgd2hpbGUgKG5lYXJlc3RCcmVha1BvaW50ICYmICFuZWFyZXN0QnJlYWtQb2ludC5pc0JyZWFrUG9pbnQoKSlcbiAgICAgICAgbmVhcmVzdEJyZWFrUG9pbnQgPSBuZWFyZXN0QnJlYWtQb2ludC5wYXJlbnQ7XG5cbiAgICBpZiAobmVhcmVzdEJyZWFrUG9pbnQpIHJldHVybiBtdWx0aXBseSh0aGlzLmdsb2JhbCwgbmVhcmVzdEJyZWFrUG9pbnQuZ2V0V29ybGRUcmFuc2Zvcm0oKSwgdGhpcy5sb2NhbCk7XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTYgOyBpKyspIHRoaXMuZ2xvYmFsW2ldID0gdGhpcy5sb2NhbFtpXTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBQcml2YXRlIGZ1bmN0aW9uLiBDcmVhdGVzIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZyb20gYSBOb2RlJ3Mgc3BlYy5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgdGhlIG5vZGUgdG8gY3JlYXRlIGEgdHJhbnNmb3JtIGZvclxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybSB0cmFuc2Zvcm0gdG8gYXBwbHlcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgdGFyZ2V0IGFycmF5IHdhcyBjaGFuZ2VkXG4gKi9cbmZ1bmN0aW9uIGZyb21Ob2RlIChub2RlLCB0cmFuc2Zvcm0pIHtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLmdldExvY2FsVHJhbnNmb3JtKCk7XG4gICAgdmFyIG15U2l6ZSA9IG5vZGUuZ2V0U2l6ZSgpO1xuICAgIHZhciB2ZWN0b3JzID0gdHJhbnNmb3JtLnZlY3RvcnM7XG4gICAgdmFyIG9mZnNldHMgPSB0cmFuc2Zvcm0ub2Zmc2V0cztcbiAgICB2YXIgcGFyZW50U2l6ZSA9IG5vZGUuZ2V0UGFyZW50KCkuZ2V0U2l6ZSgpO1xuICAgIHZhciBjaGFuZ2VkID0gMDtcblxuICAgIHZhciB0MDAgICAgICAgICA9IHRhcmdldFswXTtcbiAgICB2YXIgdDAxICAgICAgICAgPSB0YXJnZXRbMV07XG4gICAgdmFyIHQwMiAgICAgICAgID0gdGFyZ2V0WzJdO1xuICAgIHZhciB0MTAgICAgICAgICA9IHRhcmdldFs0XTtcbiAgICB2YXIgdDExICAgICAgICAgPSB0YXJnZXRbNV07XG4gICAgdmFyIHQxMiAgICAgICAgID0gdGFyZ2V0WzZdO1xuICAgIHZhciB0MjAgICAgICAgICA9IHRhcmdldFs4XTtcbiAgICB2YXIgdDIxICAgICAgICAgPSB0YXJnZXRbOV07XG4gICAgdmFyIHQyMiAgICAgICAgID0gdGFyZ2V0WzEwXTtcbiAgICB2YXIgdDMwICAgICAgICAgPSB0YXJnZXRbMTJdO1xuICAgIHZhciB0MzEgICAgICAgICA9IHRhcmdldFsxM107XG4gICAgdmFyIHQzMiAgICAgICAgID0gdGFyZ2V0WzE0XTtcbiAgICB2YXIgcG9zWCAgICAgICAgPSB2ZWN0b3JzLnBvc2l0aW9uWzBdO1xuICAgIHZhciBwb3NZICAgICAgICA9IHZlY3RvcnMucG9zaXRpb25bMV07XG4gICAgdmFyIHBvc1ogICAgICAgID0gdmVjdG9ycy5wb3NpdGlvblsyXTtcbiAgICB2YXIgcm90WCAgICAgICAgPSB2ZWN0b3JzLnJvdGF0aW9uWzBdO1xuICAgIHZhciByb3RZICAgICAgICA9IHZlY3RvcnMucm90YXRpb25bMV07XG4gICAgdmFyIHJvdFogICAgICAgID0gdmVjdG9ycy5yb3RhdGlvblsyXTtcbiAgICB2YXIgcm90VyAgICAgICAgPSB2ZWN0b3JzLnJvdGF0aW9uWzNdO1xuICAgIHZhciBzY2FsZVggICAgICA9IHZlY3RvcnMuc2NhbGVbMF07XG4gICAgdmFyIHNjYWxlWSAgICAgID0gdmVjdG9ycy5zY2FsZVsxXTtcbiAgICB2YXIgc2NhbGVaICAgICAgPSB2ZWN0b3JzLnNjYWxlWzJdO1xuICAgIHZhciBhbGlnblggICAgICA9IG9mZnNldHMuYWxpZ25bMF0gKiBwYXJlbnRTaXplWzBdO1xuICAgIHZhciBhbGlnblkgICAgICA9IG9mZnNldHMuYWxpZ25bMV0gKiBwYXJlbnRTaXplWzFdO1xuICAgIHZhciBhbGlnblogICAgICA9IG9mZnNldHMuYWxpZ25bMl0gKiBwYXJlbnRTaXplWzJdO1xuICAgIHZhciBtb3VudFBvaW50WCA9IG9mZnNldHMubW91bnRQb2ludFswXSAqIG15U2l6ZVswXTtcbiAgICB2YXIgbW91bnRQb2ludFkgPSBvZmZzZXRzLm1vdW50UG9pbnRbMV0gKiBteVNpemVbMV07XG4gICAgdmFyIG1vdW50UG9pbnRaID0gb2Zmc2V0cy5tb3VudFBvaW50WzJdICogbXlTaXplWzJdO1xuICAgIHZhciBvcmlnaW5YICAgICA9IG9mZnNldHMub3JpZ2luWzBdICogbXlTaXplWzBdO1xuICAgIHZhciBvcmlnaW5ZICAgICA9IG9mZnNldHMub3JpZ2luWzFdICogbXlTaXplWzFdO1xuICAgIHZhciBvcmlnaW5aICAgICA9IG9mZnNldHMub3JpZ2luWzJdICogbXlTaXplWzJdO1xuXG4gICAgdmFyIHd4ID0gcm90VyAqIHJvdFg7XG4gICAgdmFyIHd5ID0gcm90VyAqIHJvdFk7XG4gICAgdmFyIHd6ID0gcm90VyAqIHJvdFo7XG4gICAgdmFyIHh4ID0gcm90WCAqIHJvdFg7XG4gICAgdmFyIHl5ID0gcm90WSAqIHJvdFk7XG4gICAgdmFyIHp6ID0gcm90WiAqIHJvdFo7XG4gICAgdmFyIHh5ID0gcm90WCAqIHJvdFk7XG4gICAgdmFyIHh6ID0gcm90WCAqIHJvdFo7XG4gICAgdmFyIHl6ID0gcm90WSAqIHJvdFo7XG5cbiAgICB0YXJnZXRbMF0gPSAoMSAtIDIgKiAoeXkgKyB6eikpICogc2NhbGVYO1xuICAgIHRhcmdldFsxXSA9ICgyICogKHh5ICsgd3opKSAqIHNjYWxlWDtcbiAgICB0YXJnZXRbMl0gPSAoMiAqICh4eiAtIHd5KSkgKiBzY2FsZVg7XG4gICAgdGFyZ2V0WzNdID0gMDtcbiAgICB0YXJnZXRbNF0gPSAoMiAqICh4eSAtIHd6KSkgKiBzY2FsZVk7XG4gICAgdGFyZ2V0WzVdID0gKDEgLSAyICogKHh4ICsgenopKSAqIHNjYWxlWTtcbiAgICB0YXJnZXRbNl0gPSAoMiAqICh5eiArIHd4KSkgKiBzY2FsZVk7XG4gICAgdGFyZ2V0WzddID0gMDtcbiAgICB0YXJnZXRbOF0gPSAoMiAqICh4eiArIHd5KSkgKiBzY2FsZVo7XG4gICAgdGFyZ2V0WzldID0gKDIgKiAoeXogLSB3eCkpICogc2NhbGVaO1xuICAgIHRhcmdldFsxMF0gPSAoMSAtIDIgKiAoeHggKyB5eSkpICogc2NhbGVaO1xuICAgIHRhcmdldFsxMV0gPSAwO1xuICAgIHRhcmdldFsxMl0gPSBhbGlnblggKyBwb3NYIC0gbW91bnRQb2ludFggKyBvcmlnaW5YIC1cbiAgICAgICAgICAgICAgICAgKHRhcmdldFswXSAqIG9yaWdpblggKyB0YXJnZXRbNF0gKiBvcmlnaW5ZICsgdGFyZ2V0WzhdICogb3JpZ2luWik7XG4gICAgdGFyZ2V0WzEzXSA9IGFsaWduWSArIHBvc1kgLSBtb3VudFBvaW50WSArIG9yaWdpblkgLVxuICAgICAgICAgICAgICAgICAodGFyZ2V0WzFdICogb3JpZ2luWCArIHRhcmdldFs1XSAqIG9yaWdpblkgKyB0YXJnZXRbOV0gKiBvcmlnaW5aKTtcbiAgICB0YXJnZXRbMTRdID0gYWxpZ25aICsgcG9zWiAtIG1vdW50UG9pbnRaICsgb3JpZ2luWiAtXG4gICAgICAgICAgICAgICAgICh0YXJnZXRbMl0gKiBvcmlnaW5YICsgdGFyZ2V0WzZdICogb3JpZ2luWSArIHRhcmdldFsxMF0gKiBvcmlnaW5aKTtcbiAgICB0YXJnZXRbMTVdID0gMTtcblxuICAgIGlmICh0cmFuc2Zvcm0uaXNCcmVha1BvaW50KCkgJiYgdHJhbnNmb3JtLmNhbGN1bGF0ZVdvcmxkTWF0cml4KCkpXG4gICAgICAgIGNoYW5nZWQgfD0gVHJhbnNmb3JtLldPUkxEX0NIQU5HRUQ7XG5cbiAgICBpZiAodDAwICE9PSB0YXJnZXRbMF0gfHxcbiAgICAgICAgdDAxICE9PSB0YXJnZXRbMV0gfHxcbiAgICAgICAgdDAyICE9PSB0YXJnZXRbMl0gfHxcbiAgICAgICAgdDEwICE9PSB0YXJnZXRbNF0gfHxcbiAgICAgICAgdDExICE9PSB0YXJnZXRbNV0gfHxcbiAgICAgICAgdDEyICE9PSB0YXJnZXRbNl0gfHxcbiAgICAgICAgdDIwICE9PSB0YXJnZXRbOF0gfHxcbiAgICAgICAgdDIxICE9PSB0YXJnZXRbOV0gfHxcbiAgICAgICAgdDIyICE9PSB0YXJnZXRbMTBdIHx8XG4gICAgICAgIHQzMCAhPT0gdGFyZ2V0WzEyXSB8fFxuICAgICAgICB0MzEgIT09IHRhcmdldFsxM10gfHxcbiAgICAgICAgdDMyICE9PSB0YXJnZXRbMTRdKSBjaGFuZ2VkIHw9IFRyYW5zZm9ybS5MT0NBTF9DSEFOR0VEO1xuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5cbi8qKlxuICogUHJpdmF0ZSBmdW5jdGlvbi4gVXNlcyB0aGUgcGFyZW50IHRyYW5zZm9ybSwgdGhlIG5vZGUncyBzcGVjLCB0aGUgbm9kZSdzIHNpemUsIGFuZCB0aGUgcGFyZW50J3Mgc2l6ZVxuICogdG8gY2FsY3VsYXRlIGEgZmluYWwgdHJhbnNmb3JtIGZvciB0aGUgbm9kZS4gUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2Zvcm0gaGFzIGNoYW5nZWQuXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgdGhlIG5vZGUgdG8gY3JlYXRlIGEgdHJhbnNmb3JtIGZvclxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybSB0cmFuc2Zvcm0gdG8gYXBwbHlcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgdHJhbnNmb3JtIGNoYW5nZWRcbiAqL1xuZnVuY3Rpb24gZnJvbU5vZGVXaXRoUGFyZW50IChub2RlLCB0cmFuc2Zvcm0pIHtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLmdldExvY2FsVHJhbnNmb3JtKCk7XG4gICAgdmFyIHBhcmVudE1hdHJpeCA9IHRyYW5zZm9ybS5wYXJlbnQuZ2V0TG9jYWxUcmFuc2Zvcm0oKTtcbiAgICB2YXIgbXlTaXplID0gbm9kZS5nZXRTaXplKCk7XG4gICAgdmFyIHZlY3RvcnMgPSB0cmFuc2Zvcm0udmVjdG9ycztcbiAgICB2YXIgb2Zmc2V0cyA9IHRyYW5zZm9ybS5vZmZzZXRzO1xuICAgIHZhciBwYXJlbnRTaXplID0gbm9kZS5nZXRQYXJlbnQoKS5nZXRTaXplKCk7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgIC8vIGxvY2FsIGNhY2hlIG9mIGV2ZXJ5dGhpbmdcbiAgICB2YXIgdDAwICAgICAgICAgPSB0YXJnZXRbMF07XG4gICAgdmFyIHQwMSAgICAgICAgID0gdGFyZ2V0WzFdO1xuICAgIHZhciB0MDIgICAgICAgICA9IHRhcmdldFsyXTtcbiAgICB2YXIgdDEwICAgICAgICAgPSB0YXJnZXRbNF07XG4gICAgdmFyIHQxMSAgICAgICAgID0gdGFyZ2V0WzVdO1xuICAgIHZhciB0MTIgICAgICAgICA9IHRhcmdldFs2XTtcbiAgICB2YXIgdDIwICAgICAgICAgPSB0YXJnZXRbOF07XG4gICAgdmFyIHQyMSAgICAgICAgID0gdGFyZ2V0WzldO1xuICAgIHZhciB0MjIgICAgICAgICA9IHRhcmdldFsxMF07XG4gICAgdmFyIHQzMCAgICAgICAgID0gdGFyZ2V0WzEyXTtcbiAgICB2YXIgdDMxICAgICAgICAgPSB0YXJnZXRbMTNdO1xuICAgIHZhciB0MzIgICAgICAgICA9IHRhcmdldFsxNF07XG4gICAgdmFyIHAwMCAgICAgICAgID0gcGFyZW50TWF0cml4WzBdO1xuICAgIHZhciBwMDEgICAgICAgICA9IHBhcmVudE1hdHJpeFsxXTtcbiAgICB2YXIgcDAyICAgICAgICAgPSBwYXJlbnRNYXRyaXhbMl07XG4gICAgdmFyIHAxMCAgICAgICAgID0gcGFyZW50TWF0cml4WzRdO1xuICAgIHZhciBwMTEgICAgICAgICA9IHBhcmVudE1hdHJpeFs1XTtcbiAgICB2YXIgcDEyICAgICAgICAgPSBwYXJlbnRNYXRyaXhbNl07XG4gICAgdmFyIHAyMCAgICAgICAgID0gcGFyZW50TWF0cml4WzhdO1xuICAgIHZhciBwMjEgICAgICAgICA9IHBhcmVudE1hdHJpeFs5XTtcbiAgICB2YXIgcDIyICAgICAgICAgPSBwYXJlbnRNYXRyaXhbMTBdO1xuICAgIHZhciBwMzAgICAgICAgICA9IHBhcmVudE1hdHJpeFsxMl07XG4gICAgdmFyIHAzMSAgICAgICAgID0gcGFyZW50TWF0cml4WzEzXTtcbiAgICB2YXIgcDMyICAgICAgICAgPSBwYXJlbnRNYXRyaXhbMTRdO1xuICAgIHZhciBwb3NYICAgICAgICA9IHZlY3RvcnMucG9zaXRpb25bMF07XG4gICAgdmFyIHBvc1kgICAgICAgID0gdmVjdG9ycy5wb3NpdGlvblsxXTtcbiAgICB2YXIgcG9zWiAgICAgICAgPSB2ZWN0b3JzLnBvc2l0aW9uWzJdO1xuICAgIHZhciByb3RYICAgICAgICA9IHZlY3RvcnMucm90YXRpb25bMF07XG4gICAgdmFyIHJvdFkgICAgICAgID0gdmVjdG9ycy5yb3RhdGlvblsxXTtcbiAgICB2YXIgcm90WiAgICAgICAgPSB2ZWN0b3JzLnJvdGF0aW9uWzJdO1xuICAgIHZhciByb3RXICAgICAgICA9IHZlY3RvcnMucm90YXRpb25bM107XG4gICAgdmFyIHNjYWxlWCAgICAgID0gdmVjdG9ycy5zY2FsZVswXTtcbiAgICB2YXIgc2NhbGVZICAgICAgPSB2ZWN0b3JzLnNjYWxlWzFdO1xuICAgIHZhciBzY2FsZVogICAgICA9IHZlY3RvcnMuc2NhbGVbMl07XG4gICAgdmFyIGFsaWduWCAgICAgID0gb2Zmc2V0cy5hbGlnblswXSAqIHBhcmVudFNpemVbMF07XG4gICAgdmFyIGFsaWduWSAgICAgID0gb2Zmc2V0cy5hbGlnblsxXSAqIHBhcmVudFNpemVbMV07XG4gICAgdmFyIGFsaWduWiAgICAgID0gb2Zmc2V0cy5hbGlnblsyXSAqIHBhcmVudFNpemVbMl07XG4gICAgdmFyIG1vdW50UG9pbnRYID0gb2Zmc2V0cy5tb3VudFBvaW50WzBdICogbXlTaXplWzBdO1xuICAgIHZhciBtb3VudFBvaW50WSA9IG9mZnNldHMubW91bnRQb2ludFsxXSAqIG15U2l6ZVsxXTtcbiAgICB2YXIgbW91bnRQb2ludFogPSBvZmZzZXRzLm1vdW50UG9pbnRbMl0gKiBteVNpemVbMl07XG4gICAgdmFyIG9yaWdpblggICAgID0gb2Zmc2V0cy5vcmlnaW5bMF0gKiBteVNpemVbMF07XG4gICAgdmFyIG9yaWdpblkgICAgID0gb2Zmc2V0cy5vcmlnaW5bMV0gKiBteVNpemVbMV07XG4gICAgdmFyIG9yaWdpblogICAgID0gb2Zmc2V0cy5vcmlnaW5bMl0gKiBteVNpemVbMl07XG5cbiAgICB2YXIgd3ggPSByb3RXICogcm90WDtcbiAgICB2YXIgd3kgPSByb3RXICogcm90WTtcbiAgICB2YXIgd3ogPSByb3RXICogcm90WjtcbiAgICB2YXIgeHggPSByb3RYICogcm90WDtcbiAgICB2YXIgeXkgPSByb3RZICogcm90WTtcbiAgICB2YXIgenogPSByb3RaICogcm90WjtcbiAgICB2YXIgeHkgPSByb3RYICogcm90WTtcbiAgICB2YXIgeHogPSByb3RYICogcm90WjtcbiAgICB2YXIgeXogPSByb3RZICogcm90WjtcblxuICAgIHZhciByczAgPSAoMSAtIDIgKiAoeXkgKyB6eikpICogc2NhbGVYO1xuICAgIHZhciByczEgPSAoMiAqICh4eSArIHd6KSkgKiBzY2FsZVg7XG4gICAgdmFyIHJzMiA9ICgyICogKHh6IC0gd3kpKSAqIHNjYWxlWDtcbiAgICB2YXIgcnMzID0gKDIgKiAoeHkgLSB3eikpICogc2NhbGVZO1xuICAgIHZhciByczQgPSAoMSAtIDIgKiAoeHggKyB6eikpICogc2NhbGVZO1xuICAgIHZhciByczUgPSAoMiAqICh5eiArIHd4KSkgKiBzY2FsZVk7XG4gICAgdmFyIHJzNiA9ICgyICogKHh6ICsgd3kpKSAqIHNjYWxlWjtcbiAgICB2YXIgcnM3ID0gKDIgKiAoeXogLSB3eCkpICogc2NhbGVaO1xuICAgIHZhciByczggPSAoMSAtIDIgKiAoeHggKyB5eSkpICogc2NhbGVaO1xuXG4gICAgdmFyIHR4ID0gYWxpZ25YICsgcG9zWCAtIG1vdW50UG9pbnRYICsgb3JpZ2luWCAtIChyczAgKiBvcmlnaW5YICsgcnMzICogb3JpZ2luWSArIHJzNiAqIG9yaWdpblopO1xuICAgIHZhciB0eSA9IGFsaWduWSArIHBvc1kgLSBtb3VudFBvaW50WSArIG9yaWdpblkgLSAocnMxICogb3JpZ2luWCArIHJzNCAqIG9yaWdpblkgKyByczcgKiBvcmlnaW5aKTtcbiAgICB2YXIgdHogPSBhbGlnblogKyBwb3NaIC0gbW91bnRQb2ludFogKyBvcmlnaW5aIC0gKHJzMiAqIG9yaWdpblggKyByczUgKiBvcmlnaW5ZICsgcnM4ICogb3JpZ2luWik7XG5cbiAgICB0YXJnZXRbMF0gPSBwMDAgKiByczAgKyBwMTAgKiByczEgKyBwMjAgKiByczI7XG4gICAgdGFyZ2V0WzFdID0gcDAxICogcnMwICsgcDExICogcnMxICsgcDIxICogcnMyO1xuICAgIHRhcmdldFsyXSA9IHAwMiAqIHJzMCArIHAxMiAqIHJzMSArIHAyMiAqIHJzMjtcbiAgICB0YXJnZXRbM10gPSAwO1xuICAgIHRhcmdldFs0XSA9IHAwMCAqIHJzMyArIHAxMCAqIHJzNCArIHAyMCAqIHJzNTtcbiAgICB0YXJnZXRbNV0gPSBwMDEgKiByczMgKyBwMTEgKiByczQgKyBwMjEgKiByczU7XG4gICAgdGFyZ2V0WzZdID0gcDAyICogcnMzICsgcDEyICogcnM0ICsgcDIyICogcnM1O1xuICAgIHRhcmdldFs3XSA9IDA7XG4gICAgdGFyZ2V0WzhdID0gcDAwICogcnM2ICsgcDEwICogcnM3ICsgcDIwICogcnM4O1xuICAgIHRhcmdldFs5XSA9IHAwMSAqIHJzNiArIHAxMSAqIHJzNyArIHAyMSAqIHJzODtcbiAgICB0YXJnZXRbMTBdID0gcDAyICogcnM2ICsgcDEyICogcnM3ICsgcDIyICogcnM4O1xuICAgIHRhcmdldFsxMV0gPSAwO1xuICAgIHRhcmdldFsxMl0gPSBwMDAgKiB0eCArIHAxMCAqIHR5ICsgcDIwICogdHogKyBwMzA7XG4gICAgdGFyZ2V0WzEzXSA9IHAwMSAqIHR4ICsgcDExICogdHkgKyBwMjEgKiB0eiArIHAzMTtcbiAgICB0YXJnZXRbMTRdID0gcDAyICogdHggKyBwMTIgKiB0eSArIHAyMiAqIHR6ICsgcDMyO1xuICAgIHRhcmdldFsxNV0gPSAxO1xuXG4gICAgaWYgKHRyYW5zZm9ybS5pc0JyZWFrUG9pbnQoKSAmJiB0cmFuc2Zvcm0uY2FsY3VsYXRlV29ybGRNYXRyaXgoKSlcbiAgICAgICAgY2hhbmdlZCB8PSBUcmFuc2Zvcm0uV09STERfQ0hBTkdFRDtcblxuICAgIGlmICh0MDAgIT09IHRhcmdldFswXSB8fFxuICAgICAgICB0MDEgIT09IHRhcmdldFsxXSB8fFxuICAgICAgICB0MDIgIT09IHRhcmdldFsyXSB8fFxuICAgICAgICB0MTAgIT09IHRhcmdldFs0XSB8fFxuICAgICAgICB0MTEgIT09IHRhcmdldFs1XSB8fFxuICAgICAgICB0MTIgIT09IHRhcmdldFs2XSB8fFxuICAgICAgICB0MjAgIT09IHRhcmdldFs4XSB8fFxuICAgICAgICB0MjEgIT09IHRhcmdldFs5XSB8fFxuICAgICAgICB0MjIgIT09IHRhcmdldFsxMF0gfHxcbiAgICAgICAgdDMwICE9PSB0YXJnZXRbMTJdIHx8XG4gICAgICAgIHQzMSAhPT0gdGFyZ2V0WzEzXSB8fFxuICAgICAgICB0MzIgIT09IHRhcmdldFsxNF0pIGNoYW5nZWQgfD0gVHJhbnNmb3JtLkxPQ0FMX0NIQU5HRUQ7XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cblxuLyoqXG4gKiBwcml2YXRlIG1ldGhvZCB0byBtdWx0aXBseSB0d28gdHJhbnNmb3Jtcy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gb3V0IFRoZSBhcnJheSB0byB3cml0ZSB0aGUgcmVzdWx0IHRvXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBsZWZ0IGhhbmQgdHJhbnNmb3JtXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSByaWdodCBoYW5kIHRyYW5zZm9ybVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5IChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF07XG5cbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciByZXM7XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICB2YXIgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcblxuICAgIHJlcyA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/IGNoYW5nZWQgOiBvdXRbMF0gPT09IHJlcztcbiAgICBvdXRbMF0gPSByZXM7XG5cbiAgICByZXMgPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgPyBjaGFuZ2VkIDogb3V0WzFdID09PSByZXM7XG4gICAgb3V0WzFdID0gcmVzO1xuXG4gICAgcmVzID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkID8gY2hhbmdlZCA6IG91dFsyXSA9PT0gcmVzO1xuICAgIG91dFsyXSA9IHJlcztcblxuICAgIG91dFszXSA9IDA7XG5cbiAgICBiMCA9IGJbNF07IGIxID0gYls1XTsgYjIgPSBiWzZdOyBiMyA9IGJbN107XG5cbiAgICByZXMgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgPyBjaGFuZ2VkIDogb3V0WzRdID09PSByZXM7XG4gICAgb3V0WzRdID0gcmVzO1xuXG4gICAgcmVzID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkID8gY2hhbmdlZCA6IG91dFs1XSA9PT0gcmVzO1xuICAgIG91dFs1XSA9IHJlcztcblxuICAgIHJlcyA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/IGNoYW5nZWQgOiBvdXRbNl0gPT09IHJlcztcbiAgICBvdXRbNl0gPSByZXM7XG5cbiAgICBvdXRbN10gPSAwO1xuXG4gICAgYjAgPSBiWzhdOyBiMSA9IGJbOV07IGIyID0gYlsxMF07IGIzID0gYlsxMV07XG5cbiAgICByZXMgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgPyBjaGFuZ2VkIDogb3V0WzhdID09PSByZXM7XG4gICAgb3V0WzhdID0gcmVzO1xuXG4gICAgcmVzID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkID8gY2hhbmdlZCA6IG91dFs5XSA9PT0gcmVzO1xuICAgIG91dFs5XSA9IHJlcztcblxuICAgIHJlcyA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/IGNoYW5nZWQgOiBvdXRbMTBdID09PSByZXM7XG4gICAgb3V0WzEwXSA9IHJlcztcblxuICAgIG91dFsxMV0gPSAwO1xuXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcblxuICAgIHJlcyA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/IGNoYW5nZWQgOiBvdXRbMTJdID09PSByZXM7XG4gICAgb3V0WzEyXSA9IHJlcztcblxuICAgIHJlcyA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/IGNoYW5nZWQgOiBvdXRbMTNdID09PSByZXM7XG4gICAgb3V0WzEzXSA9IHJlcztcblxuICAgIHJlcyA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/IGNoYW5nZWQgOiBvdXRbMTRdID09PSByZXM7XG4gICAgb3V0WzE0XSA9IHJlcztcblxuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aCcpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG52YXIgRGlzcGF0Y2ggPSByZXF1aXJlKCcuL0Rpc3BhdGNoJyk7XG52YXIgUGF0aFN0b3JlID0gcmVxdWlyZSgnLi9QYXRoU3RvcmUnKTtcblxuLyoqXG4gKiBUaGUgdHJhbnNmb3JtIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciBjYWxjdWxhdGluZyB0aGUgdHJhbnNmb3JtIG9mIGEgcGFydGljdWxhclxuICogbm9kZSBmcm9tIHRoZSBkYXRhIG9uIHRoZSBub2RlIGFuZCBpdHMgcGFyZW50XG4gKlxuICogQGNvbnN0cnVjdG9yIHtUcmFuc2Zvcm1TeXN0ZW19XG4gKi9cbmZ1bmN0aW9uIFRyYW5zZm9ybVN5c3RlbSAoKSB7XG4gICAgdGhpcy5wYXRoU3RvcmUgPSBuZXcgUGF0aFN0b3JlKCk7XG59XG5cbi8qKlxuICogcmVnaXN0ZXJzIGEgbmV3IFRyYW5zZm9ybSBmb3IgdGhlIGdpdmVuIHBhdGguIFRoaXMgdHJhbnNmb3JtIHdpbGwgYmUgdXBkYXRlZFxuICogd2hlbiB0aGUgVHJhbnNmb3JtU3lzdGVtIHVwZGF0ZXMuXG4gKlxuICogQG1ldGhvZCByZWdpc3RlclRyYW5zZm9ybUF0UGF0aFxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBmb3IgdGhlIHRyYW5zZm9ybSB0byBiZSByZWdpc3RlcmVkIHRvLlxuICogQHBhcmFtIHtUcmFuc2Zvcm0gfCB1bmRlZmluZWR9IHRyYW5zZm9ybSBvcHRpb25hbCB0cmFuc2Zvcm0gdG8gcmVnaXN0ZXIuXG4gKi9cblRyYW5zZm9ybVN5c3RlbS5wcm90b3R5cGUucmVnaXN0ZXJUcmFuc2Zvcm1BdFBhdGggPSBmdW5jdGlvbiByZWdpc3RlclRyYW5zZm9ybUF0UGF0aCAocGF0aCwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKCFQYXRoVXRpbHMuZGVwdGgocGF0aCkpIHJldHVybiB0aGlzLnBhdGhTdG9yZS5pbnNlcnQocGF0aCwgdHJhbnNmb3JtID8gdHJhbnNmb3JtIDogbmV3IFRyYW5zZm9ybSgpKTtcblxuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhdGhTdG9yZS5nZXQoUGF0aFV0aWxzLnBhcmVudChwYXRoKSk7XG5cbiAgICBpZiAoIXBhcmVudCkgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ05vIHBhcmVudCB0cmFuc2Zvcm0gcmVnaXN0ZXJlZCBhdCBleHBlY3RlZCBwYXRoOiAnICsgUGF0aFV0aWxzLnBhcmVudChwYXRoKVxuICAgICk7XG5cbiAgICBpZiAodHJhbnNmb3JtKSB0cmFuc2Zvcm0uc2V0UGFyZW50KHBhcmVudCk7XG5cbiAgICB0aGlzLnBhdGhTdG9yZS5pbnNlcnQocGF0aCwgdHJhbnNmb3JtID8gdHJhbnNmb3JtIDogbmV3IFRyYW5zZm9ybShwYXJlbnQpKTtcbn07XG5cbi8qKlxuICogZGVyZWdpc3RlcnMgYSB0cmFuc2Zvcm0gcmVnaXN0ZXJlZCBhdCB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAbWV0aG9kIGRlcmVnaXN0ZXJUcmFuc2Zvcm1BdFBhdGhcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggYXQgd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIHRyYW5zZm9ybVxuICovXG5UcmFuc2Zvcm1TeXN0ZW0ucHJvdG90eXBlLmRlcmVnaXN0ZXJUcmFuc2Zvcm1BdFBhdGggPSBmdW5jdGlvbiBkZXJlZ2lzdGVyVHJhbnNmb3JtQXRQYXRoIChwYXRoKSB7XG4gICAgdGhpcy5wYXRoU3RvcmUucmVtb3ZlKHBhdGgpO1xufTtcblxuLyoqXG4gKiBNZXRob2Qgd2hpY2ggd2lsbCBtYWtlIHRoZSB0cmFuc2Zvcm0gY3VycmVudGx5IHN0b3JlZCBhdCB0aGUgZ2l2ZW4gcGF0aCBhIGJyZWFrcG9pbnQuXG4gKiBBIHRyYW5zZm9ybSBiZWluZyBhIGJyZWFrcG9pbnQgbWVhbnMgdGhhdCBib3RoIGEgbG9jYWwgYW5kIHdvcmxkIHRyYW5zZm9ybSB3aWxsIGJlIGNhbGN1bGF0ZWRcbiAqIGZvciB0aGF0IHBvaW50LiBUaGUgbG9jYWwgdHJhbnNmb3JtIGJlaW5nIHRoZSBjb25jYXRpbmF0ZWQgdHJhbnNmb3JtIG9mIGFsbCBhbmNlc3RvciB0cmFuc2Zvcm1zIHVwXG4gKiB1bnRpbCB0aGUgbmVhcmVzdCBicmVha3BvaW50LCBhbmQgdGhlIHdvcmxkIGJlaW5nIHRoZSBjb25jYXRpbmF0ZWQgdHJhbnNmb3JtIG9mIGFsbCBhbmNlc3RvciB0cmFuc2Zvcm1zLlxuICogVGhpcyBtZXRob2QgdGhyb3dzIGlmIG5vIHRyYW5zZm9ybSBpcyBhdCB0aGUgcHJvdmlkZWQgcGF0aC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIHBhdGggYXQgd2hpY2ggdG8gdHVybiB0aGUgdHJhbnNmb3JtIGludG8gYSBicmVha3BvaW50XG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuVHJhbnNmb3JtU3lzdGVtLnByb3RvdHlwZS5tYWtlQnJlYWtQb2ludEF0ID0gZnVuY3Rpb24gbWFrZUJyZWFrUG9pbnRBdCAocGF0aCkge1xuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnBhdGhTdG9yZS5nZXQocGF0aCk7XG4gICAgaWYgKCF0cmFuc2Zvcm0pIHRocm93IG5ldyBFcnJvcignTm8gdHJhbnNmb3JtIFJlZ2lzdGVyZWQgYXQgcGF0aDogJyArIHBhdGgpO1xuICAgIHRyYW5zZm9ybS5zZXRCcmVha1BvaW50KCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSB0cmFuc2Zvcm0gY2xhc3MgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBwYXRoLFxuICogb3IgdW5kZWZpbmVkIGlmIG5vIHRyYW5zZm9ybSBpcyBhc3NvY2lhdGVkLlxuICpcbiAqIEBtZXRob2RcbiAqIFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gbG9va3VwXG4gKlxuICogQHJldHVybiB7VHJhbnNmb3JtIHwgdW5kZWZpbmVkfSB0aGUgdHJhbnNmb3JtIGF0IHRoYXQgcGF0aCBpcyBhdmFpbGFibGUsIGVsc2UgdW5kZWZpbmVkLlxuICovXG5UcmFuc2Zvcm1TeXN0ZW0ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAocGF0aCkge1xuICAgIHJldHVybiB0aGlzLnBhdGhTdG9yZS5nZXQocGF0aCk7XG59O1xuXG4vKipcbiAqIG9uVXBkYXRlIGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2Zvcm0gc3lzdGVtIHJlcXVpcmVzIGFuIHVwZGF0ZS5cbiAqIEl0IHRyYXZlcnNlcyB0aGUgdHJhbnNmb3JtIGFycmF5IGFuZCBldmFsdWF0ZXMgdGhlIG5lY2Vzc2FyeSB0cmFuc2Zvcm1zXG4gKiBpbiB0aGUgc2NlbmUgZ3JhcGggd2l0aCB0aGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgY29ycmVzcG9uZGluZyBub2RlXG4gKiBpbiB0aGUgc2NlbmUgZ3JhcGhcbiAqXG4gKiBAbWV0aG9kIG9uVXBkYXRlXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuVHJhbnNmb3JtU3lzdGVtLnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uIG9uVXBkYXRlICgpIHtcbiAgICB2YXIgdHJhbnNmb3JtcyA9IHRoaXMucGF0aFN0b3JlLmdldEl0ZW1zKCk7XG4gICAgdmFyIHBhdGhzID0gdGhpcy5wYXRoU3RvcmUuZ2V0UGF0aHMoKTtcbiAgICB2YXIgdHJhbnNmb3JtO1xuICAgIHZhciBjaGFuZ2VkO1xuICAgIHZhciBub2RlO1xuICAgIHZhciB2ZWN0b3JzO1xuICAgIHZhciBvZmZzZXRzO1xuICAgIHZhciBjb21wb25lbnRzO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBub2RlID0gRGlzcGF0Y2guZ2V0Tm9kZShwYXRoc1tpXSk7XG4gICAgICAgIGlmICghbm9kZSkgY29udGludWU7XG4gICAgICAgIGNvbXBvbmVudHMgPSBub2RlLmdldENvbXBvbmVudHMoKTtcbiAgICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1tpXTtcbiAgICAgICAgdmVjdG9ycyA9IHRyYW5zZm9ybS52ZWN0b3JzO1xuICAgICAgICBvZmZzZXRzID0gdHJhbnNmb3JtLm9mZnNldHM7XG4gICAgICAgIGlmIChvZmZzZXRzLmFsaWduQ2hhbmdlZCkgYWxpZ25DaGFuZ2VkKG5vZGUsIGNvbXBvbmVudHMsIG9mZnNldHMpO1xuICAgICAgICBpZiAob2Zmc2V0cy5tb3VudFBvaW50Q2hhbmdlZCkgbW91bnRQb2ludENoYW5nZWQobm9kZSwgY29tcG9uZW50cywgb2Zmc2V0cyk7XG4gICAgICAgIGlmIChvZmZzZXRzLm9yaWdpbkNoYW5nZWQpIG9yaWdpbkNoYW5nZWQobm9kZSwgY29tcG9uZW50cywgb2Zmc2V0cyk7XG4gICAgICAgIGlmICh2ZWN0b3JzLnBvc2l0aW9uQ2hhbmdlZCkgcG9zaXRpb25DaGFuZ2VkKG5vZGUsIGNvbXBvbmVudHMsIHZlY3RvcnMpO1xuICAgICAgICBpZiAodmVjdG9ycy5yb3RhdGlvbkNoYW5nZWQpIHJvdGF0aW9uQ2hhbmdlZChub2RlLCBjb21wb25lbnRzLCB2ZWN0b3JzKTtcbiAgICAgICAgaWYgKHZlY3RvcnMuc2NhbGVDaGFuZ2VkKSBzY2FsZUNoYW5nZWQobm9kZSwgY29tcG9uZW50cywgdmVjdG9ycyk7XG4gICAgICAgIGlmICgoY2hhbmdlZCA9IHRyYW5zZm9ybS5jYWxjdWxhdGUobm9kZSkpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1DaGFuZ2VkKG5vZGUsIGNvbXBvbmVudHMsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCAmIFRyYW5zZm9ybS5MT0NBTF9DSEFOR0VEKSBsb2NhbFRyYW5zZm9ybUNoYW5nZWQobm9kZSwgY29tcG9uZW50cywgdHJhbnNmb3JtLmdldExvY2FsVHJhbnNmb3JtKCkpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQgJiBUcmFuc2Zvcm0uV09STERfQ0hBTkdFRCkgd29ybGRUcmFuc2Zvcm1DaGFuZ2VkKG5vZGUsIGNvbXBvbmVudHMsIHRyYW5zZm9ybS5nZXRXb3JsZFRyYW5zZm9ybSgpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIHByaXZhdGUgbWV0aG9kc1xuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHRvIGNhbGwgd2hlbiBhbGlnbiBjaGFuZ2VzLiBUcmlnZ2VycyAnb25BbGlnbkNoYW5nZScgbWV0aG9kc1xuICogb24gdGhlIG5vZGUgYW5kIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHNcbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSB0aGUgbm9kZSBvbiB3aGljaCB0byBjYWxsIG9uQWxpZ25DaGFuZ2UgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRzIHRoZSBjb21wb25lbnRzIG9uIHdoaWNoIHRvIGNhbGwgb25BbGlnbkNoYW5nZSBpZiBuZWNlc3NhcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvZmZzZXRzIHRoZSBzZXQgb2Ygb2Zmc2V0cyBmcm9tIHRoZSB0cmFuc2Zvcm1cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBhbGlnbkNoYW5nZWQgKG5vZGUsIGNvbXBvbmVudHMsIG9mZnNldHMpIHtcbiAgICB2YXIgeCA9IG9mZnNldHMuYWxpZ25bMF07XG4gICAgdmFyIHkgPSBvZmZzZXRzLmFsaWduWzFdO1xuICAgIHZhciB6ID0gb2Zmc2V0cy5hbGlnblsyXTtcbiAgICBpZiAobm9kZS5vbkFsaWduQ2hhbmdlKSBub2RlLm9uQWxpZ25DaGFuZ2UoeCwgeSwgeik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vbkFsaWduQ2hhbmdlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vbkFsaWduQ2hhbmdlKHgsIHksIHopO1xuICAgIG9mZnNldHMuYWxpZ25DaGFuZ2VkID0gZmFsc2U7XG59XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gY2FsbCB3aGVuIE1vdW50UG9pbnQgY2hhbmdlcy4gVHJpZ2dlcnMgJ29uTW91bnRQb2ludENoYW5nZScgbWV0aG9kc1xuICogb24gdGhlIG5vZGUgYW5kIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHNcbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSB0aGUgbm9kZSBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtBcnJheX0gY29tcG9uZW50cyB0aGUgY29tcG9uZW50cyBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtPYmplY3R9IG9mZnNldHMgdGhlIHNldCBvZiBvZmZzZXRzIGZyb20gdGhlIHRyYW5zZm9ybVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIG1vdW50UG9pbnRDaGFuZ2VkIChub2RlLCBjb21wb25lbnRzLCBvZmZzZXRzKSB7XG4gICAgdmFyIHggPSBvZmZzZXRzLm1vdW50UG9pbnRbMF07XG4gICAgdmFyIHkgPSBvZmZzZXRzLm1vdW50UG9pbnRbMV07XG4gICAgdmFyIHogPSBvZmZzZXRzLm1vdW50UG9pbnRbMl07XG4gICAgaWYgKG5vZGUub25Nb3VudFBvaW50Q2hhbmdlKSBub2RlLm9uTW91bnRQb2ludENoYW5nZSh4LCB5LCB6KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uTW91bnRQb2ludENoYW5nZSlcbiAgICAgICAgICAgIGNvbXBvbmVudHNbaV0ub25Nb3VudFBvaW50Q2hhbmdlKHgsIHksIHopO1xuICAgIG9mZnNldHMubW91bnRQb2ludENoYW5nZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBQcml2YXRlIG1ldGhvZCB0byBjYWxsIHdoZW4gT3JpZ2luIGNoYW5nZXMuIFRyaWdnZXJzICdvbk9yaWdpbkNoYW5nZScgbWV0aG9kc1xuICogb24gdGhlIG5vZGUgYW5kIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHNcbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSB0aGUgbm9kZSBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtBcnJheX0gY29tcG9uZW50cyB0aGUgY29tcG9uZW50cyBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtPYmplY3R9IG9mZnNldHMgdGhlIHNldCBvZiBvZmZzZXRzIGZyb20gdGhlIHRyYW5zZm9ybVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIG9yaWdpbkNoYW5nZWQgKG5vZGUsIGNvbXBvbmVudHMsIG9mZnNldHMpIHtcbiAgICB2YXIgeCA9IG9mZnNldHMub3JpZ2luWzBdO1xuICAgIHZhciB5ID0gb2Zmc2V0cy5vcmlnaW5bMV07XG4gICAgdmFyIHogPSBvZmZzZXRzLm9yaWdpblsyXTtcbiAgICBpZiAobm9kZS5vbk9yaWdpbkNoYW5nZSkgbm9kZS5vbk9yaWdpbkNoYW5nZSh4LCB5LCB6KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uT3JpZ2luQ2hhbmdlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vbk9yaWdpbkNoYW5nZSh4LCB5LCB6KTtcbiAgICBvZmZzZXRzLm9yaWdpbkNoYW5nZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBQcml2YXRlIG1ldGhvZCB0byBjYWxsIHdoZW4gUG9zaXRpb24gY2hhbmdlcy4gVHJpZ2dlcnMgJ29uUG9zaXRpb25DaGFuZ2UnIG1ldGhvZHNcbiAqIG9uIHRoZSBub2RlIGFuZCBhbGwgb2YgdGhlIG5vZGUncyBjb21wb25lbnRzXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgdGhlIG5vZGUgb24gd2hpY2ggdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCBpZiBuZWNlc3NhcnlcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgdGhlIGNvbXBvbmVudHMgb24gd2hpY2ggdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCBpZiBuZWNlc3NhcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSB2ZWN0b3JzIHRoZSBzZXQgb2YgdmVjdG9ycyBmcm9tIHRoZSB0cmFuc2Zvcm1cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBwb3NpdGlvbkNoYW5nZWQgKG5vZGUsIGNvbXBvbmVudHMsIHZlY3RvcnMpIHtcbiAgICB2YXIgeCA9IHZlY3RvcnMucG9zaXRpb25bMF07XG4gICAgdmFyIHkgPSB2ZWN0b3JzLnBvc2l0aW9uWzFdO1xuICAgIHZhciB6ID0gdmVjdG9ycy5wb3NpdGlvblsyXTtcbiAgICBpZiAobm9kZS5vblBvc2l0aW9uQ2hhbmdlKSBub2RlLm9uUG9zaXRpb25DaGFuZ2UoeCwgeSwgeik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vblBvc2l0aW9uQ2hhbmdlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vblBvc2l0aW9uQ2hhbmdlKHgsIHksIHopO1xuICAgIHZlY3RvcnMucG9zaXRpb25DaGFuZ2VkID0gZmFsc2U7XG59XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gY2FsbCB3aGVuIFJvdGF0aW9uIGNoYW5nZXMuIFRyaWdnZXJzICdvblJvdGF0aW9uQ2hhbmdlJyBtZXRob2RzXG4gKiBvbiB0aGUgbm9kZSBhbmQgYWxsIG9mIHRoZSBub2RlJ3MgY29tcG9uZW50c1xuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIHRoZSBub2RlIG9uIHdoaWNoIHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRzIHRoZSBjb21wb25lbnRzIG9uIHdoaWNoIHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gdmVjdG9ycyB0aGUgc2V0IG9mIHZlY3RvcnMgZnJvbSB0aGUgdHJhbnNmb3JtXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gcm90YXRpb25DaGFuZ2VkIChub2RlLCBjb21wb25lbnRzLCB2ZWN0b3JzKSB7XG4gICAgdmFyIHggPSB2ZWN0b3JzLnJvdGF0aW9uWzBdO1xuICAgIHZhciB5ID0gdmVjdG9ycy5yb3RhdGlvblsxXTtcbiAgICB2YXIgeiA9IHZlY3RvcnMucm90YXRpb25bMl07XG4gICAgdmFyIHcgPSB2ZWN0b3JzLnJvdGF0aW9uWzNdO1xuICAgIGlmIChub2RlLm9uUm90YXRpb25DaGFuZ2UpIG5vZGUub25Sb3RhdGlvbkNoYW5nZSh4LCB5LCB6LCB3KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uUm90YXRpb25DaGFuZ2UpXG4gICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uUm90YXRpb25DaGFuZ2UoeCwgeSwgeiwgdyk7XG4gICAgdmVjdG9ycy5yb3RhdGlvbkNoYW5nZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBQcml2YXRlIG1ldGhvZCB0byBjYWxsIHdoZW4gU2NhbGUgY2hhbmdlcy4gVHJpZ2dlcnMgJ29uU2NhbGVDaGFuZ2UnIG1ldGhvZHNcbiAqIG9uIHRoZSBub2RlIGFuZCBhbGwgb2YgdGhlIG5vZGUncyBjb21wb25lbnRzXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgdGhlIG5vZGUgb24gd2hpY2ggdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCBpZiBuZWNlc3NhcnlcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgdGhlIGNvbXBvbmVudHMgb24gd2hpY2ggdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCBpZiBuZWNlc3NhcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSB2ZWN0b3JzIHRoZSBzZXQgb2YgdmVjdG9ycyBmcm9tIHRoZSB0cmFuc2Zvcm1cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBzY2FsZUNoYW5nZWQgKG5vZGUsIGNvbXBvbmVudHMsIHZlY3RvcnMpIHtcbiAgICB2YXIgeCA9IHZlY3RvcnMuc2NhbGVbMF07XG4gICAgdmFyIHkgPSB2ZWN0b3JzLnNjYWxlWzFdO1xuICAgIHZhciB6ID0gdmVjdG9ycy5zY2FsZVsyXTtcbiAgICBpZiAobm9kZS5vblNjYWxlQ2hhbmdlKSBub2RlLm9uU2NhbGVDaGFuZ2UoeCwgeSwgeik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vblNjYWxlQ2hhbmdlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vblNjYWxlQ2hhbmdlKHgsIHksIHopO1xuICAgIHZlY3RvcnMuc2NhbGVDaGFuZ2VkID0gZmFsc2U7XG59XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gY2FsbCB3aGVuIGVpdGhlciB0aGUgTG9jYWwgb3IgV29ybGQgVHJhbnNmb3JtIGNoYW5nZXMuXG4gKiBUcmlnZ2VycyAnb25UcmFuc2Zvcm1DaGFuZ2UnIG1ldGhvZHMgb24gdGhlIG5vZGUgYW5kIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHNcbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSB0aGUgbm9kZSBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtBcnJheX0gY29tcG9uZW50cyB0aGUgY29tcG9uZW50cyBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybSB0aGUgdHJhbnNmb3JtIGNsYXNzIHRoYXQgY2hhbmdlZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUNoYW5nZWQgKG5vZGUsIGNvbXBvbmVudHMsIHRyYW5zZm9ybSkge1xuICAgIGlmIChub2RlLm9uVHJhbnNmb3JtQ2hhbmdlKSBub2RlLm9uVHJhbnNmb3JtQ2hhbmdlKHRyYW5zZm9ybSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vblRyYW5zZm9ybUNoYW5nZSlcbiAgICAgICAgICAgIGNvbXBvbmVudHNbaV0ub25UcmFuc2Zvcm1DaGFuZ2UodHJhbnNmb3JtKTtcbn1cblxuLyoqXG4gKiBQcml2YXRlIG1ldGhvZCB0byBjYWxsIHdoZW4gdGhlIGxvY2FsIHRyYW5zZm9ybSBjaGFuZ2VzLiBUcmlnZ2VycyAnb25Mb2NhbFRyYW5zZm9ybUNoYW5nZScgbWV0aG9kc1xuICogb24gdGhlIG5vZGUgYW5kIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHNcbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSB0aGUgbm9kZSBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtBcnJheX0gY29tcG9uZW50cyB0aGUgY29tcG9uZW50cyBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtIHRoZSBsb2NhbCB0cmFuc2Zvcm1cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBsb2NhbFRyYW5zZm9ybUNoYW5nZWQgKG5vZGUsIGNvbXBvbmVudHMsIHRyYW5zZm9ybSkge1xuICAgIGlmIChub2RlLm9uTG9jYWxUcmFuc2Zvcm1DaGFuZ2UpIG5vZGUub25Mb2NhbFRyYW5zZm9ybUNoYW5nZSh0cmFuc2Zvcm0pO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25Mb2NhbFRyYW5zZm9ybUNoYW5nZSlcbiAgICAgICAgICAgIGNvbXBvbmVudHNbaV0ub25Mb2NhbFRyYW5zZm9ybUNoYW5nZSh0cmFuc2Zvcm0pO1xufVxuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHRvIGNhbGwgd2hlbiB0aGUgd29ybGQgdHJhbnNmb3JtIGNoYW5nZXMuIFRyaWdnZXJzICdvbldvcmxkVHJhbnNmb3JtQ2hhbmdlJyBtZXRob2RzXG4gKiBvbiB0aGUgbm9kZSBhbmQgYWxsIG9mIHRoZSBub2RlJ3MgY29tcG9uZW50c1xuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIHRoZSBub2RlIG9uIHdoaWNoIHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRzIHRoZSBjb21wb25lbnRzIG9uIHdoaWNoIHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm0gdGhlIHdvcmxkIHRyYW5zZm9ybVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHdvcmxkVHJhbnNmb3JtQ2hhbmdlZCAobm9kZSwgY29tcG9uZW50cywgdHJhbnNmb3JtKSB7XG4gICAgaWYgKG5vZGUub25Xb3JsZFRyYW5zZm9ybUNoYW5nZSkgbm9kZS5vbldvcmxkVHJhbnNmb3JtQ2hhbmdlKHRyYW5zZm9ybSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vbldvcmxkVHJhbnNmb3JtQ2hhbmdlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vbldvcmxkVHJhbnNmb3JtQ2hhbmdlKHRyYW5zZm9ybSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFRyYW5zZm9ybVN5c3RlbSgpO1xuXG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDYWxsYmFja1N0b3JlID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL0NhbGxiYWNrU3RvcmUnKTtcbnZhciBUcmFuc2Zvcm1TeXN0ZW0gPSByZXF1aXJlKCcuLi9jb3JlL1RyYW5zZm9ybVN5c3RlbScpO1xudmFyIENvbW1hbmRzID0gcmVxdWlyZSgnLi4vY29yZS9Db21tYW5kcycpO1xuXG52YXIgUkVOREVSX1NJWkUgPSAyO1xuXG4vKipcbiAqIEEgRE9NRWxlbWVudCBpcyBhIGNvbXBvbmVudCB0aGF0IGNhbiBiZSBhZGRlZCB0byBhIE5vZGUgd2l0aCB0aGVcbiAqIHB1cnBvc2Ugb2Ygc2VuZGluZyBkcmF3IGNvbW1hbmRzIHRvIHRoZSByZW5kZXJlci4gUmVuZGVyYWJsZXMgc2VuZCBkcmF3IGNvbW1hbmRzXG4gKiB0byB0aHJvdWdoIHRoZWlyIE5vZGVzIHRvIHRoZSBDb21wb3NpdG9yIHdoZXJlIHRoZXkgYXJlIGFjdGVkIHVwb24uXG4gKlxuICogQGNsYXNzIERPTUVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgICAgICAgICAgICAgICAgICAgVGhlIE5vZGUgdG8gd2hpY2ggdGhlIGBET01FbGVtZW50YFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmFibGUgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgIEluaXRpYWwgb3B0aW9ucyB1c2VkIGZvciBpbnN0YW50aWF0aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIE5vZGUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9wZXJ0aWVzICAgQ1NTIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYWN0dWFsIERPTUVsZW1lbnQgb24gdGhlIGluaXRpYWwgZHJhdy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmF0dHJpYnV0ZXMgICBFbGVtZW50IGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYWN0dWFsIERPTUVsZW1lbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5pZCAgICAgICAgICAgU3RyaW5nIHRvIGJlIGFwcGxpZWQgYXMgJ2lkJyBvZiB0aGUgYWN0dWFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRE9NRWxlbWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmNvbnRlbnQgICAgICBTdHJpbmcgdG8gYmUgYXBwbGllZCBhcyB0aGUgY29udGVudCBvZiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWwgRE9NRWxlbWVudC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5jdXRvdXQgICAgICBTcGVjaWZpZXMgdGhlIHByZXNlbmNlIG9mIGEgJ2N1dG91dCcgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2ViR0wgY2FudmFzIG92ZXIgdGhpcyBlbGVtZW50IHdoaWNoIGFsbG93c1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBET00gYW5kIFdlYkdMIGxheWVyaW5nLiAgT24gYnkgZGVmYXVsdC5cbiAqL1xuZnVuY3Rpb24gRE9NRWxlbWVudChub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFub2RlKSB0aHJvdyBuZXcgRXJyb3IoJ0RPTUVsZW1lbnQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgb24gYSBub2RlJyk7XG5cbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZSA9IFtdO1xuICAgIFxuICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9yZW5kZXJTaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlcXVlc3RSZW5kZXJTaXplID0gZmFsc2U7XG5cbiAgICB0aGlzLl9VSUV2ZW50cyA9IG5vZGUuZ2V0VUlFdmVudHMoKS5zbGljZSgwKTtcbiAgICB0aGlzLl9jbGFzc2VzID0gWydmYW1vdXMtZG9tLWVsZW1lbnQnXTtcbiAgICB0aGlzLl9yZXF1ZXN0aW5nRXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9zdHlsZXMgPSB7fTtcblxuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLl9jb250ZW50ID0gJyc7XG5cbiAgICB0aGlzLl90YWdOYW1lID0gb3B0aW9ucyAmJiBvcHRpb25zLnRhZ05hbWUgPyBvcHRpb25zLnRhZ05hbWUgOiAnZGl2JztcbiAgICB0aGlzLl9yZW5kZXJTaXplID0gWzAsIDAsIDBdO1xuXG4gICAgdGhpcy5faWQgPSBub2RlID8gbm9kZS5hZGRDb21wb25lbnQodGhpcykgOiBudWxsO1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuXG4gICAgdGhpcy5vblNpemVNb2RlQ2hhbmdlLmFwcGx5KHRoaXMsIG5vZGUuZ2V0U2l6ZU1vZGUoKSk7XG5cbiAgICB0aGlzLl9jYWxsYmFja3MgPSBuZXcgQ2FsbGJhY2tTdG9yZSgpO1xuXG4gICAgdGhpcy5zZXRQcm9wZXJ0eSgnZGlzcGxheScsIG5vZGUuaXNTaG93bigpID8gJ2Jsb2NrJyA6ICdub25lJyk7XG4gICAgdGhpcy5vbk9wYWNpdHlDaGFuZ2Uobm9kZS5nZXRPcGFjaXR5KCkpO1xuXG4gICAgaWYgKCFvcHRpb25zKSByZXR1cm47XG5cbiAgICB2YXIgaTtcbiAgICB2YXIga2V5O1xuXG4gICAgaWYgKG9wdGlvbnMuY2xhc3NlcylcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMuY2xhc3Nlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3Mob3B0aW9ucy5jbGFzc2VzW2ldKTtcblxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpXG4gICAgICAgIGZvciAoa2V5IGluIG9wdGlvbnMuYXR0cmlidXRlcylcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgb3B0aW9ucy5hdHRyaWJ1dGVzW2tleV0pO1xuXG4gICAgaWYgKG9wdGlvbnMucHJvcGVydGllcylcbiAgICAgICAgZm9yIChrZXkgaW4gb3B0aW9ucy5wcm9wZXJ0aWVzKVxuICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eShrZXksIG9wdGlvbnMucHJvcGVydGllc1trZXldKTtcblxuICAgIGlmIChvcHRpb25zLmlkKSB0aGlzLnNldElkKG9wdGlvbnMuaWQpO1xuICAgIGlmIChvcHRpb25zLmNvbnRlbnQpIHRoaXMuc2V0Q29udGVudChvcHRpb25zLmNvbnRlbnQpO1xuICAgIGlmIChvcHRpb25zLmN1dG91dCA9PT0gZmFsc2UpIHRoaXMuc2V0Q3V0b3V0U3RhdGUob3B0aW9ucy5jdXRvdXQpO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhlIHN0YXRlIG9mIHRoZSBET01FbGVtZW50LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHNlcmlhbGl6ZWQgaW50ZXJhbCBzdGF0ZVxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsYXNzZXM6IHRoaXMuX2NsYXNzZXMsXG4gICAgICAgIHN0eWxlczogdGhpcy5fc3R5bGVzLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLl9hdHRyaWJ1dGVzLFxuICAgICAgICBjb250ZW50OiB0aGlzLl9jb250ZW50LFxuICAgICAgICBpZDogdGhpcy5fYXR0cmlidXRlcy5pZCxcbiAgICAgICAgdGFnTmFtZTogdGhpcy5fdGFnTmFtZVxuICAgIH07XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgYW4gdXBkYXRlIG9jY3Vycy4gVGhpcyBhbGxvd3NcbiAqIHRoZSBET01FbGVtZW50IHJlbmRlcmFibGUgdG8gZHluYW1pY2FsbHkgcmVhY3QgdG8gc3RhdGUgY2hhbmdlcyBvbiB0aGUgTm9kZS5cbiAqXG4gKiBUaGlzIGZsdXNoZXMgdGhlIGludGVybmFsIGRyYXcgY29tbWFuZCBxdWV1ZSBieSBzZW5kaW5nIGluZGl2aWR1YWwgY29tbWFuZHNcbiAqIHRvIHRoZSBub2RlIHVzaW5nIGBzZW5kRHJhd0NvbW1hbmRgLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uIG9uVXBkYXRlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGU7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fY2hhbmdlUXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblxuICAgIGlmIChsZW4gJiYgbm9kZSkge1xuICAgICAgICBub2RlLnNlbmREcmF3Q29tbWFuZChDb21tYW5kcy5XSVRIKTtcbiAgICAgICAgbm9kZS5zZW5kRHJhd0NvbW1hbmQobm9kZS5nZXRMb2NhdGlvbigpKTtcblxuICAgICAgICB3aGlsZSAobGVuLS0pIG5vZGUuc2VuZERyYXdDb21tYW5kKHF1ZXVlLnNoaWZ0KCkpO1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdFJlbmRlclNpemUpIHtcbiAgICAgICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKENvbW1hbmRzLkRPTV9SRU5ERVJfU0laRSk7XG4gICAgICAgICAgICBub2RlLnNlbmREcmF3Q29tbWFuZChub2RlLmdldExvY2F0aW9uKCkpO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdFJlbmRlclNpemUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgaW52b2tlZCBieSB0aGUgTm9kZSBhcyBzb29uIGFzIHRoZSBub2RlIChvciBhbnkgb2YgaXRzXG4gKiBhbmNlc3RvcnMpIGlzIGJlaW5nIG1vdW50ZWQuXG4gKlxuICogQG1ldGhvZCBvbk1vdW50XG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlICAgICAgUGFyZW50IG5vZGUgdG8gd2hpY2ggdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgYWRkZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgICAgICBQYXRoIGF0IHdoaWNoIHRoZSBjb21wb25lbnQgKG9yIG5vZGUpIGlzIGJlaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoZWQuIFRoZSBwYXRoIGlzIGJlaW5nIHNldCBvbiB0aGUgYWN0dWFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgRE9NRWxlbWVudCBhcyBhIGBkYXRhLWZhLXBhdGhgLWF0dHJpYnV0ZS5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vbk1vdW50ID0gZnVuY3Rpb24gb25Nb3VudChub2RlLCBpZCkge1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgdGhpcy5fVUlFdmVudHMgPSBub2RlLmdldFVJRXZlbnRzKCkuc2xpY2UoMCk7XG4gICAgVHJhbnNmb3JtU3lzdGVtLm1ha2VCcmVha1BvaW50QXQobm9kZS5nZXRMb2NhdGlvbigpKTtcbiAgICB0aGlzLmRyYXcoKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGF0YS1mYS1wYXRoJywgbm9kZS5nZXRMb2NhdGlvbigpKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIE5vZGUgYXMgc29vbiBhcyB0aGUgbm9kZSBpcyBiZWluZyBkaXNtb3VudGVkXG4gKiBlaXRoZXIgZGlyZWN0bHkgb3IgYnkgZGlzbW91bnRpbmcgb25lIG9mIGl0cyBhbmNlc3RvcnMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uRGlzbW91bnQgPSBmdW5jdGlvbiBvbkRpc21vdW50KCkge1xuICAgIHRoaXMuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdkYXRhLWZhLXBhdGgnLCAnJyk7XG4gICAgdGhpcy5zZXRDdXRvdXRTdGF0ZShmYWxzZSk7XG5cbiAgICB0aGlzLm9uVXBkYXRlKCk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIG5vZGUgYXMgc29vbiBhcyB0aGUgRE9NRWxlbWVudCBpcyBiZWluZyBzaG93bi5cbiAqIFRoaXMgcmVzdWx0cyBpbnRvIHRoZSBET01FbGVtZW50IHNldHRpbmcgdGhlIGBkaXNwbGF5YCBwcm9wZXJ0eSB0byBgYmxvY2tgXG4gKiBhbmQgdGhlcmVmb3JlIHZpc3VhbGx5IHNob3dpbmcgdGhlIGNvcnJlc3BvbmRpbmcgRE9NRWxlbWVudCAoYWdhaW4pLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblNob3cgPSBmdW5jdGlvbiBvblNob3coKSB7XG4gICAgdGhpcy5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdibG9jaycpO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgaW52b2tlZCBieSB0aGUgbm9kZSBhcyBzb29uIGFzIHRoZSBET01FbGVtZW50IGlzIGJlaW5nIGhpZGRlbi5cbiAqIFRoaXMgcmVzdWx0cyBpbnRvIHRoZSBET01FbGVtZW50IHNldHRpbmcgdGhlIGBkaXNwbGF5YCBwcm9wZXJ0eSB0byBgbm9uZWBcbiAqIGFuZCB0aGVyZWZvcmUgdmlzdWFsbHkgaGlkaW5nIHRoZSBjb3JyZXNwb25kaW5nIERPTUVsZW1lbnQgKGFnYWluKS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUub25IaWRlID0gZnVuY3Rpb24gb25IaWRlKCkge1xuICAgIHRoaXMuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnbm9uZScpO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIG9yIGRpc2FibGVzIFdlYkdMICdjdXRvdXQnIGZvciB0aGlzIGVsZW1lbnQsIHdoaWNoIGFmZmVjdHNcbiAqIGhvdyB0aGUgZWxlbWVudCBpcyBsYXllcmVkIHdpdGggV2ViR0wgb2JqZWN0cyBpbiB0aGUgc2NlbmUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlc0N1dG91dCAgVGhlIHByZXNlbmNlIG9mIGEgV2ViR0wgJ2N1dG91dCcgZm9yIHRoaXMgZWxlbWVudC5cbiAqXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGlzXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLnNldEN1dG91dFN0YXRlID0gZnVuY3Rpb24gc2V0Q3V0b3V0U3RhdGUgKHVzZXNDdXRvdXQpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpXG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goQ29tbWFuZHMuR0xfQ1VUT1VUX1NUQVRFLCB1c2VzQ3V0b3V0KTtcblxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgaW52b2tlZCBieSB0aGUgbm9kZSBhcyBzb29uIGFzIHRoZSB0cmFuc2Zvcm0gbWF0cml4IGFzc29jaWF0ZWRcbiAqIHdpdGggdGhlIG5vZGUgY2hhbmdlcy4gVGhlIERPTUVsZW1lbnQgd2lsbCByZWFjdCB0byB0cmFuc2Zvcm0gY2hhbmdlcyBieSBzZW5kaW5nXG4gKiBgQ0hBTkdFX1RSQU5TRk9STWAgY29tbWFuZHMgdG8gdGhlIGBET01SZW5kZXJlcmAuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB0cmFuc2Zvcm0gVGhlIGZpbmFsIHRyYW5zZm9ybSBtYXRyaXhcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblRyYW5zZm9ybUNoYW5nZSA9IGZ1bmN0aW9uIG9uVHJhbnNmb3JtQ2hhbmdlICh0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKENvbW1hbmRzLkNIQU5HRV9UUkFOU0ZPUk0pO1xuICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybS5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRyYW5zZm9ybS5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKHRyYW5zZm9ybVtpXSk7XG5cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIG5vZGUgYXMgc29vbiBhcyBpdHMgY29tcHV0ZWQgc2l6ZSBjaGFuZ2VzLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCB3aWR0aCBvZiB0aGUgTm9kZSB0aGUgRE9NRWxlbWVudCBpcyBhdHRhY2hlZCB0b1xuICogQHBhcmFtIHtOdW1iZXJ9IHkgaGVpZ2h0IG9mIHRoZSBOb2RlIHRoZSBET01FbGVtZW50IGlzIGF0dGFjaGVkIHRvXG4gKlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhpc1xuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblNpemVDaGFuZ2UgPSBmdW5jdGlvbiBvblNpemVDaGFuZ2UoeCwgeSkge1xuICAgIHZhciBzaXplTW9kZSA9IHRoaXMuX25vZGUuZ2V0U2l6ZU1vZGUoKTtcbiAgICB2YXIgc2l6ZWRYID0gc2l6ZU1vZGVbMF0gIT09IFJFTkRFUl9TSVpFO1xuICAgIHZhciBzaXplZFkgPSBzaXplTW9kZVsxXSAhPT0gUkVOREVSX1NJWkU7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKVxuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKENvbW1hbmRzLkNIQU5HRV9TSVpFLFxuICAgICAgICAgICAgc2l6ZWRYID8geCA6IHNpemVkWCxcbiAgICAgICAgICAgIHNpemVkWSA/IHkgOiBzaXplZFkpO1xuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgaXRzIG9wYWNpdHkgY2hhbmdlc1xuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gb3BhY2l0eSBUaGUgbmV3IG9wYWNpdHksIGFzIGEgc2NhbGFyIGZyb20gMCB0byAxXG4gKlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhpc1xuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vbk9wYWNpdHlDaGFuZ2UgPSBmdW5jdGlvbiBvbk9wYWNpdHlDaGFuZ2Uob3BhY2l0eSkge1xuICAgIHJldHVybiB0aGlzLnNldFByb3BlcnR5KCdvcGFjaXR5Jywgb3BhY2l0eSk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgYSBuZXcgVUlFdmVudCBpcyBiZWluZyBhZGRlZC5cbiAqIFRoaXMgcmVzdWx0cyBpbnRvIGFuIGBBRERfRVZFTlRfTElTVEVORVJgIGNvbW1hbmQgYmVpbmcgc2VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdWlFdmVudCB1aUV2ZW50IHRvIGJlIHN1YnNjcmliZWQgdG8gKGUuZy4gYGNsaWNrYClcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vbkFkZFVJRXZlbnQgPSBmdW5jdGlvbiBvbkFkZFVJRXZlbnQodWlFdmVudCkge1xuICAgIGlmICh0aGlzLl9VSUV2ZW50cy5pbmRleE9mKHVpRXZlbnQpID09PSAtMSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmUodWlFdmVudCk7XG4gICAgICAgIHRoaXMuX1VJRXZlbnRzLnB1c2godWlFdmVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX2luRHJhdykge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmUodWlFdmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgaW52b2tlZCBieSB0aGUgbm9kZSBhcyBzb29uIGFzIGEgVUlFdmVudCBpcyByZW1vdmVkIGZyb21cbiAqIHRoZSBub2RlLiAgVGhpcyByZXN1bHRzIGludG8gYW4gYFVOU1VCU0NSSUJFYCBjb21tYW5kIGJlaW5nIHNlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFVJRXZlbnQgVUlFdmVudCB0byBiZSByZW1vdmVkIChlLmcuIGBtb3VzZWRvd25gKVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uUmVtb3ZlVUlFdmVudCA9IGZ1bmN0aW9uIG9uUmVtb3ZlVUlFdmVudChVSUV2ZW50KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fVUlFdmVudHMuaW5kZXhPZihVSUV2ZW50KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKFVJRXZlbnQpO1xuICAgICAgICB0aGlzLl9VSUV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl9pbkRyYXcpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoVUlFdmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGFuIGBTVUJTQ1JJQkVgIGNvbW1hbmQgdG8gdGhlIGNvbW1hbmQgcXVldWUuXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdWlFdmVudCBFdmVudCB0eXBlIChlLmcuIGBjbGlja2ApXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIF9zdWJzY3JpYmUgKHVpRXZlbnQpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5TVUJTQ1JJQkUsIHVpRXZlbnQpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBXaGVuIHJ1bm5pbmcgaW4gYSB3b3JrZXIsIHRoZSBicm93c2VyJ3MgZGVmYXVsdCBhY3Rpb24gZm9yIHNwZWNpZmljIGV2ZW50c1xuICogY2FuJ3QgYmUgcHJldmVudGVkIG9uIGEgY2FzZSBieSBjYXNlIGJhc2lzICh2aWEgYGUucHJldmVudERlZmF1bHQoKWApLlxuICogSW5zdGVhZCB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkIHRvIHJlZ2lzdGVyIGFuIGV2ZW50IHRvIGJlIHByZXZlbnRlZCBieVxuICogZGVmYXVsdC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSB1aUV2ZW50ICAgICBVSSBFdmVudCAoZS5nLiB3aGVlbCkgZm9yIHdoaWNoIHRvIHByZXZlbnQgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIncyBkZWZhdWx0IGFjdGlvbiAoZS5nLiBmb3JtIHN1Ym1pc3Npb24sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGluZylcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gICAgICAgICAgdW5kZWZpbmVkXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHQgKHVpRXZlbnQpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5QUkVWRU5UX0RFRkFVTFQsIHVpRXZlbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbi8qKlxuICogT3Bwb3NpdGUgb2Yge0BsaW5rIERPTUVsZW1lbnQjcHJldmVudERlZmF1bHR9LiBObyBsb25nZXIgcHJldmVudCB0aGVcbiAqIGJyb3dzZXIncyBkZWZhdWx0IGFjdGlvbiBvbiBzdWJzZXF1ZW50IGV2ZW50cyBvZiB0aGlzIHR5cGUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSAge3R5cGV9IHVpRXZlbnQgICAgICAgVUkgRXZlbnQgcHJldmlvdXNseSByZWdpc3RlcmVkIHVzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBET01FbGVtZW50I3ByZXZlbnREZWZhdWx0fS5cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gICAgICAgICAgdW5kZWZpbmVkXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLmFsbG93RGVmYXVsdCA9IGZ1bmN0aW9uIGFsbG93RGVmYXVsdCAodWlFdmVudCkge1xuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKENvbW1hbmRzLkFMTE9XX0RFRkFVTFQsIHVpRXZlbnQpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGFuIGBVTlNVQlNDUklCRWAgY29tbWFuZCB0byB0aGUgY29tbWFuZCBxdWV1ZS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBVSUV2ZW50IEV2ZW50IHR5cGUgKGUuZy4gYGNsaWNrYClcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiBfdW5zdWJzY3JpYmUgKFVJRXZlbnQpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnVU5TVUJTQ1JJQkUnLCBVSUV2ZW50KTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgdGhlIHVuZGVybHlpbmcgc2l6ZSBtb2RlXG4gKiBjaGFuZ2VzLiBUaGlzIHJlc3VsdHMgaW50byB0aGUgc2l6ZSBiZWluZyBmZXRjaGVkIGZyb20gdGhlIG5vZGUgaW5cbiAqIG9yZGVyIHRvIHVwZGF0ZSB0aGUgYWN0dWFsLCByZW5kZXJlZCBzaXplLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCB0aGUgc2l6aW5nIG1vZGUgaW4gdXNlIGZvciBkZXRlcm1pbmluZyBzaXplIGluIHRoZSB4IGRpcmVjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHNpemluZyBtb2RlIGluIHVzZSBmb3IgZGV0ZXJtaW5pbmcgc2l6ZSBpbiB0aGUgeSBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IHRoZSBzaXppbmcgbW9kZSBpbiB1c2UgZm9yIGRldGVybWluaW5nIHNpemUgaW4gdGhlIHogZGlyZWN0aW9uXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUub25TaXplTW9kZUNoYW5nZSA9IGZ1bmN0aW9uIG9uU2l6ZU1vZGVDaGFuZ2UoeCwgeSwgeikge1xuICAgIGlmICh4ID09PSBSRU5ERVJfU0laRSB8fCB5ID09PSBSRU5ERVJfU0laRSB8fCB6ID09PSBSRU5ERVJfU0laRSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJTaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RSZW5kZXJTaXplID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHNpemUgPSB0aGlzLl9ub2RlLmdldFNpemUoKTtcbiAgICB0aGlzLm9uU2l6ZUNoYW5nZShzaXplWzBdLCBzaXplWzFdKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIHJldHJpZXZlIHRoZSByZW5kZXJlZCBzaXplIG9mIHRoZSBET00gZWxlbWVudCB0aGF0IGlzXG4gKiBkcmF3biBmb3IgdGhpcyBub2RlLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gc2l6ZSBvZiB0aGUgcmVuZGVyZWQgRE9NIGVsZW1lbnQgaW4gcGl4ZWxzXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLmdldFJlbmRlclNpemUgPSBmdW5jdGlvbiBnZXRSZW5kZXJTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJTaXplO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gaGF2ZSB0aGUgY29tcG9uZW50IHJlcXVlc3QgYW4gdXBkYXRlIGZyb20gaXRzIE5vZGVcbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLl9yZXF1ZXN0VXBkYXRlID0gZnVuY3Rpb24gX3JlcXVlc3RVcGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIERPTUVsZW1lbnQgYnkgc2VuZGluZyB0aGUgYElOSVRfRE9NYCBjb21tYW5kLiBUaGlzIGNyZWF0ZXNcbiAqIG9yIHJlYWxsb2NhdGVzIGEgbmV3IEVsZW1lbnQgaW4gdGhlIGFjdHVhbCBET00gaGllcmFyY2h5LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoKSB7XG4gICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5JTklUX0RPTSwgdGhpcy5fdGFnTmFtZSk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMub25UcmFuc2Zvcm1DaGFuZ2UoVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLl9ub2RlLmdldExvY2F0aW9uKCkpKTtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX25vZGUuZ2V0U2l6ZSgpO1xuICAgIHRoaXMub25TaXplQ2hhbmdlKHNpemVbMF0sIHNpemVbMV0pO1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBpZCBhdHRyaWJ1dGUgb2YgdGhlIERPTUVsZW1lbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBOZXcgaWQgdG8gYmUgc2V0XG4gKlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhpc1xuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5zZXRJZCA9IGZ1bmN0aW9uIHNldElkIChpZCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIG5ldyBjbGFzcyB0byB0aGUgaW50ZXJuYWwgY2xhc3MgbGlzdCBvZiB0aGUgdW5kZXJseWluZyBFbGVtZW50IGluIHRoZVxuICogRE9NLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgTmV3IGNsYXNzIG5hbWUgdG8gYmUgYWRkZWRcbiAqXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGlzXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MgKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2NsYXNzZXMuaW5kZXhPZih2YWx1ZSkgPCAwKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5BRERfQ0xBU1MsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5fY2xhc3Nlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJTaXplZCkgdGhpcy5fcmVxdWVzdFJlbmRlclNpemUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5EcmF3KSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5BRERfQ0xBU1MsIHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgRE9NRWxlbWVudCdzIGNsYXNzTGlzdC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIENsYXNzIG5hbWUgdG8gYmUgcmVtb3ZlZFxuICpcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoaXNcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyAodmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9jbGFzc2VzLmluZGV4T2YodmFsdWUpO1xuXG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIHRoaXM7XG5cbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKENvbW1hbmRzLlJFTU9WRV9DTEFTUywgdmFsdWUpO1xuXG4gICAgdGhpcy5fY2xhc3Nlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBET01FbGVtZW50IGhhcyB0aGUgcGFzc2VkIGluIGNsYXNzLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGNsYXNzIG5hbWVcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGFzc2VkIGluIGNsYXNzIG5hbWUgaXMgaW4gdGhlIERPTUVsZW1lbnQncyBjbGFzcyBsaXN0LlxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9jbGFzc2VzLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBhdHRyaWJ1dGUgb2YgdGhlIERPTUVsZW1lbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEF0dHJpYnV0ZSBrZXkgKGUuZy4gYHNyY2ApXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlIChlLmcuIGBodHRwOi8vZmFtby51c2ApXG4gKlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhpc1xuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0gIT09IHZhbHVlIHx8IHRoaXMuX2luRHJhdykge1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5DSEFOR0VfQVRUUklCVVRFLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdFVwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgQ1NTIHByb3BlcnR5XG4gKlxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICBOYW1lIG9mIHRoZSBDU1MgcnVsZSAoZS5nLiBgYmFja2dyb3VuZC1jb2xvcmApXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVmFsdWUgb2YgQ1NTIHByb3BlcnR5IChlLmcuIGByZWRgKVxuICpcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoaXNcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eSAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc3R5bGVzW25hbWVdICE9PSB2YWx1ZSB8fCB0aGlzLl9pbkRyYXcpIHtcbiAgICAgICAgdGhpcy5fc3R5bGVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5DSEFOR0VfUFJPUEVSVFksIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJTaXplZCkgdGhpcy5fcmVxdWVzdFJlbmRlclNpemUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBET01FbGVtZW50LiBUaGlzIGlzIHVzaW5nIGBpbm5lckhUTUxgLCBlc2NhcGluZyB1c2VyXG4gKiBnZW5lcmF0ZWQgY29udGVudCBpcyB0aGVyZWZvcmUgZXNzZW50aWFsIGZvciBzZWN1cml0eSBwdXJwb3Nlcy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnQgQ29udGVudCB0byBiZSBzZXQgdXNpbmcgYC5pbm5lckhUTUwgPSAuLi5gXG4gKlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhpc1xuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gc2V0Q29udGVudCAoY29udGVudCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50ICE9PSBjb250ZW50IHx8IHRoaXMuX2luRHJhdykge1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKENvbW1hbmRzLkNIQU5HRV9DT05URU5ULCBjb250ZW50KTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJTaXplZCkgdGhpcy5fcmVxdWVzdFJlbmRlclNpemUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVzIHRvIGEgRE9NRWxlbWVudCB1c2luZy5cbiAqXG4gKiBAbWV0aG9kIG9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50ICAgICAgIFRoZSBldmVudCB0eXBlIChlLmcuIGBjbGlja2ApLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgIEhhbmRsZXIgZnVuY3Rpb24gZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB3aGljaCB0aGUgcGF5bG9hZCBldmVudCBvYmplY3Qgd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzZWQgaW50by5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byBjYWxsIGlmIHlvdSB3YW50IHRvIHJlbW92ZSB0aGUgY2FsbGJhY2tcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrcy5vbihldmVudCwgbGlzdGVuZXIpO1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiB0byBiZSBpbnZva2VkIGJ5IHRoZSBOb2RlIHdoZW5ldmVyIGFuIGV2ZW50IGlzIGJlaW5nIHJlY2VpdmVkLlxuICogVGhlcmUgYXJlIHR3byBkaWZmZXJlbnQgd2F5cyB0byBzdWJzY3JpYmUgZm9yIHRob3NlIGV2ZW50czpcbiAqXG4gKiAxLiBCeSBvdmVycmlkaW5nIHRoZSBvblJlY2VpdmUgbWV0aG9kIChhbmQgcG9zc2libHkgdXNpbmcgYHN3aXRjaGAgaW4gb3JkZXJcbiAqICAgICB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdGhlIGRpZmZlcmVudCBldmVudCB0eXBlcykuXG4gKiAyLiBCeSB1c2luZyBET01FbGVtZW50IGFuZCB1c2luZyB0aGUgYnVpbHQtaW4gQ2FsbGJhY2tTdG9yZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IEV2ZW50IHR5cGUgKGUuZy4gYGNsaWNrYClcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIEV2ZW50IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblJlY2VpdmUgPSBmdW5jdGlvbiBvblJlY2VpdmUgKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgaWYgKGV2ZW50ID09PSAncmVzaXplJykge1xuICAgICAgICB0aGlzLl9yZW5kZXJTaXplWzBdID0gcGF5bG9hZC52YWxbMF07XG4gICAgICAgIHRoaXMuX3JlbmRlclNpemVbMV0gPSBwYXlsb2FkLnZhbFsxXTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIHRoaXMuX2NhbGxiYWNrcy50cmlnZ2VyKGV2ZW50LCBwYXlsb2FkKTtcbn07XG5cbi8qKlxuICogVGhlIGRyYXcgZnVuY3Rpb24gaXMgYmVpbmcgdXNlZCBpbiBvcmRlciB0byBhbGxvdyBtdXRhdGluZyB0aGUgRE9NRWxlbWVudFxuICogYmVmb3JlIGFjdHVhbGx5IG1vdW50aW5nIHRoZSBjb3JyZXNwb25kaW5nIG5vZGUuXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gZHJhdygpIHtcbiAgICB2YXIga2V5O1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICB0aGlzLl9pbkRyYXcgPSB0cnVlO1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9jbGFzc2VzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIHRoaXMuYWRkQ2xhc3ModGhpcy5fY2xhc3Nlc1tpXSk7XG5cbiAgICBpZiAodGhpcy5fY29udGVudCkgdGhpcy5zZXRDb250ZW50KHRoaXMuX2NvbnRlbnQpO1xuXG4gICAgZm9yIChrZXkgaW4gdGhpcy5fc3R5bGVzKVxuICAgICAgICBpZiAodGhpcy5fc3R5bGVzW2tleV0gIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2V0UHJvcGVydHkoa2V5LCB0aGlzLl9zdHlsZXNba2V5XSk7XG5cbiAgICBmb3IgKGtleSBpbiB0aGlzLl9hdHRyaWJ1dGVzKVxuICAgICAgICBpZiAodGhpcy5fYXR0cmlidXRlc1trZXldICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShrZXksIHRoaXMuX2F0dHJpYnV0ZXNba2V5XSk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9VSUV2ZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICB0aGlzLm9uQWRkVUlFdmVudCh0aGlzLl9VSUV2ZW50c1tpXSk7XG5cbiAgICB0aGlzLl9pbkRyYXcgPSBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NRWxlbWVudDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVsZW1lbnRDYWNoZSA9IHJlcXVpcmUoJy4vRWxlbWVudENhY2hlJyk7XG52YXIgbWF0aCA9IHJlcXVpcmUoJy4vTWF0aCcpO1xudmFyIFBhdGhVdGlscyA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aCcpO1xudmFyIHZlbmRvclByZWZpeCA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy92ZW5kb3JQcmVmaXgnKTtcbnZhciBldmVudE1hcCA9IHJlcXVpcmUoJy4vZXZlbnRzL0V2ZW50TWFwJyk7XG5cbnZhciBUUkFOU0ZPUk0gPSBudWxsO1xuXG4vKipcbiAqIERPTVJlbmRlcmVyIGlzIGEgY2xhc3MgcmVzcG9uc2libGUgZm9yIGFkZGluZyBlbGVtZW50c1xuICogdG8gdGhlIERPTSBhbmQgd3JpdGluZyB0byB0aG9zZSBlbGVtZW50cy5cbiAqIFRoZXJlIGlzIGEgRE9NUmVuZGVyZXIgcGVyIGNvbnRleHQsIHJlcHJlc2VudGVkIGFzIGFuXG4gKiBlbGVtZW50IGFuZCBhIHNlbGVjdG9yLiBJdCBpcyBpbnN0YW50aWF0ZWQgaW4gdGhlXG4gKiBjb250ZXh0IGNsYXNzLlxuICpcbiAqIEBjbGFzcyBET01SZW5kZXJlclxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgYW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciB0aGUgc2VsZWN0b3Igb2YgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0NvbXBvc2l0b3J9IGNvbXBvc2l0b3IgdGhlIGNvbXBvc2l0b3IgY29udHJvbGxpbmcgdGhlIHJlbmRlcmVyXG4gKi9cbmZ1bmN0aW9uIERPTVJlbmRlcmVyIChlbGVtZW50LCBzZWxlY3RvciwgY29tcG9zaXRvcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZhbW91cy1kb20tcmVuZGVyZXInKTtcblxuICAgIFRSQU5TRk9STSA9IFRSQU5TRk9STSB8fCB2ZW5kb3JQcmVmaXgoJ3RyYW5zZm9ybScpO1xuICAgIHRoaXMuX2NvbXBvc2l0b3IgPSBjb21wb3NpdG9yOyAvLyBhIHJlZmVyZW5jZSB0byB0aGUgY29tcG9zaXRvclxuXG4gICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDsgLy8gYSByZWdpc3RlciBmb3IgaG9sZGluZyB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgdGhhdCB0aGUgUmVuZGVyZXIgaXMgb3BlcmF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBvblxuXG4gICAgdGhpcy5fcGFyZW50ID0gbnVsbDsgLy8gYSByZWdpc3RlciBmb3IgaG9sZGluZyB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIHRhcmdldFxuXG4gICAgdGhpcy5fcGF0aCA9IG51bGw7IC8vIGEgcmVnaXN0ZXIgZm9yIGhvbGRpbmcgdGhlIHBhdGggb2YgdGhlIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJlZ2lzdGVyIG11c3QgYmUgc2V0IGZpcnN0LCBhbmQgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGlsZHJlbiwgdGFyZ2V0LCBhbmQgcGFyZW50IGFyZSBhbGwgbG9va2VkXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIHVwIGZyb20gdGhhdC5cblxuICAgIHRoaXMuX2NoaWxkcmVuID0gW107IC8vIGEgcmVnaXN0ZXIgZm9yIGhvbGRpbmcgdGhlIGNoaWxkcmVuIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgdGFyZ2V0LlxuXG4gICAgdGhpcy5fcm9vdCA9IG5ldyBFbGVtZW50Q2FjaGUoZWxlbWVudCwgc2VsZWN0b3IpOyAvLyB0aGUgcm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIGRvbSB0cmVlIHRoYXQgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyZXIgaXMgcmVzcG9uc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvclxuXG4gICAgdGhpcy5fYm91bmRUcmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl90cmlnZ2VyRXZlbnQoZXYpO1xuICAgIH07XG5cbiAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xuXG4gICAgdGhpcy5fZWxlbWVudHMgPSB7fTtcblxuICAgIHRoaXMuX2VsZW1lbnRzW3NlbGVjdG9yXSA9IHRoaXMuX3Jvb3Q7XG5cbiAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pO1xuICAgIHRoaXMuX1ZQdHJhbnNmb3JtID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pO1xuXG4gICAgdGhpcy5fbGFzdEV2ID0gbnVsbDtcbn1cblxuXG4vKipcbiAqIEF0dGFjaGVzIGFuIEV2ZW50TGlzdGVuZXIgdG8gdGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwYXNzZWQgaW4gcGF0aC5cbiAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uIG9uIGFsbCBzdWJzZXF1ZW50IGV2ZW50cyBpZlxuICogYHByZXZlbnREZWZhdWx0YCBpcyB0cnV0aHkuXG4gKiBBbGwgaW5jb21pbmcgZXZlbnRzIHdpbGwgYmUgZm9yd2FyZGVkIHRvIHRoZSBjb21wb3NpdG9yIGJ5IGludm9raW5nIHRoZVxuICogYHNlbmRFdmVudGAgbWV0aG9kLlxuICogRGVsZWdhdGVzIGV2ZW50cyBpZiBwb3NzaWJsZSBieSBhdHRhY2hpbmcgdGhlIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb250ZXh0LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBET00gZXZlbnQgdHlwZSAoZS5nLiBjbGljaywgbW91c2VvdmVyKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJldmVudERlZmF1bHQgV2hldGhlciBvciBub3QgdGhlIGRlZmF1bHQgYnJvd3NlciBhY3Rpb24gc2hvdWxkIGJlIHByZXZlbnRlZC5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlKHR5cGUpIHtcbiAgICB0aGlzLl9hc3NlcnRUYXJnZXRMb2FkZWQoKTtcbiAgICB0aGlzLl9saXN0ZW4odHlwZSk7XG4gICAgdGhpcy5fdGFyZ2V0LnN1YnNjcmliZVt0eXBlXSA9IHRydWU7XG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlcyBmcm9tIGFsbCBldmVudHMgdGhhdCBhcmUgb2YgdGhlIHNwZWNpZmllZCB0eXBlLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUgICAgRXZlbnQgdHlwZSB0byB1bnN1YnNjcmliZSBmcm9tLlxuICogQHJldHVybiB7dW5kZWZpbmVkfSAgICAgIHVuZGVmaW5lZFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZSh0eXBlKSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgdGhpcy5fbGlzdGVuKHR5cGUpO1xuICAgIHRoaXMuX3RhcmdldC5zdWJzY3JpYmVbdHlwZV0gPSBmYWxzZTtcbn07XG5cbi8qKlxuICogVXNlZCB0byBwcmV2ZW50RGVmYXVsdCBpZiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgYmVpbmcgZW1pdHRlZCBvblxuICogdGhlIGN1cnJlbnRseSBsb2FkZWQgdGFyZ2V0LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUgICAgVGhlIHR5cGUgb2YgZXZlbnRzIHRoYXQgc2hvdWxkIGJlIHByZXZlbnRlZC5cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gICAgICB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHQodHlwZSkge1xuICAgIHRoaXMuX2Fzc2VydFRhcmdldExvYWRlZCgpO1xuICAgIHRoaXMuX2xpc3Rlbih0eXBlKTtcbiAgICB0aGlzLl90YXJnZXQucHJldmVudERlZmF1bHRbdHlwZV0gPSB0cnVlO1xufTtcblxuLyoqXG4gKiBVc2VkIHRvIHVuZG8gYSBwcmV2aW91cyBjYWxsIHRvIHByZXZlbnREZWZhdWx0LiBObyBsb25nZXIgYHByZXZlbnREZWZhdWx0YFxuICogZm9yIHRoaXMgZXZlbnQgb24gdGhlIGxvYWRlZCB0YXJnZXQuXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUgICAgVGhlIGV2ZW50IHR5cGUgdGhhdCBzaG91bGQgbm8gbG9uZ2VyIGJlIGFmZmVjdGVkIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgYHByZXZlbnREZWZhdWx0YC5cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gICAgICB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLmFsbG93RGVmYXVsdCA9IGZ1bmN0aW9uIGFsbG93RGVmYXVsdCh0eXBlKSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgdGhpcy5fbGlzdGVuKHR5cGUpO1xuICAgIHRoaXMuX3RhcmdldC5wcmV2ZW50RGVmYXVsdFt0eXBlXSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdXNlZCBmb3IgYWRkaW5nIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgdGhlXG4gKiBjdXJyZW50bHkgbG9hZGVkIEVsZW1lbnRDYWNoZS5cbiAqXG4gKiBJZiB0aGUgZXZlbnQgY2FuIGJlIGRlbGVnYXRlZCBhcyBzcGVjaWZpZWQgaW4gdGhlIHtAbGluayBFdmVudE1hcH0sIHRoZVxuICogYm91bmQge0BsaW5rIF90cmlnZ2VyRXZlbnR9IGZ1bmN0aW9uIHdpbGwgYmUgYWRkZWQgYXMgYSBsaXN0ZW5lciBvbiB0aGVcbiAqIHJvb3QgZWxlbWVudC4gT3RoZXJ3aXNlLCB0aGUgbGlzdGVuZXIgd2lsbCBiZSBhZGRlZCBkaXJlY3RseSB0byB0aGUgdGFyZ2V0XG4gKiBlbGVtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlICAgIFRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiB0byAoZS5nLiBjbGljaykuXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9ICAgICAgdW5kZWZpbmVkXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5fbGlzdGVuID0gZnVuY3Rpb24gX2xpc3Rlbih0eXBlKSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG5cbiAgICBpZiAoXG4gICAgICAgICF0aGlzLl90YXJnZXQubGlzdGVuZXJzW3R5cGVdICYmICF0aGlzLl9yb290Lmxpc3RlbmVyc1t0eXBlXVxuICAgICkge1xuICAgICAgICAvLyBGSVhNRSBBZGQgdG8gY29udGVudCBESVYgaWYgYXZhaWxhYmxlXG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudE1hcFt0eXBlXVsxXSA/IHRoaXMuX3Jvb3QgOiB0aGlzLl90YXJnZXQ7XG4gICAgICAgIHRhcmdldC5saXN0ZW5lcnNbdHlwZV0gPSB0aGlzLl9ib3VuZFRyaWdnZXJFdmVudDtcbiAgICAgICAgdGFyZ2V0LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLl9ib3VuZFRyaWdnZXJFdmVudCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIEV2ZW50TGlzdGVuZXIgb2YgZ2l2ZW4gdHlwZSBmcm9tIHRoZSBlbGVtZW50IG9uIHdoaWNoIGl0IHdhc1xuICogcmVnaXN0ZXJlZC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgRE9NIGV2ZW50IHR5cGUgKGUuZy4gY2xpY2ssIG1vdXNlb3ZlcikuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUodHlwZSkge1xuICAgIHRoaXMuX2Fzc2VydFRhcmdldExvYWRlZCgpO1xuICAgIHRoaXMuX3RhcmdldC5zdWJzY3JpYmVbdHlwZV0gPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gYmUgYWRkZWQgdXNpbmcgYGFkZEV2ZW50TGlzdGVuZXJgIHRvIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET01FbGVtZW50LlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXYgRE9NIEV2ZW50IHBheWxvYWRcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuX3RyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIF90cmlnZ2VyRXZlbnQoZXYpIHtcbiAgICBpZiAodGhpcy5fbGFzdEV2ID09PSBldikgcmV0dXJuO1xuXG4gICAgLy8gVXNlIGV2LnBhdGgsIHdoaWNoIGlzIGFuIGFycmF5IG9mIEVsZW1lbnRzIChwb2x5ZmlsbGVkIGlmIG5lZWRlZCkuXG4gICAgdmFyIGV2UGF0aCA9IGV2LnBhdGggPyBldi5wYXRoIDogX2dldFBhdGgoZXYpO1xuICAgIC8vIEZpcnN0IGVsZW1lbnQgaW4gdGhlIHBhdGggaXMgdGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGV2ZW50IGhhcyBhY3R1YWxseVxuICAgIC8vIGJlZW4gZW1pdHRlZC5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2UGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBTa2lwIG5vZGVzIHRoYXQgZG9uJ3QgaGF2ZSBhIGRhdGFzZXQgcHJvcGVydHkgb3IgZGF0YS1mYS1wYXRoXG4gICAgICAgIC8vIGF0dHJpYnV0ZS5cbiAgICAgICAgaWYgKCFldlBhdGhbaV0uZGF0YXNldCkgY29udGludWU7XG4gICAgICAgIHZhciBwYXRoID0gZXZQYXRoW2ldLmRhdGFzZXQuZmFQYXRoO1xuICAgICAgICBpZiAoIXBhdGgpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIE9wdGlvbmFsbHkgcHJldmVudERlZmF1bHQuIFRoaXMgbmVlZHMgZm9ydGhlciBjb25zaWRlcmF0aW9uIGFuZFxuICAgICAgICAvLyBzaG91bGQgYmUgb3B0aW9uYWwuIEV2ZW50dWFsbHkgdGhpcyBzaG91bGQgYmUgYSBzZXBhcmF0ZSBjb21tYW5kL1xuICAgICAgICAvLyBtZXRob2QuXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50c1twYXRoXS5wcmV2ZW50RGVmYXVsdFtldi50eXBlXSkge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3AgZnVydGhlciBldmVudCBwcm9wb2dhdGlvbiBhbmQgcGF0aCB0cmF2ZXJzYWwgYXMgc29vbiBhcyB0aGVcbiAgICAgICAgLy8gZmlyc3QgRWxlbWVudENhY2hlIHN1YnNjcmliaW5nIGZvciB0aGUgZW1pdHRlZCBldmVudCBoYXMgYmVlbiBmb3VuZC5cbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRzW3BhdGhdICYmIHRoaXMuX2VsZW1lbnRzW3BhdGhdLnN1YnNjcmliZVtldi50eXBlXSkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdEV2ID0gZXY7XG5cbiAgICAgICAgICAgIHZhciBOb3JtYWxpemVkRXZlbnRDb25zdHJ1Y3RvciA9IGV2ZW50TWFwW2V2LnR5cGVdWzBdO1xuXG4gICAgICAgICAgICAvLyBGaW5hbGx5IHNlbmQgdGhlIGV2ZW50IHRvIHRoZSBXb3JrZXIgVGhyZWFkIHRocm91Z2ggdGhlXG4gICAgICAgICAgICAvLyBjb21wb3NpdG9yLlxuICAgICAgICAgICAgdGhpcy5fY29tcG9zaXRvci5zZW5kRXZlbnQocGF0aCwgZXYudHlwZSwgbmV3IE5vcm1hbGl6ZWRFdmVudENvbnN0cnVjdG9yKGV2KSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKipcbiAqIGdldFNpemVPZiBnZXRzIHRoZSBkb20gc2l6ZSBvZiBhIHBhcnRpY3VsYXIgRE9NIGVsZW1lbnQuICBUaGlzIGlzXG4gKiBuZWVkZWQgZm9yIHJlbmRlciBzaXppbmcgaW4gdGhlIHNjZW5lIGdyYXBoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBwYXRoIG9mIHRoZSBOb2RlIGluIHRoZSBzY2VuZSBncmFwaFxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBhIHZlYzMgb2YgdGhlIG9mZnNldCBzaXplIG9mIHRoZSBkb20gZWxlbWVudFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuZ2V0U2l6ZU9mID0gZnVuY3Rpb24gZ2V0U2l6ZU9mKHBhdGgpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRzW3BhdGhdO1xuICAgIGlmICghZWxlbWVudCkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgcmVzID0ge3ZhbDogZWxlbWVudC5zaXplfTtcbiAgICB0aGlzLl9jb21wb3NpdG9yLnNlbmRFdmVudChwYXRoLCAncmVzaXplJywgcmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gX2dldFBhdGgoZXYpIHtcbiAgICAvLyBUT0RPIG1vdmUgaW50byBfdHJpZ2dlckV2ZW50LCBhdm9pZCBvYmplY3QgYWxsb2NhdGlvblxuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIG5vZGUgPSBldi50YXJnZXQ7XG4gICAgd2hpbGUgKG5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcmV0cmlldmVkIGRyYXcgY29tbWFuZHMuIERyYXcgY29tbWFuZHMgb25seSByZWZlciB0byB0aGVcbiAqIGNyb3NzLWJyb3dzZXIgbm9ybWFsaXplZCBgdHJhbnNmb3JtYCBwcm9wZXJ0eS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlbmRlclN0YXRlIGRlc2NyaXB0aW9uXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiBkcmF3KHJlbmRlclN0YXRlKSB7XG4gICAgaWYgKHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlRGlydHkpIHtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzBdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMF07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMV0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxXTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsyXSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzJdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzNdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bM107XG5cbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs0XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzRdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzVdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bNV07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bNl0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs2XTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs3XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzddO1xuXG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bOF0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs4XTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs5XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzldO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzEwXSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzEwXTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMV0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMV07XG5cbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMl0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMl07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTNdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTNdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzE0XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzE0XTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxNV0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxNV07XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlclN0YXRlLnZpZXdEaXJ0eSB8fCByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5KSB7XG4gICAgICAgIG1hdGgubXVsdGlwbHkodGhpcy5fVlB0cmFuc2Zvcm0sIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm0sIHJlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm0pO1xuICAgICAgICB0aGlzLl9yb290LmVsZW1lbnQuc3R5bGVbVFJBTlNGT1JNXSA9IHRoaXMuX3N0cmluZ2lmeU1hdHJpeCh0aGlzLl9WUHRyYW5zZm9ybSk7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB1c2VkIGZvciBlbnN1cmluZyB0aGF0IGEgcGF0aCBpcyBjdXJyZW50bHkgbG9hZGVkLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLl9hc3NlcnRQYXRoTG9hZGVkID0gZnVuY3Rpb24gX2Fzc2VyUGF0aExvYWRlZCgpIHtcbiAgICBpZiAoIXRoaXMuX3BhdGgpIHRocm93IG5ldyBFcnJvcigncGF0aCBub3QgbG9hZGVkJyk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB1c2VkIGZvciBlbnN1cmluZyB0aGF0IGEgcGFyZW50IGlzIGN1cnJlbnRseSBsb2FkZWQuXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuX2Fzc2VydFBhcmVudExvYWRlZCA9IGZ1bmN0aW9uIF9hc3NlcnRQYXJlbnRMb2FkZWQoKSB7XG4gICAgaWYgKCF0aGlzLl9wYXJlbnQpIHRocm93IG5ldyBFcnJvcigncGFyZW50IG5vdCBsb2FkZWQnKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHVzZWQgZm9yIGVuc3VyaW5nIHRoYXQgY2hpbGRyZW4gYXJlIGN1cnJlbnRseVxuICogbG9hZGVkLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLl9hc3NlcnRDaGlsZHJlbkxvYWRlZCA9IGZ1bmN0aW9uIF9hc3NlcnRDaGlsZHJlbkxvYWRlZCgpIHtcbiAgICBpZiAoIXRoaXMuX2NoaWxkcmVuKSB0aHJvdyBuZXcgRXJyb3IoJ2NoaWxkcmVuIG5vdCBsb2FkZWQnKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHVzZWQgZm9yIGVuc3VyaW5nIHRoYXQgYSB0YXJnZXQgaXMgY3VycmVudGx5IGxvYWRlZC5cbiAqXG4gKiBAbWV0aG9kICBfYXNzZXJ0VGFyZ2V0TG9hZGVkXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLl9hc3NlcnRUYXJnZXRMb2FkZWQgPSBmdW5jdGlvbiBfYXNzZXJ0VGFyZ2V0TG9hZGVkKCkge1xuICAgIGlmICghdGhpcy5fdGFyZ2V0KSB0aHJvdyBuZXcgRXJyb3IoJ05vIHRhcmdldCBsb2FkZWQnKTtcbn07XG5cbi8qKlxuICogRmluZHMgYW5kIHNldHMgdGhlIHBhcmVudCBvZiB0aGUgY3VycmVudGx5IGxvYWRlZCBlbGVtZW50IChwYXRoKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnRDYWNoZX0gUGFyZW50IGVsZW1lbnQuXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5maW5kUGFyZW50ID0gZnVuY3Rpb24gZmluZFBhcmVudCAoKSB7XG4gICAgdGhpcy5fYXNzZXJ0UGF0aExvYWRlZCgpO1xuXG4gICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhciBwYXJlbnQ7XG5cbiAgICB3aGlsZSAoIXBhcmVudCAmJiBwYXRoLmxlbmd0aCkge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgcGFyZW50ID0gdGhpcy5fZWxlbWVudHNbcGF0aF07XG4gICAgfVxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICByZXR1cm4gcGFyZW50O1xufTtcblxuLyoqXG4gKiBVc2VkIGZvciBkZXRlcm1pbmluZyB0aGUgdGFyZ2V0IGxvYWRlZCB1bmRlciB0aGUgY3VycmVudCBwYXRoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50Q2FjaGV8dW5kZWZpbmVkfSBFbGVtZW50IGxvYWRlZCB1bmRlciBkZWZpbmVkIHBhdGguXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5maW5kVGFyZ2V0ID0gZnVuY3Rpb24gZmluZFRhcmdldCgpIHtcbiAgICB0aGlzLl90YXJnZXQgPSB0aGlzLl9lbGVtZW50c1t0aGlzLl9wYXRoXTtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xufTtcblxuXG4vKipcbiAqIExvYWRzIHRoZSBwYXNzZWQgaW4gcGF0aC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggUGF0aCB0byBiZSBsb2FkZWRcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IExvYWRlZCBwYXRoXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5sb2FkUGF0aCA9IGZ1bmN0aW9uIGxvYWRQYXRoIChwYXRoKSB7XG4gICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHRoaXMuX3BhdGg7XG59O1xuXG4vKipcbiAqIEZpbmRzIGNoaWxkcmVuIG9mIGEgcGFyZW50IGVsZW1lbnQgdGhhdCBhcmUgZGVzY2VuZGVudHMgb2YgYSBpbnNlcnRlZCBlbGVtZW50IGluIHRoZSBzY2VuZVxuICogZ3JhcGguIEFwcGVuZHMgdGhvc2UgY2hpbGRyZW4gdG8gdGhlIGluc2VydGVkIGVsZW1lbnQuXG4gKlxuICogQG1ldGhvZCByZXNvbHZlQ2hpbGRyZW5cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCB0aGUgaW5zZXJ0ZWQgZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IHRoZSBwYXJlbnQgb2YgdGhlIGluc2VydGVkIGVsZW1lbnRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLnJlc29sdmVDaGlsZHJlbiA9IGZ1bmN0aW9uIHJlc29sdmVDaGlsZHJlbiAoZWxlbWVudCwgcGFyZW50KSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBjaGlsZE5vZGU7XG4gICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhciBjaGlsZFBhdGg7XG5cbiAgICB3aGlsZSAoKGNoaWxkTm9kZSA9IHBhcmVudC5jaGlsZE5vZGVzW2ldKSkge1xuICAgICAgICBpZiAoIWNoaWxkTm9kZS5kYXRhc2V0KSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZFBhdGggPSBjaGlsZE5vZGUuZGF0YXNldC5mYVBhdGg7XG4gICAgICAgIGlmICghY2hpbGRQYXRoKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoUGF0aFV0aWxzLmlzRGVzY2VuZGVudE9mKGNoaWxkUGF0aCwgcGF0aCkpIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcbiAgICAgICAgZWxzZSBpKys7XG4gICAgfVxufTtcblxuLyoqXG4gKiBJbnNlcnRzIGEgRE9NRWxlbWVudCBhdCB0aGUgY3VycmVudGx5IGxvYWRlZCBwYXRoLCBhc3N1bWluZyBubyB0YXJnZXQgaXNcbiAqIGxvYWRlZC4gT25seSBvbmUgRE9NRWxlbWVudCBjYW4gYmUgYXNzb2NpYXRlZCB3aXRoIGVhY2ggcGF0aC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWUgVGFnIG5hbWUgKGNhcGl0YWxpemF0aW9uIHdpbGwgYmUgbm9ybWFsaXplZCkuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLmluc2VydEVsID0gZnVuY3Rpb24gaW5zZXJ0RWwgKHRhZ05hbWUpIHtcbiAgICBpZiAoIXRoaXMuX3RhcmdldCB8fFxuICAgICAgICB0aGlzLl90YXJnZXQuZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IHRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xuXG4gICAgICAgIHRoaXMuZmluZFBhcmVudCgpO1xuXG4gICAgICAgIHRoaXMuX2Fzc2VydFBhcmVudExvYWRlZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQudm9pZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQucGF0aCArICcgaXMgYSB2b2lkIGVsZW1lbnQuICcgK1xuICAgICAgICAgICAgICAgICdWb2lkIGVsZW1lbnRzIGFyZSBub3QgYWxsb3dlZCB0byBoYXZlIGNoaWxkcmVuLidcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldCkgdGhpcy5fcGFyZW50LmVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5fdGFyZ2V0LmVsZW1lbnQpO1xuXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IG5ldyBFbGVtZW50Q2FjaGUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKSwgdGhpcy5fcGF0aCk7XG5cbiAgICAgICAgdmFyIGVsID0gdGhpcy5fdGFyZ2V0LmVsZW1lbnQ7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQuZWxlbWVudDtcblxuICAgICAgICB0aGlzLnJlc29sdmVDaGlsZHJlbihlbCwgcGFyZW50KTtcblxuICAgICAgICB0aGlzLl9wYXJlbnQuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl90YXJnZXQuZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzW3RoaXMuX3BhdGhdID0gdGhpcy5fdGFyZ2V0O1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBTZXRzIGEgcHJvcGVydHkgb24gdGhlIGN1cnJlbnRseSBsb2FkZWQgdGFyZ2V0LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIChlLmcuIGJhY2tncm91bmQsIGNvbG9yLCBmb250KVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFByb3BydHkgdmFsdWUgKGUuZy4gYmxhY2ssIDIwcHgpXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJvcGVydHkgKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50bHkgbG9hZGVkIHRhcmdldC5cbiAqIFJlbW92ZXMgYW55IGV4cGxpY2l0IHNpemluZyBjb25zdHJhaW50cyB3aGVuIHBhc3NlZCBpbiBgZmFsc2VgXG4gKiAoXCJ0cnVlLXNpemluZ1wiKS5cbiAqIFxuICogSW52b2tpbmcgc2V0U2l6ZSBpcyBlcXVpdmFsZW50IHRvIGEgbWFudWFsIGludm9jYXRpb24gb2YgYHNldFdpZHRoYCBmb2xsb3dlZFxuICogYnkgYHNldEhlaWdodGAuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfGZhbHNlfSB3aWR0aCAgIFdpZHRoIHRvIGJlIHNldC5cbiAqIEBwYXJhbSB7TnVtYmVyfGZhbHNlfSBoZWlnaHQgIEhlaWdodCB0byBiZSBzZXQuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiBzZXRTaXplICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG5cbiAgICB0aGlzLnNldFdpZHRoKHdpZHRoKTtcbiAgICB0aGlzLnNldEhlaWdodChoZWlnaHQpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB3aWR0aCBvZiB0aGUgY3VycmVudGx5IGxvYWRlZCBFbGVtZW50Q2FjaGUuXG4gKiBcbiAqIEBtZXRob2RcbiAqICBcbiAqIEBwYXJhbSAge051bWJlcnxmYWxzZX0gd2lkdGggICAgIFRoZSBleHBsaWNpdCB3aWR0aCB0byBiZSBzZXQgb24gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbGVtZW50Q2FjaGUncyB0YXJnZXQgKGFuZCBjb250ZW50KSBlbGVtZW50LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGZhbHNlYCByZW1vdmVzIGFueSBleHBsaWNpdCBzaXppbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzIGZyb20gdGhlIHVuZGVybHlpbmcgRE9NXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbGVtZW50cy5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovIFxuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gc2V0V2lkdGgod2lkdGgpIHtcbiAgICB0aGlzLl9hc3NlcnRUYXJnZXRMb2FkZWQoKTtcblxuICAgIHZhciBjb250ZW50V3JhcHBlciA9IHRoaXMuX3RhcmdldC5jb250ZW50O1xuXG4gICAgaWYgKHdpZHRoID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl90YXJnZXQuZXhwbGljaXRXaWR0aCA9IHRydWU7XG4gICAgICAgIGlmIChjb250ZW50V3JhcHBlcikgY29udGVudFdyYXBwZXIuc3R5bGUud2lkdGggPSAnJztcbiAgICAgICAgd2lkdGggPSBjb250ZW50V3JhcHBlciA/IGNvbnRlbnRXcmFwcGVyLm9mZnNldFdpZHRoIDogMDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl90YXJnZXQuZXhwbGljaXRXaWR0aCA9IGZhbHNlO1xuICAgICAgICBpZiAoY29udGVudFdyYXBwZXIpIGNvbnRlbnRXcmFwcGVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICB9XG5cbiAgICB0aGlzLl90YXJnZXQuc2l6ZVswXSA9IHdpZHRoO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGN1cnJlbnRseSBsb2FkZWQgRWxlbWVudENhY2hlLlxuICogXG4gKiBAbWV0aG9kICBzZXRIZWlnaHRcbiAqICBcbiAqIEBwYXJhbSAge051bWJlcnxmYWxzZX0gaGVpZ2h0ICAgIFRoZSBleHBsaWNpdCBoZWlnaHQgdG8gYmUgc2V0IG9uIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRWxlbWVudENhY2hlJ3MgdGFyZ2V0IChhbmQgY29udGVudCkgZWxlbWVudC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBmYWxzZWAgcmVtb3ZlcyBhbnkgZXhwbGljaXQgc2l6aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50cyBmcm9tIHRoZSB1bmRlcmx5aW5nIERPTVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRWxlbWVudHMuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqLyBcbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG5cbiAgICB2YXIgY29udGVudFdyYXBwZXIgPSB0aGlzLl90YXJnZXQuY29udGVudDtcblxuICAgIGlmIChoZWlnaHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5leHBsaWNpdEhlaWdodCA9IHRydWU7XG4gICAgICAgIGlmIChjb250ZW50V3JhcHBlcikgY29udGVudFdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgIGhlaWdodCA9IGNvbnRlbnRXcmFwcGVyID8gY29udGVudFdyYXBwZXIub2Zmc2V0SGVpZ2h0IDogMDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5leHBsaWNpdEhlaWdodCA9IGZhbHNlO1xuICAgICAgICBpZiAoY29udGVudFdyYXBwZXIpIGNvbnRlbnRXcmFwcGVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuXG4gICAgdGhpcy5fdGFyZ2V0LnNpemVbMV0gPSBoZWlnaHQ7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gYXR0cmlidXRlIG9uIHRoZSBjdXJyZW50bHkgbG9hZGVkIHRhcmdldC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgQXR0cmlidXRlIG5hbWUgKGUuZy4gaHJlZilcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUgKGUuZy4gaHR0cDovL2ZhbW91cy5vcmcpXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuX2Fzc2VydFRhcmdldExvYWRlZCgpO1xuICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGBpbm5lckhUTUxgIGNvbnRlbnQgb2YgdGhlIGN1cnJlbnRseSBsb2FkZWQgdGFyZ2V0LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGVudCBDb250ZW50IHRvIGJlIHNldCBhcyBgaW5uZXJIVE1MYFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gc2V0Q29udGVudChjb250ZW50KSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG5cbiAgICBpZiAodGhpcy5fdGFyZ2V0LmZvcm1FbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LnZhbHVlID0gY29udGVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5fdGFyZ2V0LmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQuY29udGVudC5jbGFzc0xpc3QuYWRkKCdmYW1vdXMtZG9tLWVsZW1lbnQtY29udGVudCcpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldC5jb250ZW50LFxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LmZpcnN0Q2hpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGFyZ2V0LmNvbnRlbnQuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICB9XG5cblxuICAgIHRoaXMuc2V0U2l6ZShcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmV4cGxpY2l0V2lkdGggPyBmYWxzZSA6IHRoaXMuX3RhcmdldC5zaXplWzBdLFxuICAgICAgICB0aGlzLl90YXJnZXQuZXhwbGljaXRIZWlnaHQgPyBmYWxzZSA6IHRoaXMuX3RhcmdldC5zaXplWzFdXG4gICAgKTtcbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBwYXNzZWQgaW4gdHJhbnNmb3JtIG1hdHJpeCAod29ybGQgc3BhY2UpLiBJbnZlcnRzIHRoZSBwYXJlbnQncyB3b3JsZFxuICogdHJhbnNmb3JtLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdHJhbnNmb3JtIFRoZSB0cmFuc2Zvcm0gZm9yIHRoZSBsb2FkZWQgRE9NIEVsZW1lbnQgaW4gd29ybGQgc3BhY2VcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuc2V0TWF0cml4ID0gZnVuY3Rpb24gc2V0TWF0cml4ICh0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLl9hc3NlcnRUYXJnZXRMb2FkZWQoKTtcbiAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5zdHlsZVtUUkFOU0ZPUk1dID0gdGhpcy5fc3RyaW5naWZ5TWF0cml4KHRyYW5zZm9ybSk7XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIGNsYXNzIHRvIHRoZSBjbGFzc0xpc3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50bHkgbG9hZGVkIHRhcmdldC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRvbUNsYXNzIENsYXNzIG5hbWUgdG8gYmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgdGFyZ2V0LlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKGRvbUNsYXNzKSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuY2xhc3NMaXN0LmFkZChkb21DbGFzcyk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGNsYXNzTGlzdCBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnRseSBsb2FkZWRcbiAqIHRhcmdldC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRvbUNsYXNzIENsYXNzIG5hbWUgdG8gYmUgcmVtb3ZlZCBmcm9tIGN1cnJlbnRseSBsb2FkZWQgdGFyZ2V0LlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGRvbUNsYXNzKSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShkb21DbGFzcyk7XG59O1xuXG5cbi8qKlxuICogU3RyaW5naWZpZXMgdGhlIHBhc3NlZCBpbiBtYXRyaXggZm9yIHNldHRpbmcgdGhlIGB0cmFuc2Zvcm1gIHByb3BlcnR5LlxuICpcbiAqIEBtZXRob2QgIF9zdHJpbmdpZnlNYXRyaXhcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbSAgICBNYXRyaXggYXMgYW4gYXJyYXkgb3IgYXJyYXktbGlrZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBTdHJpbmdpZmllZCBtYXRyaXggYXMgYG1hdHJpeDNkYC1wcm9wZXJ0eS5cbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLl9zdHJpbmdpZnlNYXRyaXggPSBmdW5jdGlvbiBfc3RyaW5naWZ5TWF0cml4KG0pIHtcbiAgICB2YXIgciA9ICdtYXRyaXgzZCgnO1xuICAgIFxuICAgIHIgKz0gKG1bMF0gPCAwLjAwMDAwMSAmJiBtWzBdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzBdICsgJywnO1xuICAgIHIgKz0gKG1bMV0gPCAwLjAwMDAwMSAmJiBtWzFdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzFdICsgJywnO1xuICAgIHIgKz0gKG1bMl0gPCAwLjAwMDAwMSAmJiBtWzJdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzJdICsgJywnO1xuICAgIHIgKz0gKG1bM10gPCAwLjAwMDAwMSAmJiBtWzNdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzNdICsgJywnO1xuICAgIHIgKz0gKG1bNF0gPCAwLjAwMDAwMSAmJiBtWzRdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzRdICsgJywnO1xuICAgIHIgKz0gKG1bNV0gPCAwLjAwMDAwMSAmJiBtWzVdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzVdICsgJywnO1xuICAgIHIgKz0gKG1bNl0gPCAwLjAwMDAwMSAmJiBtWzZdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzZdICsgJywnO1xuICAgIHIgKz0gKG1bN10gPCAwLjAwMDAwMSAmJiBtWzddID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzddICsgJywnO1xuICAgIHIgKz0gKG1bOF0gPCAwLjAwMDAwMSAmJiBtWzhdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzhdICsgJywnO1xuICAgIHIgKz0gKG1bOV0gPCAwLjAwMDAwMSAmJiBtWzldID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzldICsgJywnO1xuICAgIHIgKz0gKG1bMTBdIDwgMC4wMDAwMDEgJiYgbVsxMF0gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bMTBdICsgJywnO1xuICAgIHIgKz0gKG1bMTFdIDwgMC4wMDAwMDEgJiYgbVsxMV0gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bMTFdICsgJywnO1xuICAgIHIgKz0gKG1bMTJdIDwgMC4wMDAwMDEgJiYgbVsxMl0gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bMTJdICsgJywnO1xuICAgIHIgKz0gKG1bMTNdIDwgMC4wMDAwMDEgJiYgbVsxM10gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bMTNdICsgJywnO1xuICAgIHIgKz0gKG1bMTRdIDwgMC4wMDAwMDEgJiYgbVsxNF0gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bMTRdICsgJywnO1xuICAgIFxuICAgIHIgKz0gbVsxNV0gKyAnKSc7XG4gICAgcmV0dXJuIHI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVJlbmRlcmVyO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVm9pZEVsZW1lbnRzID0gcmVxdWlyZSgnLi9Wb2lkRWxlbWVudHMnKTtcblxuLyoqXG4gKiBFbGVtZW50Q2FjaGUgaXMgYmVpbmcgdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiBhbiBlbGVtZW50J3MgRE9NIEVsZW1lbnQsXG4gKiBwYXRoLCB3b3JsZCB0cmFuc2Zvcm0sIGludmVydGVkIHBhcmVudCwgZmluYWwgdHJhbnNmb3JtIChhcyBiZWluZyB1c2VkIGZvclxuICogc2V0dGluZyB0aGUgYWN0dWFsIGB0cmFuc2Zvcm1gLXByb3BlcnR5KSBhbmQgcG9zdCByZW5kZXIgc2l6ZSAoZmluYWwgc2l6ZSBhc1xuICogYmVpbmcgcmVuZGVyZWQgdG8gdGhlIERPTSkuXG4gKlxuICogQGNsYXNzIEVsZW1lbnRDYWNoZVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBET01FbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBQYXRoIHVzZWQgZm9yIHVuaXF1ZWx5IGlkZW50aWZ5aW5nIHRoZSBsb2NhdGlvbiBpbiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgIHNjZW5lIGdyYXBoLlxuICovXG5mdW5jdGlvbiBFbGVtZW50Q2FjaGUgKGVsZW1lbnQsIHBhdGgpIHtcbiAgICB0aGlzLnRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnZvaWQgPSBWb2lkRWxlbWVudHNbdGhpcy50YWdOYW1lXTtcblxuICAgIHZhciBjb25zdHJ1Y3RvciA9IGVsZW1lbnQuY29uc3RydWN0b3I7XG5cbiAgICB0aGlzLmZvcm1FbGVtZW50ID0gY29uc3RydWN0b3IgPT09IEhUTUxJbnB1dEVsZW1lbnQgfHxcbiAgICAgICAgY29uc3RydWN0b3IgPT09IEhUTUxUZXh0QXJlYUVsZW1lbnQgfHxcbiAgICAgICAgY29uc3RydWN0b3IgPT09IEhUTUxTZWxlY3RFbGVtZW50O1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgdGhpcy5zaXplID0gbmV3IEludDE2QXJyYXkoMyk7XG4gICAgdGhpcy5leHBsaWNpdEhlaWdodCA9IGZhbHNlO1xuICAgIHRoaXMuZXhwbGljaXRXaWR0aCA9IGZhbHNlO1xuICAgIHRoaXMucG9zdFJlbmRlclNpemUgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdCA9IHt9O1xuICAgIHRoaXMuc3Vic2NyaWJlID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudENhY2hlO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgbWV0aG9kIGZvciBpbnZlcnRpbmcgYSB0cmFuc2Zvcm0gbWF0cml4XG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCBhcnJheSB0byBzdG9yZSB0aGUgcmV0dXJuIG9mIHRoZSBpbnZlcnNpb25cbiAqIEBwYXJhbSB7QXJyYXl9IGEgdHJhbnNmb3JtIG1hdHJpeCB0byBpbnZlcnNlXG4gKlxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICogICBvdXRwdXQgYXJyYXkgdGhhdCBpcyBzdG9yaW5nIHRoZSB0cmFuc2Zvcm0gbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGludmVydCAob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQSBtZXRob2QgZm9yIG11bHRpcGx5aW5nIHR3byBtYXRyaWNpZXNcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gb3V0IGFycmF5IHRvIHN0b3JlIHRoZSByZXR1cm4gb2YgdGhlIG11bHRpcGxpY2F0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRyYW5zZm9ybSBtYXRyaXggdG8gbXVsdGlwbHlcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdHJhbnNmb3JtIG1hdHJpeCB0byBtdWx0aXBseVxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqICAgb3V0cHV0IGFycmF5IHRoYXQgaXMgc3RvcmluZyB0aGUgdHJhbnNmb3JtIG1hdHJpeFxuICovXG5mdW5jdGlvbiBtdWx0aXBseSAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLFxuICAgICAgICBiNCA9IGJbNF0sIGI1ID0gYls1XSwgYjYgPSBiWzZdLCBiNyA9IGJbN10sXG4gICAgICAgIGI4ID0gYls4XSwgYjkgPSBiWzldLCBiMTAgPSBiWzEwXSwgYjExID0gYlsxMV0sXG4gICAgICAgIGIxMiA9IGJbMTJdLCBiMTMgPSBiWzEzXSwgYjE0ID0gYlsxNF0sIGIxNSA9IGJbMTVdO1xuXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgb3V0MCwgb3V0MSwgb3V0Miwgb3V0MztcblxuICAgIG91dDAgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0MSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXQyID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dDMgPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/XG4gICAgICAgICAgICAgIGNoYW5nZWQgOiBvdXQwID09PSBvdXRbMF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDEgPT09IG91dFsxXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MiA9PT0gb3V0WzJdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQzID09PSBvdXRbM107XG5cbiAgICBvdXRbMF0gPSBvdXQwO1xuICAgIG91dFsxXSA9IG91dDE7XG4gICAgb3V0WzJdID0gb3V0MjtcbiAgICBvdXRbM10gPSBvdXQzO1xuXG4gICAgYjAgPSBiNDsgYjEgPSBiNTsgYjIgPSBiNjsgYjMgPSBiNztcbiAgICBvdXQwID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dDEgPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0MiA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXQzID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgP1xuICAgICAgICAgICAgICBjaGFuZ2VkIDogb3V0MCA9PT0gb3V0WzRdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQxID09PSBvdXRbNV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDIgPT09IG91dFs2XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MyA9PT0gb3V0WzddO1xuXG4gICAgb3V0WzRdID0gb3V0MDtcbiAgICBvdXRbNV0gPSBvdXQxO1xuICAgIG91dFs2XSA9IG91dDI7XG4gICAgb3V0WzddID0gb3V0MztcblxuICAgIGIwID0gYjg7IGIxID0gYjk7IGIyID0gYjEwOyBiMyA9IGIxMTtcbiAgICBvdXQwID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dDEgPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0MiA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXQzID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgP1xuICAgICAgICAgICAgICBjaGFuZ2VkIDogb3V0MCA9PT0gb3V0WzhdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQxID09PSBvdXRbOV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDIgPT09IG91dFsxMF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDMgPT09IG91dFsxMV07XG5cbiAgICBvdXRbOF0gPSBvdXQwO1xuICAgIG91dFs5XSA9IG91dDE7XG4gICAgb3V0WzEwXSA9IG91dDI7XG4gICAgb3V0WzExXSA9IG91dDM7XG5cbiAgICBiMCA9IGIxMjsgYjEgPSBiMTM7IGIyID0gYjE0OyBiMyA9IGIxNTtcbiAgICBvdXQwID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dDEgPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0MiA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXQzID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgP1xuICAgICAgICAgICAgICBjaGFuZ2VkIDogb3V0MCA9PT0gb3V0WzEyXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MSA9PT0gb3V0WzEzXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MiA9PT0gb3V0WzE0XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MyA9PT0gb3V0WzE1XTtcblxuICAgIG91dFsxMl0gPSBvdXQwO1xuICAgIG91dFsxM10gPSBvdXQxO1xuICAgIG91dFsxNF0gPSBvdXQyO1xuICAgIG91dFsxNV0gPSBvdXQzO1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbXVsdGlwbHk6IG11bHRpcGx5LFxuICAgIGludmVydDogaW52ZXJ0XG59O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1hcCBvZiB2b2lkIGVsZW1lbnRzIGFzIGRlZmluZWQgYnkgdGhlXG4gKiBbSFRNTDUgc3BlY10oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudHMtMCkuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIFZvaWRFbGVtZW50cyA9IHtcbiAgICBhcmVhICA6IHRydWUsXG4gICAgYmFzZSAgOiB0cnVlLFxuICAgIGJyICAgIDogdHJ1ZSxcbiAgICBjb2wgICA6IHRydWUsXG4gICAgZW1iZWQgOiB0cnVlLFxuICAgIGhyICAgIDogdHJ1ZSxcbiAgICBpbWcgICA6IHRydWUsXG4gICAgaW5wdXQgOiB0cnVlLFxuICAgIGtleWdlbjogdHJ1ZSxcbiAgICBsaW5rICA6IHRydWUsXG4gICAgbWV0YSAgOiB0cnVlLFxuICAgIHBhcmFtIDogdHJ1ZSxcbiAgICBzb3VyY2U6IHRydWUsXG4gICAgdHJhY2sgOiB0cnVlLFxuICAgIHdiciAgIDogdHJ1ZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWb2lkRWxlbWVudHM7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVSUV2ZW50ID0gcmVxdWlyZSgnLi9VSUV2ZW50Jyk7XG5cbi8qKlxuICogU2VlIFtVSSBFdmVudHMgKGZvcm1lcmx5IERPTSBMZXZlbCAzIEV2ZW50cyldKGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTUvV0QtdWlldmVudHMtMjAxNTA0MjgvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50cykuXG4gKlxuICogQGNsYXNzIENvbXBvc2l0aW9uRXZlbnRcbiAqIEBhdWdtZW50cyBVSUV2ZW50XG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXYgVGhlIG5hdGl2ZSBET00gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIENvbXBvc2l0aW9uRXZlbnQoZXYpIHtcbiAgICAvLyBbQ29uc3RydWN0b3IoRE9NU3RyaW5nIHR5cGVBcmcsIG9wdGlvbmFsIENvbXBvc2l0aW9uRXZlbnRJbml0IGNvbXBvc2l0aW9uRXZlbnRJbml0RGljdCldXG4gICAgLy8gaW50ZXJmYWNlIENvbXBvc2l0aW9uRXZlbnQgOiBVSUV2ZW50IHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIERPTVN0cmluZyBkYXRhO1xuICAgIC8vIH07XG5cbiAgICBVSUV2ZW50LmNhbGwodGhpcywgZXYpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgQ29tcG9zaXRpb25FdmVudCNkYXRhXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gZXYuZGF0YTtcbn1cblxuQ29tcG9zaXRpb25FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFVJRXZlbnQucHJvdG90eXBlKTtcbkNvbXBvc2l0aW9uRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tcG9zaXRpb25FdmVudDtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBOYW1lIG9mIHRoZSBldmVudCB0eXBlXG4gKi9cbkNvbXBvc2l0aW9uRXZlbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnQ29tcG9zaXRpb25FdmVudCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2l0aW9uRXZlbnQ7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIEV2ZW50IGNsYXNzIGlzIGJlaW5nIHVzZWQgaW4gb3JkZXIgdG8gbm9ybWFsaXplIG5hdGl2ZSBET00gZXZlbnRzLlxuICogRXZlbnRzIG5lZWQgdG8gYmUgbm9ybWFsaXplZCBpbiBvcmRlciB0byBiZSBzZXJpYWxpemVkIHRocm91Z2ggdGhlIHN0cnVjdHVyZWRcbiAqIGNsb25pbmcgYWxnb3JpdGhtIHVzZWQgYnkgdGhlIGBwb3N0TWVzc2FnZWAgbWV0aG9kIChXZWIgV29ya2VycykuXG4gKlxuICogV3JhcHBpbmcgRE9NIGV2ZW50cyBhbHNvIGhhcyB0aGUgYWR2YW50YWdlIG9mIHByb3ZpZGluZyBhIGNvbnNpc3RlbnRcbiAqIGludGVyZmFjZSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBET00gZXZlbnRzIGFjcm9zcyBicm93c2VycyBieSBjb3B5aW5nIG92ZXIgYVxuICogc3Vic2V0IG9mIHRoZSBleHBvc2VkIHByb3BlcnRpZXMgdGhhdCBpcyBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnQgYWNyb3NzXG4gKiBicm93c2Vycy5cbiAqXG4gKiBTZWUgW1VJIEV2ZW50cyAoZm9ybWVybHkgRE9NIExldmVsIDMgRXZlbnRzKV0oaHR0cDovL3d3dy53My5vcmcvVFIvMjAxNS9XRC11aWV2ZW50cy0yMDE1MDQyOC8jaW50ZXJmYWNlLUV2ZW50KS5cbiAqXG4gKiBAY2xhc3MgRXZlbnRcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldiBUaGUgbmF0aXZlIERPTSBldmVudC5cbiAqL1xuZnVuY3Rpb24gRXZlbnQoZXYpIHtcbiAgICAvLyBbQ29uc3RydWN0b3IoRE9NU3RyaW5nIHR5cGUsIG9wdGlvbmFsIEV2ZW50SW5pdCBldmVudEluaXREaWN0KSxcbiAgICAvLyAgRXhwb3NlZD1XaW5kb3csV29ya2VyXVxuICAgIC8vIGludGVyZmFjZSBFdmVudCB7XG4gICAgLy8gICByZWFkb25seSBhdHRyaWJ1dGUgRE9NU3RyaW5nIHR5cGU7XG4gICAgLy8gICByZWFkb25seSBhdHRyaWJ1dGUgRXZlbnRUYXJnZXQ/IHRhcmdldDtcbiAgICAvLyAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBFdmVudFRhcmdldD8gY3VycmVudFRhcmdldDtcblxuICAgIC8vICAgY29uc3QgdW5zaWduZWQgc2hvcnQgTk9ORSA9IDA7XG4gICAgLy8gICBjb25zdCB1bnNpZ25lZCBzaG9ydCBDQVBUVVJJTkdfUEhBU0UgPSAxO1xuICAgIC8vICAgY29uc3QgdW5zaWduZWQgc2hvcnQgQVRfVEFSR0VUID0gMjtcbiAgICAvLyAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IEJVQkJMSU5HX1BIQVNFID0gMztcbiAgICAvLyAgIHJlYWRvbmx5IGF0dHJpYnV0ZSB1bnNpZ25lZCBzaG9ydCBldmVudFBoYXNlO1xuXG4gICAgLy8gICB2b2lkIHN0b3BQcm9wYWdhdGlvbigpO1xuICAgIC8vICAgdm9pZCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuICAgIC8vICAgcmVhZG9ubHkgYXR0cmlidXRlIGJvb2xlYW4gYnViYmxlcztcbiAgICAvLyAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBib29sZWFuIGNhbmNlbGFibGU7XG4gICAgLy8gICB2b2lkIHByZXZlbnREZWZhdWx0KCk7XG4gICAgLy8gICByZWFkb25seSBhdHRyaWJ1dGUgYm9vbGVhbiBkZWZhdWx0UHJldmVudGVkO1xuXG4gICAgLy8gICBbVW5mb3JnZWFibGVdIHJlYWRvbmx5IGF0dHJpYnV0ZSBib29sZWFuIGlzVHJ1c3RlZDtcbiAgICAvLyAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBET01UaW1lU3RhbXAgdGltZVN0YW1wO1xuXG4gICAgLy8gICB2b2lkIGluaXRFdmVudChET01TdHJpbmcgdHlwZSwgYm9vbGVhbiBidWJibGVzLCBib29sZWFuIGNhbmNlbGFibGUpO1xuICAgIC8vIH07XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBFdmVudCN0eXBlXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gZXYudHlwZTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIEV2ZW50I2RlZmF1bHRQcmV2ZW50ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gZXYuZGVmYXVsdFByZXZlbnRlZDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIEV2ZW50I3RpbWVTdGFtcFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMudGltZVN0YW1wID0gZXYudGltZVN0YW1wO1xuXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBleHBvc2luZyB0aGUgY3VycmVudCB0YXJnZXQncyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIEV2ZW50I3ZhbHVlXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgdmFyIHRhcmdldENvbnN0cnVjdG9yID0gZXYudGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAgIC8vIFRPRE8gU3VwcG9ydCBIVE1MS2V5Z2VuRWxlbWVudFxuICAgIGlmIChcbiAgICAgICAgdGFyZ2V0Q29uc3RydWN0b3IgPT09IEhUTUxJbnB1dEVsZW1lbnQgfHxcbiAgICAgICAgdGFyZ2V0Q29uc3RydWN0b3IgPT09IEhUTUxUZXh0QXJlYUVsZW1lbnQgfHxcbiAgICAgICAgdGFyZ2V0Q29uc3RydWN0b3IgPT09IEhUTUxTZWxlY3RFbGVtZW50XG4gICAgKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBldi50YXJnZXQudmFsdWU7XG4gICAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdHlwZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqL1xuRXZlbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnRXZlbnQnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbXBvc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL0NvbXBvc2l0aW9uRXZlbnQnKTtcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4vRXZlbnQnKTtcbnZhciBGb2N1c0V2ZW50ID0gcmVxdWlyZSgnLi9Gb2N1c0V2ZW50Jyk7XG52YXIgSW5wdXRFdmVudCA9IHJlcXVpcmUoJy4vSW5wdXRFdmVudCcpO1xudmFyIEtleWJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL0tleWJvYXJkRXZlbnQnKTtcbnZhciBNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9Nb3VzZUV2ZW50Jyk7XG52YXIgVG91Y2hFdmVudCA9IHJlcXVpcmUoJy4vVG91Y2hFdmVudCcpO1xudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcbnZhciBXaGVlbEV2ZW50ID0gcmVxdWlyZSgnLi9XaGVlbEV2ZW50Jyk7XG5cbi8qKlxuICogQSBtYXBwaW5nIG9mIERPTSBldmVudHMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgaGFuZGxlcnNcbiAqXG4gKiBAbmFtZSBFdmVudE1hcFxuICogQHR5cGUgT2JqZWN0XG4gKi9cbnZhciBFdmVudE1hcCA9IHtcbiAgICBjaGFuZ2UgICAgICAgICAgICAgICAgICAgICAgICAgOiBbRXZlbnQsIHRydWVdLFxuICAgIHN1Ym1pdCAgICAgICAgICAgICAgICAgICAgICAgICA6IFtFdmVudCwgdHJ1ZV0sXG5cbiAgICAvLyBVSSBFdmVudHMgKGh0dHA6Ly93d3cudzMub3JnL1RSL3VpZXZlbnRzLylcbiAgICBhYm9ydCAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbRXZlbnQsIGZhbHNlXSxcbiAgICBiZWZvcmVpbnB1dCAgICAgICAgICAgICAgICAgICAgOiBbSW5wdXRFdmVudCwgdHJ1ZV0sXG4gICAgYmx1ciAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW0ZvY3VzRXZlbnQsIGZhbHNlXSxcbiAgICBjbGljayAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbTW91c2VFdmVudCwgdHJ1ZV0sXG4gICAgY29tcG9zaXRpb25lbmQgICAgICAgICAgICAgICAgIDogW0NvbXBvc2l0aW9uRXZlbnQsIHRydWVdLFxuICAgIGNvbXBvc2l0aW9uc3RhcnQgICAgICAgICAgICAgICA6IFtDb21wb3NpdGlvbkV2ZW50LCB0cnVlXSxcbiAgICBjb21wb3NpdGlvbnVwZGF0ZSAgICAgICAgICAgICAgOiBbQ29tcG9zaXRpb25FdmVudCwgdHJ1ZV0sXG4gICAgZGJsY2xpY2sgICAgICAgICAgICAgICAgICAgICAgIDogW01vdXNlRXZlbnQsIHRydWVdLFxuICAgIGZvY3VzICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtGb2N1c0V2ZW50LCBmYWxzZV0sXG4gICAgZm9jdXNpbiAgICAgICAgICAgICAgICAgICAgICAgIDogW0ZvY3VzRXZlbnQsIHRydWVdLFxuICAgIGZvY3Vzb3V0ICAgICAgICAgICAgICAgICAgICAgICA6IFtGb2N1c0V2ZW50LCB0cnVlXSxcbiAgICBpbnB1dCAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbSW5wdXRFdmVudCwgdHJ1ZV0sXG4gICAga2V5ZG93biAgICAgICAgICAgICAgICAgICAgICAgIDogW0tleWJvYXJkRXZlbnQsIHRydWVdLFxuICAgIGtleXVwICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtLZXlib2FyZEV2ZW50LCB0cnVlXSxcbiAgICBsb2FkICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbRXZlbnQsIGZhbHNlXSxcbiAgICBtb3VzZWRvd24gICAgICAgICAgICAgICAgICAgICAgOiBbTW91c2VFdmVudCwgdHJ1ZV0sXG4gICAgbW91c2VlbnRlciAgICAgICAgICAgICAgICAgICAgIDogW01vdXNlRXZlbnQsIGZhbHNlXSxcbiAgICBtb3VzZWxlYXZlICAgICAgICAgICAgICAgICAgICAgOiBbTW91c2VFdmVudCwgZmFsc2VdLFxuXG4gICAgLy8gYnViYmxlcywgYnV0IHdpbGwgYmUgdHJpZ2dlcmVkIHZlcnkgZnJlcXVlbnRseVxuICAgIG1vdXNlbW92ZSAgICAgICAgICAgICAgICAgICAgICA6IFtNb3VzZUV2ZW50LCBmYWxzZV0sXG5cbiAgICBtb3VzZW91dCAgICAgICAgICAgICAgICAgICAgICAgOiBbTW91c2VFdmVudCwgdHJ1ZV0sXG4gICAgbW91c2VvdmVyICAgICAgICAgICAgICAgICAgICAgIDogW01vdXNlRXZlbnQsIHRydWVdLFxuICAgIG1vdXNldXAgICAgICAgICAgICAgICAgICAgICAgICA6IFtNb3VzZUV2ZW50LCB0cnVlXSxcbiAgICByZXNpemUgICAgICAgICAgICAgICAgICAgICAgICAgOiBbVUlFdmVudCwgZmFsc2VdLFxuXG4gICAgLy8gbWlnaHQgYnViYmxlXG4gICAgc2Nyb2xsICAgICAgICAgICAgICAgICAgICAgICAgIDogW1VJRXZlbnQsIGZhbHNlXSxcblxuICAgIHNlbGVjdCAgICAgICAgICAgICAgICAgICAgICAgICA6IFtFdmVudCwgdHJ1ZV0sXG4gICAgdW5sb2FkICAgICAgICAgICAgICAgICAgICAgICAgIDogW0V2ZW50LCBmYWxzZV0sXG4gICAgd2hlZWwgICAgICAgICAgICAgICAgICAgICAgICAgIDogW1doZWVsRXZlbnQsIHRydWVdLFxuXG4gICAgLy8gVG91Y2ggRXZlbnRzIEV4dGVuc2lvbiAoaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzLWV4dGVuc2lvbnMvKVxuICAgIHRvdWNoY2FuY2VsICAgICAgICAgICAgICAgICAgICA6IFtUb3VjaEV2ZW50LCB0cnVlXSxcbiAgICB0b3VjaGVuZCAgICAgICAgICAgICAgICAgICAgICAgOiBbVG91Y2hFdmVudCwgdHJ1ZV0sXG4gICAgdG91Y2htb3ZlICAgICAgICAgICAgICAgICAgICAgIDogW1RvdWNoRXZlbnQsIHRydWVdLFxuICAgIHRvdWNoc3RhcnQgICAgICAgICAgICAgICAgICAgICA6IFtUb3VjaEV2ZW50LCB0cnVlXVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudE1hcDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcblxuLyoqXG4gKiBTZWUgW1VJIEV2ZW50cyAoZm9ybWVybHkgRE9NIExldmVsIDMgRXZlbnRzKV0oaHR0cDovL3d3dy53My5vcmcvVFIvMjAxNS9XRC11aWV2ZW50cy0yMDE1MDQyOC8jZXZlbnRzLWZvY3VzZXZlbnQpLlxuICpcbiAqIEBjbGFzcyBGb2N1c0V2ZW50XG4gKiBAYXVnbWVudHMgVUlFdmVudFxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2IFRoZSBuYXRpdmUgRE9NIGV2ZW50LlxuICovXG5mdW5jdGlvbiBGb2N1c0V2ZW50KGV2KSB7XG4gICAgLy8gW0NvbnN0cnVjdG9yKERPTVN0cmluZyB0eXBlQXJnLCBvcHRpb25hbCBGb2N1c0V2ZW50SW5pdCBmb2N1c0V2ZW50SW5pdERpY3QpXVxuICAgIC8vIGludGVyZmFjZSBGb2N1c0V2ZW50IDogVUlFdmVudCB7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBFdmVudFRhcmdldD8gcmVsYXRlZFRhcmdldDtcbiAgICAvLyB9O1xuXG4gICAgVUlFdmVudC5jYWxsKHRoaXMsIGV2KTtcbn1cblxuRm9jdXNFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFVJRXZlbnQucHJvdG90eXBlKTtcbkZvY3VzRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRm9jdXNFdmVudDtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBOYW1lIG9mIHRoZSBldmVudCB0eXBlXG4gKi9cbkZvY3VzRXZlbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnRm9jdXNFdmVudCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvY3VzRXZlbnQ7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVSUV2ZW50ID0gcmVxdWlyZSgnLi9VSUV2ZW50Jyk7XG5cbi8qKlxuICogU2VlIFtJbnB1dCBFdmVudHNdKGh0dHA6Ly93M2MuZ2l0aHViLmlvL2VkaXRpbmctZXhwbGFpbmVyL2lucHV0LWV2ZW50cy5odG1sI2lkbC1kZWYtSW5wdXRFdmVudCkuXG4gKlxuICogQGNsYXNzIElucHV0RXZlbnRcbiAqIEBhdWdtZW50cyBVSUV2ZW50XG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXYgVGhlIG5hdGl2ZSBET00gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIElucHV0RXZlbnQoZXYpIHtcbiAgICAvLyBbQ29uc3RydWN0b3IoRE9NU3RyaW5nIHR5cGVBcmcsIG9wdGlvbmFsIElucHV0RXZlbnRJbml0IGlucHV0RXZlbnRJbml0RGljdCldXG4gICAgLy8gaW50ZXJmYWNlIElucHV0RXZlbnQgOiBVSUV2ZW50IHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIERPTVN0cmluZyBpbnB1dFR5cGU7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBET01TdHJpbmcgZGF0YTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICBpc0NvbXBvc2luZztcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIFJhbmdlICAgICB0YXJnZXRSYW5nZTtcbiAgICAvLyB9O1xuXG4gICAgVUlFdmVudC5jYWxsKHRoaXMsIGV2KTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lICAgIElucHV0RXZlbnQjaW5wdXRUeXBlXG4gICAgICogQHR5cGUgICAgU3RyaW5nXG4gICAgICovXG4gICAgdGhpcy5pbnB1dFR5cGUgPSBldi5pbnB1dFR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSAgICBJbnB1dEV2ZW50I2RhdGFcbiAgICAgKiBAdHlwZSAgICBTdHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSBldi5kYXRhO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgICAgSW5wdXRFdmVudCNpc0NvbXBvc2luZ1xuICAgICAqIEB0eXBlICAgIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmlzQ29tcG9zaW5nID0gZXYuaXNDb21wb3Npbmc7XG5cbiAgICAvKipcbiAgICAgKiAqKkxpbWl0ZWQgYnJvd3NlciBzdXBwb3J0KiouXG4gICAgICpcbiAgICAgKiBAbmFtZSAgICBJbnB1dEV2ZW50I3RhcmdldFJhbmdlXG4gICAgICogQHR5cGUgICAgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0UmFuZ2UgPSBldi50YXJnZXRSYW5nZTtcbn1cblxuSW5wdXRFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFVJRXZlbnQucHJvdG90eXBlKTtcbklucHV0RXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5wdXRFdmVudDtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBOYW1lIG9mIHRoZSBldmVudCB0eXBlXG4gKi9cbklucHV0RXZlbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnSW5wdXRFdmVudCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0RXZlbnQ7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVSUV2ZW50ID0gcmVxdWlyZSgnLi9VSUV2ZW50Jyk7XG5cbi8qKlxuICogU2VlIFtVSSBFdmVudHMgKGZvcm1lcmx5IERPTSBMZXZlbCAzIEV2ZW50cyldKGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTUvV0QtdWlldmVudHMtMjAxNTA0MjgvI2V2ZW50cy1rZXlib2FyZGV2ZW50cykuXG4gKlxuICogQGNsYXNzIEtleWJvYXJkRXZlbnRcbiAqIEBhdWdtZW50cyBVSUV2ZW50XG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXYgVGhlIG5hdGl2ZSBET00gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIEtleWJvYXJkRXZlbnQoZXYpIHtcbiAgICAvLyBbQ29uc3RydWN0b3IoRE9NU3RyaW5nIHR5cGVBcmcsIG9wdGlvbmFsIEtleWJvYXJkRXZlbnRJbml0IGtleWJvYXJkRXZlbnRJbml0RGljdCldXG4gICAgLy8gaW50ZXJmYWNlIEtleWJvYXJkRXZlbnQgOiBVSUV2ZW50IHtcbiAgICAvLyAgICAgLy8gS2V5TG9jYXRpb25Db2RlXG4gICAgLy8gICAgIGNvbnN0IHVuc2lnbmVkIGxvbmcgRE9NX0tFWV9MT0NBVElPTl9TVEFOREFSRCA9IDB4MDA7XG4gICAgLy8gICAgIGNvbnN0IHVuc2lnbmVkIGxvbmcgRE9NX0tFWV9MT0NBVElPTl9MRUZUID0gMHgwMTtcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fS0VZX0xPQ0FUSU9OX1JJR0hUID0gMHgwMjtcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fS0VZX0xPQ0FUSU9OX05VTVBBRCA9IDB4MDM7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBET01TdHJpbmcgICAgIGtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIERPTVN0cmluZyAgICAgY29kZTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIHVuc2lnbmVkIGxvbmcgbG9jYXRpb247XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgIGN0cmxLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgIHNoaWZ0S2V5O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgYm9vbGVhbiAgICAgICBhbHRLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgIG1ldGFLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgIHJlcGVhdDtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgaXNDb21wb3Npbmc7XG4gICAgLy8gICAgIGJvb2xlYW4gZ2V0TW9kaWZpZXJTdGF0ZSAoRE9NU3RyaW5nIGtleUFyZyk7XG4gICAgLy8gfTtcblxuICAgIFVJRXZlbnQuY2FsbCh0aGlzLCBldik7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBLZXlib2FyZEV2ZW50I0RPTV9LRVlfTE9DQVRJT05fU1RBTkRBUkRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLkRPTV9LRVlfTE9DQVRJT05fU1RBTkRBUkQgPSAweDAwO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgS2V5Ym9hcmRFdmVudCNET01fS0VZX0xPQ0FUSU9OX0xFRlRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLkRPTV9LRVlfTE9DQVRJT05fTEVGVCA9IDB4MDE7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBLZXlib2FyZEV2ZW50I0RPTV9LRVlfTE9DQVRJT05fUklHSFRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLkRPTV9LRVlfTE9DQVRJT05fUklHSFQgPSAweDAyO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgS2V5Ym9hcmRFdmVudCNET01fS0VZX0xPQ0FUSU9OX05VTVBBRFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuRE9NX0tFWV9MT0NBVElPTl9OVU1QQUQgPSAweDAzO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgS2V5Ym9hcmRFdmVudCNrZXlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLmtleSA9IGV2LmtleTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIEtleWJvYXJkRXZlbnQjY29kZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIHRoaXMuY29kZSA9IGV2LmNvZGU7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBLZXlib2FyZEV2ZW50I2xvY2F0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5sb2NhdGlvbiA9IGV2LmxvY2F0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgS2V5Ym9hcmRFdmVudCNjdHJsS2V5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuY3RybEtleSA9IGV2LmN0cmxLZXk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBLZXlib2FyZEV2ZW50I3NoaWZ0S2V5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuc2hpZnRLZXkgPSBldi5zaGlmdEtleTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIEtleWJvYXJkRXZlbnQjYWx0S2V5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuYWx0S2V5ID0gZXYuYWx0S2V5O1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgS2V5Ym9hcmRFdmVudCNtZXRhS2V5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMubWV0YUtleSA9IGV2Lm1ldGFLZXk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBLZXlib2FyZEV2ZW50I3JlcGVhdFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLnJlcGVhdCA9IGV2LnJlcGVhdDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIEtleWJvYXJkRXZlbnQjaXNDb21wb3NpbmdcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5pc0NvbXBvc2luZyA9IGV2LmlzQ29tcG9zaW5nO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgS2V5Ym9hcmRFdmVudCNrZXlDb2RlXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmtleUNvZGUgPSBldi5rZXlDb2RlO1xufVxuXG5LZXlib2FyZEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVUlFdmVudC5wcm90b3R5cGUpO1xuS2V5Ym9hcmRFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXlib2FyZEV2ZW50O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdHlwZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqL1xuS2V5Ym9hcmRFdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdLZXlib2FyZEV2ZW50Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5Ym9hcmRFdmVudDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcblxuLyoqXG4gKiBTZWUgW1VJIEV2ZW50cyAoZm9ybWVybHkgRE9NIExldmVsIDMgRXZlbnRzKV0oaHR0cDovL3d3dy53My5vcmcvVFIvMjAxNS9XRC11aWV2ZW50cy0yMDE1MDQyOC8jZXZlbnRzLW1vdXNlZXZlbnRzKS5cbiAqXG4gKiBAY2xhc3MgS2V5Ym9hcmRFdmVudFxuICogQGF1Z21lbnRzIFVJRXZlbnRcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldiBUaGUgbmF0aXZlIERPTSBldmVudC5cbiAqL1xuZnVuY3Rpb24gTW91c2VFdmVudChldikge1xuICAgIC8vIFtDb25zdHJ1Y3RvcihET01TdHJpbmcgdHlwZUFyZywgb3B0aW9uYWwgTW91c2VFdmVudEluaXQgbW91c2VFdmVudEluaXREaWN0KV1cbiAgICAvLyBpbnRlcmZhY2UgTW91c2VFdmVudCA6IFVJRXZlbnQge1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgbG9uZyAgICAgICAgICAgc2NyZWVuWDtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGxvbmcgICAgICAgICAgIHNjcmVlblk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBsb25nICAgICAgICAgICBjbGllbnRYO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgbG9uZyAgICAgICAgICAgY2xpZW50WTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgIGN0cmxLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgICBzaGlmdEtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgIGFsdEtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgIG1ldGFLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBzaG9ydCAgICAgICAgICBidXR0b247XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBFdmVudFRhcmdldD8gICByZWxhdGVkVGFyZ2V0O1xuICAgIC8vICAgICAvLyBJbnRyb2R1Y2VkIGluIHRoaXMgc3BlY2lmaWNhdGlvblxuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgdW5zaWduZWQgc2hvcnQgYnV0dG9ucztcbiAgICAvLyAgICAgYm9vbGVhbiBnZXRNb2RpZmllclN0YXRlIChET01TdHJpbmcga2V5QXJnKTtcbiAgICAvLyB9O1xuXG4gICAgVUlFdmVudC5jYWxsKHRoaXMsIGV2KTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIE1vdXNlRXZlbnQjc2NyZWVuWFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuc2NyZWVuWCA9IGV2LnNjcmVlblg7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBNb3VzZUV2ZW50I3NjcmVlbllcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnNjcmVlblkgPSBldi5zY3JlZW5ZO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgTW91c2VFdmVudCNjbGllbnRYXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5jbGllbnRYID0gZXYuY2xpZW50WDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIE1vdXNlRXZlbnQjY2xpZW50WVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50WSA9IGV2LmNsaWVudFk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBNb3VzZUV2ZW50I2N0cmxLZXlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5jdHJsS2V5ID0gZXYuY3RybEtleTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIE1vdXNlRXZlbnQjc2hpZnRLZXlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5zaGlmdEtleSA9IGV2LnNoaWZ0S2V5O1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgTW91c2VFdmVudCNhbHRLZXlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5hbHRLZXkgPSBldi5hbHRLZXk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBNb3VzZUV2ZW50I21ldGFLZXlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5tZXRhS2V5ID0gZXYubWV0YUtleTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIE1vdXNlRXZlbnQjYnV0dG9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5idXR0b24gPSBldi5idXR0b247XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSBNb3VzZUV2ZW50I2J1dHRvbnNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmJ1dHRvbnMgPSBldi5idXR0b25zO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgTW91c2VFdmVudCNwYWdlWFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMucGFnZVggPSBldi5wYWdlWDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIE1vdXNlRXZlbnQjcGFnZVlcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnBhZ2VZID0gZXYucGFnZVk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSBNb3VzZUV2ZW50I3hcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnggPSBldi54O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgTW91c2VFdmVudCN5XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy55ID0gZXYueTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIE1vdXNlRXZlbnQjb2Zmc2V0WFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMub2Zmc2V0WCA9IGV2Lm9mZnNldFg7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSBNb3VzZUV2ZW50I29mZnNldFlcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldFkgPSBldi5vZmZzZXRZO1xufVxuXG5Nb3VzZUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVUlFdmVudC5wcm90b3R5cGUpO1xuTW91c2VFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb3VzZUV2ZW50O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdHlwZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqL1xuTW91c2VFdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdNb3VzZUV2ZW50Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTW91c2VFdmVudDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcblxudmFyIEVNUFRZX0FSUkFZID0gW107XG5cbi8qKlxuICogU2VlIFtUb3VjaCBJbnRlcmZhY2VdKGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvUkVDLXRvdWNoLWV2ZW50cy0yMDEzMTAxMC8jdG91Y2gtaW50ZXJmYWNlKS5cbiAqXG4gKiBAY2xhc3MgVG91Y2hcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtUb3VjaH0gdG91Y2ggVGhlIG5hdGl2ZSBUb3VjaCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIFRvdWNoKHRvdWNoKSB7XG4gICAgLy8gaW50ZXJmYWNlIFRvdWNoIHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGxvbmcgICAgICAgIGlkZW50aWZpZXI7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBFdmVudFRhcmdldCB0YXJnZXQ7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICBzY3JlZW5YO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgZG91YmxlICAgICAgc2NyZWVuWTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGRvdWJsZSAgICAgIGNsaWVudFg7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICBjbGllbnRZO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgZG91YmxlICAgICAgcGFnZVg7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICBwYWdlWTtcbiAgICAvLyB9O1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVG91Y2gjaWRlbnRpZmllclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuaWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXI7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUb3VjaCNzY3JlZW5YXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5zY3JlZW5YID0gdG91Y2guc2NyZWVuWDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFRvdWNoI3NjcmVlbllcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnNjcmVlblkgPSB0b3VjaC5zY3JlZW5ZO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVG91Y2gjY2xpZW50WFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50WCA9IHRvdWNoLmNsaWVudFg7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUb3VjaCNjbGllbnRZXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5jbGllbnRZID0gdG91Y2guY2xpZW50WTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFRvdWNoI3BhZ2VYXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5wYWdlWCA9IHRvdWNoLnBhZ2VYO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVG91Y2gjcGFnZVlcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnBhZ2VZID0gdG91Y2gucGFnZVk7XG59XG5cblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBicm93c2VyJ3MgbmF0aXZlIFRvdWNoTGlzdCBieSBjb252ZXJ0aW5nIGl0IGludG8gYW4gYXJyYXkgb2ZcbiAqIG5vcm1hbGl6ZWQgVG91Y2ggb2JqZWN0cy5cbiAqXG4gKiBAbWV0aG9kICBjbG9uZVRvdWNoTGlzdFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0gIHtUb3VjaExpc3R9IHRvdWNoTGlzdCAgICBUaGUgbmF0aXZlIFRvdWNoTGlzdCBhcnJheS5cbiAqIEByZXR1cm4ge0FycmF5LjxUb3VjaD59ICAgICAgICAgIEFuIGFycmF5IG9mIG5vcm1hbGl6ZWQgVG91Y2ggb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUb3VjaExpc3QodG91Y2hMaXN0KSB7XG4gICAgaWYgKCF0b3VjaExpc3QpIHJldHVybiBFTVBUWV9BUlJBWTtcbiAgICAvLyBpbnRlcmZhY2UgVG91Y2hMaXN0IHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIHVuc2lnbmVkIGxvbmcgbGVuZ3RoO1xuICAgIC8vICAgICBnZXR0ZXIgVG91Y2g/IGl0ZW0gKHVuc2lnbmVkIGxvbmcgaW5kZXgpO1xuICAgIC8vIH07XG5cbiAgICB2YXIgdG91Y2hMaXN0QXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3VjaExpc3RBcnJheVtpXSA9IG5ldyBUb3VjaCh0b3VjaExpc3RbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdG91Y2hMaXN0QXJyYXk7XG59XG5cbi8qKlxuICogU2VlIFtUb3VjaCBFdmVudCBJbnRlcmZhY2VdKGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvUkVDLXRvdWNoLWV2ZW50cy0yMDEzMTAxMC8jdG91Y2hldmVudC1pbnRlcmZhY2UpLlxuICpcbiAqIEBjbGFzcyBUb3VjaEV2ZW50XG4gKiBAYXVnbWVudHMgVUlFdmVudFxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2IFRoZSBuYXRpdmUgRE9NIGV2ZW50LlxuICovXG5mdW5jdGlvbiBUb3VjaEV2ZW50KGV2KSB7XG4gICAgLy8gaW50ZXJmYWNlIFRvdWNoRXZlbnQgOiBVSUV2ZW50IHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIFRvdWNoTGlzdCB0b3VjaGVzO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgVG91Y2hMaXN0IHRhcmdldFRvdWNoZXM7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBUb3VjaExpc3QgY2hhbmdlZFRvdWNoZXM7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgYWx0S2V5O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgYm9vbGVhbiAgIG1ldGFLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgY3RybEtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICBzaGlmdEtleTtcbiAgICAvLyB9O1xuICAgIFVJRXZlbnQuY2FsbCh0aGlzLCBldik7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUb3VjaEV2ZW50I3RvdWNoZXNcbiAgICAgKiBAdHlwZSBBcnJheS48VG91Y2g+XG4gICAgICovXG4gICAgdGhpcy50b3VjaGVzID0gY2xvbmVUb3VjaExpc3QoZXYudG91Y2hlcyk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUb3VjaEV2ZW50I3RhcmdldFRvdWNoZXNcbiAgICAgKiBAdHlwZSBBcnJheS48VG91Y2g+XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRUb3VjaGVzID0gY2xvbmVUb3VjaExpc3QoZXYudGFyZ2V0VG91Y2hlcyk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUb3VjaEV2ZW50I2NoYW5nZWRUb3VjaGVzXG4gICAgICogQHR5cGUgVG91Y2hMaXN0XG4gICAgICovXG4gICAgdGhpcy5jaGFuZ2VkVG91Y2hlcyA9IGNsb25lVG91Y2hMaXN0KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFRvdWNoRXZlbnQjYWx0S2V5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuYWx0S2V5ID0gZXYuYWx0S2V5O1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVG91Y2hFdmVudCNtZXRhS2V5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMubWV0YUtleSA9IGV2Lm1ldGFLZXk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUb3VjaEV2ZW50I2N0cmxLZXlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5jdHJsS2V5ID0gZXYuY3RybEtleTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFRvdWNoRXZlbnQjc2hpZnRLZXlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5zaGlmdEtleSA9IGV2LnNoaWZ0S2V5O1xufVxuXG5Ub3VjaEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVUlFdmVudC5wcm90b3R5cGUpO1xuVG91Y2hFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3VjaEV2ZW50O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdHlwZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqL1xuVG91Y2hFdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdUb3VjaEV2ZW50Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVG91Y2hFdmVudDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9FdmVudCcpO1xuXG4vKipcbiAqIFNlZSBbVUkgRXZlbnRzIChmb3JtZXJseSBET00gTGV2ZWwgMyBFdmVudHMpXShodHRwOi8vd3d3LnczLm9yZy9UUi8yMDE1L1dELXVpZXZlbnRzLTIwMTUwNDI4KS5cbiAqXG4gKiBAY2xhc3MgVUlFdmVudFxuICogQGF1Z21lbnRzIEV2ZW50XG4gKlxuICogQHBhcmFtICB7RXZlbnR9IGV2ICAgVGhlIG5hdGl2ZSBET00gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIFVJRXZlbnQoZXYpIHtcbiAgICAvLyBbQ29uc3RydWN0b3IoRE9NU3RyaW5nIHR5cGUsIG9wdGlvbmFsIFVJRXZlbnRJbml0IGV2ZW50SW5pdERpY3QpXVxuICAgIC8vIGludGVyZmFjZSBVSUV2ZW50IDogRXZlbnQge1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgV2luZG93PyB2aWV3O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgbG9uZyAgICBkZXRhaWw7XG4gICAgLy8gfTtcbiAgICBFdmVudC5jYWxsKHRoaXMsIGV2KTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFVJRXZlbnQjZGV0YWlsXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5kZXRhaWwgPSBldi5kZXRhaWw7XG59XG5cblVJRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudC5wcm90b3R5cGUpO1xuVUlFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVSUV2ZW50O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdHlwZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqL1xuVUlFdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdVSUV2ZW50Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVUlFdmVudDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vdXNlRXZlbnQgPSByZXF1aXJlKCcuL01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBTZWUgW1VJIEV2ZW50cyAoZm9ybWVybHkgRE9NIExldmVsIDMgRXZlbnRzKV0oaHR0cDovL3d3dy53My5vcmcvVFIvMjAxNS9XRC11aWV2ZW50cy0yMDE1MDQyOC8jZXZlbnRzLXdoZWVsZXZlbnRzKS5cbiAqXG4gKiBAY2xhc3MgV2hlZWxFdmVudFxuICogQGF1Z21lbnRzIFVJRXZlbnRcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldiBUaGUgbmF0aXZlIERPTSBldmVudC5cbiAqL1xuZnVuY3Rpb24gV2hlZWxFdmVudChldikge1xuICAgIC8vIFtDb25zdHJ1Y3RvcihET01TdHJpbmcgdHlwZUFyZywgb3B0aW9uYWwgV2hlZWxFdmVudEluaXQgd2hlZWxFdmVudEluaXREaWN0KV1cbiAgICAvLyBpbnRlcmZhY2UgV2hlZWxFdmVudCA6IE1vdXNlRXZlbnQge1xuICAgIC8vICAgICAvLyBEZWx0YU1vZGVDb2RlXG4gICAgLy8gICAgIGNvbnN0IHVuc2lnbmVkIGxvbmcgRE9NX0RFTFRBX1BJWEVMID0gMHgwMDtcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fREVMVEFfTElORSA9IDB4MDE7XG4gICAgLy8gICAgIGNvbnN0IHVuc2lnbmVkIGxvbmcgRE9NX0RFTFRBX1BBR0UgPSAweDAyO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgZG91YmxlICAgICAgICBkZWx0YVg7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICAgIGRlbHRhWTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGRvdWJsZSAgICAgICAgZGVsdGFaO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgdW5zaWduZWQgbG9uZyBkZWx0YU1vZGU7XG4gICAgLy8gfTtcblxuICAgIE1vdXNlRXZlbnQuY2FsbCh0aGlzLCBldik7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBXaGVlbEV2ZW50I0RPTV9ERUxUQV9QSVhFTFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuRE9NX0RFTFRBX1BJWEVMID0gMHgwMDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFdoZWVsRXZlbnQjRE9NX0RFTFRBX0xJTkVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLkRPTV9ERUxUQV9MSU5FID0gMHgwMTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFdoZWVsRXZlbnQjRE9NX0RFTFRBX1BBR0VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLkRPTV9ERUxUQV9QQUdFID0gMHgwMjtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFdoZWVsRXZlbnQjZGVsdGFYXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5kZWx0YVggPSBldi5kZWx0YVg7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBXaGVlbEV2ZW50I2RlbHRhWVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFZID0gZXYuZGVsdGFZO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgV2hlZWxFdmVudCNkZWx0YVpcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmRlbHRhWiA9IGV2LmRlbHRhWjtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFdoZWVsRXZlbnQjZGVsdGFNb2RlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5kZWx0YU1vZGUgPSBldi5kZWx0YU1vZGU7XG59XG5cbldoZWVsRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb3VzZUV2ZW50LnByb3RvdHlwZSk7XG5XaGVlbEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdoZWVsRXZlbnQ7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBldmVudCB0eXBlXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gTmFtZSBvZiB0aGUgZXZlbnQgdHlwZVxuICovXG5XaGVlbEV2ZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gJ1doZWVsRXZlbnQnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaGVlbEV2ZW50O1xuIiwiLy8gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbi8vIGh0dHA6Ly9teS5vcGVyYS5jb20vZW1vbGxlci9ibG9nLzIwMTEvMTIvMjAvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1lci1hbmltYXRpbmdcbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBieSBFcmlrIE3DtmxsZXIuIGZpeGVzIGZyb20gUGF1bCBJcmlzaCBhbmQgVGlubyBaaWpkZWxcbi8vIE1JVCBsaWNlbnNlXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGxhc3RUaW1lID0gMDtcbnZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcblxudmFyIHJBRiwgY0FGO1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICByQUYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgIGNBRiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cuY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXJBRjsgKyt4KSB7XG4gICAgICAgIHJBRiA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgICBjQUYgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSB8fFxuICAgICAgICAgICAgICB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddO1xuICAgIH1cblxuICAgIGlmIChyQUYgJiYgIWNBRikge1xuICAgICAgICAvLyBjQUYgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHNldEludGVydmFsIGZvciBub3cgKHZlcnkgcmFyZSkuXG4gICAgICAgIHJBRiA9IG51bGw7XG4gICAgfVxufVxuXG5pZiAoIXJBRikge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdyA/IERhdGUubm93IDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcblxuICAgIHJBRiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjdXJyVGltZSA9IG5vdygpO1xuICAgICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICAgICAgdmFyIGlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgICAgICB9LCB0aW1lVG9DYWxsKTtcbiAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuXG4gICAgY0FGID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcbn1cblxudmFyIGFuaW1hdGlvbkZyYW1lID0ge1xuICAgIC8qKlxuICAgICAqIENyb3NzIGJyb3dzZXIgdmVyc2lvbiBvZiBbcmVxdWVzdEFuaW1hdGlvbkZyYW1lXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZX0uXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IEVuZ2luZSBpbiBvcmRlciB0byBlc3RhYmxpc2ggYSByZW5kZXIgbG9vcC5cbiAgICAgKlxuICAgICAqIElmIG5vICh2ZW5kb3IgcHJlZml4ZWQgdmVyc2lvbiBvZikgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgaXMgYXZhaWxhYmxlLFxuICAgICAqIGBzZXRUaW1lb3V0YCB3aWxsIGJlIHVzZWQgaW4gb3JkZXIgdG8gZW11bGF0ZSBhIHJlbmRlciBsb29wIHJ1bm5pbmcgYXRcbiAgICAgKiBhcHByb3hpbWF0ZWx5IDYwIGZyYW1lcyBwZXIgc2Vjb25kLlxuICAgICAqXG4gICAgICogQG1ldGhvZCAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7RnVuY3Rpb259ICBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIG9uIHRoZSBuZXh0IGZyYW1lLlxuICAgICAqIEByZXR1cm4gIHtOdW1iZXJ9ICAgIHJlcXVlc3RJZCB0byBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdCB1c2luZ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBjYW5jZWxBbmltYXRpb25GcmFtZX0uXG4gICAgICovXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiByQUYsXG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHZlcnNpb24gb2YgW2NhbmNlbEFuaW1hdGlvbkZyYW1lXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lfS5cbiAgICAgKlxuICAgICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IHVzaW5nIFtyZXF1ZXN0QW5pbWF0aW9uRnJhbWVde0BsaW5rIGFuaW1hdGlvbkZyYW1lI3JlcXVlc3RBbmltYXRpb25GcmFtZX1cbiAgICAgKiBzY2hlZHVsZWQgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIFVzZWQgZm9yIGltbWVkaWF0ZWx5IHN0b3BwaW5nIHRoZSByZW5kZXIgbG9vcCB3aXRoaW4gdGhlIEVuZ2luZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgIGNhbmNlbEFuaW1hdGlvbkZyYW1lXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7TnVtYmVyfSAgICByZXF1ZXN0SWQgb2YgdGhlIHNjaGVkdWxlZCBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkIGJ5IFtyZXF1ZXN0QW5pbWF0aW9uRnJhbWVde0BsaW5rIGFuaW1hdGlvbkZyYW1lI3JlcXVlc3RBbmltYXRpb25GcmFtZX0uXG4gICAgICovXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWU6IGNBRlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhbmltYXRpb25GcmFtZTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZTogcmVxdWlyZSgnLi9hbmltYXRpb25GcmFtZScpLnJlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZTogcmVxdWlyZSgnLi9hbmltYXRpb25GcmFtZScpLmNhbmNlbEFuaW1hdGlvbkZyYW1lXG59O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcG9seWZpbGxzID0gcmVxdWlyZSgnLi4vcG9seWZpbGxzJyk7XG52YXIgckFGID0gcG9seWZpbGxzLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbnZhciBjQUYgPSBwb2x5ZmlsbHMuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cbi8qKlxuICogQm9vbGVhbiBjb25zdGFudCBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AgaGFzIGFjY2Vzc1xuICogdG8gdGhlIGRvY3VtZW50LiBUaGUgZG9jdW1lbnQgaXMgYmVpbmcgdXNlZCBpbiBvcmRlciB0byBzdWJzY3JpYmUgZm9yXG4gKiB2aXNpYmlsaXR5Y2hhbmdlIGV2ZW50cyB1c2VkIGZvciBub3JtYWxpemluZyB0aGUgUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcFxuICogdGltZSB3aGVuIGUuZy4gd2hlbiBzd2l0Y2hpbmcgdGFicy5cbiAqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG52YXIgRE9DVU1FTlRfQUNDRVNTID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuaWYgKERPQ1VNRU5UX0FDQ0VTUykge1xuICAgIHZhciBWRU5ET1JfSElEREVOLCBWRU5ET1JfVklTSUJJTElUWV9DSEFOR0U7XG5cbiAgICAvLyBPcGVyYSAxMi4xMCBhbmQgRmlyZWZveCAxOCBhbmQgbGF0ZXIgc3VwcG9ydFxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuaGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBWRU5ET1JfSElEREVOID0gJ2hpZGRlbic7XG4gICAgICAgIFZFTkRPUl9WSVNJQklMSVRZX0NIQU5HRSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Lm1vekhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgVkVORE9SX0hJRERFTiA9ICdtb3pIaWRkZW4nO1xuICAgICAgICBWRU5ET1JfVklTSUJJTElUWV9DSEFOR0UgPSAnbW96dmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5tc0hpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgVkVORE9SX0hJRERFTiA9ICdtc0hpZGRlbic7XG4gICAgICAgIFZFTkRPUl9WSVNJQklMSVRZX0NIQU5HRSA9ICdtc3Zpc2liaWxpdHljaGFuZ2UnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQud2Via2l0SGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBWRU5ET1JfSElEREVOID0gJ3dlYmtpdEhpZGRlbic7XG4gICAgICAgIFZFTkRPUl9WSVNJQklMSVRZX0NIQU5HRSA9ICd3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICB9XG59XG5cbi8qKlxuICogUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcCBjbGFzcyB1c2VkIGZvciB1cGRhdGluZyBvYmplY3RzIG9uIGEgZnJhbWUtYnktZnJhbWUuXG4gKiBTeW5jaHJvbml6ZXMgdGhlIGB1cGRhdGVgIG1ldGhvZCBpbnZvY2F0aW9ucyB0byB0aGUgcmVmcmVzaCByYXRlIG9mIHRoZVxuICogc2NyZWVuLiBNYW5hZ2VzIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC1sb29wIGJ5IG5vcm1hbGl6aW5nIHRoZSBwYXNzZWQgaW5cbiAqIHRpbWVzdGFtcCB3aGVuIHN3aXRjaGluZyB0YWJzLlxuICpcbiAqIEBjbGFzcyBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wXG4gKi9cbmZ1bmN0aW9uIFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIFJlZmVyZW5jZXMgdG8gb2JqZWN0cyB0byBiZSB1cGRhdGVkIG9uIG5leHQgZnJhbWUuXG4gICAgdGhpcy5fdXBkYXRlcyA9IFtdO1xuXG4gICAgdGhpcy5fbG9vcGVyID0gZnVuY3Rpb24odGltZSkge1xuICAgICAgICBfdGhpcy5sb29wKHRpbWUpO1xuICAgIH07XG4gICAgdGhpcy5fdGltZSA9IDA7XG4gICAgdGhpcy5fc3RvcHBlZEF0ID0gMDtcbiAgICB0aGlzLl9zbGVlcCA9IDA7XG5cbiAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZW5naW5lIHNob3VsZCBiZSByZXN0YXJ0ZWQgd2hlbiB0aGUgdGFiLyB3aW5kb3cgaXNcbiAgICAvLyBiZWluZyBmb2N1c2VkIGFnYWluICh2aXNpYmlsaXR5IGNoYW5nZSkuXG4gICAgdGhpcy5fc3RhcnRPblZpc2liaWxpdHlDaGFuZ2UgPSB0cnVlO1xuXG4gICAgLy8gcmVxdWVzdElkIGFzIHJldHVybmVkIGJ5IHJlcXVlc3RBbmltYXRpb25GcmFtZSBmdW5jdGlvbjtcbiAgICB0aGlzLl9yQUYgPSBudWxsO1xuXG4gICAgdGhpcy5fc2xlZXBEaWZmID0gdHJ1ZTtcblxuICAgIC8vIFRoZSBlbmdpbmUgaXMgYmVpbmcgc3RhcnRlZCBvbiBpbnN0YW50aWF0aW9uLlxuICAgIC8vIFRPRE8oYWxleGFuZGVyR3VnZWwpXG4gICAgdGhpcy5zdGFydCgpO1xuXG4gICAgLy8gVGhlIFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3Agc3VwcG9ydHMgcnVubmluZyBpbiBhIG5vbi1icm93c2VyXG4gICAgLy8gZW52aXJvbm1lbnQgKGUuZy4gV29ya2VyKS5cbiAgICBpZiAoRE9DVU1FTlRfQUNDRVNTKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoVkVORE9SX1ZJU0lCSUxJVFlfQ0hBTkdFLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF90aGlzLl9vblZpc2liaWxpdHlDaGFuZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSB0aGUgc3dpdGNoaW5nIG9mIHRhYnMuXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5SZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wLnByb3RvdHlwZS5fb25WaXNpYmlsaXR5Q2hhbmdlID0gZnVuY3Rpb24gX29uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoZG9jdW1lbnRbVkVORE9SX0hJRERFTl0pIHtcbiAgICAgICAgdGhpcy5fb25VbmZvY3VzKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkZvY3VzKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhcyBzb29uIGFzIHRoZSB3aW5kb3cvIHRhYiBpcyBiZWluZ1xuICogZm9jdXNlZCBhZnRlciBhIHZpc2liaWx0aXkgY2hhbmdlLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcC5wcm90b3R5cGUuX29uRm9jdXMgPSBmdW5jdGlvbiBfb25Gb2N1cygpIHtcbiAgICBpZiAodGhpcy5fc3RhcnRPblZpc2liaWxpdHlDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fc3RhcnQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFzIHNvb24gYXMgdGhlIHdpbmRvdy8gdGFiIGlzIGJlaW5nXG4gKiB1bmZvY3VzZWQgKGhpZGRlbikgYWZ0ZXIgYSB2aXNpYmlsdGl5IGNoYW5nZS5cbiAqXG4gKiBAbWV0aG9kICBfb25Gb2N1c1xuICogQHByaXZhdGVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5SZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wLnByb3RvdHlwZS5fb25VbmZvY3VzID0gZnVuY3Rpb24gX29uVW5mb2N1cygpIHtcbiAgICB0aGlzLl9zdG9wKCk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0aGUgUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcC4gV2hlbiBzd2l0Y2hpbmcgdG8gYSBkaWZmZXJudCB0YWIvXG4gKiB3aW5kb3cgKGNoYW5naW5nIHRoZSB2aXNpYmlsdGl5KSwgdGhlIGVuZ2luZSB3aWxsIGJlIHJldGFydGVkIHdoZW4gc3dpdGNoaW5nXG4gKiBiYWNrIHRvIGEgdmlzaWJsZSBzdGF0ZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7UmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcH0gdGhpc1xuICovXG5SZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgICB0aGlzLl9zdGFydE9uVmlzaWJpbGl0eUNoYW5nZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3N0YXJ0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCB2ZXJzaW9uIG9mIFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AncyBzdGFydCBmdW5jdGlvbiwgbm90IGFmZmVjdGluZ1xuICogYmVoYXZpb3Igb24gdmlzaWJpbHR5IGNoYW5nZS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gX3N0YXJ0KCkge1xuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3NsZWVwRGlmZiA9IHRydWU7XG4gICAgdGhpcy5fckFGID0gckFGKHRoaXMuX2xvb3Blcik7XG59O1xuXG4vKipcbiAqIFN0b3BzIHRoZSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHJldHVybiB7UmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcH0gdGhpc1xuICovXG5SZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgICB0aGlzLl9zdGFydE9uVmlzaWJpbGl0eUNoYW5nZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdG9wKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCB2ZXJzaW9uIG9mIFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AncyBzdG9wIGZ1bmN0aW9uLCBub3QgYWZmZWN0aW5nXG4gKiBiZWhhdmlvciBvbiB2aXNpYmlsdHkgY2hhbmdlLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcC5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiBfc3RvcCgpIHtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcHBlZEF0ID0gdGhpcy5fdGltZTtcblxuICAgIC8vIEJ1ZyBpbiBvbGQgdmVyc2lvbnMgb2YgRnguIEV4cGxpY2l0bHkgY2FuY2VsLlxuICAgIGNBRih0aGlzLl9yQUYpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AgaXMgY3VycmVudGx5IHJ1bm5pbmcgb3Igbm90LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGVcbiAqIFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AgaXMgY3VycmVudGx5IHJ1bm5pbmcgb3Igbm90XG4gKi9cblJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AucHJvdG90eXBlLmlzUnVubmluZyA9IGZ1bmN0aW9uIGlzUnVubmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVubmluZztcbn07XG5cbi8qKlxuICogVXBkYXRlcyBhbGwgcmVnaXN0ZXJlZCBvYmplY3RzLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBoaWdoIHJlc29sdXRpb24gdGltc3RhbXAgdXNlZCBmb3IgaW52b2tpbmcgdGhlIGB1cGRhdGVgXG4gKiBtZXRob2Qgb24gYWxsIHJlZ2lzdGVyZWQgb2JqZWN0c1xuICpcbiAqIEByZXR1cm4ge1JlcXVlc3RBbmltYXRpb25GcmFtZUxvb3B9IHRoaXNcbiAqL1xuUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcC5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uIHN0ZXAgKHRpbWUpIHtcbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICBpZiAodGhpcy5fc2xlZXBEaWZmKSB7XG4gICAgICAgIHRoaXMuX3NsZWVwICs9IHRpbWUgLSB0aGlzLl9zdG9wcGVkQXQ7XG4gICAgICAgIHRoaXMuX3NsZWVwRGlmZiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoZSBzYW1lIHRpbWV0YW1wIHdpbGwgYmUgZW1pdHRlZCBpbW1lZGlhdGVseSBiZWZvcmUgYW5kIGFmdGVyIHZpc2liaWxpdHlcbiAgICAvLyBjaGFuZ2UuXG4gICAgdmFyIG5vcm1hbGl6ZWRUaW1lID0gdGltZSAtIHRoaXMuX3NsZWVwO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl91cGRhdGVzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlc1tpXS51cGRhdGUobm9ybWFsaXplZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWV0aG9kIGJlaW5nIGNhbGxlZCBieSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBvbiBldmVyeSBwYWludC4gSW5kaXJlY3RseVxuICogcmVjdXJzaXZlIGJ5IHNjaGVkdWxpbmcgYSBmdXR1cmUgaW52b2NhdGlvbiBvZiBpdHNlbGYgb24gdGhlIG5leHQgcGFpbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIGhpZ2ggcmVzb2x1dGlvbiB0aW1zdGFtcCB1c2VkIGZvciBpbnZva2luZyB0aGUgYHVwZGF0ZWBcbiAqIG1ldGhvZCBvbiBhbGwgcmVnaXN0ZXJlZCBvYmplY3RzXG4gKiBAcmV0dXJuIHtSZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wfSB0aGlzXG4gKi9cblJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AucHJvdG90eXBlLmxvb3AgPSBmdW5jdGlvbiBsb29wKHRpbWUpIHtcbiAgICB0aGlzLnN0ZXAodGltZSk7XG4gICAgdGhpcy5fckFGID0gckFGKHRoaXMuX2xvb3Blcik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyZXMgYW4gdXBkYXRlYWJsZSBvYmplY3Qgd2hpY2ggYHVwZGF0ZWAgbWV0aG9kIHNob3VsZCBiZSBpbnZva2VkIG9uXG4gKiBldmVyeSBwYWludCwgc3RhcnRpbmcgb24gdGhlIG5leHQgcGFpbnQgKGFzc3VtaW5nIHRoZVxuICogUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcCBpcyBydW5uaW5nKS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZWFibGUgb2JqZWN0IHRvIGJlIHVwZGF0ZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZWFibGUudXBkYXRlIHVwZGF0ZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gdGhlXG4gKiByZWdpc3RlcmVkIG9iamVjdFxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3RBbmltYXRpb25GcmFtZUxvb3B9IHRoaXNcbiAqL1xuUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHVwZGF0ZWFibGUpIHtcbiAgICBpZiAodGhpcy5fdXBkYXRlcy5pbmRleE9mKHVwZGF0ZWFibGUpID09PSAtMSkge1xuICAgICAgICB0aGlzLl91cGRhdGVzLnB1c2godXBkYXRlYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZXJlZ2lzdGVycyBhbiB1cGRhdGVhYmxlIG9iamVjdCBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgdXNpbmcgYHVwZGF0ZWAgdG8gYmVcbiAqIG5vIGxvbmdlciB1cGRhdGVkLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlYWJsZSB1cGRhdGVhYmxlIG9iamVjdCBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgdXNpbmdcbiAqIGB1cGRhdGVgXG4gKlxuICogQHJldHVybiB7UmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcH0gdGhpc1xuICovXG5SZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wLnByb3RvdHlwZS5ub0xvbmdlclVwZGF0ZSA9IGZ1bmN0aW9uIG5vTG9uZ2VyVXBkYXRlKHVwZGF0ZWFibGUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl91cGRhdGVzLmluZGV4T2YodXBkYXRlYWJsZSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbnRleHQgPSByZXF1aXJlKCcuL0NvbnRleHQnKTtcbnZhciBpbmplY3RDU1MgPSByZXF1aXJlKCcuL2luamVjdC1jc3MnKTtcbnZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbWFuZHMnKTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYSBuZXcgQ29tcG9zaXRvci5cbiAqIFRoZSBDb21wb3NpdG9yIHJlY2VpdmVzIGRyYXcgY29tbWFuZHMgZnJtIHRoZSBVSU1hbmFnZXIgYW5kIHJvdXRlcyB0aGUgdG8gdGhlXG4gKiByZXNwZWN0aXZlIGNvbnRleHQgb2JqZWN0cy5cbiAqXG4gKiBVcG9uIGNyZWF0aW9uLCBpdCBpbmplY3RzIGEgc3R5bGVzaGVldCB1c2VkIGZvciBzdHlsaW5nIHRoZSBpbmRpdmlkdWFsXG4gKiByZW5kZXJlcnMgdXNlZCBpbiB0aGUgY29udGV4dCBvYmplY3RzLlxuICpcbiAqIEBjbGFzcyBDb21wb3NpdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIENvbXBvc2l0b3IoKSB7XG4gICAgaW5qZWN0Q1NTKCk7XG5cbiAgICB0aGlzLl9jb250ZXh0cyA9IHt9O1xuICAgIHRoaXMuX291dENvbW1hbmRzID0gW107XG4gICAgdGhpcy5faW5Db21tYW5kcyA9IFtdO1xuICAgIHRoaXMuX3RpbWUgPSBudWxsO1xuXG4gICAgdGhpcy5fcmVzaXplZCA9IGZhbHNlO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLm9uUmVzaXplKCk7XG4gICAgfSk7XG59XG5cbkNvbXBvc2l0b3IucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gb25SZXNpemUgKCkge1xuICAgIHRoaXMuX3Jlc2l6ZWQgPSB0cnVlO1xuICAgIGZvciAodmFyIHNlbGVjdG9yIGluIHRoaXMuX2NvbnRleHRzKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXS51cGRhdGVTaXplKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHRpbWUgYmVpbmcgdXNlZCBieSB0aGUgaW50ZXJuYWwgY2xvY2sgbWFuYWdlZCBieVxuICogYEZhbW91c0VuZ2luZWAuXG4gKlxuICogVGhlIHRpbWUgaXMgYmVpbmcgcGFzc2VkIGludG8gY29yZSBieSB0aGUgRW5naW5lIHRocm91Z2ggdGhlIFVJTWFuYWdlci5cbiAqIFNpbmNlIGNvcmUgaGFzIHRoZSBhYmlsaXR5IHRvIHNjYWxlIHRoZSB0aW1lLCB0aGUgdGltZSBuZWVkcyB0byBiZSBwYXNzZWRcbiAqIGJhY2sgdG8gdGhlIHJlbmRlcmluZyBzeXN0ZW0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gdGltZSBUaGUgY2xvY2sgdGltZSB1c2VkIGluIGNvcmUuXG4gKi9cbkNvbXBvc2l0b3IucHJvdG90eXBlLmdldFRpbWUgPSBmdW5jdGlvbiBnZXRUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lO1xufTtcblxuLyoqXG4gKiBTY2hlZHVsZXMgYW4gZXZlbnQgdG8gYmUgc2VudCB0aGUgbmV4dCB0aW1lIHRoZSBvdXQgY29tbWFuZCBxdWV1ZSBpcyBiZWluZ1xuICogZmx1c2hlZC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCBSZW5kZXIgcGF0aCB0byB0aGUgbm9kZSB0aGUgZXZlbnQgc2hvdWxkIGJlIHRyaWdnZXJlZFxuICogb24gKCp0YXJnZXRlZCBldmVudCopXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGV2IEV2ZW50IHR5cGVcbiAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZCBFdmVudCBvYmplY3QgKHNlcmlhbGl6YWJsZSB1c2luZyBzdHJ1Y3R1cmVkIGNsb25pbmdcbiAqIGFsZ29yaXRobSlcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS5zZW5kRXZlbnQgPSBmdW5jdGlvbiBzZW5kRXZlbnQocGF0aCwgZXYsIHBheWxvYWQpIHtcbiAgICB0aGlzLl9vdXRDb21tYW5kcy5wdXNoKENvbW1hbmRzLldJVEgsIHBhdGgsIENvbW1hbmRzLlRSSUdHRVIsIGV2LCBwYXlsb2FkKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIG1ldGhvZCB1c2VkIGZvciBub3RpZnlpbmcgZXh0ZXJuYWxseVxuICogcmVzaXplZCBjb250ZXh0cyAoZS5nLiBieSByZXNpemluZyB0aGUgYnJvd3NlciB3aW5kb3cpLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzZWxlY3RvciByZW5kZXIgcGF0aCB0byB0aGUgbm9kZSAoY29udGV4dCkgdGhhdCBzaG91bGQgYmVcbiAqIHJlc2l6ZWRcbiAqIEBwYXJhbSAge0FycmF5fSBzaXplIG5ldyBjb250ZXh0IHNpemVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS5zZW5kUmVzaXplID0gZnVuY3Rpb24gc2VuZFJlc2l6ZSAoc2VsZWN0b3IsIHNpemUpIHtcbiAgICB0aGlzLnNlbmRFdmVudChzZWxlY3RvciwgJ0NPTlRFWFRfUkVTSVpFJywgc2l6ZSk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBtZXRob2QgdXNlZCBieSBgZHJhd0NvbW1hbmRzYC5cbiAqIFN1YnNlcXVlbnQgY29tbWFuZHMgYXJlIGJlaW5nIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZSBkZWZpbmVkIHRoZSB0aGUgcGF0aFxuICogZm9sbG93aW5nIHRoZSBgV0lUSGAgY29tbWFuZC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gaXRlcmF0b3IgcG9zaXRpb24gaW5kZXggd2l0aGluIHRoZSBjb21tYW5kcyBxdWV1ZVxuICogQHBhcmFtICB7QXJyYXl9IGNvbW1hbmRzIHJlbWFpbmluZyBtZXNzYWdlIHF1ZXVlIHJlY2VpdmVkLCB1c2VkIHRvXG4gKiBzaGlmdCBzaW5nbGUgbWVzc2FnZXMgZnJvbVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkNvbXBvc2l0b3IucHJvdG90eXBlLmhhbmRsZVdpdGggPSBmdW5jdGlvbiBoYW5kbGVXaXRoIChpdGVyYXRvciwgY29tbWFuZHMpIHtcbiAgICB2YXIgcGF0aCA9IGNvbW1hbmRzW2l0ZXJhdG9yXTtcbiAgICB2YXIgcGF0aEFyciA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0T3JTZXRDb250ZXh0KHBhdGhBcnIuc2hpZnQoKSk7XG4gICAgcmV0dXJuIGNvbnRleHQucmVjZWl2ZShwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHRvcC1sZXZlbCBDb250ZXh0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcGFzc2VkIGluIGRvY3VtZW50XG4gKiBxdWVyeSBzZWxlY3Rvci4gSWYgbm8gc3VjaCBDb250ZXh0IGV4aXN0cywgYSBuZXcgb25lIHdpbGwgYmUgaW5zdGFudGlhdGVkLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHNlbGVjdG9yIGRvY3VtZW50IHF1ZXJ5IHNlbGVjdG9yIHVzZWQgZm9yIHJldHJpZXZpbmcgdGhlXG4gKiBET00gbm9kZSB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIGEgcm9vdCBlbGVtZW50IGJ5IHRoZSBDb250ZXh0XG4gKlxuICogQHJldHVybiB7Q29udGV4dH0gY29udGV4dFxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS5nZXRPclNldENvbnRleHQgPSBmdW5jdGlvbiBnZXRPclNldENvbnRleHQoc2VsZWN0b3IpIHtcbiAgICBpZiAodGhpcy5fY29udGV4dHNbc2VsZWN0b3JdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0c1tzZWxlY3Rvcl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHNlbGVjdG9yLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dHNbc2VsZWN0b3JdID0gY29udGV4dDtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBjb250ZXh0IG9iamVjdCByZWdpc3RlcmVkIHVuZGVyIHRoZSBwYXNzZWQgaW4gc2VsZWN0b3IuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc2VsZWN0b3IgICAgUXVlcnkgc2VsZWN0b3IgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIHVzZWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXIgdGhlIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtDb250ZXh0fSAgICAgICAgICAgIFRoZSByZXBzZWN0aXZlIGNvbnRleHQuXG4gKi9cbkNvbXBvc2l0b3IucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiBnZXRDb250ZXh0KHNlbGVjdG9yKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXTtcbn07XG5cbi8qKlxuICogUHJvY2Vzc2VzIHRoZSBwcmV2aW91c2x5IHZpYSBgcmVjZWl2ZUNvbW1hbmRzYCB1cGRhdGVkIGluY29taW5nIFwiaW5cIlxuICogY29tbWFuZCBxdWV1ZS5cbiAqIENhbGxlZCBieSBVSU1hbmFnZXIgb24gYSBmcmFtZSBieSBmcmFtZSBiYXNpcy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7QXJyYXl9IG91dENvbW1hbmRzIHNldCBvZiBjb21tYW5kcyB0byBiZSBzZW50IGJhY2tcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuZHJhd0NvbW1hbmRzID0gZnVuY3Rpb24gZHJhd0NvbW1hbmRzKCkge1xuICAgIHZhciBjb21tYW5kcyA9IHRoaXMuX2luQ29tbWFuZHM7XG4gICAgdmFyIGxvY2FsSXRlcmF0b3IgPSAwO1xuICAgIHZhciBjb21tYW5kID0gY29tbWFuZHNbbG9jYWxJdGVyYXRvcl07XG4gICAgd2hpbGUgKGNvbW1hbmQpIHtcbiAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLlRJTUU6XG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLldJVEg6XG4gICAgICAgICAgICAgICAgbG9jYWxJdGVyYXRvciA9IHRoaXMuaGFuZGxlV2l0aCgrK2xvY2FsSXRlcmF0b3IsIGNvbW1hbmRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTkVFRF9TSVpFX0ZPUjpcbiAgICAgICAgICAgICAgICB0aGlzLmdpdmVTaXplRm9yKCsrbG9jYWxJdGVyYXRvciwgY29tbWFuZHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1hbmQgPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFN3aXRjaCB0byBhc3NvY2lhdGl2ZSBhcnJheXMgaGVyZS4uLlxuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2NvbnRleHRzKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzW2tleV0uZHJhdygpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZXNpemVkKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9vdXRDb21tYW5kcztcbn07XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBzaXplIG9mIGFsbCBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgY29udGV4dCBvYmplY3RzLlxuICogVGhpcyByZXN1bHRzIGludG8gQ09OVEVYVF9SRVNJWkUgZXZlbnRzIGJlaW5nIHNlbnQgYW5kIHRoZSByb290IGVsZW1lbnRzXG4gKiB1c2VkIGJ5IHRoZSBpbmRpdmlkdWFsIHJlbmRlcmVycyBiZWluZyByZXNpemVkIHRvIHRoZSB0aGUgRE9NUmVuZGVyZXIncyByb290XG4gKiBzaXplLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gdXBkYXRlU2l6ZSgpIHtcbiAgICBmb3IgKHZhciBzZWxlY3RvciBpbiB0aGlzLl9jb250ZXh0cykge1xuICAgICAgICB0aGlzLl9jb250ZXh0c1tzZWxlY3Rvcl0udXBkYXRlU2l6ZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVXNlZCBieSBUaHJlYWRNYW5hZ2VyIHRvIHVwZGF0ZSB0aGUgaW50ZXJuYWwgcXVldWUgb2YgaW5jb21pbmcgY29tbWFuZHMuXG4gKiBSZWNlaXZpbmcgY29tbWFuZHMgZG9lcyBub3QgaW1tZWRpYXRlbHkgc3RhcnQgdGhlIHJlbmRlcmluZyBwcm9jZXNzLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gY29tbWFuZHMgY29tbWFuZCBxdWV1ZSB0byBiZSBwcm9jZXNzZWQgYnkgdGhlIGNvbXBvc2l0b3Inc1xuICogYGRyYXdDb21tYW5kc2AgbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUucmVjZWl2ZUNvbW1hbmRzID0gZnVuY3Rpb24gcmVjZWl2ZUNvbW1hbmRzKGNvbW1hbmRzKSB7XG4gICAgdmFyIGxlbiA9IGNvbW1hbmRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2luQ29tbWFuZHMucHVzaChjb21tYW5kc1tpXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgc2VsZWN0b3IgaW4gdGhpcy5fY29udGV4dHMpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dHNbc2VsZWN0b3JdLmNoZWNrSW5pdCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIG1ldGhvZCB1c2VkIGJ5IGBkcmF3Q29tbWFuZHNgLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSBpdGVyYXRvciBwb3NpdGlvbiBpbmRleCB3aXRoaW4gdGhlIGNvbW1hbmQgcXVldWVcbiAqIEBwYXJhbSAge0FycmF5fSBjb21tYW5kcyByZW1haW5pbmcgbWVzc2FnZSBxdWV1ZSByZWNlaXZlZCwgdXNlZCB0b1xuICogc2hpZnQgc2luZ2xlIG1lc3NhZ2VzXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuZ2l2ZVNpemVGb3IgPSBmdW5jdGlvbiBnaXZlU2l6ZUZvcihpdGVyYXRvciwgY29tbWFuZHMpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBjb21tYW5kc1tpdGVyYXRvcl07XG4gICAgdmFyIHNpemUgPSB0aGlzLmdldE9yU2V0Q29udGV4dChzZWxlY3RvcikuZ2V0Um9vdFNpemUoKTtcbiAgICB0aGlzLnNlbmRSZXNpemUoc2VsZWN0b3IsIHNpemUpO1xufTtcblxuLyoqXG4gKiBGbHVzaGVzIHRoZSBxdWV1ZSBvZiBvdXRnb2luZyBcIm91dFwiIGNvbW1hbmRzLlxuICogQ2FsbGVkIGJ5IFRocmVhZE1hbmFnZXIuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkNvbXBvc2l0b3IucHJvdG90eXBlLmNsZWFyQ29tbWFuZHMgPSBmdW5jdGlvbiBjbGVhckNvbW1hbmRzKCkge1xuICAgIHRoaXMuX2luQ29tbWFuZHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9vdXRDb21tYW5kcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3Jlc2l6ZWQgPSBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9zaXRvcjtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFdlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi93ZWJnbC1yZW5kZXJlcnMvV2ViR0xSZW5kZXJlcicpO1xudmFyIENhbWVyYSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQ2FtZXJhJyk7XG52YXIgRE9NUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9kb20tcmVuZGVyZXJzL0RPTVJlbmRlcmVyJyk7XG52YXIgQ29tbWFuZHMgPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1hbmRzJyk7XG5cbi8qKlxuICogQ29udGV4dCBpcyBhIHJlbmRlciBsYXllciB3aXRoIGl0cyBvd24gV2ViR0xSZW5kZXJlciBhbmQgRE9NUmVuZGVyZXIuXG4gKiBJdCBpcyB0aGUgaW50ZXJmYWNlIGJldHdlZW4gdGhlIENvbXBvc2l0b3Igd2hpY2ggcmVjZWl2ZXMgY29tbWFuZHNcbiAqIGFuZCB0aGUgcmVuZGVyZXJzIHRoYXQgaW50ZXJwcmV0IHRoZW0uIEl0IGFsc28gcmVsYXlzIGluZm9ybWF0aW9uIHRvXG4gKiB0aGUgcmVuZGVyZXJzIGFib3V0IHJlc2l6aW5nLlxuICpcbiAqIFRoZSBET01FbGVtZW50IGF0IHRoZSBnaXZlbiBxdWVyeSBzZWxlY3RvciBpcyB1c2VkIGFzIHRoZSByb290LiBBXG4gKiBuZXcgRE9NRWxlbWVudCBpcyBhcHBlbmRlZCB0byB0aGlzIHJvb3QgZWxlbWVudCwgYW5kIHVzZWQgYXMgdGhlXG4gKiBwYXJlbnQgZWxlbWVudCBmb3IgYWxsIEZhbW91cyBET00gcmVuZGVyaW5nIGF0IHRoaXMgY29udGV4dC4gQVxuICogY2FudmFzIGlzIGFkZGVkIGFuZCB1c2VkIGZvciBhbGwgV2ViR0wgcmVuZGVyaW5nIGF0IHRoaXMgY29udGV4dC5cbiAqXG4gKiBAY2xhc3MgQ29udGV4dFxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIFF1ZXJ5IHNlbGVjdG9yIHVzZWQgdG8gbG9jYXRlIHJvb3QgZWxlbWVudCBvZlxuICogY29udGV4dCBsYXllci5cbiAqIEBwYXJhbSB7Q29tcG9zaXRvcn0gY29tcG9zaXRvciBDb21wb3NpdG9yIHJlZmVyZW5jZSB0byBwYXNzIGRvd24gdG9cbiAqIFdlYkdMUmVuZGVyZXIuXG4gKi9cbmZ1bmN0aW9uIENvbnRleHQoc2VsZWN0b3IsIGNvbXBvc2l0b3IpIHtcbiAgICB0aGlzLl9jb21wb3NpdG9yID0gY29tcG9zaXRvcjtcbiAgICB0aGlzLl9yb290RWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xuXG4gICAgaWYgKHRoaXMuX3Jvb3RFbCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnRmFpbGVkIHRvIGNyZWF0ZSBDb250ZXh0OiAnICtcbiAgICAgICAgICAgICdObyBtYXRjaGVzIGZvciBcIicgKyBzZWxlY3RvciArICdcIiBmb3VuZC4nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuICAgIC8vIEluaXRpYWxpemVzIHRoZSBET01SZW5kZXJlci5cbiAgICAvLyBFdmVyeSBDb250ZXh0IGhhcyBhdCBsZWFzdCBhIERPTVJlbmRlcmVyIGZvciBub3cuXG4gICAgdGhpcy5faW5pdERPTVJlbmRlcmVyKCk7XG5cbiAgICAvLyBXZWJHTFJlbmRlcmVyIHdpbGwgYmUgaW5zdGFudGlhdGVkIHdoZW4gbmVlZGVkLlxuICAgIHRoaXMuX3dlYkdMUmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuX2RvbVJlbmRlcmVyID0gbmV3IERPTVJlbmRlcmVyKHRoaXMuX2RvbVJlbmRlcmVyUm9vdEVsLCBzZWxlY3RvciwgY29tcG9zaXRvcik7XG4gICAgdGhpcy5fY2FudmFzRWwgPSBudWxsO1xuICAgIFxuICAgIC8vIFN0YXRlIGhvbGRlcnNcblxuICAgIHRoaXMuX3JlbmRlclN0YXRlID0ge1xuICAgICAgICBwcm9qZWN0aW9uVHlwZTogQ2FtZXJhLk9SVEhPR1JBUEhJQ19QUk9KRUNUSU9OLFxuICAgICAgICBwZXJzcGVjdGl2ZVRyYW5zZm9ybTogbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pLFxuICAgICAgICB2aWV3VHJhbnNmb3JtOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSksXG4gICAgICAgIHZpZXdEaXJ0eTogZmFsc2UsXG4gICAgICAgIHBlcnNwZWN0aXZlRGlydHk6IGZhbHNlXG4gICAgfTtcblxuICAgIHRoaXMuX3NpemUgPSBbXTtcblxuICAgIHRoaXMuX21lc2hUcmFuc2Zvcm0gPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICB0aGlzLl9tZXNoU2l6ZSA9IFswLCAwLCAwXTtcblxuICAgIHRoaXMuX2luaXRET00gPSBmYWxzZTtcblxuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLmluaXRDb21tYW5kQ2FsbGJhY2tzKCk7XG5cbiAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbn1cblxuLyoqXG4gKiBRdWVyaWVzIERPTVJlbmRlcmVyIHNpemUgYW5kIHVwZGF0ZXMgY2FudmFzIHNpemUuIFJlbGF5cyBzaXplIGluZm9ybWF0aW9uIHRvXG4gKiBXZWJHTFJlbmRlcmVyLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtDb250ZXh0fSB0aGlzXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5fcm9vdEVsLm9mZnNldFdpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLl9yb290RWwub2Zmc2V0SGVpZ2h0O1xuXG4gICAgdGhpcy5fc2l6ZVswXSA9IHdpZHRoO1xuICAgIHRoaXMuX3NpemVbMV0gPSBoZWlnaHQ7XG4gICAgdGhpcy5fc2l6ZVsyXSA9ICh3aWR0aCA+IGhlaWdodCkgPyB3aWR0aCA6IGhlaWdodDtcblxuICAgIHRoaXMuX2NvbXBvc2l0b3Iuc2VuZFJlc2l6ZSh0aGlzLl9zZWxlY3RvciwgdGhpcy5fc2l6ZSk7XG4gICAgaWYgKHRoaXMuX3dlYkdMUmVuZGVyZXIpIHRoaXMuX3dlYkdMUmVuZGVyZXIudXBkYXRlU2l6ZSh0aGlzLl9zaXplKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEcmF3IGZ1bmN0aW9uIGNhbGxlZCBhZnRlciBhbGwgY29tbWFuZHMgaGF2ZSBiZWVuIGhhbmRsZWQgZm9yIGN1cnJlbnQgZnJhbWUuXG4gKiBJc3N1ZXMgZHJhdyBjb21tYW5kcyB0byBhbGwgcmVuZGVyZXJzIHdpdGggY3VycmVudCByZW5kZXJTdGF0ZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgdGhpcy5fZG9tUmVuZGVyZXIuZHJhdyh0aGlzLl9yZW5kZXJTdGF0ZSk7XG4gICAgaWYgKHRoaXMuX3dlYkdMUmVuZGVyZXIpIHRoaXMuX3dlYkdMUmVuZGVyZXIuZHJhdyh0aGlzLl9yZW5kZXJTdGF0ZSk7XG5cbiAgICBpZiAodGhpcy5fcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVEaXJ0eSkgdGhpcy5fcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVEaXJ0eSA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9yZW5kZXJTdGF0ZS52aWV3RGlydHkpIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdEaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgRE9NUmVuZGVyZXIgYnkgY3JlYXRpbmcgYSByb290IERJViBlbGVtZW50IGFuZCBhcHBlbmRpbmcgaXRcbiAqIHRvIHRoZSBjb250ZXh0LlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuX2luaXRET01SZW5kZXJlciA9IGZ1bmN0aW9uIF9pbml0RE9NUmVuZGVyZXIoKSB7XG4gICAgdGhpcy5fZG9tUmVuZGVyZXJSb290RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9yb290RWwuYXBwZW5kQ2hpbGQodGhpcy5fZG9tUmVuZGVyZXJSb290RWwpO1xuICAgIHRoaXMuX2RvbVJlbmRlcmVyUm9vdEVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICB0aGlzLl9kb21SZW5kZXJlciA9IG5ldyBET01SZW5kZXJlcihcbiAgICAgICAgdGhpcy5fZG9tUmVuZGVyZXJSb290RWwsXG4gICAgICAgIHRoaXMuX3NlbGVjdG9yLFxuICAgICAgICB0aGlzLl9jb21wb3NpdG9yXG4gICAgKTtcbn07XG5cbkNvbnRleHQucHJvdG90eXBlLmdldFJvb3RTaXplID0gZnVuY3Rpb24gZ2V0Um9vdFNpemUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGhpcy5fcm9vdEVsLm9mZnNldFdpZHRoLFxuICAgICAgICB0aGlzLl9yb290RWwub2Zmc2V0SGVpZ2h0XG4gICAgXTtcbn07XG5cbkNvbnRleHQucHJvdG90eXBlLmluaXRDb21tYW5kQ2FsbGJhY2tzID0gZnVuY3Rpb24gaW5pdENvbW1hbmRDYWxsYmFja3MgKCkge1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuSU5JVF9ET01dID0gaW5pdERPTTtcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLkRPTV9SRU5ERVJfU0laRV0gPSBkb21SZW5kZXJTaXplO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuQ0hBTkdFX1RSQU5TRk9STV0gPSBjaGFuZ2VUcmFuc2Zvcm07XG4gICAgdGhpcy5fY29tbWFuZENhbGxiYWNrc1tDb21tYW5kcy5DSEFOR0VfU0laRV0gPSBjaGFuZ2VTaXplO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuQ0hBTkdFX1BST1BFUlRZXSA9IGNoYW5nZVByb3BlcnR5O1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuQ0hBTkdFX0NPTlRFTlRdID0gY2hhbmdlQ29udGVudDtcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLkNIQU5HRV9BVFRSSUJVVEVdID0gY2hhbmdlQXR0cmlidXRlO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuQUREX0NMQVNTXSA9IGFkZENsYXNzO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuUkVNT1ZFX0NMQVNTXSA9IHJlbW92ZUNsYXNzO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuU1VCU0NSSUJFXSA9IHN1YnNjcmliZTtcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLkdMX1NFVF9EUkFXX09QVElPTlNdID0gZ2xTZXREcmF3T3B0aW9ucztcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLkdMX0FNQklFTlRfTElHSFRdID0gZ2xBbWJpZW50TGlnaHQ7XG4gICAgdGhpcy5fY29tbWFuZENhbGxiYWNrc1tDb21tYW5kcy5HTF9MSUdIVF9QT1NJVElPTl0gPSBnbExpZ2h0UG9zaXRpb247XG4gICAgdGhpcy5fY29tbWFuZENhbGxiYWNrc1tDb21tYW5kcy5HTF9MSUdIVF9DT0xPUl0gPSBnbExpZ2h0Q29sb3I7XG4gICAgdGhpcy5fY29tbWFuZENhbGxiYWNrc1tDb21tYW5kcy5NQVRFUklBTF9JTlBVVF0gPSBtYXRlcmlhbElucHV0O1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuR0xfU0VUX0dFT01FVFJZXSA9IGdsU2V0R2VvbWV0cnk7XG4gICAgdGhpcy5fY29tbWFuZENhbGxiYWNrc1tDb21tYW5kcy5HTF9VTklGT1JNU10gPSBnbFVuaWZvcm1zO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuR0xfQlVGRkVSX0RBVEFdID0gZ2xCdWZmZXJEYXRhO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuR0xfQ1VUT1VUX1NUQVRFXSA9IGdsQ3V0b3V0U3RhdGU7XG4gICAgdGhpcy5fY29tbWFuZENhbGxiYWNrc1tDb21tYW5kcy5HTF9NRVNIX1ZJU0lCSUxJVFldID0gZ2xNZXNoVmlzaWJpbGl0eTtcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLkdMX1JFTU9WRV9NRVNIXSA9IGdsUmVtb3ZlTWVzaDtcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLlBJTkhPTEVfUFJPSkVDVElPTl0gPSBwaW5ob2xlUHJvamVjdGlvbjtcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLk9SVEhPR1JBUEhJQ19QUk9KRUNUSU9OXSA9IG9ydGhvZ3JhcGhpY1Byb2plY3Rpb247XG4gICAgdGhpcy5fY29tbWFuZENhbGxiYWNrc1tDb21tYW5kcy5DSEFOR0VfVklFV19UUkFOU0ZPUk1dID0gY2hhbmdlVmlld1RyYW5zZm9ybTtcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLlBSRVZFTlRfREVGQVVMVF0gPSBwcmV2ZW50RGVmYXVsdDtcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLkFMTE9XX0RFRkFVTFRdID0gYWxsb3dEZWZhdWx0O1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuUkVBRFldID0gcmVhZHk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBXZWJHTFJlbmRlcmVyIGFuZCB1cGRhdGVzIGl0IGluaXRpYWwgc2l6ZS5cbiAqXG4gKiBUaGUgSW5pdGlhbGl6YXRpb24gcHJvY2VzcyBjb25zaXN0cyBvZiB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICpcbiAqIDEuIEEgbmV3IGA8Y2FudmFzPmAgZWxlbWVudCBpcyBiZWluZyBjcmVhdGVkIGFuZCBhcHBlbmRlZCB0byB0aGUgcm9vdCBlbGVtZW50LlxuICogMi4gVGhlIFdlYkdMUmVuZGVyZXIgaXMgYmVpbmcgaW5zdGFudGlhdGVkLlxuICogMy4gVGhlIHNpemUgb2YgdGhlIFdlYkdMUmVuZGVyZXIgaXMgYmVpbmcgdXBkYXRlZC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLl9pbml0V2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIF9pbml0V2ViR0xSZW5kZXJlcigpIHtcbiAgICB0aGlzLl93ZWJHTFJlbmRlcmVyUm9vdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5fcm9vdEVsLmFwcGVuZENoaWxkKHRoaXMuX3dlYkdMUmVuZGVyZXJSb290RWwpO1xuXG4gICAgdGhpcy5fd2ViR0xSZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKFxuICAgICAgICB0aGlzLl93ZWJHTFJlbmRlcmVyUm9vdEVsLFxuICAgICAgICB0aGlzLl9jb21wb3NpdG9yXG4gICAgKTtcblxuICAgIC8vIERvbid0IHJlYWQgb2Zmc2V0IHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgdGhpcy5fd2ViR0xSZW5kZXJlci51cGRhdGVTaXplKHRoaXMuX3NpemUpO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIHRoZSBwYXJlbnQgZWxlbWVudCBvZiB0aGUgRE9NUmVuZGVyZXIgZm9yIHRoaXMgY29udGV4dC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuZ2V0Um9vdFNpemUgPSBmdW5jdGlvbiBnZXRSb290U2l6ZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB0aGlzLl9yb290RWwub2Zmc2V0V2lkdGgsXG4gICAgICAgIHRoaXMuX3Jvb3RFbC5vZmZzZXRIZWlnaHRcbiAgICBdO1xufTtcblxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBjb250ZXh0IGlmIHRoZSBgUkVBRFlgIGNvbW1hbmQgaGFzIGJlZW4gcmVjZWl2ZWQgZWFybGllci5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5Db250ZXh0LnByb3RvdHlwZS5jaGVja0luaXQgPSBmdW5jdGlvbiBjaGVja0luaXQgKCkge1xuICAgIGlmICh0aGlzLl9pbml0RE9NKSB7XG4gICAgICAgIHRoaXMuX2RvbVJlbmRlcmVyUm9vdEVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLl9pbml0RE9NID0gZmFsc2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGRlbGVnYXRpb24gb2YgY29tbWFuZHMgdG8gcmVuZGVyZXJzIG9mIHRoaXMgY29udGV4dC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggU3RyaW5nIHVzZWQgYXMgaWRlbnRpZmllciBvZiBhIGdpdmVuIG5vZGUgaW4gdGhlXG4gKiBzY2VuZSBncmFwaC5cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbW1hbmRzIExpc3Qgb2YgYWxsIGNvbW1hbmRzIGZyb20gdGhpcyBmcmFtZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpdGVyYXRvciBOdW1iZXIgaW5kaWNhdGluZyBwcm9ncmVzcyB0aHJvdWdoIHRoZSBjb21tYW5kXG4gKiBxdWV1ZS5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGl0ZXJhdG9yIGluZGljYXRpbmcgcHJvZ3Jlc3MgdGhyb3VnaCB0aGUgY29tbWFuZCBxdWV1ZS5cbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uIHJlY2VpdmUocGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgdmFyIGxvY2FsSXRlcmF0b3IgPSBpdGVyYXRvcjtcblxuICAgIHZhciBjb21tYW5kID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcblxuICAgIHRoaXMuX2RvbVJlbmRlcmVyLmxvYWRQYXRoKHBhdGgpO1xuICAgIHRoaXMuX2RvbVJlbmRlcmVyLmZpbmRUYXJnZXQoKTtcblxuICAgIHdoaWxlIChjb21tYW5kICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGNvbW1hbmQgPT09IENvbW1hbmRzLldJVEggfHwgY29tbWFuZCA9PT0gQ29tbWFuZHMuVElNRSkgcmV0dXJuIGxvY2FsSXRlcmF0b3IgLSAxO1xuICAgICAgICBlbHNlIGxvY2FsSXRlcmF0b3IgPSB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW2NvbW1hbmRdKHRoaXMsIHBhdGgsIGNvbW1hbmRzLCBsb2NhbEl0ZXJhdG9yKSArIDE7IFxuICAgICAgICBjb21tYW5kID0gY29tbWFuZHNbbG9jYWxJdGVyYXRvcl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvY2FsSXRlcmF0b3I7XG59O1xuXG4vKipcbiAqIEdldHRlciBtZXRob2QgdXNlZCBmb3IgcmV0cmlldmluZyB0aGUgdXNlZCBET01SZW5kZXJlci5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7RE9NUmVuZGVyZXJ9ICAgIFRoZSBET01SZW5kZXJlciBiZWluZyB1c2VkIGJ5IHRoZSBDb250ZXh0LlxuICovXG5Db250ZXh0LnByb3RvdHlwZS5nZXRET01SZW5kZXJlciA9IGZ1bmN0aW9uIGdldERPTVJlbmRlcmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9kb21SZW5kZXJlcjtcbn07XG5cbi8qKlxuICogR2V0dGVyIG1ldGhvZCB1c2VkIGZvciByZXRyaWV2aW5nIHRoZSB1c2VkIFdlYkdMUmVuZGVyZXIgKGlmIGFueSkuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge1dlYkdMUmVuZGVyZXJ8bnVsbH0gICAgVGhlIFdlYkdMUmVuZGVyZXIgYmVpbmcgdXNlZCBieSB0aGUgQ29udGV4dC5cbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuZ2V0V2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIGdldFdlYkdMUmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYkdMUmVuZGVyZXI7XG59O1xuXG4vLyBDb21tYW5kIENhbGxiYWNrc1xuZnVuY3Rpb24gcHJldmVudERlZmF1bHQgKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGlmIChjb250ZXh0Ll93ZWJHTFJlbmRlcmVyKSBjb250ZXh0Ll93ZWJHTFJlbmRlcmVyLmdldE9yU2V0Q3V0b3V0KHBhdGgpO1xuICAgIGNvbnRleHQuX2RvbVJlbmRlcmVyLnByZXZlbnREZWZhdWx0KGNvbW1hbmRzWysraXRlcmF0b3JdKTtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGFsbG93RGVmYXVsdCAoY29udGV4dCwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgaWYgKGNvbnRleHQuX3dlYkdMUmVuZGVyZXIpIGNvbnRleHQuX3dlYkdMUmVuZGVyZXIuZ2V0T3JTZXRDdXRvdXQocGF0aCk7XG4gICAgY29udGV4dC5fZG9tUmVuZGVyZXIuYWxsb3dEZWZhdWx0KGNvbW1hbmRzWysraXRlcmF0b3JdKTtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIHJlYWR5IChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICBjb250ZXh0Ll9pbml0RE9NID0gdHJ1ZTtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGluaXRET00gKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGNvbnRleHQuX2RvbVJlbmRlcmVyLmluc2VydEVsKGNvbW1hbmRzWysraXRlcmF0b3JdKTtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGRvbVJlbmRlclNpemUgKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGNvbnRleHQuX2RvbVJlbmRlcmVyLmdldFNpemVPZihjb21tYW5kc1srK2l0ZXJhdG9yXSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBjaGFuZ2VUcmFuc2Zvcm0gKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIHZhciB0ZW1wID0gY29udGV4dC5fbWVzaFRyYW5zZm9ybTtcblxuICAgIHRlbXBbMF0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICB0ZW1wWzFdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgdGVtcFsyXSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIHRlbXBbM10gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICB0ZW1wWzRdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgdGVtcFs1XSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIHRlbXBbNl0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICB0ZW1wWzddID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgdGVtcFs4XSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIHRlbXBbOV0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICB0ZW1wWzEwXSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIHRlbXBbMTFdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgdGVtcFsxMl0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICB0ZW1wWzEzXSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIHRlbXBbMTRdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgdGVtcFsxNV0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcblxuICAgIGNvbnRleHQuX2RvbVJlbmRlcmVyLnNldE1hdHJpeCh0ZW1wKTtcbiAgICBcbiAgICBpZiAoY29udGV4dC5fd2ViR0xSZW5kZXJlcilcbiAgICAgICAgY29udGV4dC5fd2ViR0xSZW5kZXJlci5zZXRDdXRvdXRVbmlmb3JtKHBhdGgsICd1X3RyYW5zZm9ybScsIHRlbXApO1xuXG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBjaGFuZ2VTaXplIChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICB2YXIgd2lkdGggPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICB2YXIgaGVpZ2h0ID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG5cbiAgICBjb250ZXh0Ll9kb21SZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChjb250ZXh0Ll93ZWJHTFJlbmRlcmVyKSB7XG4gICAgICAgIGNvbnRleHQuX21lc2hTaXplWzBdID0gd2lkdGg7XG4gICAgICAgIGNvbnRleHQuX21lc2hTaXplWzFdID0gaGVpZ2h0O1xuICAgICAgICBjb250ZXh0Ll93ZWJHTFJlbmRlcmVyLnNldEN1dG91dFVuaWZvcm0ocGF0aCwgJ3Vfc2l6ZScsIGNvbnRleHQuX21lc2hTaXplKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBjaGFuZ2VQcm9wZXJ0eSAoY29udGV4dCwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgaWYgKGNvbnRleHQuX3dlYkdMUmVuZGVyZXIpIGNvbnRleHQuX3dlYkdMUmVuZGVyZXIuZ2V0T3JTZXRDdXRvdXQocGF0aCk7XG4gICAgY29udGV4dC5fZG9tUmVuZGVyZXIuc2V0UHJvcGVydHkoY29tbWFuZHNbKytpdGVyYXRvcl0sIGNvbW1hbmRzWysraXRlcmF0b3JdKTtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZUNvbnRlbnQgKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGlmIChjb250ZXh0Ll93ZWJHTFJlbmRlcmVyKSBjb250ZXh0Ll93ZWJHTFJlbmRlcmVyLmdldE9yU2V0Q3V0b3V0KHBhdGgpO1xuICAgIGNvbnRleHQuX2RvbVJlbmRlcmVyLnNldENvbnRlbnQoY29tbWFuZHNbKytpdGVyYXRvcl0pO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbn1cbiAgXG5mdW5jdGlvbiBjaGFuZ2VBdHRyaWJ1dGUgKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGlmIChjb250ZXh0Ll93ZWJHTFJlbmRlcmVyKSBjb250ZXh0Ll93ZWJHTFJlbmRlcmVyLmdldE9yU2V0Q3V0b3V0KHBhdGgpO1xuICAgIGNvbnRleHQuX2RvbVJlbmRlcmVyLnNldEF0dHJpYnV0ZShjb21tYW5kc1srK2l0ZXJhdG9yXSwgY29tbWFuZHNbKytpdGVyYXRvcl0pO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ2xhc3MgKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGlmIChjb250ZXh0Ll93ZWJHTFJlbmRlcmVyKSBjb250ZXh0Ll93ZWJHTFJlbmRlcmVyLmdldE9yU2V0Q3V0b3V0KHBhdGgpO1xuICAgIGNvbnRleHQuX2RvbVJlbmRlcmVyLmFkZENsYXNzKGNvbW1hbmRzWysraXRlcmF0b3JdKTtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICBpZiAoY29udGV4dC5fd2ViR0xSZW5kZXJlcikgY29udGV4dC5fd2ViR0xSZW5kZXJlci5nZXRPclNldEN1dG91dChwYXRoKTtcbiAgICBjb250ZXh0Ll9kb21SZW5kZXJlci5yZW1vdmVDbGFzcyhjb21tYW5kc1srK2l0ZXJhdG9yXSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUgKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGlmIChjb250ZXh0Ll93ZWJHTFJlbmRlcmVyKSBjb250ZXh0Ll93ZWJHTFJlbmRlcmVyLmdldE9yU2V0Q3V0b3V0KHBhdGgpO1xuICAgIGNvbnRleHQuX2RvbVJlbmRlcmVyLnN1YnNjcmliZShjb21tYW5kc1srK2l0ZXJhdG9yXSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBnbFNldERyYXdPcHRpb25zIChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICBpZiAoIWNvbnRleHQuX3dlYkdMUmVuZGVyZXIpIGNvbnRleHQuX2luaXRXZWJHTFJlbmRlcmVyKCk7XG4gICAgY29udGV4dC5fd2ViR0xSZW5kZXJlci5zZXRNZXNoT3B0aW9ucyhwYXRoLCBjb21tYW5kc1srK2l0ZXJhdG9yXSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBnbEFtYmllbnRMaWdodCAoY29udGV4dCwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgaWYgKCFjb250ZXh0Ll93ZWJHTFJlbmRlcmVyKSBjb250ZXh0Ll9pbml0V2ViR0xSZW5kZXJlcigpO1xuICAgIGNvbnRleHQuX3dlYkdMUmVuZGVyZXIuc2V0QW1iaWVudExpZ2h0Q29sb3IoXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGNvbW1hbmRzWysraXRlcmF0b3JdLFxuICAgICAgICBjb21tYW5kc1srK2l0ZXJhdG9yXSxcbiAgICAgICAgY29tbWFuZHNbKytpdGVyYXRvcl1cbiAgICApO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gZ2xMaWdodFBvc2l0aW9uIChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICBpZiAoIWNvbnRleHQuX3dlYkdMUmVuZGVyZXIpIGNvbnRleHQuX2luaXRXZWJHTFJlbmRlcmVyKCk7XG4gICAgY29udGV4dC5fd2ViR0xSZW5kZXJlci5zZXRMaWdodFBvc2l0aW9uKFxuICAgICAgICBwYXRoLFxuICAgICAgICBjb21tYW5kc1srK2l0ZXJhdG9yXSxcbiAgICAgICAgY29tbWFuZHNbKytpdGVyYXRvcl0sXG4gICAgICAgIGNvbW1hbmRzWysraXRlcmF0b3JdXG4gICAgKTtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGdsTGlnaHRDb2xvciAoY29udGV4dCwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgaWYgKCFjb250ZXh0Ll93ZWJHTFJlbmRlcmVyKSBjb250ZXh0Ll9pbml0V2ViR0xSZW5kZXJlcigpO1xuICAgIGNvbnRleHQuX3dlYkdMUmVuZGVyZXIuc2V0TGlnaHRDb2xvcihcbiAgICAgICAgcGF0aCxcbiAgICAgICAgY29tbWFuZHNbKytpdGVyYXRvcl0sXG4gICAgICAgIGNvbW1hbmRzWysraXRlcmF0b3JdLFxuICAgICAgICBjb21tYW5kc1srK2l0ZXJhdG9yXVxuICAgICk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBtYXRlcmlhbElucHV0IChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICBpZiAoIWNvbnRleHQuX3dlYkdMUmVuZGVyZXIpIGNvbnRleHQuX2luaXRXZWJHTFJlbmRlcmVyKCk7XG4gICAgY29udGV4dC5fd2ViR0xSZW5kZXJlci5oYW5kbGVNYXRlcmlhbElucHV0KFxuICAgICAgICBwYXRoLFxuICAgICAgICBjb21tYW5kc1srK2l0ZXJhdG9yXSxcbiAgICAgICAgY29tbWFuZHNbKytpdGVyYXRvcl1cbiAgICApO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gZ2xTZXRHZW9tZXRyeSAoY29udGV4dCwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgaWYgKCFjb250ZXh0Ll93ZWJHTFJlbmRlcmVyKSBjb250ZXh0Ll9pbml0V2ViR0xSZW5kZXJlcigpO1xuICAgIGNvbnRleHQuX3dlYkdMUmVuZGVyZXIuc2V0R2VvbWV0cnkoXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGNvbW1hbmRzWysraXRlcmF0b3JdLFxuICAgICAgICBjb21tYW5kc1srK2l0ZXJhdG9yXSxcbiAgICAgICAgY29tbWFuZHNbKytpdGVyYXRvcl1cbiAgICApO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gZ2xVbmlmb3JtcyAoY29udGV4dCwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgaWYgKCFjb250ZXh0Ll93ZWJHTFJlbmRlcmVyKSBjb250ZXh0Ll9pbml0V2ViR0xSZW5kZXJlcigpO1xuICAgIGNvbnRleHQuX3dlYkdMUmVuZGVyZXIuc2V0TWVzaFVuaWZvcm0oXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGNvbW1hbmRzWysraXRlcmF0b3JdLFxuICAgICAgICBjb21tYW5kc1srK2l0ZXJhdG9yXVxuICAgICk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBnbEJ1ZmZlckRhdGEgKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGlmICghY29udGV4dC5fd2ViR0xSZW5kZXJlcikgY29udGV4dC5faW5pdFdlYkdMUmVuZGVyZXIoKTtcbiAgICBjb250ZXh0Ll93ZWJHTFJlbmRlcmVyLmJ1ZmZlckRhdGEoXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGNvbW1hbmRzWysraXRlcmF0b3JdLFxuICAgICAgICBjb21tYW5kc1srK2l0ZXJhdG9yXSxcbiAgICAgICAgY29tbWFuZHNbKytpdGVyYXRvcl0sXG4gICAgICAgIGNvbW1hbmRzWysraXRlcmF0b3JdLFxuICAgICAgICBjb21tYW5kc1srK2l0ZXJhdG9yXVxuICAgICk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBnbEN1dG91dFN0YXRlIChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICBpZiAoIWNvbnRleHQuX3dlYkdMUmVuZGVyZXIpIGNvbnRleHQuX2luaXRXZWJHTFJlbmRlcmVyKCk7XG4gICAgY29udGV4dC5fd2ViR0xSZW5kZXJlci5zZXRDdXRvdXRTdGF0ZShwYXRoLCBjb21tYW5kc1srK2l0ZXJhdG9yXSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBnbE1lc2hWaXNpYmlsaXR5IChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICBpZiAoIWNvbnRleHQuX3dlYkdMUmVuZGVyZXIpIGNvbnRleHQuX2luaXRXZWJHTFJlbmRlcmVyKCk7XG4gICAgY29udGV4dC5fd2ViR0xSZW5kZXJlci5zZXRNZXNoVmlzaWJpbGl0eShwYXRoLCBjb21tYW5kc1srK2l0ZXJhdG9yXSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBnbFJlbW92ZU1lc2ggKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGlmICghY29udGV4dC5fd2ViR0xSZW5kZXJlcikgY29udGV4dC5faW5pdFdlYkdMUmVuZGVyZXIoKTtcbiAgICBjb250ZXh0Ll93ZWJHTFJlbmRlcmVyLnJlbW92ZU1lc2gocGF0aCk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBwaW5ob2xlUHJvamVjdGlvbiAoY29udGV4dCwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUucHJvamVjdGlvblR5cGUgPSBDYW1lcmEuUElOSE9MRV9QUk9KRUNUSU9OO1xuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzExXSA9IC0xIC8gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVEaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBvcnRob2dyYXBoaWNQcm9qZWN0aW9uIChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS5wcm9qZWN0aW9uVHlwZSA9IENhbWVyYS5PUlRIT0dSQVBISUNfUFJPSkVDVElPTjtcbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMV0gPSAwO1xuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnBlcnNwZWN0aXZlRGlydHkgPSB0cnVlO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gY2hhbmdlVmlld1RyYW5zZm9ybSAoY29udGV4dCwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVswXSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bMV0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzJdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVszXSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuXG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVs0XSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bNV0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzZdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVs3XSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuXG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVs4XSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bOV0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzEwXSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bMTFdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG5cbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzEyXSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bMTNdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVsxNF0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzE1XSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuXG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUudmlld0RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGV4dDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbW1hbmRzID0gcmVxdWlyZSgnLi4vY29yZS9Db21tYW5kcycpO1xuXG4vKipcbiAqIFRoZSBVSU1hbmFnZXIgaXMgYmVpbmcgdXBkYXRlZCBieSBhbiBFbmdpbmUgYnkgY29uc2VjdXRpdmVseSBjYWxsaW5nIGl0c1xuICogYHVwZGF0ZWAgbWV0aG9kLiBJdCBjYW4gZWl0aGVyIG1hbmFnZSBhIHJlYWwgV2ViLVdvcmtlciBvciB0aGUgZ2xvYmFsXG4gKiBGYW1vdXNFbmdpbmUgY29yZSBzaW5nbGV0b24uXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBjb21wb3NpdG9yID0gbmV3IENvbXBvc2l0b3IoKTtcbiAqIHZhciBlbmdpbmUgPSBuZXcgRW5naW5lKCk7XG4gKlxuICogLy8gVXNpbmcgYSBXZWIgV29ya2VyXG4gKiB2YXIgd29ya2VyID0gbmV3IFdvcmtlcignd29ya2VyLmJ1bmRsZS5qcycpO1xuICogdmFyIHRocmVhZG1hbmdlciA9IG5ldyBVSU1hbmFnZXIod29ya2VyLCBjb21wb3NpdG9yLCBlbmdpbmUpO1xuICpcbiAqIC8vIFdpdGhvdXQgdXNpbmcgYSBXZWIgV29ya2VyXG4gKiB2YXIgdGhyZWFkbWFuZ2VyID0gbmV3IFVJTWFuYWdlcihGYW1vdXMsIGNvbXBvc2l0b3IsIGVuZ2luZSk7XG4gKlxuICogQGNsYXNzICBVSU1hbmFnZXJcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7RmFtb3VzfFdvcmtlcn0gdGhyZWFkIFRoZSB0aHJlYWQgYmVpbmcgdXNlZCB0byByZWNlaXZlIG1lc3NhZ2VzXG4gKiBmcm9tIGFuZCBwb3N0IG1lc3NhZ2VzIHRvLiBFeHBlY3RlZCB0byBleHBvc2UgYSBXZWJXb3JrZXItbGlrZSBBUEksIHdoaWNoXG4gKiBtZWFucyBwcm92aWRpbmcgYSB3YXkgdG8gbGlzdGVuIGZvciB1cGRhdGVzIGJ5IHNldHRpbmcgaXRzIGBvbm1lc3NhZ2VgXG4gKiBwcm9wZXJ0eSBhbmQgc2VuZGluZyB1cGRhdGVzIHVzaW5nIGBwb3N0TWVzc2FnZWAuXG4gKiBAcGFyYW0ge0NvbXBvc2l0b3J9IGNvbXBvc2l0b3IgYW4gaW5zdGFuY2Ugb2YgQ29tcG9zaXRvciB1c2VkIHRvIGV4dHJhY3RcbiAqIGVucXVldWVkIGRyYXcgY29tbWFuZHMgZnJvbSB0byBiZSBzZW50IHRvIHRoZSB0aHJlYWQuXG4gKiBAcGFyYW0ge1JlbmRlckxvb3B9IHJlbmRlckxvb3AgYW4gaW5zdGFuY2Ugb2YgRW5naW5lIHVzZWQgZm9yIGV4ZWN1dGluZ1xuICogdGhlIGBFTkdJTkVgIGNvbW1hbmRzIG9uLlxuICovXG5mdW5jdGlvbiBVSU1hbmFnZXIgKHRocmVhZCwgY29tcG9zaXRvciwgcmVuZGVyTG9vcCkge1xuICAgIHRoaXMuX3RocmVhZCA9IHRocmVhZDtcbiAgICB0aGlzLl9jb21wb3NpdG9yID0gY29tcG9zaXRvcjtcbiAgICB0aGlzLl9yZW5kZXJMb29wID0gcmVuZGVyTG9vcDtcblxuICAgIHRoaXMuX3JlbmRlckxvb3AudXBkYXRlKHRoaXMpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl90aHJlYWQub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gZXYuZGF0YSA/IGV2LmRhdGEgOiBldjtcbiAgICAgICAgaWYgKG1lc3NhZ2VbMF0gPT09IENvbW1hbmRzLkVOR0lORSkge1xuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlWzFdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TVEFSVDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VuZ2luZS5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbW1hbmRzLlNUT1A6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9lbmdpbmUuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1Vua25vd24gRU5HSU5FIGNvbW1hbmQgXCInICsgbWVzc2FnZVsxXSArICdcIidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5fY29tcG9zaXRvci5yZWNlaXZlQ29tbWFuZHMobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX3RocmVhZC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdGhyZWFkIGJlaW5nIHVzZWQgYnkgdGhlIFVJTWFuYWdlci5cbiAqIFRoaXMgY291bGQgZWl0aGVyIGJlIGFuIGFuIGFjdHVhbCB3ZWIgd29ya2VyIG9yIGEgYEZhbW91c0VuZ2luZWAgc2luZ2xldG9uLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtXb3JrZXJ8RmFtb3VzRW5naW5lfSBFaXRoZXIgYSB3ZWIgd29ya2VyIG9yIGEgYEZhbW91c0VuZ2luZWAgc2luZ2xldG9uLlxuICovXG5VSU1hbmFnZXIucHJvdG90eXBlLmdldFRocmVhZCA9IGZ1bmN0aW9uIGdldFRocmVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhyZWFkO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb21wb3NpdG9yIGJlaW5nIHVzZWQgYnkgdGhpcyBVSU1hbmFnZXIuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0NvbXBvc2l0b3J9IFRoZSBjb21wb3NpdG9yIHVzZWQgYnkgdGhlIFVJTWFuYWdlci5cbiAqL1xuVUlNYW5hZ2VyLnByb3RvdHlwZS5nZXRDb21wb3NpdG9yID0gZnVuY3Rpb24gZ2V0Q29tcG9zaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9zaXRvcjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZW5naW5lIGJlaW5nIHVzZWQgYnkgdGhpcyBVSU1hbmFnZXIuXG4gKlxuICogQG1ldGhvZFxuICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBVSU1hbmFnZXIjZ2V0UmVuZGVyTG9vcCBpbnN0ZWFkIX1cbiAqXG4gKiBAcmV0dXJuIHtFbmdpbmV9IFRoZSBlbmdpbmUgdXNlZCBieSB0aGUgVUlNYW5hZ2VyLlxuICovXG5VSU1hbmFnZXIucHJvdG90eXBlLmdldEVuZ2luZSA9IGZ1bmN0aW9uIGdldEVuZ2luZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyTG9vcDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZW5kZXIgbG9vcCBjdXJyZW50bHkgYmVpbmcgdXNlZCBieSB0aGUgVUlNYW5hZ2VyLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtSZW5kZXJMb29wfSAgVGhlIHJlZ2lzdGVyZWQgcmVuZGVyIGxvb3AgdXNlZCBmb3IgdXBkYXRpbmcgdGhlXG4gKiBVSU1hbmFnZXIuXG4gKi9cblVJTWFuYWdlci5wcm90b3R5cGUuZ2V0UmVuZGVyTG9vcCA9IGZ1bmN0aW9uIGdldFJlbmRlckxvb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlckxvb3A7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBtZXRob2QgYmVpbmcgaW52b2tlZCBieSB0aGUgRW5naW5lIG9uIGV2ZXJ5IGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICogVXNlZCBmb3IgdXBkYXRpbmcgdGhlIG5vdGlvbiBvZiB0aW1lIHdpdGhpbiB0aGUgbWFuYWdlZCB0aHJlYWQgYnkgc2VuZGluZ1xuICogYSBGUkFNRSBjb21tYW5kIGFuZCBzZW5kaW5nIG1lc3NhZ2VzIHRvXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gdGltZSB1bml4IHRpbWVzdGFtcCB0byBiZSBwYXNzZWQgZG93biB0byB0aGUgd29ya2VyIGFzIGFcbiAqIEZSQU1FIGNvbW1hbmRcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblVJTWFuYWdlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICh0aW1lKSB7XG4gICAgdGhpcy5fdGhyZWFkLnBvc3RNZXNzYWdlKFtDb21tYW5kcy5GUkFNRSwgdGltZV0pO1xuICAgIHZhciB0aHJlYWRNZXNzYWdlcyA9IHRoaXMuX2NvbXBvc2l0b3IuZHJhd0NvbW1hbmRzKCk7XG4gICAgdGhpcy5fdGhyZWFkLnBvc3RNZXNzYWdlKHRocmVhZE1lc3NhZ2VzKTtcbiAgICB0aGlzLl9jb21wb3NpdG9yLmNsZWFyQ29tbWFuZHMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVUlNYW5hZ2VyO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3NzID0gJy5mYW1vdXMtZG9tLXJlbmRlcmVyIHsnICtcbiAgICAnd2lkdGg6MTAwJTsnICtcbiAgICAnaGVpZ2h0OjEwMCU7JyArXG4gICAgJ3RyYW5zZm9ybS1zdHlsZTpwcmVzZXJ2ZS0zZDsnICtcbiAgICAnLXdlYmtpdC10cmFuc2Zvcm0tc3R5bGU6cHJlc2VydmUtM2Q7JyArXG4nfScgK1xuXG4nLmZhbW91cy1kb20tZWxlbWVudCB7JyArXG4gICAgJy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjowJSAwJTsnICtcbiAgICAndHJhbnNmb3JtLW9yaWdpbjowJSAwJTsnICtcbiAgICAnLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OnZpc2libGU7JyArXG4gICAgJ2JhY2tmYWNlLXZpc2liaWxpdHk6dmlzaWJsZTsnICtcbiAgICAnLXdlYmtpdC10cmFuc2Zvcm0tc3R5bGU6cHJlc2VydmUtM2Q7JyArXG4gICAgJ3RyYW5zZm9ybS1zdHlsZTpwcmVzZXJ2ZS0zZDsnICtcbiAgICAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50OycgK1xuICAgICdwb2ludGVyLWV2ZW50czphdXRvOycgK1xuICAgICd6LWluZGV4OjE7JyArXG4nfScgK1xuXG4nLmZhbW91cy1kb20tZWxlbWVudC1jb250ZW50LCcgK1xuJy5mYW1vdXMtZG9tLWVsZW1lbnQgeycgK1xuICAgICdwb3NpdGlvbjphYnNvbHV0ZTsnICtcbiAgICAnYm94LXNpemluZzpib3JkZXItYm94OycgK1xuICAgICctbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDsnICtcbiAgICAnLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7JyArXG4nfScgK1xuXG4nLmZhbW91cy13ZWJnbC1yZW5kZXJlciB7JyArXG4gICAgJy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVooMTAwMDAwMHB4KTsnICsgIC8qIFRPRE86IEZpeCB3aGVuIFNhZmFyaSBGaXhlcyovXG4gICAgJ3RyYW5zZm9ybTp0cmFuc2xhdGVaKDEwMDAwMDBweCk7JyArXG4gICAgJ3BvaW50ZXItZXZlbnRzOm5vbmU7JyArXG4gICAgJ3Bvc2l0aW9uOmFic29sdXRlOycgK1xuICAgICd6LWluZGV4OjE7JyArXG4gICAgJ3RvcDowOycgK1xuICAgICd3aWR0aDoxMDAlOycgK1xuICAgICdoZWlnaHQ6MTAwJTsnICtcbid9JztcblxudmFyIElOSkVDVEVEID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJztcblxuZnVuY3Rpb24gaW5qZWN0Q1NTKCkge1xuICAgIGlmIChJTkpFQ1RFRCkgcmV0dXJuO1xuICAgIElOSkVDVEVEID0gdHJ1ZTtcbiAgICBpZiAoZG9jdW1lbnQuY3JlYXRlU3R5bGVTaGVldCkge1xuICAgICAgICB2YXIgc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVTdHlsZVNoZWV0KCk7XG4gICAgICAgIHNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgKGhlYWQgPyBoZWFkIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluamVjdENTUztcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNoaW50IC1XMDA4ICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGxpYnJhcnkgb2YgY3VydmVzIHdoaWNoIG1hcCBhbiBhbmltYXRpb24gZXhwbGljaXRseSBhcyBhIGZ1bmN0aW9uIG9mIHRpbWUuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGluZWFyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlYXNlSW5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVhc2VPdXRcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVhc2VJbk91dFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZWFzZU91dEJvdW5jZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc3ByaW5nXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpblF1YWRcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG91dFF1YWRcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGluT3V0UXVhZFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5DdWJpY1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb3V0Q3ViaWNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGluT3V0Q3ViaWNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGluUXVhcnRcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG91dFF1YXJ0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpbk91dFF1YXJ0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpblF1aW50XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvdXRRdWludFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5PdXRRdWludFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5TaW5lXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvdXRTaW5lXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpbk91dFNpbmVcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGluRXhwb1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb3V0RXhwb1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5PdXRFeHBcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGluQ2lyY1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb3V0Q2lyY1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5PdXRDaXJjXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpbkVsYXN0aWNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG91dEVsYXN0aWNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGluT3V0RWxhc3RpY1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5Cb3VuY2VcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG91dEJvdW5jZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5PdXRCb3VuY2VcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZsYXQgICAgICAgICAgICAtIFVzZWZ1bCBmb3IgZGVsYXlpbmcgdGhlIGV4ZWN1dGlvbiBvZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBzdWJzZXF1ZW50IHRyYW5zaXRpb24uXG4gKi9cbnZhciBDdXJ2ZXMgPSB7XG4gICAgbGluZWFyOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0sXG5cbiAgICBlYXNlSW46IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdDtcbiAgICB9LFxuXG4gICAgZWFzZU91dDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCooMi10KTtcbiAgICB9LFxuXG4gICAgZWFzZUluT3V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0IDw9IDAuNSkgcmV0dXJuIDIqdCp0O1xuICAgICAgICBlbHNlIHJldHVybiAtMip0KnQgKyA0KnQgLSAxO1xuICAgIH0sXG5cbiAgICBlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KigzIC0gMip0KTtcbiAgICB9LFxuXG4gICAgc3ByaW5nOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAoMSAtIHQpICogTWF0aC5zaW4oNiAqIE1hdGguUEkgKiB0KSArIHQ7XG4gICAgfSxcblxuICAgIGluUXVhZDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0O1xuICAgIH0sXG5cbiAgICBvdXRRdWFkOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAtKHQtPTEpKnQrMTtcbiAgICB9LFxuXG4gICAgaW5PdXRRdWFkOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41KnQqdDtcbiAgICAgICAgcmV0dXJuIC0uNSooKC0tdCkqKHQtMikgLSAxKTtcbiAgICB9LFxuXG4gICAgaW5DdWJpYzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0KnQ7XG4gICAgfSxcblxuICAgIG91dEN1YmljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAoKC0tdCkqdCp0ICsgMSk7XG4gICAgfSxcblxuICAgIGluT3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqdCp0KnQ7XG4gICAgICAgIHJldHVybiAuNSooKHQtPTIpKnQqdCArIDIpO1xuICAgIH0sXG5cbiAgICBpblF1YXJ0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KnQqdCp0O1xuICAgIH0sXG5cbiAgICBvdXRRdWFydDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLSgoLS10KSp0KnQqdCAtIDEpO1xuICAgIH0sXG5cbiAgICBpbk91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41KnQqdCp0KnQ7XG4gICAgICAgIHJldHVybiAtLjUgKiAoKHQtPTIpKnQqdCp0IC0gMik7XG4gICAgfSxcblxuICAgIGluUXVpbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdCp0KnQqdDtcbiAgICB9LFxuXG4gICAgb3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICgoLS10KSp0KnQqdCp0ICsgMSk7XG4gICAgfSxcblxuICAgIGluT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqdCp0KnQqdCp0O1xuICAgICAgICByZXR1cm4gLjUqKCh0LT0yKSp0KnQqdCp0ICsgMik7XG4gICAgfSxcblxuICAgIGluU2luZTogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLTEuMCpNYXRoLmNvcyh0ICogKE1hdGguUEkvMikpICsgMS4wO1xuICAgIH0sXG5cbiAgICBvdXRTaW5lOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpbih0ICogKE1hdGguUEkvMikpO1xuICAgIH0sXG5cbiAgICBpbk91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0uNSooTWF0aC5jb3MoTWF0aC5QSSp0KSAtIDEpO1xuICAgIH0sXG5cbiAgICBpbkV4cG86IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICh0PT09MCkgPyAwLjAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuICAgIH0sXG5cbiAgICBvdXRFeHBvOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAodD09PTEuMCkgPyAxLjAgOiAoLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSk7XG4gICAgfSxcblxuICAgIGluT3V0RXhwbzogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAodD09PTApIHJldHVybiAwLjA7XG4gICAgICAgIGlmICh0PT09MS4wKSByZXR1cm4gMS4wO1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG4gICAgICAgIHJldHVybiAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpO1xuICAgIH0sXG5cbiAgICBpbkNpcmM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0oTWF0aC5zcXJ0KDEgLSB0KnQpIC0gMSk7XG4gICAgfSxcblxuICAgIG91dENpcmM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgxIC0gKC0tdCkqdCk7XG4gICAgfSxcblxuICAgIGluT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAtLjUgKiAoTWF0aC5zcXJ0KDEgLSB0KnQpIC0gMSk7XG4gICAgICAgIHJldHVybiAuNSAqIChNYXRoLnNxcnQoMSAtICh0LT0yKSp0KSArIDEpO1xuICAgIH0sXG5cbiAgICBpbkVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHM9MS43MDE1ODt2YXIgcD0wO3ZhciBhPTEuMDtcbiAgICAgICAgaWYgKHQ9PT0wKSByZXR1cm4gMC4wOyAgaWYgKHQ9PT0xKSByZXR1cm4gMS4wOyAgaWYgKCFwKSBwPS4zO1xuICAgICAgICBzID0gcC8oMipNYXRoLlBJKSAqIE1hdGguYXNpbigxLjAvYSk7XG4gICAgICAgIHJldHVybiAtKGEqTWF0aC5wb3coMiwxMCoodC09MSkpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvIHApKTtcbiAgICB9LFxuXG4gICAgb3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcz0xLjcwMTU4O3ZhciBwPTA7dmFyIGE9MS4wO1xuICAgICAgICBpZiAodD09PTApIHJldHVybiAwLjA7ICBpZiAodD09PTEpIHJldHVybiAxLjA7ICBpZiAoIXApIHA9LjM7XG4gICAgICAgIHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luKDEuMC9hKTtcbiAgICAgICAgcmV0dXJuIGEqTWF0aC5wb3coMiwtMTAqdCkgKiBNYXRoLnNpbigodC1zKSooMipNYXRoLlBJKS9wKSArIDEuMDtcbiAgICB9LFxuXG4gICAgaW5PdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzPTEuNzAxNTg7dmFyIHA9MDt2YXIgYT0xLjA7XG4gICAgICAgIGlmICh0PT09MCkgcmV0dXJuIDAuMDsgIGlmICgodC89LjUpPT09MikgcmV0dXJuIDEuMDsgIGlmICghcCkgcD0oLjMqMS41KTtcbiAgICAgICAgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4oMS4wL2EpO1xuICAgICAgICBpZiAodCA8IDEpIHJldHVybiAtLjUqKGEqTWF0aC5wb3coMiwxMCoodC09MSkpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvcCkpO1xuICAgICAgICByZXR1cm4gYSpNYXRoLnBvdygyLC0xMCoodC09MSkpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvcCkqLjUgKyAxLjA7XG4gICAgfSxcblxuICAgIGluQmFjazogZnVuY3Rpb24odCwgcykge1xuICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIHQqdCooKHMrMSkqdCAtIHMpO1xuICAgIH0sXG5cbiAgICBvdXRCYWNrOiBmdW5jdGlvbih0LCBzKSB7XG4gICAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHMgPSAxLjcwMTU4O1xuICAgICAgICByZXR1cm4gKCgtLXQpKnQqKChzKzEpKnQgKyBzKSArIDEpO1xuICAgIH0sXG5cbiAgICBpbk91dEJhY2s6IGZ1bmN0aW9uKHQsIHMpIHtcbiAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDEuNzAxNTg7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41Kih0KnQqKCgocyo9KDEuNTI1KSkrMSkqdCAtIHMpKTtcbiAgICAgICAgcmV0dXJuIC41KigodC09MikqdCooKChzKj0oMS41MjUpKSsxKSp0ICsgcykgKyAyKTtcbiAgICB9LFxuXG4gICAgaW5Cb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIDEuMCAtIEN1cnZlcy5vdXRCb3VuY2UoMS4wLXQpO1xuICAgIH0sXG5cbiAgICBvdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQgPCAoMS8yLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqdCp0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0IDwgKDIvMi43NSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoNy41NjI1Kih0LT0oMS41LzIuNzUpKSp0ICsgLjc1KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0IDwgKDIuNS8yLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqKHQtPSgyLjI1LzIuNzUpKSp0ICsgLjkzNzUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqKHQtPSgyLjYyNS8yLjc1KSkqdCArIC45ODQzNzUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0IDwgLjUpIHJldHVybiBDdXJ2ZXMuaW5Cb3VuY2UodCoyKSAqIC41O1xuICAgICAgICByZXR1cm4gQ3VydmVzLm91dEJvdW5jZSh0KjItMS4wKSAqIC41ICsgLjU7XG4gICAgfSxcblxuICAgIGZsYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1cnZlcztcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEN1cnZlcyA9IHJlcXVpcmUoJy4vQ3VydmVzJyk7XG52YXIgRmFtb3VzRW5naW5lID0gcmVxdWlyZSgnLi4vY29yZS9GYW1vdXNFbmdpbmUnKTtcblxuLyoqXG4gKiBBIHN0YXRlIG1haW50YWluZXIgZm9yIGEgc21vb3RoIHRyYW5zaXRpb24gYmV0d2VlblxuICogICAgbnVtZXJpY2FsbHktc3BlY2lmaWVkIHN0YXRlcy4gRXhhbXBsZSBudW1lcmljIHN0YXRlcyBpbmNsdWRlIGZsb2F0cyBhbmRcbiAqICAgIGFycmF5cyBvZiBmbG9hdHMgb2JqZWN0cy5cbiAqXG4gKiBBbiBpbml0aWFsIHN0YXRlIGlzIHNldCB3aXRoIHRoZSBjb25zdHJ1Y3RvciBvciB1c2luZ1xuICogICAgIHtAbGluayBUcmFuc2l0aW9uYWJsZSNmcm9tfS4gU3Vic2VxdWVudCB0cmFuc2l0aW9ucyBjb25zaXN0IG9mIGFuXG4gKiAgICAgaW50ZXJtZWRpYXRlIHN0YXRlLCBlYXNpbmcgY3VydmUsIGR1cmF0aW9uIGFuZCBjYWxsYmFjay4gVGhlIGZpbmFsIHN0YXRlXG4gKiAgICAgb2YgZWFjaCB0cmFuc2l0aW9uIGlzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBzdWJzZXF1ZW50IG9uZS4gQ2FsbHMgdG9cbiAqICAgICB7QGxpbmsgVHJhbnNpdGlvbmFibGUjZ2V0fSBwcm92aWRlIHRoZSBpbnRlcnBvbGF0ZWQgc3RhdGUgYWxvbmcgdGhlIHdheS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gZXZlbnQgbG9vcCBoZXJlIC0gY2FsbHMgdG8ge0BsaW5rIFRyYW5zaXRpb25hYmxlI2dldH1cbiAqICAgIGFyZSB0aGUgb25seSB3YXkgdG8gZmluZCBzdGF0ZSBwcm9qZWN0ZWQgdG8gdGhlIGN1cnJlbnQgKG9yIHByb3ZpZGVkKVxuICogICAgdGltZSBhbmQgYXJlIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGNhbGxiYWNrcyBhbmQgbXV0YXRlIHRoZSBpbnRlcm5hbFxuICogICAgdHJhbnNpdGlvbiBxdWV1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHQgPSBuZXcgVHJhbnNpdGlvbmFibGUoWzAsIDBdKTtcbiAqIHRcbiAqICAgICAudG8oWzEwMCwgMF0sICdsaW5lYXInLCAxMDAwKVxuICogICAgIC5kZWxheSgxMDAwKVxuICogICAgIC50byhbMjAwLCAwXSwgJ291dEJvdW5jZScsIDEwMDApO1xuICpcbiAqIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAqIGRpdi5zdHlsZS5iYWNrZ3JvdW5kID0gJ2JsdWUnO1xuICogZGl2LnN0eWxlLndpZHRoID0gJzEwMHB4JztcbiAqIGRpdi5zdHlsZS5oZWlnaHQgPSAnMTAwcHgnO1xuICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICpcbiAqIGRpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICogICAgIHQuaXNQYXVzZWQoKSA/IHQucmVzdW1lKCkgOiB0LnBhdXNlKCk7XG4gKiB9KTtcbiAqXG4gKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCgpIHtcbiAqICAgICBkaXYuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoJyArIHQuZ2V0KClbMF0gKyAncHgpJyArICcgdHJhbnNsYXRlWSgnICsgdC5nZXQoKVsxXSArICdweCknO1xuICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAqIH0pO1xuICpcbiAqIEBjbGFzcyBUcmFuc2l0aW9uYWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcnxBcnJheS5OdW1iZXJ9IGluaXRpYWxTdGF0ZSAgICBpbml0aWFsIHN0YXRlIHRvIHRyYW5zaXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gLSBlcXVpdmFsZW50IHRvIGEgcHVyc3VhbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludm9jYXRpb24gb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBUcmFuc2l0aW9uYWJsZSNmcm9tfVxuICovXG5mdW5jdGlvbiBUcmFuc2l0aW9uYWJsZShpbml0aWFsU3RhdGUpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX2Zyb20gPSBudWxsO1xuICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICB0aGlzLl9zdGFydGVkQXQgPSBudWxsO1xuICAgIHRoaXMuX3BhdXNlZEF0ID0gbnVsbDtcbiAgICBpZiAoaW5pdGlhbFN0YXRlICE9IG51bGwpIHRoaXMuZnJvbShpbml0aWFsU3RhdGUpO1xufVxuXG4vKipcbiAqIEludGVybmFsIENsb2NrIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBjdXJyZW50IHRpbWUgZm9yIHRoZSBvbmdvaW5nXG4gKiB0cmFuc2l0aW9ucy5cbiAqXG4gKiBAdHlwZSB7UGVyZm9ybWFuY2V8RGF0ZXxDbG9ja31cbiAqL1xuVHJhbnNpdGlvbmFibGUuQ2xvY2sgPSBGYW1vdXNFbmdpbmUuZ2V0Q2xvY2soKTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSB0cmFuc2l0aW9uIHRvIGJlIHB1c2hlZCBvbnRvIHRoZSBpbnRlcm5hbCBxdWV1ZS5cbiAqXG4gKiBAbWV0aG9kIHRvXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfEFycmF5Lk51bWJlcn0gICAgZmluYWxTdGF0ZSAgICAgICAgICAgICAgZmluYWwgc3RhdGUgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRvbiB0b1xuICogQHBhcmFtICB7U3RyaW5nfEZ1bmN0aW9ufSAgICAgICAgW2N1cnZlPUN1cnZlcy5saW5lYXJdICAgZWFzaW5nIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGZvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWzAsIDFdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICBbZHVyYXRpb249MTAwXSAgICAgICAgICBkdXJhdGlvbiBvZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgICAgICAgICAgW2NhbGxiYWNrXSAgICAgICAgICAgICAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGNhbGxlZCBhZnRlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHRyYW5zaXRpb24gaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgICAgICBbbWV0aG9kXSAgICAgICAgICAgICAgICBtZXRob2QgdXNlZCBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLmcuIHNsZXJwKVxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiB0byhmaW5hbFN0YXRlLCBjdXJ2ZSwgZHVyYXRpb24sIGNhbGxiYWNrLCBtZXRob2QpIHtcbiAgICBjdXJ2ZSA9IGN1cnZlICE9IG51bGwgJiYgY3VydmUuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IEN1cnZlc1tjdXJ2ZV0gOiBjdXJ2ZTtcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWRBdCA9IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCk7XG4gICAgICAgIHRoaXMuX3BhdXNlZEF0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fcXVldWUucHVzaChcbiAgICAgICAgZmluYWxTdGF0ZSxcbiAgICAgICAgY3VydmUgIT0gbnVsbCA/IGN1cnZlIDogQ3VydmVzLmxpbmVhcixcbiAgICAgICAgZHVyYXRpb24gIT0gbnVsbCA/IGR1cmF0aW9uIDogMTAwLFxuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgbWV0aG9kXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoZSB0cmFuc2l0aW9uIHF1ZXVlIHRvIGEgc3RhYmxlIGluaXRpYWwgc3RhdGUuXG4gKlxuICogQG1ldGhvZCBmcm9tXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfEFycmF5Lk51bWJlcn0gICAgaW5pdGlhbFN0YXRlICAgIGluaXRpYWwgc3RhdGUgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uIGZyb21cbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSAgICAgICAgIHRoaXNcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiBmcm9tKGluaXRpYWxTdGF0ZSkge1xuICAgIHRoaXMuX3N0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMuX2Zyb20gPSB0aGlzLl9zeW5jKG51bGwsIHRoaXMuX3N0YXRlKTtcbiAgICB0aGlzLl9xdWV1ZS5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3N0YXJ0ZWRBdCA9IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCk7XG4gICAgdGhpcy5fcGF1c2VkQXQgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWxheXMgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZvciBhIGNlcnRhaW4gcGVyaW9kIG9mXG4gKiB0aW1lLlxuICpcbiAqIEBtZXRob2QgZGVsYXlcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICBkdXJhdGlvbiAgICBkZWxheSB0aW1lIGluIG1zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICBbY2FsbGJhY2tdICBaZXJvLWFyZ3VtZW50IGZ1bmN0aW9uIHRvIGNhbGwgb24gb2JzZXJ2ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb24gKHQ9MSlcbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSAgICAgICAgIHRoaXNcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gZGVsYXkoZHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVuZFN0YXRlID0gdGhpcy5fcXVldWUubGVuZ3RoID4gMCA/IHRoaXMuX3F1ZXVlW3RoaXMuX3F1ZXVlLmxlbmd0aCAtIDVdIDogdGhpcy5fc3RhdGU7XG4gICAgcmV0dXJuIHRoaXMudG8oZW5kU3RhdGUsIEN1cnZlcy5mbGF0LCBkdXJhdGlvbiwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZXMgY3VycmVudCB0cmFuc2l0aW9uLlxuICpcbiAqIEBtZXRob2Qgb3ZlcnJpZGVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfSAgICBbZmluYWxTdGF0ZV0gICAgZmluYWwgc3RhdGUgdG8gdHJhbnNpdG9uIHRvXG4gKiBAcGFyYW0gIHtTdHJpbmd8RnVuY3Rpb259ICAgICAgICBbY3VydmVdICAgICAgICAgZWFzaW5nIGZ1bmN0aW9uIHVzZWQgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGluZyBbMCwgMV1cbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICAgICAgICAgIFtkdXJhdGlvbl0gICAgICBkdXJhdGlvbiBvZiB0cmFuc2l0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgICAgICAgICBbY2FsbGJhY2tdICAgICAgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWQgYWZ0ZXIgdGhlIHRyYW5zaXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBjb21wbGV0ZVxuICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgW21ldGhvZF0gICAgICAgIG9wdGlvbmFsIG1ldGhvZCB1c2VkIGZvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpbmcgYmV0d2VlbiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuIFNldCB0byBgc2xlcnBgIGZvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwaGVyaWNhbCBsaW5lYXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uLlxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUub3ZlcnJpZGUgPSBmdW5jdGlvbiBvdmVycmlkZShmaW5hbFN0YXRlLCBjdXJ2ZSwgZHVyYXRpb24sIGNhbGxiYWNrLCBtZXRob2QpIHtcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoZmluYWxTdGF0ZSAhPSBudWxsKSB0aGlzLl9xdWV1ZVswXSA9IGZpbmFsU3RhdGU7XG4gICAgICAgIGlmIChjdXJ2ZSAhPSBudWxsKSAgICAgIHRoaXMuX3F1ZXVlWzFdID0gY3VydmUuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IEN1cnZlc1tjdXJ2ZV0gOiBjdXJ2ZTtcbiAgICAgICAgaWYgKGR1cmF0aW9uICE9IG51bGwpICAgdGhpcy5fcXVldWVbMl0gPSBkdXJhdGlvbjtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpICAgdGhpcy5fcXVldWVbM10gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG1ldGhvZCAhPSBudWxsKSAgICAgdGhpcy5fcXVldWVbNF0gPSBtZXRob2Q7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIFVzZWQgZm9yIGludGVycG9sYXRpbmcgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBzdGF0ZSBvZiB0aGUgY3VycmVudGx5XG4gKiBydW5uaW5nIHRyYW5zaXRpb25cbiAqXG4gKiBAbWV0aG9kICBfaW50ZXJwb2xhdGVcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fE51bWJlcn0gb3V0cHV0ICAgICBXaGVyZSB0byB3cml0ZSB0byAoaW4gb3JkZXIgdG8gYXZvaWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IGFsbG9jYXRpb24gYW5kIHRoZXJlZm9yZSBHQykuXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl8TnVtYmVyfSBmcm9tICAgICAgIFN0YXJ0IHN0YXRlIG9mIGN1cnJlbnQgdHJhbnNpdGlvbi5cbiAqIEBwYXJhbSAge09iamVjdHxBcnJheXxOdW1iZXJ9IHRvICAgICAgICAgRW5kIHN0YXRlIG9mIGN1cnJlbnQgdHJhbnNpdGlvbi5cbiAqIEBwYXJhbSAge051bWJlcn0gcHJvZ3Jlc3MgICAgICAgICAgICAgICAgUHJvZ3Jlc3Mgb2YgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gWzAsIDFdXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1ldGhvZCAgICAgICAgICAgICAgICAgIE1ldGhvZCB1c2VkIGZvciBpbnRlcnBvbGF0aW9uIChlLmcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsZXJwKVxuICogQHJldHVybiB7T2JqZWN0fEFycmF5fE51bWJlcn0gICAgICAgICAgICBvdXRwdXRcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLl9pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIF9pbnRlcnBvbGF0ZShvdXRwdXQsIGZyb20sIHRvLCBwcm9ncmVzcywgbWV0aG9kKSB7XG4gICAgaWYgKHRvIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdzbGVycCcpIHtcbiAgICAgICAgICAgIHZhciB4LCB5LCB6LCB3O1xuICAgICAgICAgICAgdmFyIHF4LCBxeSwgcXosIHF3O1xuICAgICAgICAgICAgdmFyIG9tZWdhLCBjb3NvbWVnYSwgc2lub21lZ2EsIHNjYWxlRnJvbSwgc2NhbGVUbztcblxuICAgICAgICAgICAgeCA9IGZyb21bMF07XG4gICAgICAgICAgICB5ID0gZnJvbVsxXTtcbiAgICAgICAgICAgIHogPSBmcm9tWzJdO1xuICAgICAgICAgICAgdyA9IGZyb21bM107XG5cbiAgICAgICAgICAgIHF4ID0gdG9bMF07XG4gICAgICAgICAgICBxeSA9IHRvWzFdO1xuICAgICAgICAgICAgcXogPSB0b1syXTtcbiAgICAgICAgICAgIHF3ID0gdG9bM107XG5cbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG91dHB1dFswXSA9IHF4O1xuICAgICAgICAgICAgICAgIG91dHB1dFsxXSA9IHF5O1xuICAgICAgICAgICAgICAgIG91dHB1dFsyXSA9IHF6O1xuICAgICAgICAgICAgICAgIG91dHB1dFszXSA9IHF3O1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvc29tZWdhID0gdyAqIHF3ICsgeCAqIHF4ICsgeSAqIHF5ICsgeiAqIHF6O1xuICAgICAgICAgICAgaWYgKCgxLjAgLSBjb3NvbWVnYSkgPiAxZS01KSB7XG4gICAgICAgICAgICAgICAgb21lZ2EgPSBNYXRoLmFjb3MoY29zb21lZ2EpO1xuICAgICAgICAgICAgICAgIHNpbm9tZWdhID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICAgICAgICAgIHNjYWxlRnJvbSA9IE1hdGguc2luKCgxLjAgLSBwcm9ncmVzcykgKiBvbWVnYSkgLyBzaW5vbWVnYTtcbiAgICAgICAgICAgICAgICBzY2FsZVRvID0gTWF0aC5zaW4ocHJvZ3Jlc3MgKiBvbWVnYSkgLyBzaW5vbWVnYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYWxlRnJvbSA9IDEuMCAtIHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIHNjYWxlVG8gPSBwcm9ncmVzcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0cHV0WzBdID0geCAqIHNjYWxlRnJvbSArIHF4ICogc2NhbGVUbztcbiAgICAgICAgICAgIG91dHB1dFsxXSA9IHkgKiBzY2FsZUZyb20gKyBxeSAqIHNjYWxlVG87XG4gICAgICAgICAgICBvdXRwdXRbMl0gPSB6ICogc2NhbGVGcm9tICsgcXogKiBzY2FsZVRvO1xuICAgICAgICAgICAgb3V0cHV0WzNdID0gdyAqIHNjYWxlRnJvbSArIHF3ICogc2NhbGVUbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0byBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbaV0gPSB0aGlzLl9pbnRlcnBvbGF0ZShvdXRwdXRbaV0sIGZyb21baV0sIHRvW2ldLCBwcm9ncmVzcywgbWV0aG9kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0bykge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gdGhpcy5faW50ZXJwb2xhdGUob3V0cHV0W2tleV0sIGZyb21ba2V5XSwgdG9ba2V5XSwgcHJvZ3Jlc3MsIG1ldGhvZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IGZyb20gKyBwcm9ncmVzcyAqICh0byAtIGZyb20pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBtZXRob2QgdXNlZCBmb3Igc3luY2hyb25pemluZyB0aGUgY3VycmVudCwgYWJzb2x1dGUgc3RhdGUgb2ZcbiAqIGEgdHJhbnNpdGlvbiB0byBhIGdpdmVuIG91dHB1dCBhcnJheSwgb2JqZWN0IGxpdGVyYWwgb3IgbnVtYmVyLiBTdXBwb3J0c1xuICogbmVzdGVkIHN0YXRlIG9iamVjdHMgYnkgdGhyb3VnaCByZWN1cnNpb24uXG4gKlxuICogQG1ldGhvZCAgX3N5bmNcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfEFycmF5fE9iamVjdH0gb3V0cHV0ICAgICBXaGVyZSB0byB3cml0ZSB0byAoaW4gb3JkZXIgdG8gYXZvaWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IGFsbG9jYXRpb24gYW5kIHRoZXJlZm9yZSBHQykuXG4gKiBAcGFyYW0gIHtOdW1iZXJ8QXJyYXl8T2JqZWN0fSBpbnB1dCAgICAgIElucHV0IHN0YXRlIHRvIHByb3h5IG9udG8gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5cbiAqIEByZXR1cm4ge051bWJlcnxBcnJheXxPYmplY3R9IG91dHB1dCAgICAgUGFzc2VkIGluIG91dHB1dCBvYmplY3QuXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5fc3luYyA9IGZ1bmN0aW9uIF9zeW5jKG91dHB1dCwgaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykgb3V0cHV0ID0gaW5wdXQ7XG4gICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBpZiAob3V0cHV0ID09IG51bGwpIG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW5wdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IF9zeW5jKG91dHB1dFtpXSwgaW5wdXRbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIGlmIChvdXRwdXQgPT0gbnVsbCkgb3V0cHV0ID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBfc3luYyhvdXRwdXRba2V5XSwgaW5wdXRba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogR2V0IGludGVycG9sYXRlZCBzdGF0ZSBvZiBjdXJyZW50IGFjdGlvbiBhdCBwcm92aWRlZCB0aW1lLiBJZiB0aGUgbGFzdFxuICogICAgYWN0aW9uIGhhcyBjb21wbGV0ZWQsIGludm9rZSBpdHMgY2FsbGJhY2suXG4gKlxuICogQG1ldGhvZCBnZXRcbiAqXG4gKiBAcGFyYW0ge051bWJlcj19IHQgICAgICAgICAgICAgICBFdmFsdWF0ZSB0aGUgY3VydmUgYXQgYSBub3JtYWxpemVkIHZlcnNpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoaXMgdGltZS4gSWYgb21pdHRlZCwgdXNlIGN1cnJlbnQgdGltZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFVuaXggZXBvY2ggdGltZSByZXRyaWV2ZWQgZnJvbSBDbG9jaykuXG4gKiBAcmV0dXJuIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfSAgICBCZWdpbm5pbmcgc3RhdGUgaW50ZXJwb2xhdGVkIHRvIHRoaXMgcG9pbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRpbWUuXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQodCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zdGF0ZTtcblxuICAgIHQgPSB0aGlzLl9wYXVzZWRBdCA/IHRoaXMuX3BhdXNlZEF0IDogdDtcbiAgICB0ID0gdCA/IHQgOiB0aGlzLmNvbnN0cnVjdG9yLkNsb2NrLm5vdygpO1xuXG4gICAgdmFyIHByb2dyZXNzID0gKHQgLSB0aGlzLl9zdGFydGVkQXQpIC8gdGhpcy5fcXVldWVbMl07XG4gICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9pbnRlcnBvbGF0ZShcbiAgICAgICAgdGhpcy5fc3RhdGUsXG4gICAgICAgIHRoaXMuX2Zyb20sXG4gICAgICAgIHRoaXMuX3F1ZXVlWzBdLFxuICAgICAgICB0aGlzLl9xdWV1ZVsxXShwcm9ncmVzcyA+IDEgPyAxIDogcHJvZ3Jlc3MpLFxuICAgICAgICB0aGlzLl9xdWV1ZVs0XVxuICAgICk7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgaWYgKHByb2dyZXNzID49IDEpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRlZEF0ID0gdGhpcy5fc3RhcnRlZEF0ICsgdGhpcy5fcXVldWVbMl07XG4gICAgICAgIHRoaXMuX2Zyb20gPSB0aGlzLl9zeW5jKHRoaXMuX2Zyb20sIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvZ3Jlc3MgPiAxID8gdGhpcy5nZXQoKSA6IHN0YXRlO1xufTtcblxuLyoqXG4gKiBJcyB0aGVyZSBhdCBsZWFzdCBvbmUgdHJhbnNpdGlvbiBwZW5kaW5nIGNvbXBsZXRpb24/XG4gKlxuICogQG1ldGhvZCBpc0FjdGl2ZVxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwZW5kaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLiBQYXVzZWQgdHJhbnNpdGlvbnMgYXJlIHN0aWxsIGJlaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICBjb25zaWRlcmVkIGFjdGl2ZS5cbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDA7XG59O1xuXG4vKipcbiAqIEhhbHQgdHJhbnNpdGlvbiBhdCBjdXJyZW50IHN0YXRlIGFuZCBlcmFzZSBhbGwgcGVuZGluZyBhY3Rpb25zLlxuICpcbiAqIEBtZXRob2QgaGFsdFxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSB0aGlzXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gaGFsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKHRoaXMuZ2V0KCkpO1xufTtcblxuLyoqXG4gKiBQYXVzZSB0cmFuc2l0aW9uLiBUaGlzIHdpbGwgbm90IGVyYXNlIGFueSBhY3Rpb25zLlxuICpcbiAqIEBtZXRob2QgcGF1c2VcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICB0aGlzLl9wYXVzZWRBdCA9IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEhhcyB0aGUgY3VycmVudCBhY3Rpb24gYmVlbiBwYXVzZWQ/XG4gKlxuICogQG1ldGhvZCBpc1BhdXNlZFxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlmIHRoZSBjdXJyZW50IGFjdGlvbiBoYXMgYmVlbiBwYXVzZWRcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gaXNQYXVzZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcGF1c2VkQXQ7XG59O1xuXG4vKipcbiAqIFJlc3VtZSBhIHByZXZpb3VzbHkgcGF1c2VkIHRyYW5zaXRpb24uXG4gKlxuICogQG1ldGhvZCByZXN1bWVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIHZhciBkaWZmID0gdGhpcy5fcGF1c2VkQXQgLSB0aGlzLl9zdGFydGVkQXQ7XG4gICAgdGhpcy5fc3RhcnRlZEF0ID0gdGhpcy5jb25zdHJ1Y3Rvci5DbG9jay5ub3coKSAtIGRpZmY7XG4gICAgdGhpcy5fcGF1c2VkQXQgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYW5jZWwgYWxsIHRyYW5zaXRpb25zIGFuZCByZXNldCB0byBhIHN0YWJsZSBzdGF0ZVxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqIEBjaGFpbmFibGVcbiAqIEBkZXByZWNhdGVkIFVzZSBgLmZyb21gIGluc3RlYWQhXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfE9iamVjdC48bnVtYmVyLCBudW1iZXI+fSBzdGFydFxuICogICAgc3RhYmxlIHN0YXRlIHRvIHNldCB0b1xuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbShzdGFydCk7XG59O1xuXG4vKipcbiAqIEFkZCB0cmFuc2l0aW9uIHRvIGVuZCBzdGF0ZSB0byB0aGUgcXVldWUgb2YgcGVuZGluZyB0cmFuc2l0aW9ucy4gU3BlY2lhbFxuICogICAgVXNlOiBjYWxsaW5nIHdpdGhvdXQgYSB0cmFuc2l0aW9uIHJlc2V0cyB0aGUgb2JqZWN0IHRvIHRoYXQgc3RhdGUgd2l0aFxuICogICAgbm8gcGVuZGluZyBhY3Rpb25zXG4gKlxuICogQG1ldGhvZCBzZXRcbiAqIEBjaGFpbmFibGVcbiAqIEBkZXByZWNhdGVkIFVzZSBgLnRvYCBpbnN0ZWFkIVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfEZhbW91c0VuZ2luZU1hdHJpeHxBcnJheS5OdW1iZXJ8T2JqZWN0LjxudW1iZXIsIG51bWJlcj59IHN0YXRlXG4gKiAgICBlbmQgc3RhdGUgdG8gd2hpY2ggd2UgaW50ZXJwb2xhdGVcbiAqIEBwYXJhbSB7dHJhbnNpdGlvbj19IHRyYW5zaXRpb24gb2JqZWN0IG9mIHR5cGUge2R1cmF0aW9uOiBudW1iZXIsIGN1cnZlOlxuICogICAgZlswLDFdIC0+IFswLDFdIG9yIG5hbWV9LiBJZiB0cmFuc2l0aW9uIGlzIG9taXR0ZWQsIGNoYW5nZSB3aWxsIGJlXG4gKiAgICBpbnN0YW50YW5lb3VzLlxuICogQHBhcmFtIHtmdW5jdGlvbigpPX0gY2FsbGJhY2sgWmVyby1hcmd1bWVudCBmdW5jdGlvbiB0byBjYWxsIG9uIG9ic2VydmVkXG4gKiAgICBjb21wbGV0aW9uICh0PTEpXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oc3RhdGUsIHRyYW5zaXRpb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRyYW5zaXRpb24gPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZyb20oc3RhdGUpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnRvKHN0YXRlLCB0cmFuc2l0aW9uLmN1cnZlLCB0cmFuc2l0aW9uLmR1cmF0aW9uLCBjYWxsYmFjaywgdHJhbnNpdGlvbi5tZXRob2QpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNpdGlvbmFibGU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBsaWdodHdlaWdodCwgZmVhdHVyZWxlc3MgRXZlbnRFbWl0dGVyLlxuICpcbiAqIEBjbGFzcyBDYWxsYmFja1N0b3JlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ2FsbGJhY2tTdG9yZSAoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG59XG5cbi8qKlxuICogQWRkcyBhIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50ICg9IGtleSkuXG4gKlxuICogQG1ldGhvZCBvblxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gICBrZXkgICAgICAgVGhlIGV2ZW50IHR5cGUgKGUuZy4gYGNsaWNrYCkuXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuZXZlciBga2V5YFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudCBpcyBiZWluZyB0cmlnZ2VyZWQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gZGVzdHJveSAgIEEgZnVuY3Rpb24gdG8gY2FsbCBpZiB5b3Ugd2FudCB0byByZW1vdmUgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLlxuICovXG5DYWxsYmFja1N0b3JlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uIChrZXksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNba2V5XSkgdGhpcy5fZXZlbnRzW2tleV0gPSBbXTtcbiAgICB2YXIgY2FsbGJhY2tMaXN0ID0gdGhpcy5fZXZlbnRzW2tleV07XG4gICAgY2FsbGJhY2tMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrTGlzdC5zcGxpY2UoY2FsbGJhY2tMaXN0LmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAbWV0aG9kIG9mZlxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30ga2V5ICAgICAgICAgVGhlIGV2ZW50IHR5cGUgZnJvbSB3aGljaCB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIGJlIHJlbW92ZWQuXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSByZW1vdmVkIGZyb20gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycyBmb3Iga2V5LlxuICogQHJldHVybiB7Q2FsbGJhY2tTdG9yZX0gdGhpc1xuICovXG5DYWxsYmFja1N0b3JlLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYgKGtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW2tleV07XG4gICAgaWYgKGV2ZW50cykgZXZlbnRzLnNwbGljZShldmVudHMuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGFsbCB0aGUgcHJldmlvdXNseSBmb3IgdGhpcyBrZXkgcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQG1ldGhvZCB0cmlnZ2VyXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAga2V5ICAgICAgVGhlIGV2ZW50IHR5cGUuXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBwYXlsb2FkICBUaGUgZXZlbnQgcGF5bG9hZCAoZXZlbnQgb2JqZWN0KS5cbiAqIEByZXR1cm4ge0NhbGxiYWNrU3RvcmV9IHRoaXNcbiAqL1xuQ2FsbGJhY2tTdG9yZS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIgKGtleSwgcGF5bG9hZCkge1xuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNba2V5XTtcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGV2ZW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSBldmVudHNbaV0ocGF5bG9hZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxsYmFja1N0b3JlO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERlZXAgY2xvbmUgYW4gb2JqZWN0LlxuICpcbiAqIEBtZXRob2QgIGNsb25lXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGIgICAgICAgT2JqZWN0IHRvIGJlIGNsb25lZC5cbiAqIEByZXR1cm4ge09iamVjdH0gYSAgICAgIENsb25lZCBvYmplY3QgKGRlZXAgZXF1YWxpdHkpLlxuICovXG52YXIgY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShiKSB7XG4gICAgdmFyIGE7XG4gICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhID0gKGIgaW5zdGFuY2VvZiBBcnJheSkgPyBbXSA6IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiW2tleV0gPT09ICdvYmplY3QnICYmIGJba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChiW2tleV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBhW2tleV0gPSBuZXcgQXJyYXkoYltrZXldLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYltrZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhW2tleV1baV0gPSBjbG9uZShiW2tleV1baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYVtrZXldID0gY2xvbmUoYltrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGEgPSBiO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogVGFrZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcga2V5cyBhbmQgdmFsdWVzIGFuZCByZXR1cm5zIGFuIG9iamVjdFxuICogY29tcHJpc2luZyB0d28gXCJhc3NvY2lhdGVcIiBhcnJheXMsIG9uZSB3aXRoIHRoZSBrZXlzIGFuZCB0aGUgb3RoZXJcbiAqIHdpdGggdGhlIHZhbHVlcy5cbiAqXG4gKiBAbWV0aG9kIGtleVZhbHVlc1RvQXJyYXlzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAgICAgICAgICAgICAgICAgICAgICBPYmplY3RzIHdoZXJlIHRvIGV4dHJhY3Qga2V5cyBhbmQgdmFsdWVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20uXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgcmVzdWx0XG4gKiAgICAgICAgIHtBcnJheS48U3RyaW5nPn0gcmVzdWx0LmtleXMgICAgIEtleXMgb2YgYHJlc3VsdGAsIGFzIHJldHVybmVkIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPYmplY3Qua2V5cygpYFxuICogICAgICAgICB7QXJyYXl9ICAgICAgICAgIHJlc3VsdC52YWx1ZXMgICBWYWx1ZXMgb2YgcGFzc2VkIGluIG9iamVjdC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBrZXlWYWx1ZXNUb0FycmF5cyhvYmopIHtcbiAgICB2YXIga2V5c0FycmF5ID0gW10sIHZhbHVlc0FycmF5ID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvcih2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGtleXNBcnJheVtpXSA9IGtleTtcbiAgICAgICAgICAgIHZhbHVlc0FycmF5W2ldID0gb2JqW2tleV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5czoga2V5c0FycmF5LFxuICAgICAgICB2YWx1ZXM6IHZhbHVlc0FycmF5XG4gICAgfTtcbn07XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQUkVGSVhFUyA9IFsnJywgJy1tcy0nLCAnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW8tJ107XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdXNlZCBmb3IgZGV0ZXJtaW5pbmcgdGhlIHZlbmRvciBwcmVmaXhlZCB2ZXJzaW9uIG9mIHRoZVxuICogcGFzc2VkIGluIENTUyBwcm9wZXJ0eS5cbiAqXG4gKiBWZW5kb3IgY2hlY2tzIGFyZSBiZWluZyBjb25kdWN0ZWQgaW4gdGhlIGZvbGxvd2luZyBvcmRlcjpcbiAqXG4gKiAxLiAobm8gcHJlZml4KVxuICogMi4gYC1tei1gXG4gKiAzLiBgLXdlYmtpdC1gXG4gKiA0LiBgLW1vei1gXG4gKiA1LiBgLW8tYFxuICpcbiAqIEBtZXRob2QgdmVuZG9yUHJlZml4XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5ICAgICBDU1MgcHJvcGVydHkgKG5vIGNhbWVsQ2FzZSksIGUuZy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGJvcmRlci1yYWRpdXNgLlxuICogQHJldHVybiB7U3RyaW5nfSBwcmVmaXhlZCAgICBWZW5kb3IgcHJlZml4ZWQgdmVyc2lvbiBvZiBwYXNzZWQgaW4gQ1NTXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5IChlLmcuIGAtd2Via2l0LWJvcmRlci1yYWRpdXNgKS5cbiAqL1xuZnVuY3Rpb24gdmVuZG9yUHJlZml4KHByb3BlcnR5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBQUkVGSVhFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJlZml4ZWQgPSBQUkVGSVhFU1tpXSArIHByb3BlcnR5O1xuICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3ByZWZpeGVkXSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXhlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydHk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVuZG9yUHJlZml4O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEJ1ZmZlciBpcyBhIHByaXZhdGUgY2xhc3MgdGhhdCB3cmFwcyB0aGUgdmVydGV4IGRhdGEgdGhhdCBkZWZpbmVzXG4gKiB0aGUgdGhlIHBvaW50cyBvZiB0aGUgdHJpYW5nbGVzIHRoYXQgd2ViZ2wgZHJhd3MuIEVhY2ggYnVmZmVyXG4gKiBtYXBzIHRvIG9uZSBhdHRyaWJ1dGUgb2YgYSBtZXNoLlxuICpcbiAqIEBjbGFzcyBCdWZmZXJcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXQgVGhlIGJpbmQgdGFyZ2V0IG9mIHRoZSBidWZmZXIgdG8gdXBkYXRlOiBBUlJBWV9CVUZGRVIgb3IgRUxFTUVOVF9BUlJBWV9CVUZGRVJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlIEFycmF5IHR5cGUgdG8gYmUgdXNlZCBpbiBjYWxscyB0byBnbC5idWZmZXJEYXRhLlxuICogQHBhcmFtIHtXZWJHTENvbnRleHR9IGdsIFRoZSBXZWJHTCBjb250ZXh0IHRoYXQgdGhlIGJ1ZmZlciBpcyBob3N0ZWQgYnkuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gQnVmZmVyKHRhcmdldCwgdHlwZSwgZ2wpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLmdsID0gZ2w7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFdlYkdMIGJ1ZmZlciBpZiBvbmUgZG9lcyBub3QgeWV0IGV4aXN0IGFuZCBiaW5kcyB0aGUgYnVmZmVyIHRvXG4gKiB0byB0aGUgY29udGV4dC4gUnVucyBidWZmZXJEYXRhIHdpdGggYXBwcm9wcmlhdGUgZGF0YS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5zdWJEYXRhID0gZnVuY3Rpb24gc3ViRGF0YSgpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBkYXRhID0gW107XG5cbiAgICAvLyB0byBwcmV2ZW50IGFnYWluc3QgbWF4aW11bSBjYWxsLXN0YWNrIGlzc3VlLlxuICAgIGZvciAodmFyIGkgPSAwLCBjaHVuayA9IDEwMDAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSBjaHVuaylcbiAgICAgICAgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoZGF0YSwgdGhpcy5kYXRhLnNsaWNlKGksIGkgKyBjaHVuaykpO1xuXG4gICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlciB8fCBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKHRoaXMudGFyZ2V0LCB0aGlzLmJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YSh0aGlzLnRhcmdldCwgbmV3IHRoaXMudHlwZShkYXRhKSwgZ2wuU1RBVElDX0RSQVcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXI7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBJTkRJQ0VTID0gJ2luZGljZXMnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9CdWZmZXInKTtcblxuLyoqXG4gKiBCdWZmZXJSZWdpc3RyeSBpcyBhIGNsYXNzIHRoYXQgbWFuYWdlcyBhbGxvY2F0aW9uIG9mIGJ1ZmZlcnMgdG9cbiAqIGlucHV0IGdlb21ldHJpZXMuXG4gKlxuICogQGNsYXNzIEJ1ZmZlclJlZ2lzdHJ5XG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1dlYkdMQ29udGV4dH0gY29udGV4dCBXZWJHTCBkcmF3aW5nIGNvbnRleHQgdG8gYmUgcGFzc2VkIHRvIGJ1ZmZlcnMuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gQnVmZmVyUmVnaXN0cnkoY29udGV4dCkge1xuICAgIHRoaXMuZ2wgPSBjb250ZXh0O1xuXG4gICAgdGhpcy5yZWdpc3RyeSA9IHt9O1xuICAgIHRoaXMuX2R5bmFtaWNCdWZmZXJzID0gW107XG4gICAgdGhpcy5fc3RhdGljQnVmZmVycyA9IFtdO1xuXG4gICAgdGhpcy5fYXJyYXlCdWZmZXJNYXggPSAzMDAwMDtcbiAgICB0aGlzLl9lbGVtZW50QnVmZmVyTWF4ID0gMzAwMDA7XG59XG5cbi8qKlxuICogQmluZHMgYW5kIGZpbGxzIGFsbCB0aGUgdmVydGV4IGRhdGEgaW50byB3ZWJnbCBidWZmZXJzLiAgV2lsbCByZXVzZSBidWZmZXJzIGlmXG4gKiBwb3NzaWJsZS4gIFBvcHVsYXRlcyByZWdpc3RyeSB3aXRoIHRoZSBuYW1lIG9mIHRoZSBidWZmZXIsIHRoZSBXZWJHTCBidWZmZXJcbiAqIG9iamVjdCwgc3BhY2luZyBvZiB0aGUgYXR0cmlidXRlLCB0aGUgYXR0cmlidXRlJ3Mgb2Zmc2V0IHdpdGhpbiB0aGUgYnVmZmVyLFxuICogYW5kIGZpbmFsbHkgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyLiAgVGhpcyBpbmZvcm1hdGlvbiBpcyBsYXRlciBhY2Nlc3NlZCBieVxuICogdGhlIHJvb3QgdG8gZHJhdyB0aGUgYnVmZmVycy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGdlb21ldHJ5SWQgSWQgb2YgdGhlIGdlb21ldHJ5IGluc3RhbmNlIHRoYXQgaG9sZHMgdGhlIGJ1ZmZlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBLZXkgb2YgdGhlIGlucHV0IGJ1ZmZlciBpbiB0aGUgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBGbGF0IGFycmF5IGNvbnRhaW5pbmcgaW5wdXQgZGF0YSBmb3IgYnVmZmVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYWNpbmcgVGhlIHNwYWNpbmcsIG9yIGl0ZW1TaXplLCBvZiB0aGUgaW5wdXQgYnVmZmVyLlxuICogQHBhcmFtIHtCb29sZWFufSBkeW5hbWljIEJvb2xlYW4gZGVub3Rpbmcgd2hldGhlciBhIGdlb21ldHJ5IGlzIGR5bmFtaWMgb3Igc3RhdGljLlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkJ1ZmZlclJlZ2lzdHJ5LnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uIGFsbG9jYXRlKGdlb21ldHJ5SWQsIG5hbWUsIHZhbHVlLCBzcGFjaW5nLCBkeW5hbWljKSB7XG4gICAgdmFyIHZlcnRleEJ1ZmZlcnMgPSB0aGlzLnJlZ2lzdHJ5W2dlb21ldHJ5SWRdIHx8ICh0aGlzLnJlZ2lzdHJ5W2dlb21ldHJ5SWRdID0geyBrZXlzOiBbXSwgdmFsdWVzOiBbXSwgc3BhY2luZzogW10sIG9mZnNldDogW10sIGxlbmd0aDogW10gfSk7XG5cbiAgICB2YXIgaiA9IHZlcnRleEJ1ZmZlcnMua2V5cy5pbmRleE9mKG5hbWUpO1xuICAgIHZhciBpc0luZGV4ID0gbmFtZSA9PT0gSU5ESUNFUztcbiAgICB2YXIgYnVmZmVyRm91bmQgPSBmYWxzZTtcbiAgICB2YXIgbmV3T2Zmc2V0O1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBsZW5ndGg7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICB2YXIgaztcblxuICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICBqID0gdmVydGV4QnVmZmVycy5rZXlzLmxlbmd0aDtcbiAgICAgICAgbGVuZ3RoID0gaXNJbmRleCA/IHZhbHVlLmxlbmd0aCA6IE1hdGguZmxvb3IodmFsdWUubGVuZ3RoIC8gc3BhY2luZyk7XG5cbiAgICAgICAgaWYgKCFkeW5hbWljKSB7XG5cbiAgICAgICAgICAgIC8vIFVzZSBhIHByZXZpb3VzbHkgY3JlYXRlZCBidWZmZXIgaWYgYXZhaWxhYmxlLlxuXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgdGhpcy5fc3RhdGljQnVmZmVycy5sZW5ndGg7IGsrKykge1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5kZXggPT09IHRoaXMuX3N0YXRpY0J1ZmZlcnNba10uaXNJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPZmZzZXQgPSB0aGlzLl9zdGF0aWNCdWZmZXJzW2tdLm9mZnNldCArIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghaXNJbmRleCAmJiBuZXdPZmZzZXQgPCB0aGlzLl9hcnJheUJ1ZmZlck1heCkgfHwgKGlzSW5kZXggJiYgbmV3T2Zmc2V0IDwgdGhpcy5fZWxlbWVudEJ1ZmZlck1heCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuX3N0YXRpY0J1ZmZlcnNba10uYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fc3RhdGljQnVmZmVyc1trXS5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0aWNCdWZmZXJzW2tdLm9mZnNldCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHN0YXRpYyBidWZmZXIgaW4gbm9uZSB3ZXJlIGZvdW5kLlxuXG4gICAgICAgICAgICBpZiAoIWJ1ZmZlckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IEJ1ZmZlcihcbiAgICAgICAgICAgICAgICAgICAgaXNJbmRleCA/IHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgOiB0aGlzLmdsLkFSUkFZX0JVRkZFUixcbiAgICAgICAgICAgICAgICAgICAgaXNJbmRleCA/IFVpbnQxNkFycmF5IDogRmxvYXQzMkFycmF5LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRpY0J1ZmZlcnMucHVzaCh7IGJ1ZmZlcjogYnVmZmVyLCBvZmZzZXQ6IHZhbHVlLmxlbmd0aCwgaXNJbmRleDogaXNJbmRleCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gRm9yIGR5bmFtaWMgZ2VvbWV0cmllcywgYWx3YXlzIGNyZWF0ZSBuZXcgYnVmZmVyLlxuXG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgQnVmZmVyKFxuICAgICAgICAgICAgICAgIGlzSW5kZXggPyB0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSIDogdGhpcy5nbC5BUlJBWV9CVUZGRVIsXG4gICAgICAgICAgICAgICAgaXNJbmRleCA/IFVpbnQxNkFycmF5IDogRmxvYXQzMkFycmF5LFxuICAgICAgICAgICAgICAgIHRoaXMuZ2xcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNCdWZmZXJzLnB1c2goeyBidWZmZXI6IGJ1ZmZlciwgb2Zmc2V0OiB2YWx1ZS5sZW5ndGgsIGlzSW5kZXg6IGlzSW5kZXggfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlZ2lzdHJ5IGZvciB0aGUgc3BlYyB3aXRoIGJ1ZmZlciBpbmZvcm1hdGlvbi5cblxuICAgICAgICB2ZXJ0ZXhCdWZmZXJzLmtleXMucHVzaChuYW1lKTtcbiAgICAgICAgdmVydGV4QnVmZmVycy52YWx1ZXMucHVzaChidWZmZXIpO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJzLnNwYWNpbmcucHVzaChzcGFjaW5nKTtcbiAgICAgICAgdmVydGV4QnVmZmVycy5vZmZzZXQucHVzaChvZmZzZXQpO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJzLmxlbmd0aC5wdXNoKGxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgdmVydGV4QnVmZmVycy52YWx1ZXNbal0uZGF0YVtvZmZzZXQgKyBrXSA9IHZhbHVlW2tdO1xuICAgIH1cbiAgICB2ZXJ0ZXhCdWZmZXJzLnZhbHVlc1tqXS5zdWJEYXRhKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlclJlZ2lzdHJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIFRha2VzIHRoZSBvcmlnaW5hbCByZW5kZXJpbmcgY29udGV4dHMnIGNvbXBpbGVyIGZ1bmN0aW9uXG4gKiBhbmQgYXVnbWVudHMgaXQgd2l0aCBhZGRlZCBmdW5jdGlvbmFsaXR5IGZvciBwYXJzaW5nIGFuZFxuICogZGlzcGxheWluZyBlcnJvcnMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQXVnbWVudGVkIGZ1bmN0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRGVidWcoKSB7XG4gICAgcmV0dXJuIF9hdWdtZW50RnVuY3Rpb24oXG4gICAgICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcixcbiAgICAgICAgZnVuY3Rpb24oc2hhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gdGhpcy5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U2hhZGVyU291cmNlKHNoYWRlcik7XG4gICAgICAgICAgICAgICAgX3Byb2Nlc3NFcnJvcnMoZXJyb3JzLCBzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcbn07XG5cbi8vIFRha2VzIGEgZnVuY3Rpb24sIGtlZXBzIHRoZSByZWZlcmVuY2UgYW5kIHJlcGxhY2VzIGl0IGJ5IGEgY2xvc3VyZSB0aGF0XG4vLyBleGVjdXRlcyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gYW5kIHRoZSBwcm92aWRlZCBjYWxsYmFjay5cbmZ1bmN0aW9uIF9hdWdtZW50RnVuY3Rpb24oZnVuYywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXMgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cblxuLy8gUGFyc2VzIGVycm9ycyBhbmQgZmFpbGVkIHNvdXJjZSBjb2RlIGZyb20gc2hhZGVycyBpbiBvcmRlclxuLy8gdG8gYnVpbGQgZGlzcGxheWFibGUgZXJyb3IgYmxvY2tzLlxuLy8gSW5zcGlyZWQgYnkgSmF1bWUgU2FuY2hleiBFbGlhcy5cbmZ1bmN0aW9uIF9wcm9jZXNzRXJyb3JzKGVycm9ycywgc291cmNlKSB7XG5cbiAgICB2YXIgY3NzID0gJ2JvZHksaHRtbHtiYWNrZ3JvdW5kOiNlM2UzZTM7Zm9udC1mYW1pbHk6bW9uYWNvLG1vbm9zcGFjZTtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoxLjdlbX0nICtcbiAgICAgICAgICAgICAgJyNzaGFkZXJSZXBvcnR7bGVmdDowO3RvcDowO3JpZ2h0OjA7Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MTAwMDtjb2xvcjonICtcbiAgICAgICAgICAgICAgJyMyMjI7cGFkZGluZzoxNXB4O3doaXRlLXNwYWNlOm5vcm1hbDtsaXN0LXN0eWxlLXR5cGU6bm9uZTttYXJnaW46NTBweCBhdXRvO21heC13aWR0aDoxMjAwcHh9JyArXG4gICAgICAgICAgICAgICcjc2hhZGVyUmVwb3J0IGxpe2JhY2tncm91bmQtY29sb3I6I2ZmZjttYXJnaW46MTNweCAwO2JveC1zaGFkb3c6MCAxcHggMnB4IHJnYmEoMCwwLDAsLjE1KTsnICtcbiAgICAgICAgICAgICAgJ3BhZGRpbmc6MjBweCAzMHB4O2JvcmRlci1yYWRpdXM6MnB4O2JvcmRlci1sZWZ0OjIwcHggc29saWQgI2UwMTExMX1zcGFue2NvbG9yOiNlMDExMTE7JyArXG4gICAgICAgICAgICAgICd0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lO2ZvbnQtd2VpZ2h0OjcwMH0jc2hhZGVyUmVwb3J0IGxpIHB7cGFkZGluZzowO21hcmdpbjowfScgK1xuICAgICAgICAgICAgICAnI3NoYWRlclJlcG9ydCBsaTpudGgtY2hpbGQoZXZlbil7YmFja2dyb3VuZC1jb2xvcjojZjRmNGY0fScgK1xuICAgICAgICAgICAgICAnI3NoYWRlclJlcG9ydCBsaSBwOmZpcnN0LWNoaWxke21hcmdpbi1ib3R0b206MTBweDtjb2xvcjojNjY2fSc7XG5cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoZWwpO1xuICAgIGVsLnRleHRDb250ZW50ID0gY3NzO1xuXG4gICAgdmFyIHJlcG9ydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgcmVwb3J0LnNldEF0dHJpYnV0ZSgnaWQnLCAnc2hhZGVyUmVwb3J0Jyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZXBvcnQpO1xuXG4gICAgdmFyIHJlID0gL0VSUk9SOiBbXFxkXSs6KFtcXGRdKyk6ICguKykvZ21pO1xuICAgIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgnXFxuJyk7XG5cbiAgICB2YXIgbTtcbiAgICB3aGlsZSAoKG0gPSByZS5leGVjKGVycm9ycykpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG0uaW5kZXggPT09IHJlLmxhc3RJbmRleCkgcmUubGFzdEluZGV4Kys7XG4gICAgICAgIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgIHZhciBjb2RlID0gJzxwPjxzcGFuPkVSUk9SPC9zcGFuPiBcIicgKyBtWzJdICsgJ1wiIGluIGxpbmUgJyArIG1bMV0gKyAnPC9wPic7XG4gICAgICAgIGNvZGUgKz0gJzxwPjxiPicgKyBsaW5lc1ttWzFdIC0gMV0ucmVwbGFjZSgvXlsgXFx0XSsvZywgJycpICsgJzwvYj48L3A+JztcbiAgICAgICAgbGkuaW5uZXJIVE1MID0gY29kZTtcbiAgICAgICAgcmVwb3J0LmFwcGVuZENoaWxkKGxpKTtcbiAgICB9XG59XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjbG9uZSA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9jbG9uZScpO1xudmFyIGtleVZhbHVlVG9BcnJheXMgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMva2V5VmFsdWVUb0FycmF5cycpO1xuXG52YXIgdmVydGV4V3JhcHBlciA9IHJlcXVpcmUoJy4uL3dlYmdsLXNoYWRlcnMnKS52ZXJ0ZXg7XG52YXIgZnJhZ21lbnRXcmFwcGVyID0gcmVxdWlyZSgnLi4vd2ViZ2wtc2hhZGVycycpLmZyYWdtZW50O1xudmFyIERlYnVnID0gcmVxdWlyZSgnLi9EZWJ1ZycpO1xuXG52YXIgVkVSVEVYX1NIQURFUiA9IDM1NjMzO1xudmFyIEZSQUdNRU5UX1NIQURFUiA9IDM1NjMyO1xudmFyIGlkZW50aXR5TWF0cml4ID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuXG52YXIgaGVhZGVyID0gJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbic7XG5cbnZhciBUWVBFUyA9IHtcbiAgICB1bmRlZmluZWQ6ICdmbG9hdCAnLFxuICAgIDE6ICdmbG9hdCAnLFxuICAgIDI6ICd2ZWMyICcsXG4gICAgMzogJ3ZlYzMgJyxcbiAgICA0OiAndmVjNCAnLFxuICAgIDE2OiAnbWF0NCAnXG59O1xuXG52YXIgaW5wdXRUeXBlcyA9IHtcbiAgICB1X2Jhc2VDb2xvcjogJ3ZlYzQnLFxuICAgIHVfbm9ybWFsczogJ3ZlcnQnLFxuICAgIHVfZ2xvc3NpbmVzczogJ3ZlYzQnLFxuICAgIHVfcG9zaXRpb25PZmZzZXQ6ICd2ZXJ0J1xufTtcblxudmFyIG1hc2tzID0gIHtcbiAgICB2ZXJ0OiAxLFxuICAgIHZlYzM6IDIsXG4gICAgdmVjNDogNCxcbiAgICBmbG9hdDogOFxufTtcblxuLyoqXG4gKiBVbmlmb3JtIGtleXMgYW5kIHZhbHVlc1xuICovXG52YXIgdW5pZm9ybXMgPSBrZXlWYWx1ZVRvQXJyYXlzKHtcbiAgICB1X3BlcnNwZWN0aXZlOiBpZGVudGl0eU1hdHJpeCxcbiAgICB1X3ZpZXc6IGlkZW50aXR5TWF0cml4LFxuICAgIHVfcmVzb2x1dGlvbjogWzAsIDAsIDBdLFxuICAgIHVfdHJhbnNmb3JtOiBpZGVudGl0eU1hdHJpeCxcbiAgICB1X3NpemU6IFsxLCAxLCAxXSxcbiAgICB1X3RpbWU6IDAsXG4gICAgdV9vcGFjaXR5OiAxLFxuICAgIHVfbWV0YWxuZXNzOiAwLFxuICAgIHVfZ2xvc3NpbmVzczogWzAsIDAsIDAsIDBdLFxuICAgIHVfYmFzZUNvbG9yOiBbMSwgMSwgMSwgMV0sXG4gICAgdV9ub3JtYWxzOiBbMSwgMSwgMV0sXG4gICAgdV9wb3NpdGlvbk9mZnNldDogWzAsIDAsIDBdLFxuICAgIHVfbGlnaHRQb3NpdGlvbjogaWRlbnRpdHlNYXRyaXgsXG4gICAgdV9saWdodENvbG9yOiBpZGVudGl0eU1hdHJpeCxcbiAgICB1X2FtYmllbnRMaWdodDogWzAsIDAsIDBdLFxuICAgIHVfZmxhdFNoYWRpbmc6IDAsXG4gICAgdV9udW1MaWdodHM6IDBcbn0pO1xuXG4vKipcbiAqIEF0dHJpYnV0ZXMga2V5cyBhbmQgdmFsdWVzXG4gKi9cbnZhciBhdHRyaWJ1dGVzID0ga2V5VmFsdWVUb0FycmF5cyh7XG4gICAgYV9wb3M6IFswLCAwLCAwXSxcbiAgICBhX3RleENvb3JkOiBbMCwgMF0sXG4gICAgYV9ub3JtYWxzOiBbMCwgMCwgMF1cbn0pO1xuXG4vKipcbiAqIFZhcnlpbmdzIGtleXMgYW5kIHZhbHVlc1xuICovXG52YXIgdmFyeWluZ3MgPSBrZXlWYWx1ZVRvQXJyYXlzKHtcbiAgICB2X3RleHR1cmVDb29yZGluYXRlOiBbMCwgMF0sXG4gICAgdl9ub3JtYWw6IFswLCAwLCAwXSxcbiAgICB2X3Bvc2l0aW9uOiBbMCwgMCwgMF0sXG4gICAgdl9leWVWZWN0b3I6IFswLCAwLCAwXVxufSk7XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGhhbmRsZXMgaW50ZXJhY3Rpb25zIHdpdGggdGhlIFdlYkdMIHNoYWRlciBwcm9ncmFtXG4gKiB1c2VkIGJ5IGEgc3BlY2lmaWMgY29udGV4dC4gIEl0IG1hbmFnZXMgY3JlYXRpb24gb2YgdGhlIHNoYWRlciBwcm9ncmFtXG4gKiBhbmQgdGhlIGF0dGFjaGVkIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy4gIEl0IGlzIGFsc28gaW4gY2hhcmdlIG9mXG4gKiBwYXNzaW5nIGFsbCB1bmlmb3JtcyB0byB0aGUgV2ViR0xDb250ZXh0LlxuICpcbiAqIEBjbGFzcyBQcm9ncmFtXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1dlYkdMX0NvbnRleHR9IGdsIENvbnRleHQgdG8gYmUgdXNlZCB0byBjcmVhdGUgdGhlIHNoYWRlciBwcm9ncmFtXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQcm9ncmFtIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBQcm9ncmFtKGdsLCBvcHRpb25zKSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMudGV4dHVyZVNsb3RzID0gMTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5yZWdpc3RlcmVkTWF0ZXJpYWxzID0ge307XG4gICAgdGhpcy5mbGFnZ2VkVW5pZm9ybXMgPSBbXTtcbiAgICB0aGlzLmNhY2hlZFVuaWZvcm1zICA9IHt9O1xuICAgIHRoaXMudW5pZm9ybVR5cGVzID0gW107XG5cbiAgICB0aGlzLmRlZmluaXRpb25WZWM0ID0gW107XG4gICAgdGhpcy5kZWZpbml0aW9uVmVjMyA9IFtdO1xuICAgIHRoaXMuZGVmaW5pdGlvbkZsb2F0ID0gW107XG4gICAgdGhpcy5hcHBsaWNhdGlvblZlYzMgPSBbXTtcbiAgICB0aGlzLmFwcGxpY2F0aW9uVmVjNCA9IFtdO1xuICAgIHRoaXMuYXBwbGljYXRpb25GbG9hdCA9IFtdO1xuICAgIHRoaXMuYXBwbGljYXRpb25WZXJ0ID0gW107XG4gICAgdGhpcy5kZWZpbml0aW9uVmVydCA9IFtdO1xuXG4gICAgdGhpcy5yZXNldFByb2dyYW0oKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBtYXRlcmlhbCBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgdG9cbiAqIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0YXJnZXQgaW5wdXQgb2YgbWF0ZXJpYWwuXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWwgQ29tcGlsZWQgbWF0ZXJpYWwgb2JqZWN0IGJlaW5nIHZlcmlmaWVkLlxuICpcbiAqIEByZXR1cm4ge1Byb2dyYW19IHRoaXMgQ3VycmVudCBwcm9ncmFtLlxuICovXG5Qcm9ncmFtLnByb3RvdHlwZS5yZWdpc3Rlck1hdGVyaWFsID0gZnVuY3Rpb24gcmVnaXN0ZXJNYXRlcmlhbChuYW1lLCBtYXRlcmlhbCkge1xuICAgIHZhciBjb21waWxlZCA9IG1hdGVyaWFsO1xuICAgIHZhciB0eXBlID0gaW5wdXRUeXBlc1tuYW1lXTtcbiAgICB2YXIgbWFzayA9IG1hc2tzW3R5cGVdO1xuXG4gICAgaWYgKCh0aGlzLnJlZ2lzdGVyZWRNYXRlcmlhbHNbbWF0ZXJpYWwuX2lkXSAmIG1hc2spID09PSBtYXNrKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBrO1xuXG4gICAgZm9yIChrIGluIGNvbXBpbGVkLnVuaWZvcm1zKSB7XG4gICAgICAgIGlmICh1bmlmb3Jtcy5rZXlzLmluZGV4T2YoaykgPT09IC0xKSB7XG4gICAgICAgICAgICB1bmlmb3Jtcy5rZXlzLnB1c2goayk7XG4gICAgICAgICAgICB1bmlmb3Jtcy52YWx1ZXMucHVzaChjb21waWxlZC51bmlmb3Jtc1trXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGsgaW4gY29tcGlsZWQudmFyeWluZ3MpIHtcbiAgICAgICAgaWYgKHZhcnlpbmdzLmtleXMuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHZhcnlpbmdzLmtleXMucHVzaChrKTtcbiAgICAgICAgICAgIHZhcnlpbmdzLnZhbHVlcy5wdXNoKGNvbXBpbGVkLnZhcnlpbmdzW2tdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoayBpbiBjb21waWxlZC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLmtleXMuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMua2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgYXR0cmlidXRlcy52YWx1ZXMucHVzaChjb21waWxlZC5hdHRyaWJ1dGVzW2tdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVnaXN0ZXJlZE1hdGVyaWFsc1ttYXRlcmlhbC5faWRdIHw9IG1hc2s7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICB0aGlzLmRlZmluaXRpb25GbG9hdC5wdXNoKG1hdGVyaWFsLmRlZmluZXMpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25GbG9hdC5wdXNoKCdmbG9hdCBmYV8nICsgbWF0ZXJpYWwuX2lkICsgJygpIHtcXG4gJyAgKyBjb21waWxlZC5nbHNsICsgJyBcXG59Jyk7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25GbG9hdC5wdXNoKCdpZiAoaW50KGFicyhJRCkpID09ICcgKyBtYXRlcmlhbC5faWQgKyAnKSByZXR1cm4gZmFfJyArIG1hdGVyaWFsLl9pZCAgKyAnKCk7Jyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICd2ZWMzJykge1xuICAgICAgICB0aGlzLmRlZmluaXRpb25WZWMzLnB1c2gobWF0ZXJpYWwuZGVmaW5lcyk7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvblZlYzMucHVzaCgndmVjMyBmYV8nICsgbWF0ZXJpYWwuX2lkICsgJygpIHtcXG4gJyAgKyBjb21waWxlZC5nbHNsICsgJyBcXG59Jyk7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25WZWMzLnB1c2goJ2lmIChpbnQoYWJzKElELngpKSA9PSAnICsgbWF0ZXJpYWwuX2lkICsgJykgcmV0dXJuIGZhXycgKyBtYXRlcmlhbC5faWQgKyAnKCk7Jyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICd2ZWM0Jykge1xuICAgICAgICB0aGlzLmRlZmluaXRpb25WZWM0LnB1c2gobWF0ZXJpYWwuZGVmaW5lcyk7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvblZlYzQucHVzaCgndmVjNCBmYV8nICsgbWF0ZXJpYWwuX2lkICsgJygpIHtcXG4gJyAgKyBjb21waWxlZC5nbHNsICsgJyBcXG59Jyk7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25WZWM0LnB1c2goJ2lmIChpbnQoYWJzKElELngpKSA9PSAnICsgbWF0ZXJpYWwuX2lkICsgJykgcmV0dXJuIGZhXycgKyBtYXRlcmlhbC5faWQgKyAnKCk7Jyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICd2ZXJ0Jykge1xuICAgICAgICB0aGlzLmRlZmluaXRpb25WZXJ0LnB1c2gobWF0ZXJpYWwuZGVmaW5lcyk7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvblZlcnQucHVzaCgndmVjMyBmYV8nICsgbWF0ZXJpYWwuX2lkICsgJygpIHtcXG4gJyAgKyBjb21waWxlZC5nbHNsICsgJyBcXG59Jyk7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25WZXJ0LnB1c2goJ2lmIChpbnQoYWJzKElELngpKSA9PSAnICsgbWF0ZXJpYWwuX2lkICsgJykgcmV0dXJuIGZhXycgKyBtYXRlcmlhbC5faWQgKyAnKCk7Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVzZXRQcm9ncmFtKCk7XG59O1xuXG4vKipcbiAqIENsZWFycyBhbGwgY2FjaGVkIHVuaWZvcm1zIGFuZCBhdHRyaWJ1dGUgbG9jYXRpb25zLiAgQXNzZW1ibGVzXG4gKiBuZXcgZnJhZ21lbnQgYW5kIHZlcnRleCBzaGFkZXJzIGFuZCBiYXNlZCBvbiBtYXRlcmlhbCBmcm9tXG4gKiBjdXJyZW50bHkgcmVnaXN0ZXJlZCBtYXRlcmlhbHMuICBBdHRhY2hlcyBzYWlkIHNoYWRlcnMgdG8gbmV3XG4gKiBzaGFkZXIgcHJvZ3JhbSBhbmQgdXBvbiBzdWNjZXNzIGxpbmtzIHByb2dyYW0gdG8gdGhlIFdlYkdMXG4gKiBjb250ZXh0LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtQcm9ncmFtfSBDdXJyZW50IHByb2dyYW0uXG4gKi9cblByb2dyYW0ucHJvdG90eXBlLnJlc2V0UHJvZ3JhbSA9IGZ1bmN0aW9uIHJlc2V0UHJvZ3JhbSgpIHtcbiAgICB2YXIgdmVydGV4SGVhZGVyID0gW2hlYWRlcl07XG4gICAgdmFyIGZyYWdtZW50SGVhZGVyID0gW2hlYWRlcl07XG5cbiAgICB2YXIgZnJhZ21lbnRTb3VyY2U7XG4gICAgdmFyIHZlcnRleFNvdXJjZTtcbiAgICB2YXIgcHJvZ3JhbTtcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGk7XG5cbiAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnMgICA9IFtdO1xuICAgIHRoaXMuYXR0cmlidXRlTG9jYXRpb25zID0ge307XG5cbiAgICB0aGlzLnVuaWZvcm1UeXBlcyA9IHt9O1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lcyA9IGNsb25lKGF0dHJpYnV0ZXMua2V5cyk7XG4gICAgdGhpcy5hdHRyaWJ1dGVWYWx1ZXMgPSBjbG9uZShhdHRyaWJ1dGVzLnZhbHVlcyk7XG5cbiAgICB0aGlzLnZhcnlpbmdOYW1lcyA9IGNsb25lKHZhcnlpbmdzLmtleXMpO1xuICAgIHRoaXMudmFyeWluZ1ZhbHVlcyA9IGNsb25lKHZhcnlpbmdzLnZhbHVlcyk7XG5cbiAgICB0aGlzLnVuaWZvcm1OYW1lcyA9IGNsb25lKHVuaWZvcm1zLmtleXMpO1xuICAgIHRoaXMudW5pZm9ybVZhbHVlcyA9IGNsb25lKHVuaWZvcm1zLnZhbHVlcyk7XG5cbiAgICB0aGlzLmZsYWdnZWRVbmlmb3JtcyA9IFtdO1xuICAgIHRoaXMuY2FjaGVkVW5pZm9ybXMgPSB7fTtcblxuICAgIGZyYWdtZW50SGVhZGVyLnB1c2goJ3VuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZXNbN107XFxuJyk7XG5cbiAgICBpZiAodGhpcy5hcHBsaWNhdGlvblZlcnQubGVuZ3RoKSB7XG4gICAgICAgIHZlcnRleEhlYWRlci5wdXNoKCd1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVzWzddO1xcbicpO1xuICAgIH1cblxuICAgIGZvcihpID0gMDsgaSA8IHRoaXMudW5pZm9ybU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLnVuaWZvcm1OYW1lc1tpXTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnVuaWZvcm1WYWx1ZXNbaV07XG4gICAgICAgIHZlcnRleEhlYWRlci5wdXNoKCd1bmlmb3JtICcgKyBUWVBFU1t2YWx1ZS5sZW5ndGhdICsgbmFtZSArICc7XFxuJyk7XG4gICAgICAgIGZyYWdtZW50SGVhZGVyLnB1c2goJ3VuaWZvcm0gJyArIFRZUEVTW3ZhbHVlLmxlbmd0aF0gKyBuYW1lICsgJztcXG4nKTtcbiAgICB9XG5cbiAgICBmb3IoaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLmF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuYXR0cmlidXRlVmFsdWVzW2ldO1xuICAgICAgICB2ZXJ0ZXhIZWFkZXIucHVzaCgnYXR0cmlidXRlICcgKyBUWVBFU1t2YWx1ZS5sZW5ndGhdICsgbmFtZSArICc7XFxuJyk7XG4gICAgfVxuXG4gICAgZm9yKGkgPSAwOyBpIDwgdGhpcy52YXJ5aW5nTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IHRoaXMudmFyeWluZ05hbWVzW2ldO1xuICAgICAgICB2YWx1ZSA9IHRoaXMudmFyeWluZ1ZhbHVlc1tpXTtcbiAgICAgICAgdmVydGV4SGVhZGVyLnB1c2goJ3ZhcnlpbmcgJyArIFRZUEVTW3ZhbHVlLmxlbmd0aF0gICsgbmFtZSArICc7XFxuJyk7XG4gICAgICAgIGZyYWdtZW50SGVhZGVyLnB1c2goJ3ZhcnlpbmcgJyArIFRZUEVTW3ZhbHVlLmxlbmd0aF0gKyBuYW1lICsgJztcXG4nKTtcbiAgICB9XG5cbiAgICB2ZXJ0ZXhTb3VyY2UgPSB2ZXJ0ZXhIZWFkZXIuam9pbignJykgKyB2ZXJ0ZXhXcmFwcGVyXG4gICAgICAgIC5yZXBsYWNlKCcjdmVydF9kZWZpbml0aW9ucycsIHRoaXMuZGVmaW5pdGlvblZlcnQuam9pbignXFxuJykpXG4gICAgICAgIC5yZXBsYWNlKCcjdmVydF9hcHBsaWNhdGlvbnMnLCB0aGlzLmFwcGxpY2F0aW9uVmVydC5qb2luKCdcXG4nKSk7XG5cbiAgICBmcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50SGVhZGVyLmpvaW4oJycpICsgZnJhZ21lbnRXcmFwcGVyXG4gICAgICAgIC5yZXBsYWNlKCcjdmVjM19kZWZpbml0aW9ucycsIHRoaXMuZGVmaW5pdGlvblZlYzMuam9pbignXFxuJykpXG4gICAgICAgIC5yZXBsYWNlKCcjdmVjM19hcHBsaWNhdGlvbnMnLCB0aGlzLmFwcGxpY2F0aW9uVmVjMy5qb2luKCdcXG4nKSlcbiAgICAgICAgLnJlcGxhY2UoJyN2ZWM0X2RlZmluaXRpb25zJywgdGhpcy5kZWZpbml0aW9uVmVjNC5qb2luKCdcXG4nKSlcbiAgICAgICAgLnJlcGxhY2UoJyN2ZWM0X2FwcGxpY2F0aW9ucycsIHRoaXMuYXBwbGljYXRpb25WZWM0LmpvaW4oJ1xcbicpKVxuICAgICAgICAucmVwbGFjZSgnI2Zsb2F0X2RlZmluaXRpb25zJywgdGhpcy5kZWZpbml0aW9uRmxvYXQuam9pbignXFxuJykpXG4gICAgICAgIC5yZXBsYWNlKCcjZmxvYXRfYXBwbGljYXRpb25zJywgdGhpcy5hcHBsaWNhdGlvbkZsb2F0LmpvaW4oJ1xcbicpKTtcblxuICAgIHByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKFxuICAgICAgICBwcm9ncmFtLFxuICAgICAgICB0aGlzLmNvbXBpbGVTaGFkZXIodGhpcy5nbC5jcmVhdGVTaGFkZXIoVkVSVEVYX1NIQURFUiksIHZlcnRleFNvdXJjZSlcbiAgICApO1xuXG4gICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIoXG4gICAgICAgIHByb2dyYW0sXG4gICAgICAgIHRoaXMuY29tcGlsZVNoYWRlcih0aGlzLmdsLmNyZWF0ZVNoYWRlcihGUkFHTUVOVF9TSEFERVIpLCBmcmFnbWVudFNvdXJjZSlcbiAgICApO1xuXG4gICAgdGhpcy5nbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIGlmICghIHRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCB0aGlzLmdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdsaW5rIGVycm9yOiAnICsgdGhpcy5nbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFVuaWZvcm1zKHRoaXMudW5pZm9ybU5hbWVzLCB0aGlzLnVuaWZvcm1WYWx1ZXMpO1xuXG4gICAgdmFyIHRleHR1cmVMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ3VfdGV4dHVyZXNbMF0nKTtcbiAgICB0aGlzLmdsLnVuaWZvcm0xaXYodGV4dHVyZUxvY2F0aW9uLCBbMCwgMSwgMiwgMywgNCwgNSwgNl0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgdW5pZm9ybSB2YWx1ZSBhZ2FpbnN0XG4gKiB0aGUgY2FjaGVkIHZhbHVlIHN0b3JlZCBvbiB0aGUgUHJvZ3JhbSBjbGFzcy4gIFVwZGF0ZXMgYW5kXG4gKiBjcmVhdGVzIG5ldyBlbnRyaWVzIGluIHRoZSBjYWNoZSB3aGVuIG5lY2Vzc2FyeS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0TmFtZSBLZXkgb2YgdW5pZm9ybSBzcGVjIGJlaW5nIGV2YWx1YXRlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfEFycmF5fSB2YWx1ZSBWYWx1ZSBvZiB1bmlmb3JtIHNwZWMgYmVpbmcgZXZhbHVhdGVkLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGJvb2xlYW4gSW5kaWNhdGluZyB3aGV0aGVyIHRoZSB1bmlmb3JtIGJlaW5nIHNldCBpcyBjYWNoZWQuXG4gKi9cblByb2dyYW0ucHJvdG90eXBlLnVuaWZvcm1Jc0NhY2hlZCA9IGZ1bmN0aW9uKHRhcmdldE5hbWUsIHZhbHVlKSB7XG4gICAgaWYodGhpcy5jYWNoZWRVbmlmb3Jtc1t0YXJnZXROYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkVW5pZm9ybXNbdGFyZ2V0TmFtZV0gPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkVW5pZm9ybXNbdGFyZ2V0TmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgaWYodmFsdWVbaV0gIT09IHRoaXMuY2FjaGVkVW5pZm9ybXNbdGFyZ2V0TmFtZV1baV0pIHtcbiAgICAgICAgICAgICAgICBpID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlKGktLSkgdGhpcy5jYWNoZWRVbmlmb3Jtc1t0YXJnZXROYW1lXVtpXSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsc2UgaWYgKHRoaXMuY2FjaGVkVW5pZm9ybXNbdGFyZ2V0TmFtZV0gIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FjaGVkVW5pZm9ybXNbdGFyZ2V0TmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIGFsbCBwYXNzaW5nIG9mIHVuaWZvcm1zIHRvIFdlYkdMIGRyYXdpbmcgY29udGV4dC4gIFRoaXNcbiAqIGZ1bmN0aW9uIHdpbGwgZmluZCB0aGUgdW5pZm9ybSBsb2NhdGlvbiBhbmQgdGhlbiwgYmFzZWQgb25cbiAqIGEgdHlwZSBpbmZlcnJlZCBmcm9tIHRoZSBqYXZhc2NyaXB0IHZhbHVlIG9mIHRoZSB1bmlmb3JtLCBpdCB3aWxsIGNhbGxcbiAqIHRoZSBhcHByb3ByaWF0ZSBmdW5jdGlvbiB0byBwYXNzIHRoZSB1bmlmb3JtIHRvIFdlYkdMLiAgRmluYWxseSxcbiAqIHNldFVuaWZvcm1zIHdpbGwgaXRlcmF0ZSB0aHJvdWdoIHRoZSBwYXNzZWQgaW4gc2hhZGVyQ2h1bmtzIChpZiBhbnkpXG4gKiBhbmQgc2V0IHRoZSBhcHByb3ByaWF0ZSB1bmlmb3JtcyB0byBzcGVjaWZ5IHdoaWNoIGNodW5rcyB0byB1c2UuXG4gKlxuICogQG1ldGhvZFxuICogQHBhcmFtIHtBcnJheX0gdW5pZm9ybU5hbWVzIEFycmF5IGNvbnRhaW5pbmcgdGhlIGtleXMgb2YgYWxsIHVuaWZvcm1zIHRvIGJlIHNldC5cbiAqIEBwYXJhbSB7QXJyYXl9IHVuaWZvcm1WYWx1ZSBBcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZXMgb2YgYWxsIHVuaWZvcm1zIHRvIGJlIHNldC5cbiAqXG4gKiBAcmV0dXJuIHtQcm9ncmFtfSBDdXJyZW50IHByb2dyYW0uXG4gKi9cblByb2dyYW0ucHJvdG90eXBlLnNldFVuaWZvcm1zID0gZnVuY3Rpb24gKHVuaWZvcm1OYW1lcywgdW5pZm9ybVZhbHVlKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgbG9jYXRpb247XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBuYW1lO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIXRoaXMucHJvZ3JhbSkgcmV0dXJuIHRoaXM7XG5cbiAgICBsZW4gPSB1bmlmb3JtTmFtZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBuYW1lID0gdW5pZm9ybU5hbWVzW2ldO1xuICAgICAgICB2YWx1ZSA9IHVuaWZvcm1WYWx1ZVtpXTtcblxuICAgICAgICAvLyBSZXRyZWl2ZSB0aGUgY2FjaGVkIGxvY2F0aW9uIG9mIHRoZSB1bmlmb3JtLFxuICAgICAgICAvLyByZXF1ZXN0aW5nIGEgbmV3IGxvY2F0aW9uIGZyb20gdGhlIFdlYkdMIGNvbnRleHRcbiAgICAgICAgLy8gaWYgaXQgZG9lcyBub3QgeWV0IGV4aXN0LlxuXG4gICAgICAgIGxvY2F0aW9uID0gdGhpcy51bmlmb3JtTG9jYXRpb25zW25hbWVdO1xuXG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpO1xuICAgICAgICAgICAgdGhpcy51bmlmb3JtTG9jYXRpb25zW25hbWVdID0gbG9jYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSBzZXQgZm9yIHRoZVxuICAgICAgICAvLyBnaXZlbiB1bmlmb3JtLlxuXG4gICAgICAgIGlmICh0aGlzLnVuaWZvcm1Jc0NhY2hlZChuYW1lLCB2YWx1ZSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgY29ycmVjdCBmdW5jdGlvbiBhbmQgcGFzcyB0aGUgdW5pZm9ybVxuICAgICAgICAvLyB2YWx1ZSB0byBXZWJHTC5cblxuICAgICAgICBpZiAoIXRoaXMudW5pZm9ybVR5cGVzW25hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1UeXBlc1tuYW1lXSA9IHRoaXMuZ2V0VW5pZm9ybVR5cGVGcm9tVmFsdWUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbCB1bmlmb3JtIHNldHRlciBmdW5jdGlvbiBvbiBXZWJHTCBjb250ZXh0IHdpdGggY29ycmVjdCB2YWx1ZVxuXG4gICAgICAgIHN3aXRjaCAodGhpcy51bmlmb3JtVHlwZXNbbmFtZV0pIHtcbiAgICAgICAgICAgIGNhc2UgJ3VuaWZvcm00ZnYnOiAgZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VuaWZvcm0zZnYnOiAgZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VuaWZvcm0yZnYnOiAgZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VuaWZvcm0xZnYnOiAgZ2wudW5pZm9ybTFmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VuaWZvcm0xZicgOiAgZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndW5pZm9ybU1hdHJpeDNmdic6IGdsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndW5pZm9ybU1hdHJpeDRmdic6IGdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluZmVycyB1bmlmb3JtIHNldHRlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gdGhlIFdlYkdMIGNvbnRleHQsIGJhc2VkXG4gKiBvbiBhbiBpbnB1dCB2YWx1ZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IHZhbHVlIFZhbHVlIGZyb20gd2hpY2ggdW5pZm9ybSB0eXBlIGlzIGluZmVycmVkLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gTmFtZSBvZiB1bmlmb3JtIGZ1bmN0aW9uIGZvciBnaXZlbiB2YWx1ZS5cbiAqL1xuUHJvZ3JhbS5wcm90b3R5cGUuZ2V0VW5pZm9ybVR5cGVGcm9tVmFsdWUgPSBmdW5jdGlvbiBnZXRVbmlmb3JtVHlwZUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOiAgcmV0dXJuICd1bmlmb3JtMWZ2JztcbiAgICAgICAgICAgIGNhc2UgMjogIHJldHVybiAndW5pZm9ybTJmdic7XG4gICAgICAgICAgICBjYXNlIDM6ICByZXR1cm4gJ3VuaWZvcm0zZnYnO1xuICAgICAgICAgICAgY2FzZSA0OiAgcmV0dXJuICd1bmlmb3JtNGZ2JztcbiAgICAgICAgICAgIGNhc2UgOTogIHJldHVybiAndW5pZm9ybU1hdHJpeDNmdic7XG4gICAgICAgICAgICBjYXNlIDE2OiByZXR1cm4gJ3VuaWZvcm1NYXRyaXg0ZnYnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkgJiYgaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAndW5pZm9ybTFmJztcbiAgICB9XG5cbiAgICB0aHJvdyAnY2FudCBsb2FkIHVuaWZvcm0gXCInICsgbmFtZSArICdcIiB3aXRoIHZhbHVlOicgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZHMgc2hhZGVyIHNvdXJjZSB0byBzaGFkZXIgYW5kIGNvbXBpbGVzIHRoZSBpbnB1dCBzaGFkZXIuICBDaGVja3NcbiAqIGNvbXBpbGUgc3RhdHVzIGFuZCBsb2dzIGVycm9yIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNoYWRlciBQcm9ncmFtIHRvIGJlIGNvbXBpbGVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSBTb3VyY2UgdG8gYmUgdXNlZCBpbiB0aGUgc2hhZGVyLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gQ29tcGlsZWQgc2hhZGVyLlxuICovXG5Qcm9ncmFtLnByb3RvdHlwZS5jb21waWxlU2hhZGVyID0gZnVuY3Rpb24gY29tcGlsZVNoYWRlcihzaGFkZXIsIHNvdXJjZSkge1xuICAgIHZhciBpID0gMTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgdGhpcy5nbC5jb21waWxlU2hhZGVyID0gRGVidWcuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLmdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG4gICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgaWYgKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2NvbXBpbGUgZXJyb3I6ICcgKyB0aGlzLmdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJzE6ICcgKyBzb3VyY2UucmVwbGFjZSgvXFxuL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxuJyArIChpKz0xKSArICc6ICc7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9ncmFtO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRleHR1cmUgaXMgYSBwcml2YXRlIGNsYXNzIHRoYXQgc3RvcmVzIGltYWdlIGRhdGFcbiAqIHRvIGJlIGFjY2Vzc2VkIGZyb20gYSBzaGFkZXIgb3IgdXNlZCBhcyBhIHJlbmRlciB0YXJnZXQuXG4gKlxuICogQGNsYXNzIFRleHR1cmVcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7R0x9IGdsIEdMXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gVGV4dHVyZShnbCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuaWQgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgdGhpcy53aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgMDtcbiAgICB0aGlzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IDA7XG4gICAgdGhpcy5taXBtYXAgPSBvcHRpb25zLm1pcG1hcDtcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8ICdSR0JBJztcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGUgfHwgJ1VOU0lHTkVEX0JZVEUnO1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIHRoaXMuYmluZCgpO1xuXG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgb3B0aW9ucy5mbGlwWVdlYmdsIHx8IGZhbHNlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIG9wdGlvbnMucHJlbXVsdGlwbHlBbHBoYVdlYmdsIHx8IGZhbHNlKTtcblxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbFtvcHRpb25zLm1hZ0ZpbHRlcl0gfHwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsW29wdGlvbnMubWluRmlsdGVyXSB8fCBnbC5ORUFSRVNUKTtcblxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsW29wdGlvbnMud3JhcFNdIHx8IGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsW29wdGlvbnMud3JhcFRdIHx8IGdsLkNMQU1QX1RPX0VER0UpO1xufVxuXG4vKipcbiAqIEJpbmRzIHRoaXMgdGV4dHVyZSBhcyB0aGUgc2VsZWN0ZWQgdGFyZ2V0LlxuICpcbiAqIEBtZXRob2RcbiAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCB0ZXh0dXJlIGluc3RhbmNlLlxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gYmluZCgpIHtcbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5pZCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVyYXNlcyB0aGUgdGV4dHVyZSBkYXRhIGluIHRoZSBnaXZlbiB0ZXh0dXJlIHNsb3QuXG4gKlxuICogQG1ldGhvZFxuICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IHRleHR1cmUgaW5zdGFuY2UuXG4gKi9cblRleHR1cmUucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlcGxhY2VzIHRoZSBpbWFnZSBkYXRhIGluIHRoZSB0ZXh0dXJlIHdpdGggdGhlIGdpdmVuIGltYWdlLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge0ltYWdlfSAgIGltZyAgICAgVGhlIGltYWdlIG9iamVjdCB0byB1cGxvYWQgcGl4ZWwgZGF0YSBmcm9tLlxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIEN1cnJlbnQgdGV4dHVyZSBpbnN0YW5jZS5cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuc2V0SW1hZ2UgPSBmdW5jdGlvbiBzZXRJbWFnZShpbWcpIHtcbiAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdsW3RoaXMuZm9ybWF0XSwgdGhpcy5nbFt0aGlzLmZvcm1hdF0sIHRoaXMuZ2xbdGhpcy50eXBlXSwgaW1nKTtcbiAgICBpZiAodGhpcy5taXBtYXApIHRoaXMuZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5nbC5URVhUVVJFXzJEKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIGltYWdlIGRhdGEgaW4gdGhlIHRleHR1cmUgd2l0aCBhbiBhcnJheSBvZiBhcmJpdHJhcnkgZGF0YS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gICBpbnB1dCAgIEFycmF5IHRvIGJlIHNldCBhcyBkYXRhIHRvIHRleHR1cmUuXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgQ3VycmVudCB0ZXh0dXJlIGluc3RhbmNlLlxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5zZXRBcnJheSA9IGZ1bmN0aW9uIHNldEFycmF5KGlucHV0KSB7XG4gICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbFt0aGlzLmZvcm1hdF0sIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCB0aGlzLmdsW3RoaXMuZm9ybWF0XSwgdGhpcy5nbFt0aGlzLnR5cGVdLCBpbnB1dCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIER1bXBzIHRoZSByZ2ItcGl4ZWwgY29udGVudHMgb2YgYSB0ZXh0dXJlIGludG8gYW4gYXJyYXkgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCAgICAgICAgeC1vZmZzZXQgYmV0d2VlbiB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFuZCBzbmFwc2hvdFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgICAgICAgIHktb2Zmc2V0IGJldHdlZW4gdGV4dHVyZSBjb29yZGluYXRlcyBhbmQgc25hcHNob3RcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAgICB4LWRlcHRoIG9mIHRoZSBzbmFwc2hvdFxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAgIHktZGVwdGggb2YgdGhlIHNuYXBzaG90XG4gKlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgIEFuIGFycmF5IG9mIHRoZSBwaXhlbHMgY29udGFpbmVkIGluIHRoZSBzbmFwc2hvdC5cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUucmVhZEJhY2sgPSBmdW5jdGlvbiByZWFkQmFjayh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgcGl4ZWxzO1xuICAgIHggPSB4IHx8IDA7XG4gICAgeSA9IHkgfHwgMDtcbiAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMud2lkdGg7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0O1xuICAgIHZhciBmYiA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLmlkLCAwKTtcbiAgICBpZiAoZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUikgPT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG4gICAgICAgIHBpeGVscyA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpeGVscztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUZXh0dXJlID0gcmVxdWlyZSgnLi9UZXh0dXJlJyk7XG52YXIgY3JlYXRlQ2hlY2tlcmJvYXJkID0gcmVxdWlyZSgnLi9jcmVhdGVDaGVja2VyYm9hcmQnKTtcblxuLyoqXG4gKiBIYW5kbGVzIGxvYWRpbmcsIGJpbmRpbmcsIGFuZCByZXNhbXBsaW5nIG9mIHRleHR1cmVzIGZvciBXZWJHTFJlbmRlcmVyLlxuICpcbiAqIEBjbGFzcyBUZXh0dXJlTWFuYWdlclxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtXZWJHTF9Db250ZXh0fSBnbCBDb250ZXh0IHVzZWQgdG8gY3JlYXRlIGFuZCBiaW5kIHRleHR1cmVzLlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIFRleHR1cmVNYW5hZ2VyKGdsKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICAgIHRoaXMuX25lZWRzUmVzYW1wbGUgPSBbXTtcblxuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmUgPSAwO1xuICAgIHRoaXMuX2JvdW5kVGV4dHVyZSA9IG51bGw7XG5cbiAgICB0aGlzLl9jaGVja2VyYm9hcmQgPSBjcmVhdGVDaGVja2VyYm9hcmQoKTtcblxuICAgIHRoaXMuZ2wgPSBnbDtcbn1cblxuLyoqXG4gKiBVcGRhdGUgZnVuY3Rpb24gdXNlZCBieSBXZWJHTFJlbmRlcmVyIHRvIHF1ZXVlIHJlc2FtcGxlcyBvblxuICogcmVnaXN0ZXJlZCB0ZXh0dXJlcy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgdGltZSAgICBUaW1lIGluIG1pbGxpc2Vjb25kcyBhY2NvcmRpbmcgdG8gdGhlIGNvbXBvc2l0b3IuXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9ICAgICAgICAgIHVuZGVmaW5lZFxuICovXG5UZXh0dXJlTWFuYWdlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHRpbWUpIHtcbiAgICB2YXIgcmVnaXN0cnlMZW5ndGggPSB0aGlzLnJlZ2lzdHJ5Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmVnaXN0cnlMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMucmVnaXN0cnlbaV07XG5cbiAgICAgICAgaWYgKHRleHR1cmUgJiYgdGV4dHVyZS5pc0xvYWRlZCAmJiB0ZXh0dXJlLnJlc2FtcGxlUmF0ZSkge1xuICAgICAgICAgICAgaWYgKCF0ZXh0dXJlLmxhc3RSZXNhbXBsZSB8fCB0aW1lIC0gdGV4dHVyZS5sYXN0UmVzYW1wbGUgPiB0ZXh0dXJlLnJlc2FtcGxlUmF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbmVlZHNSZXNhbXBsZVt0ZXh0dXJlLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc1Jlc2FtcGxlW3RleHR1cmUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5sYXN0UmVzYW1wbGUgPSB0aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNwZWMgYW5kIGNyZWF0ZXMgYSB0ZXh0dXJlIGJhc2VkIG9uIGdpdmVuIHRleHR1cmUgZGF0YS5cbiAqIEhhbmRsZXMgbG9hZGluZyBhc3NldHMgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gIGlucHV0ICAgT2JqZWN0IGNvbnRhaW5pbmcgdGV4dHVyZSBpZCwgdGV4dHVyZSBkYXRhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIG9wdGlvbnMgdXNlZCB0byBkcmF3IHRleHR1cmUuXG4gKiBAcGFyYW0ge051bWJlcn0gIHNsb3QgICAgVGV4dHVyZSBzbG90IHRvIGJpbmQgZ2VuZXJhdGVkIHRleHR1cmUgdG8uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9ICAgICAgdW5kZWZpbmVkXG4gKi9cblRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGlucHV0LCBzbG90KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBzb3VyY2UgPSBpbnB1dC5kYXRhO1xuICAgIHZhciB0ZXh0dXJlSWQgPSBpbnB1dC5pZDtcbiAgICB2YXIgb3B0aW9ucyA9IGlucHV0Lm9wdGlvbnMgfHwge307XG4gICAgdmFyIHRleHR1cmUgPSB0aGlzLnJlZ2lzdHJ5W3RleHR1cmVJZF07XG4gICAgdmFyIHNwZWM7XG5cbiAgICBpZiAoIXRleHR1cmUpIHtcblxuICAgICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwgb3B0aW9ucyk7XG4gICAgICAgIHRleHR1cmUuc2V0SW1hZ2UodGhpcy5fY2hlY2tlcmJvYXJkKTtcblxuICAgICAgICAvLyBBZGQgdGV4dHVyZSB0byByZWdpc3RyeVxuXG4gICAgICAgIHNwZWMgPSB0aGlzLnJlZ2lzdHJ5W3RleHR1cmVJZF0gPSB7XG4gICAgICAgICAgICByZXNhbXBsZVJhdGU6IG9wdGlvbnMucmVzYW1wbGVSYXRlIHx8IG51bGwsXG4gICAgICAgICAgICBsYXN0UmVzYW1wbGU6IG51bGwsXG4gICAgICAgICAgICBpc0xvYWRlZDogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0dXJlOiB0ZXh0dXJlLFxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICBpZDogdGV4dHVyZUlkLFxuICAgICAgICAgICAgc2xvdDogc2xvdFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEhhbmRsZSBhcnJheVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFRleHR1cmUodGV4dHVyZUlkKTtcbiAgICAgICAgICAgIHRleHR1cmUuc2V0QXJyYXkoc291cmNlKTtcbiAgICAgICAgICAgIHNwZWMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHZpZGVvXG5cbiAgICAgICAgZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZGRhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5iaW5kVGV4dHVyZSh0ZXh0dXJlSWQpO1xuICAgICAgICAgICAgICAgIHRleHR1cmUuc2V0SW1hZ2Uoc291cmNlKTtcblxuICAgICAgICAgICAgICAgIHNwZWMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNwZWMuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgaW1hZ2UgdXJsXG5cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxvYWRJbWFnZShzb3VyY2UsIGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5iaW5kVGV4dHVyZSh0ZXh0dXJlSWQpO1xuICAgICAgICAgICAgICAgIHRleHR1cmUuc2V0SW1hZ2UoaW1nKTtcblxuICAgICAgICAgICAgICAgIHNwZWMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNwZWMuc291cmNlID0gaW1nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dHVyZUlkO1xufTtcblxuLyoqXG4gKiBMb2FkcyBhbiBpbWFnZSBmcm9tIGEgc3RyaW5nIG9yIEltYWdlIG9iamVjdCBhbmQgZXhlY3V0ZXMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gaW5wdXQgVGhlIGlucHV0IGltYWdlIGRhdGEgdG8gbG9hZCBhcyBhbiBhc3NldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBmaXJlZCB3aGVuIHRoZSBpbWFnZSBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IEltYWdlIG9iamVjdCBiZWluZyBsb2FkZWQuXG4gKi9cbmZ1bmN0aW9uIGxvYWRJbWFnZSAoaW5wdXQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGltYWdlID0gKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyBuZXcgSW1hZ2UoKSA6IGlucHV0KSB8fCB7fTtcbiAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcblxuICAgIGlmICghaW1hZ2Uuc3JjKSBpbWFnZS5zcmMgPSBpbnB1dDtcbiAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGltYWdlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKGltYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2U7XG59XG5cbi8qKlxuICogU2V0cyBhY3RpdmUgdGV4dHVyZSBzbG90IGFuZCBiaW5kcyB0YXJnZXQgdGV4dHVyZS4gIEFsc28gaGFuZGxlc1xuICogcmVzYW1wbGluZyB3aGVuIG5lY2Vzc2FyeS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIElkZW50aWZpZXIgdXNlZCB0byByZXRyZWl2ZSB0ZXh0dXJlIHNwZWNcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5UZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuYmluZFRleHR1cmUgPSBmdW5jdGlvbiBiaW5kVGV4dHVyZShpZCkge1xuICAgIHZhciBzcGVjID0gdGhpcy5yZWdpc3RyeVtpZF07XG5cbiAgICBpZiAodGhpcy5fYWN0aXZlVGV4dHVyZSAhPT0gc3BlYy5zbG90KSB7XG4gICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgc3BlYy5zbG90KTtcbiAgICAgICAgdGhpcy5fYWN0aXZlVGV4dHVyZSA9IHNwZWMuc2xvdDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYm91bmRUZXh0dXJlICE9PSBpZCkge1xuICAgICAgICB0aGlzLl9ib3VuZFRleHR1cmUgPSBpZDtcbiAgICAgICAgc3BlYy50ZXh0dXJlLmJpbmQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbmVlZHNSZXNhbXBsZVtzcGVjLmlkXSkge1xuXG4gICAgICAgIC8vIFRPRE86IEFjY291bnQgZm9yIHJlc2FtcGxpbmcgb2YgYXJyYXlzLlxuXG4gICAgICAgIHNwZWMudGV4dHVyZS5zZXRJbWFnZShzcGVjLnNvdXJjZSk7XG4gICAgICAgIHRoaXMuX25lZWRzUmVzYW1wbGVbc3BlYy5pZF0gPSBmYWxzZTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmVNYW5hZ2VyO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvZ3JhbSA9IHJlcXVpcmUoJy4vUHJvZ3JhbScpO1xudmFyIEJ1ZmZlclJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9CdWZmZXJSZWdpc3RyeScpO1xudmFyIHNvcnRlciA9IHJlcXVpcmUoJy4vcmFkaXhTb3J0Jyk7XG52YXIga2V5VmFsdWVUb0FycmF5cyA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9rZXlWYWx1ZVRvQXJyYXlzJyk7XG52YXIgVGV4dHVyZU1hbmFnZXIgPSByZXF1aXJlKCcuL1RleHR1cmVNYW5hZ2VyJyk7XG52YXIgY29tcGlsZU1hdGVyaWFsID0gcmVxdWlyZSgnLi9jb21waWxlTWF0ZXJpYWwnKTtcblxudmFyIGlkZW50aXR5ID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuXG52YXIgZ2xvYmFsVW5pZm9ybXMgPSBrZXlWYWx1ZVRvQXJyYXlzKHtcbiAgICAndV9udW1MaWdodHMnOiAwLFxuICAgICd1X2FtYmllbnRMaWdodCc6IG5ldyBBcnJheSgzKSxcbiAgICAndV9saWdodFBvc2l0aW9uJzogbmV3IEFycmF5KDMpLFxuICAgICd1X2xpZ2h0Q29sb3InOiBuZXcgQXJyYXkoMyksXG4gICAgJ3VfcGVyc3BlY3RpdmUnOiBuZXcgQXJyYXkoMTYpLFxuICAgICd1X3RpbWUnOiAwLFxuICAgICd1X3ZpZXcnOiBuZXcgQXJyYXkoMTYpXG59KTtcblxuLyoqXG4gKiBXZWJHTFJlbmRlcmVyIGlzIGEgcHJpdmF0ZSBjbGFzcyB0aGF0IG1hbmFnZXMgYWxsIGludGVyYWN0aW9ucyB3aXRoIHRoZSBXZWJHTFxuICogQVBJLiBFYWNoIGZyYW1lIGl0IHJlY2VpdmVzIGNvbW1hbmRzIGZyb20gdGhlIGNvbXBvc2l0b3IgYW5kIHVwZGF0ZXMgaXRzXG4gKiByZWdpc3RyaWVzIGFjY29yZGluZ2x5LiBTdWJzZXF1ZW50bHksIHRoZSBkcmF3IGZ1bmN0aW9uIGlzIGNhbGxlZCBhbmQgdGhlXG4gKiBXZWJHTFJlbmRlcmVyIGlzc3VlcyBkcmF3IGNhbGxzIGZvciBhbGwgbWVzaGVzIGluIGl0cyByZWdpc3RyeS5cbiAqXG4gKiBAY2xhc3MgV2ViR0xSZW5kZXJlclxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBjYW52YXMgVGhlIERPTSBlbGVtZW50IHRoYXQgR0wgd2lsbCBwYWludCBpdHNlbGYgb250by5cbiAqIEBwYXJhbSB7Q29tcG9zaXRvcn0gY29tcG9zaXRvciBDb21wb3NpdG9yIHVzZWQgZm9yIHF1ZXJ5aW5nIHRoZSB0aW1lIGZyb20uXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gV2ViR0xSZW5kZXJlcihjYW52YXMsIGNvbXBvc2l0b3IpIHtcbiAgICBjYW52YXMuY2xhc3NMaXN0LmFkZCgnZmFtb3VzLXdlYmdsLXJlbmRlcmVyJyk7XG5cbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmNvbXBvc2l0b3IgPSBjb21wb3NpdG9yO1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbCA9IHRoaXMuZ2V0V2ViR0xDb250ZXh0KHRoaXMuY2FudmFzKTtcblxuICAgIGdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICBnbC5wb2x5Z29uT2Zmc2V0KDAuMSwgMC4xKTtcbiAgICBnbC5lbmFibGUoZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7XG4gICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgZ2wuZGVwdGhGdW5jKGdsLkxFUVVBTCk7XG4gICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgZ2wuY3VsbEZhY2UoZ2wuQkFDSyk7XG5cbiAgICB0aGlzLm1lc2hSZWdpc3RyeSA9IHt9O1xuICAgIHRoaXMubWVzaFJlZ2lzdHJ5S2V5cyA9IFtdO1xuXG4gICAgdGhpcy5jdXRvdXRSZWdpc3RyeSA9IHt9O1xuXG4gICAgdGhpcy5jdXRvdXRSZWdpc3RyeUtleXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIExpZ2h0c1xuICAgICAqL1xuICAgIHRoaXMubnVtTGlnaHRzID0gMDtcbiAgICB0aGlzLmFtYmllbnRMaWdodENvbG9yID0gWzAsIDAsIDBdO1xuICAgIHRoaXMubGlnaHRSZWdpc3RyeSA9IHt9O1xuICAgIHRoaXMubGlnaHRSZWdpc3RyeUtleXMgPSBbXTtcbiAgICB0aGlzLmxpZ2h0UG9zaXRpb25zID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIHRoaXMubGlnaHRDb2xvcnMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG5cbiAgICB0aGlzLnRleHR1cmVNYW5hZ2VyID0gbmV3IFRleHR1cmVNYW5hZ2VyKGdsKTtcbiAgICB0aGlzLnRleENhY2hlID0ge307XG4gICAgdGhpcy5idWZmZXJSZWdpc3RyeSA9IG5ldyBCdWZmZXJSZWdpc3RyeShnbCk7XG4gICAgdGhpcy5wcm9ncmFtID0gbmV3IFByb2dyYW0oZ2wsIHsgZGVidWc6IHRydWUgfSk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBib3VuZEFycmF5QnVmZmVyOiBudWxsLFxuICAgICAgICBib3VuZEVsZW1lbnRCdWZmZXI6IG51bGwsXG4gICAgICAgIGxhc3REcmF3bjogbnVsbCxcbiAgICAgICAgZW5hYmxlZEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICBlbmFibGVkQXR0cmlidXRlc0tleXM6IFtdXG4gICAgfTtcblxuICAgIHRoaXMucmVzb2x1dGlvbk5hbWUgPSBbJ3VfcmVzb2x1dGlvbiddO1xuICAgIHRoaXMucmVzb2x1dGlvblZhbHVlcyA9IFtbMCwgMCwgMF1dO1xuXG4gICAgdGhpcy5jYWNoZWRTaXplID0gW107XG5cbiAgICAvKlxuICAgIFRoZSBwcm9qZWN0aW9uVHJhbnNmb3JtIGhhcyBzb21lIGNvbnN0YW50IGNvbXBvbmVudHMsIGkuZS4gdGhlIHogc2NhbGUsIGFuZCB0aGUgeCBhbmQgeSB0cmFuc2xhdGlvbi5cblxuICAgIFRoZSB6IHNjYWxlIGtlZXBzIHRoZSBmaW5hbCB6IHBvc2l0aW9uIG9mIGFueSB2ZXJ0ZXggd2l0aGluIHRoZSBjbGlwJ3MgZG9tYWluIGJ5IHNjYWxpbmcgaXQgYnkgYW5cbiAgICBhcmJpdHJhcmlseSBzbWFsbCBjb2VmZmljaWVudC4gVGhpcyBoYXMgdGhlIGFkdmFudGFnZSBvZiBiZWluZyBhIHVzZWZ1bCBkZWZhdWx0IGluIHRoZSBldmVudCBvZiB0aGVcbiAgICB1c2VyIGZvcmdvaW5nIGEgbmVhciBhbmQgZmFyIHBsYW5lLCBhbiBhbGllbiBjb252ZW50aW9uIGluIGRvbSBzcGFjZSBhcyBpbiBET00gb3ZlcmxhcHBpbmcgaXNcbiAgICBjb25kdWN0ZWQgdmlhIHBhaW50ZXIncyBhbGdvcml0aG0uXG5cbiAgICBUaGUgeCBhbmQgeSB0cmFuc2xhdGlvbiB0cmFuc2Zvcm1zIHRoZSB3b3JsZCBzcGFjZSBvcmlnaW4gdG8gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgc2NyZWVuLlxuXG4gICAgVGhlIGZpbmFsIGNvbXBvbmVudCAodGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtWzE1XSkgaXMgaW5pdGlhbGl6ZWQgYXMgMSBiZWNhdXNlIGNlcnRhaW4gcHJvamVjdGlvbiBtb2RlbHMsXG4gICAgZS5nLiB0aGUgV0MzIHNwZWNpZmllZCBtb2RlbCwga2VlcCB0aGUgWFkgcGxhbmUgYXMgdGhlIHByb2plY3Rpb24gaHlwZXJwbGFuZS5cbiAgICAqL1xuICAgIHRoaXMucHJvamVjdGlvblRyYW5zZm9ybSA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAtMC4wMDAwMDEsIDAsIC0xLCAxLCAwLCAxXTtcblxuICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGhhY2tcblxuICAgIHZhciBjdXRvdXQgPSB0aGlzLmN1dG91dEdlb21ldHJ5ID0ge1xuICAgICAgICBzcGVjOiB7XG4gICAgICAgICAgICBpZDogLTEsXG4gICAgICAgICAgICBidWZmZXJWYWx1ZXM6IFtbLTEsIC0xLCAwLCAxLCAtMSwgMCwgLTEsIDEsIDAsIDEsIDEsIDBdXSxcbiAgICAgICAgICAgIGJ1ZmZlck5hbWVzOiBbJ2FfcG9zJ10sXG4gICAgICAgICAgICB0eXBlOiAnVFJJQU5HTEVfU1RSSVAnXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5idWZmZXJSZWdpc3RyeS5hbGxvY2F0ZShcbiAgICAgICAgdGhpcy5jdXRvdXRHZW9tZXRyeS5zcGVjLmlkLFxuICAgICAgICBjdXRvdXQuc3BlYy5idWZmZXJOYW1lc1swXSxcbiAgICAgICAgY3V0b3V0LnNwZWMuYnVmZmVyVmFsdWVzWzBdLFxuICAgICAgICAzXG4gICAgKTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXRyZWl2ZSB0aGUgV2ViR0xSZW5kZXJlciBjb250ZXh0IHVzaW5nIHNldmVyYWxcbiAqIGFjY2Vzc29ycy4gRm9yIGJyb3dzZXIgY29tcGF0YWJpbGl0eS4gVGhyb3dzIG9uIGVycm9yLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY2FudmFzIENhbnZhcyBlbGVtZW50IGZyb20gd2hpY2ggdGhlIGNvbnRleHQgaXMgcmV0cmVpdmVkXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBXZWJHTENvbnRleHQgV2ViR0wgY29udGV4dFxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5nZXRXZWJHTENvbnRleHQgPSBmdW5jdGlvbiBnZXRXZWJHTENvbnRleHQoY2FudmFzKSB7XG4gICAgdmFyIG5hbWVzID0gWyd3ZWJnbCcsICdleHBlcmltZW50YWwtd2ViZ2wnLCAnd2Via2l0LTNkJywgJ21vei13ZWJnbCddO1xuICAgIHZhciBjb250ZXh0O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQobmFtZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dDogJyArIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0KSByZXR1cm4gY29udGV4dDtcbiAgICB9XG5cbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQ291bGQgbm90IHJldHJpZXZlIFdlYkdMIGNvbnRleHQuIFBsZWFzZSByZWZlciB0byBodHRwczovL3d3dy5raHJvbm9zLm9yZy93ZWJnbC8gZm9yIHJlcXVpcmVtZW50cycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGRzIGEgbmV3IGJhc2Ugc3BlYyB0byB0aGUgbGlnaHQgcmVnaXN0cnkgYXQgYSBnaXZlbiBwYXRoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBQYXRoIHVzZWQgYXMgaWQgb2YgbmV3IGxpZ2h0IGluIGxpZ2h0UmVnaXN0cnlcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IE5ld2x5IGNyZWF0ZWQgbGlnaHQgc3BlY1xuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVMaWdodCA9IGZ1bmN0aW9uIGNyZWF0ZUxpZ2h0KHBhdGgpIHtcbiAgICB0aGlzLm51bUxpZ2h0cysrO1xuICAgIHRoaXMubGlnaHRSZWdpc3RyeUtleXMucHVzaChwYXRoKTtcbiAgICB0aGlzLmxpZ2h0UmVnaXN0cnlbcGF0aF0gPSB7XG4gICAgICAgIGNvbG9yOiBbMCwgMCwgMF0sXG4gICAgICAgIHBvc2l0aW9uOiBbMCwgMCwgMF1cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmxpZ2h0UmVnaXN0cnlbcGF0aF07XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXcgYmFzZSBzcGVjIHRvIHRoZSBtZXNoIHJlZ2lzdHJ5IGF0IGEgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggUGF0aCB1c2VkIGFzIGlkIG9mIG5ldyBtZXNoIGluIG1lc2hSZWdpc3RyeS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IE5ld2x5IGNyZWF0ZWQgbWVzaCBzcGVjLlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVNZXNoID0gZnVuY3Rpb24gY3JlYXRlTWVzaChwYXRoKSB7XG4gICAgdGhpcy5tZXNoUmVnaXN0cnlLZXlzLnB1c2gocGF0aCk7XG5cbiAgICB2YXIgdW5pZm9ybXMgPSBrZXlWYWx1ZVRvQXJyYXlzKHtcbiAgICAgICAgdV9vcGFjaXR5OiAxLFxuICAgICAgICB1X3RyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgICAgIHVfc2l6ZTogWzAsIDAsIDBdLFxuICAgICAgICB1X2Jhc2VDb2xvcjogWzAuNSwgMC41LCAwLjUsIDFdLFxuICAgICAgICB1X3Bvc2l0aW9uT2Zmc2V0OiBbMCwgMCwgMF0sXG4gICAgICAgIHVfbm9ybWFsczogWzAsIDAsIDBdLFxuICAgICAgICB1X2ZsYXRTaGFkaW5nOiAwLFxuICAgICAgICB1X2dsb3NzaW5lc3M6IFswLCAwLCAwLCAwXVxuICAgIH0pO1xuICAgIHRoaXMubWVzaFJlZ2lzdHJ5W3BhdGhdID0ge1xuICAgICAgICBkZXB0aDogbnVsbCxcbiAgICAgICAgdW5pZm9ybUtleXM6IHVuaWZvcm1zLmtleXMsXG4gICAgICAgIHVuaWZvcm1WYWx1ZXM6IHVuaWZvcm1zLnZhbHVlcyxcbiAgICAgICAgYnVmZmVyczoge30sXG4gICAgICAgIGdlb21ldHJ5OiBudWxsLFxuICAgICAgICBkcmF3VHlwZTogbnVsbCxcbiAgICAgICAgdGV4dHVyZXM6IFtdLFxuICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5tZXNoUmVnaXN0cnlbcGF0aF07XG59O1xuXG4vKipcbiAqIFNldHMgZmxhZyBvbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gZG8gc2tpcCBkcmF3IHBoYXNlIGZvclxuICogY3V0b3V0IG1lc2ggYXQgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggUGF0aCB1c2VkIGFzIGlkIG9mIHRhcmdldCBjdXRvdXQgbWVzaC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlc0N1dG91dCBJbmRpY2F0ZXMgdGhlIHByZXNlbmNlIG9mIGEgY3V0b3V0IG1lc2hcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRDdXRvdXRTdGF0ZSA9IGZ1bmN0aW9uIHNldEN1dG91dFN0YXRlKHBhdGgsIHVzZXNDdXRvdXQpIHtcbiAgICB2YXIgY3V0b3V0ID0gdGhpcy5nZXRPclNldEN1dG91dChwYXRoKTtcblxuICAgIGN1dG91dC52aXNpYmxlID0gdXNlc0N1dG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBvciByZXRyZWl2ZXMgY3V0b3V0XG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdXNlZCBhcyBpZCBvZiB0YXJnZXQgY3V0b3V0IG1lc2guXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBOZXdseSBjcmVhdGVkIGN1dG91dCBzcGVjLlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5nZXRPclNldEN1dG91dCA9IGZ1bmN0aW9uIGdldE9yU2V0Q3V0b3V0KHBhdGgpIHtcbiAgICBpZiAodGhpcy5jdXRvdXRSZWdpc3RyeVtwYXRoXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXRvdXRSZWdpc3RyeVtwYXRoXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB1bmlmb3JtcyA9IGtleVZhbHVlVG9BcnJheXMoe1xuICAgICAgICAgICAgdV9vcGFjaXR5OiAwLFxuICAgICAgICAgICAgdV90cmFuc2Zvcm06IGlkZW50aXR5LnNsaWNlKCksXG4gICAgICAgICAgICB1X3NpemU6IFswLCAwLCAwXSxcbiAgICAgICAgICAgIHVfb3JpZ2luOiBbMCwgMCwgMF0sXG4gICAgICAgICAgICB1X2Jhc2VDb2xvcjogWzAsIDAsIDAsIDFdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY3V0b3V0UmVnaXN0cnlLZXlzLnB1c2gocGF0aCk7XG5cbiAgICAgICAgdGhpcy5jdXRvdXRSZWdpc3RyeVtwYXRoXSA9IHtcbiAgICAgICAgICAgIHVuaWZvcm1LZXlzOiB1bmlmb3Jtcy5rZXlzLFxuICAgICAgICAgICAgdW5pZm9ybVZhbHVlczogdW5pZm9ybXMudmFsdWVzLFxuICAgICAgICAgICAgZ2VvbWV0cnk6IHRoaXMuY3V0b3V0R2VvbWV0cnkuc3BlYy5pZCxcbiAgICAgICAgICAgIGRyYXdUeXBlOiB0aGlzLmN1dG91dEdlb21ldHJ5LnNwZWMudHlwZSxcbiAgICAgICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jdXRvdXRSZWdpc3RyeVtwYXRoXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldHMgZmxhZyBvbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gZG8gc2tpcCBkcmF3IHBoYXNlIGZvclxuICogbWVzaCBhdCBnaXZlbiBwYXRoLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdXNlZCBhcyBpZCBvZiB0YXJnZXQgbWVzaC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJpbGl0eSBJbmRpY2F0ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGFyZ2V0IG1lc2guXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0TWVzaFZpc2liaWxpdHkgPSBmdW5jdGlvbiBzZXRNZXNoVmlzaWJpbGl0eShwYXRoLCB2aXNpYmlsaXR5KSB7XG4gICAgdmFyIG1lc2ggPSB0aGlzLm1lc2hSZWdpc3RyeVtwYXRoXSB8fCB0aGlzLmNyZWF0ZU1lc2gocGF0aCk7XG5cbiAgICBtZXNoLnZpc2libGUgPSB2aXNpYmlsaXR5O1xufTtcblxuLyoqXG4gKiBEZWxldGVzIGEgbWVzaCBmcm9tIHRoZSBtZXNoUmVnaXN0cnkuXG4gKlxuICogQG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggUGF0aCB1c2VkIGFzIGlkIG9mIHRhcmdldCBtZXNoLlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZU1lc2ggPSBmdW5jdGlvbiByZW1vdmVNZXNoKHBhdGgpIHtcbiAgICB2YXIga2V5TG9jYXRpb24gPSB0aGlzLm1lc2hSZWdpc3RyeUtleXMuaW5kZXhPZihwYXRoKTtcbiAgICB0aGlzLm1lc2hSZWdpc3RyeUtleXMuc3BsaWNlKGtleUxvY2F0aW9uLCAxKTtcbiAgICB0aGlzLm1lc2hSZWdpc3RyeVtwYXRoXSA9IG51bGw7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgb3IgcmV0cmVpdmVzIGN1dG91dFxuICpcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdXNlZCBhcyBpZCBvZiBjdXRvdXQgaW4gY3V0b3V0IHJlZ2lzdHJ5LlxuICogQHBhcmFtIHtTdHJpbmd9IHVuaWZvcm1OYW1lIElkZW50aWZpZXIgdXNlZCB0byB1cGxvYWQgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHVuaWZvcm1WYWx1ZSBWYWx1ZSBvZiB1bmlmb3JtIGRhdGFcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRDdXRvdXRVbmlmb3JtID0gZnVuY3Rpb24gc2V0Q3V0b3V0VW5pZm9ybShwYXRoLCB1bmlmb3JtTmFtZSwgdW5pZm9ybVZhbHVlKSB7XG4gICAgdmFyIGN1dG91dCA9IHRoaXMuZ2V0T3JTZXRDdXRvdXQocGF0aCk7XG5cbiAgICB2YXIgaW5kZXggPSBjdXRvdXQudW5pZm9ybUtleXMuaW5kZXhPZih1bmlmb3JtTmFtZSk7XG5cbiAgICBpZiAodW5pZm9ybVZhbHVlLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdW5pZm9ybVZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjdXRvdXQudW5pZm9ybVZhbHVlc1tpbmRleF1baV0gPSB1bmlmb3JtVmFsdWVbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGN1dG91dC51bmlmb3JtVmFsdWVzW2luZGV4XSA9IHVuaWZvcm1WYWx1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEVkaXRzIHRoZSBvcHRpb25zIGZpZWxkIG9uIGEgbWVzaFxuICpcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdXNlZCBhcyBpZCBvZiB0YXJnZXQgbWVzaFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgTWFwIG9mIGRyYXcgb3B0aW9ucyBmb3IgbWVzaFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4qKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldE1lc2hPcHRpb25zID0gZnVuY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuICAgIHZhciBtZXNoID0gdGhpcy5tZXNoUmVnaXN0cnlbcGF0aF0gfHwgdGhpcy5jcmVhdGVNZXNoKHBhdGgpO1xuXG4gICAgbWVzaC5vcHRpb25zID0gb3B0aW9ucztcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgY29sb3Igb2YgdGhlIGZpeGVkIGludGVuc2l0eSBsaWdodGluZyBpbiB0aGUgc2NlbmVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggUGF0aCB1c2VkIGFzIGlkIG9mIGxpZ2h0XG4gKiBAcGFyYW0ge051bWJlcn0gciByZWQgY2hhbm5lbFxuICogQHBhcmFtIHtOdW1iZXJ9IGcgZ3JlZW4gY2hhbm5lbFxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYmx1ZSBjaGFubmVsXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbioqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0QW1iaWVudExpZ2h0Q29sb3IgPSBmdW5jdGlvbiBzZXRBbWJpZW50TGlnaHRDb2xvcihwYXRoLCByLCBnLCBiKSB7XG4gICAgdGhpcy5hbWJpZW50TGlnaHRDb2xvclswXSA9IHI7XG4gICAgdGhpcy5hbWJpZW50TGlnaHRDb2xvclsxXSA9IGc7XG4gICAgdGhpcy5hbWJpZW50TGlnaHRDb2xvclsyXSA9IGI7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBsaWdodCBpbiB0aGUgc2NlbmVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggUGF0aCB1c2VkIGFzIGlkIG9mIGxpZ2h0XG4gKiBAcGFyYW0ge051bWJlcn0geCB4IHBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0geSB5IHBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0geiB6IHBvc2l0aW9uXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbioqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0TGlnaHRQb3NpdGlvbiA9IGZ1bmN0aW9uIHNldExpZ2h0UG9zaXRpb24ocGF0aCwgeCwgeSwgeikge1xuICAgIHZhciBsaWdodCA9IHRoaXMubGlnaHRSZWdpc3RyeVtwYXRoXSB8fCB0aGlzLmNyZWF0ZUxpZ2h0KHBhdGgpO1xuXG4gICAgbGlnaHQucG9zaXRpb25bMF0gPSB4O1xuICAgIGxpZ2h0LnBvc2l0aW9uWzFdID0geTtcbiAgICBsaWdodC5wb3NpdGlvblsyXSA9IHo7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIGNvbG9yIG9mIGEgZHluYW1pYyBpbnRlbnNpdHkgbGlnaHRpbmcgaW4gdGhlIHNjZW5lXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdXNlZCBhcyBpZCBvZiBsaWdodCBpbiBsaWdodCBSZWdpc3RyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSByIHJlZCBjaGFubmVsXG4gKiBAcGFyYW0ge051bWJlcn0gZyBncmVlbiBjaGFubmVsXG4gKiBAcGFyYW0ge051bWJlcn0gYiBibHVlIGNoYW5uZWxcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuKiovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRMaWdodENvbG9yID0gZnVuY3Rpb24gc2V0TGlnaHRDb2xvcihwYXRoLCByLCBnLCBiKSB7XG4gICAgdmFyIGxpZ2h0ID0gdGhpcy5saWdodFJlZ2lzdHJ5W3BhdGhdIHx8IHRoaXMuY3JlYXRlTGlnaHQocGF0aCk7XG5cbiAgICBsaWdodC5jb2xvclswXSA9IHI7XG4gICAgbGlnaHQuY29sb3JbMV0gPSBnO1xuICAgIGxpZ2h0LmNvbG9yWzJdID0gYjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tcGlsZXMgbWF0ZXJpYWwgc3BlYyBpbnRvIHByb2dyYW0gc2hhZGVyXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdXNlZCBhcyBpZCBvZiBjdXRvdXQgaW4gY3V0b3V0IHJlZ2lzdHJ5LlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSB0aGF0IHRoZSByZW5kZXJpbmcgaW5wdXQgdGhlIG1hdGVyaWFsIGlzIGJvdW5kIHRvXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWwgTWF0ZXJpYWwgc3BlY1xuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4qKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZU1hdGVyaWFsSW5wdXQgPSBmdW5jdGlvbiBoYW5kbGVNYXRlcmlhbElucHV0KHBhdGgsIG5hbWUsIG1hdGVyaWFsKSB7XG4gICAgdmFyIG1lc2ggPSB0aGlzLm1lc2hSZWdpc3RyeVtwYXRoXSB8fCB0aGlzLmNyZWF0ZU1lc2gocGF0aCk7XG4gICAgbWF0ZXJpYWwgPSBjb21waWxlTWF0ZXJpYWwobWF0ZXJpYWwsIG1lc2gudGV4dHVyZXMubGVuZ3RoKTtcblxuICAgIC8vIFNldCB1bmlmb3JtcyB0byBlbmFibGUgdGV4dHVyZSFcblxuICAgIG1lc2gudW5pZm9ybVZhbHVlc1ttZXNoLnVuaWZvcm1LZXlzLmluZGV4T2YobmFtZSldWzBdID0gLW1hdGVyaWFsLl9pZDtcblxuICAgIC8vIFJlZ2lzdGVyIHRleHR1cmVzIVxuXG4gICAgdmFyIGkgPSBtYXRlcmlhbC50ZXh0dXJlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBtZXNoLnRleHR1cmVzLnB1c2goXG4gICAgICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlZ2lzdGVyKG1hdGVyaWFsLnRleHR1cmVzW2ldLCBtZXNoLnRleHR1cmVzLmxlbmd0aCArIGkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXIgbWF0ZXJpYWwhXG5cbiAgICB0aGlzLnByb2dyYW0ucmVnaXN0ZXJNYXRlcmlhbChuYW1lLCBtYXRlcmlhbCk7XG5cbiAgICByZXR1cm4gdGhpcy51cGRhdGVTaXplKCk7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIGdlb21ldHJ5IGRhdGEgb2YgYSBtZXNoXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdXNlZCBhcyBpZCBvZiBjdXRvdXQgaW4gY3V0b3V0IHJlZ2lzdHJ5LlxuICogQHBhcmFtIHtPYmplY3R9IGdlb21ldHJ5IEdlb21ldHJ5IG9iamVjdCBjb250YWluaW5nIHZlcnRleCBkYXRhIHRvIGJlIGRyYXduXG4gKiBAcGFyYW0ge051bWJlcn0gZHJhd1R5cGUgUHJpbWl0aXZlIGlkZW50aWZpZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZHluYW1pYyBXaGV0aGVyIGdlb21ldHJ5IGlzIGR5bmFtaWNcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuKiovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRHZW9tZXRyeSA9IGZ1bmN0aW9uIHNldEdlb21ldHJ5KHBhdGgsIGdlb21ldHJ5LCBkcmF3VHlwZSwgZHluYW1pYykge1xuICAgIHZhciBtZXNoID0gdGhpcy5tZXNoUmVnaXN0cnlbcGF0aF0gfHwgdGhpcy5jcmVhdGVNZXNoKHBhdGgpO1xuXG4gICAgbWVzaC5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgIG1lc2guZHJhd1R5cGUgPSBkcmF3VHlwZTtcbiAgICBtZXNoLmR5bmFtaWMgPSBkeW5hbWljO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVwbG9hZHMgYSBuZXcgdmFsdWUgZm9yIHRoZSB1bmlmb3JtIGRhdGEgd2hlbiB0aGUgbWVzaCBpcyBiZWluZyBkcmF3blxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBQYXRoIHVzZWQgYXMgaWQgb2YgbWVzaCBpbiBtZXNoIHJlZ2lzdHJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gdW5pZm9ybU5hbWUgSWRlbnRpZmllciB1c2VkIHRvIHVwbG9hZCB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gdW5pZm9ybVZhbHVlIFZhbHVlIG9mIHVuaWZvcm0gZGF0YVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4qKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldE1lc2hVbmlmb3JtID0gZnVuY3Rpb24gc2V0TWVzaFVuaWZvcm0ocGF0aCwgdW5pZm9ybU5hbWUsIHVuaWZvcm1WYWx1ZSkge1xuICAgIHZhciBtZXNoID0gdGhpcy5tZXNoUmVnaXN0cnlbcGF0aF0gfHwgdGhpcy5jcmVhdGVNZXNoKHBhdGgpO1xuXG4gICAgdmFyIGluZGV4ID0gbWVzaC51bmlmb3JtS2V5cy5pbmRleE9mKHVuaWZvcm1OYW1lKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgbWVzaC51bmlmb3JtS2V5cy5wdXNoKHVuaWZvcm1OYW1lKTtcbiAgICAgICAgbWVzaC51bmlmb3JtVmFsdWVzLnB1c2godW5pZm9ybVZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1lc2gudW5pZm9ybVZhbHVlc1tpbmRleF0gPSB1bmlmb3JtVmFsdWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmlnZ2VycyB0aGUgJ2RyYXcnIHBoYXNlIG9mIHRoZSBXZWJHTFJlbmRlcmVyLiBJdGVyYXRlcyB0aHJvdWdoIHJlZ2lzdHJpZXNcbiAqIHRvIHNldCB1bmlmb3Jtcywgc2V0IGF0dHJpYnV0ZXMgYW5kIGlzc3VlIGRyYXcgY29tbWFuZHMgZm9yIHJlbmRlcmFibGVzLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBQYXRoIHVzZWQgYXMgaWQgb2YgbWVzaCBpbiBtZXNoIHJlZ2lzdHJ5XG4gKiBAcGFyYW0ge051bWJlcn0gZ2VvbWV0cnlJZCBJZCBvZiBnZW9tZXRyeSBpbiBnZW9tZXRyeSByZWdpc3RyeVxuICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlck5hbWUgQXR0cmlidXRlIGxvY2F0aW9uIG5hbWVcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlclZhbHVlIFZlcnRleCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gYnVmZmVyU3BhY2luZyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgdmVydGV4XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzRHluYW1pYyBXaGV0aGVyIGdlb21ldHJ5IGlzIGR5bmFtaWNcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5idWZmZXJEYXRhID0gZnVuY3Rpb24gYnVmZmVyRGF0YShwYXRoLCBnZW9tZXRyeUlkLCBidWZmZXJOYW1lLCBidWZmZXJWYWx1ZSwgYnVmZmVyU3BhY2luZywgaXNEeW5hbWljKSB7XG4gICAgdGhpcy5idWZmZXJSZWdpc3RyeS5hbGxvY2F0ZShnZW9tZXRyeUlkLCBidWZmZXJOYW1lLCBidWZmZXJWYWx1ZSwgYnVmZmVyU3BhY2luZywgaXNEeW5hbWljKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VycyB0aGUgJ2RyYXcnIHBoYXNlIG9mIHRoZSBXZWJHTFJlbmRlcmVyLiBJdGVyYXRlcyB0aHJvdWdoIHJlZ2lzdHJpZXNcbiAqIHRvIHNldCB1bmlmb3Jtcywgc2V0IGF0dHJpYnV0ZXMgYW5kIGlzc3VlIGRyYXcgY29tbWFuZHMgZm9yIHJlbmRlcmFibGVzLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVuZGVyU3RhdGUgUGFyYW1ldGVycyBwcm92aWRlZCBieSB0aGUgY29tcG9zaXRvciwgdGhhdCBhZmZlY3QgdGhlIHJlbmRlcmluZyBvZiBhbGwgcmVuZGVyYWJsZXMuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIGRyYXcocmVuZGVyU3RhdGUpIHtcbiAgICB2YXIgdGltZSA9IHRoaXMuY29tcG9zaXRvci5nZXRUaW1lKCk7XG5cbiAgICB0aGlzLmdsLmNsZWFyKHRoaXMuZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IHRoaXMuZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG4gICAgdGhpcy50ZXh0dXJlTWFuYWdlci51cGRhdGUodGltZSk7XG5cbiAgICB0aGlzLm1lc2hSZWdpc3RyeUtleXMgPSBzb3J0ZXIodGhpcy5tZXNoUmVnaXN0cnlLZXlzLCB0aGlzLm1lc2hSZWdpc3RyeSk7XG5cbiAgICB0aGlzLnNldEdsb2JhbFVuaWZvcm1zKHJlbmRlclN0YXRlKTtcbiAgICB0aGlzLmRyYXdDdXRvdXRzKCk7XG4gICAgdGhpcy5kcmF3TWVzaGVzKCk7XG59O1xuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggYW5kIGRyYXdzIGFsbCByZWdpc3RlcmVkIG1lc2hlcy4gVGhpcyBpbmNsdWRlc1xuICogYmluZGluZyB0ZXh0dXJlcywgaGFuZGxpbmcgZHJhdyBvcHRpb25zLCBzZXR0aW5nIG1lc2ggdW5pZm9ybXNcbiAqIGFuZCBkcmF3aW5nIG1lc2ggYnVmZmVycy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZHJhd01lc2hlcyA9IGZ1bmN0aW9uIGRyYXdNZXNoZXMoKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgYnVmZmVycztcbiAgICB2YXIgbWVzaDtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLm1lc2hSZWdpc3RyeUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWVzaCA9IHRoaXMubWVzaFJlZ2lzdHJ5W3RoaXMubWVzaFJlZ2lzdHJ5S2V5c1tpXV07XG4gICAgICAgIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlclJlZ2lzdHJ5LnJlZ2lzdHJ5W21lc2guZ2VvbWV0cnldO1xuXG4gICAgICAgIGlmICghbWVzaC52aXNpYmxlKSBjb250aW51ZTtcblxuICAgICAgICBpZiAobWVzaC51bmlmb3JtVmFsdWVzWzBdIDwgMSkge1xuICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKGZhbHNlKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbC5kZXB0aE1hc2sodHJ1ZSk7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYnVmZmVycykgY29udGludWU7XG5cbiAgICAgICAgdmFyIGogPSBtZXNoLnRleHR1cmVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGotLSkgdGhpcy50ZXh0dXJlTWFuYWdlci5iaW5kVGV4dHVyZShtZXNoLnRleHR1cmVzW2pdKTtcblxuICAgICAgICBpZiAobWVzaC5vcHRpb25zKSB0aGlzLmhhbmRsZU9wdGlvbnMobWVzaC5vcHRpb25zLCBtZXNoKTtcblxuICAgICAgICB0aGlzLnByb2dyYW0uc2V0VW5pZm9ybXMobWVzaC51bmlmb3JtS2V5cywgbWVzaC51bmlmb3JtVmFsdWVzKTtcbiAgICAgICAgdGhpcy5kcmF3QnVmZmVycyhidWZmZXJzLCBtZXNoLmRyYXdUeXBlLCBtZXNoLmdlb21ldHJ5KTtcblxuICAgICAgICBpZiAobWVzaC5vcHRpb25zKSB0aGlzLnJlc2V0T3B0aW9ucyhtZXNoLm9wdGlvbnMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBhbmQgZHJhd3MgYWxsIHJlZ2lzdGVyZWQgY3V0b3V0IG1lc2hlcy4gQmxlbmRpbmdcbiAqIGlzIGRpc2FibGVkLCBjdXRvdXQgdW5pZm9ybXMgYXJlIHNldCBhbmQgZmluYWxseSBidWZmZXJzIGFyZSBkcmF3bi5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZHJhd0N1dG91dHMgPSBmdW5jdGlvbiBkcmF3Q3V0b3V0cygpIHtcbiAgICB2YXIgY3V0b3V0O1xuICAgIHZhciBidWZmZXJzO1xuICAgIHZhciBsZW4gPSB0aGlzLmN1dG91dFJlZ2lzdHJ5S2V5cy5sZW5ndGg7XG5cbiAgICBpZiAoIWxlbikgcmV0dXJuO1xuXG4gICAgdGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcbiAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkJMRU5EKTtcbiAgICB0aGlzLmdsLmRlcHRoTWFzayh0cnVlKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY3V0b3V0ID0gdGhpcy5jdXRvdXRSZWdpc3RyeVt0aGlzLmN1dG91dFJlZ2lzdHJ5S2V5c1tpXV07XG4gICAgICAgIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlclJlZ2lzdHJ5LnJlZ2lzdHJ5W2N1dG91dC5nZW9tZXRyeV07XG5cbiAgICAgICAgaWYgKCFjdXRvdXQudmlzaWJsZSkgY29udGludWU7XG5cbiAgICAgICAgdGhpcy5wcm9ncmFtLnNldFVuaWZvcm1zKGN1dG91dC51bmlmb3JtS2V5cywgY3V0b3V0LnVuaWZvcm1WYWx1ZXMpO1xuICAgICAgICB0aGlzLmRyYXdCdWZmZXJzKGJ1ZmZlcnMsIGN1dG91dC5kcmF3VHlwZSwgY3V0b3V0Lmdlb21ldHJ5KTtcbiAgICB9XG5cbiAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkNVTExfRkFDRSk7XG59O1xuXG4vKipcbiAqIFNldHMgdW5pZm9ybXMgdG8gYmUgc2hhcmVkIGJ5IGFsbCBtZXNoZXMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJTdGF0ZSBEcmF3IHN0YXRlIG9wdGlvbnMgcGFzc2VkIGRvd24gZnJvbSBjb21wb3NpdG9yLlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldEdsb2JhbFVuaWZvcm1zID0gZnVuY3Rpb24gc2V0R2xvYmFsVW5pZm9ybXMocmVuZGVyU3RhdGUpIHtcbiAgICB2YXIgbGlnaHQ7XG4gICAgdmFyIHN0cmlkZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmxpZ2h0UmVnaXN0cnlLZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpZ2h0ID0gdGhpcy5saWdodFJlZ2lzdHJ5W3RoaXMubGlnaHRSZWdpc3RyeUtleXNbaV1dO1xuICAgICAgICBzdHJpZGUgPSBpICogNDtcblxuICAgICAgICAvLyBCdWlsZCB0aGUgbGlnaHQgcG9zaXRpb25zJyA0eDQgbWF0cml4XG5cbiAgICAgICAgdGhpcy5saWdodFBvc2l0aW9uc1swICsgc3RyaWRlXSA9IGxpZ2h0LnBvc2l0aW9uWzBdO1xuICAgICAgICB0aGlzLmxpZ2h0UG9zaXRpb25zWzEgKyBzdHJpZGVdID0gbGlnaHQucG9zaXRpb25bMV07XG4gICAgICAgIHRoaXMubGlnaHRQb3NpdGlvbnNbMiArIHN0cmlkZV0gPSBsaWdodC5wb3NpdGlvblsyXTtcblxuICAgICAgICAvLyBCdWlsZCB0aGUgbGlnaHQgY29sb3JzJyA0eDQgbWF0cml4XG5cbiAgICAgICAgdGhpcy5saWdodENvbG9yc1swICsgc3RyaWRlXSA9IGxpZ2h0LmNvbG9yWzBdO1xuICAgICAgICB0aGlzLmxpZ2h0Q29sb3JzWzEgKyBzdHJpZGVdID0gbGlnaHQuY29sb3JbMV07XG4gICAgICAgIHRoaXMubGlnaHRDb2xvcnNbMiArIHN0cmlkZV0gPSBsaWdodC5jb2xvclsyXTtcbiAgICB9XG5cbiAgICBnbG9iYWxVbmlmb3Jtcy52YWx1ZXNbMF0gPSB0aGlzLm51bUxpZ2h0cztcbiAgICBnbG9iYWxVbmlmb3Jtcy52YWx1ZXNbMV0gPSB0aGlzLmFtYmllbnRMaWdodENvbG9yO1xuICAgIGdsb2JhbFVuaWZvcm1zLnZhbHVlc1syXSA9IHRoaXMubGlnaHRQb3NpdGlvbnM7XG4gICAgZ2xvYmFsVW5pZm9ybXMudmFsdWVzWzNdID0gdGhpcy5saWdodENvbG9ycztcblxuICAgIC8qXG4gICAgICogU2V0IHRpbWUgYW5kIHByb2plY3Rpb24gdW5pZm9ybXNcbiAgICAgKiBwcm9qZWN0aW5nIHdvcmxkIHNwYWNlIGludG8gYSAyZCBwbGFuZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2FudmFzLlxuICAgICAqIFRoZSB4IGFuZCB5IHNjYWxlICh0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm1bMF0gYW5kIHRoaXMucHJvamVjdGlvblRyYW5zZm9ybVs1XSByZXNwZWN0aXZlbHkpXG4gICAgICogY29udmVydCB0aGUgcHJvamVjdGVkIGdlb21ldHJ5IGJhY2sgaW50byBjbGlwc3BhY2UuXG4gICAgICogVGhlIHBlcnBlY3RpdmUgZGl2aWRlICh0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm1bMTFdKSwgYWRkcyB0aGUgeiB2YWx1ZSBvZiB0aGUgcG9pbnRcbiAgICAgKiBtdWx0aXBsaWVkIGJ5IHRoZSBwZXJzcGVjdGl2ZSBkaXZpZGUgdG8gdGhlIHcgdmFsdWUgb2YgdGhlIHBvaW50LiBJbiB0aGUgcHJvY2Vzc1xuICAgICAqIG9mIGNvbnZlcnRpbmcgZnJvbSBob21vZ2Vub3VzIGNvb3JkaW5hdGVzIHRvIE5EQyAobm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXMpXG4gICAgICogdGhlIHggYW5kIHkgdmFsdWVzIG9mIHRoZSBwb2ludCBhcmUgZGl2aWRlZCBieSB3LCB3aGljaCBpbXBsZW1lbnRzIHBlcnNwZWN0aXZlLlxuICAgICAqL1xuICAgIHRoaXMucHJvamVjdGlvblRyYW5zZm9ybVswXSA9IDEgLyAodGhpcy5jYWNoZWRTaXplWzBdICogMC41KTtcbiAgICB0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm1bNV0gPSAtMSAvICh0aGlzLmNhY2hlZFNpemVbMV0gKiAwLjUpO1xuICAgIHRoaXMucHJvamVjdGlvblRyYW5zZm9ybVsxMV0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMV07XG5cbiAgICBnbG9iYWxVbmlmb3Jtcy52YWx1ZXNbNF0gPSB0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm07XG4gICAgZ2xvYmFsVW5pZm9ybXMudmFsdWVzWzVdID0gdGhpcy5jb21wb3NpdG9yLmdldFRpbWUoKSAqIDAuMDAxO1xuICAgIGdsb2JhbFVuaWZvcm1zLnZhbHVlc1s2XSA9IHJlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm07XG5cbiAgICB0aGlzLnByb2dyYW0uc2V0VW5pZm9ybXMoZ2xvYmFsVW5pZm9ybXMua2V5cywgZ2xvYmFsVW5pZm9ybXMudmFsdWVzKTtcbn07XG5cbi8qKlxuICogTG9hZHMgdGhlIGJ1ZmZlcnMgYW5kIGlzc3VlcyB0aGUgZHJhdyBjb21tYW5kIGZvciBhIGdlb21ldHJ5LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmVydGV4QnVmZmVycyBBbGwgYnVmZmVycyB1c2VkIHRvIGRyYXcgdGhlIGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IG1vZGUgRW51bWVyYXRvciBkZWZpbmluZyB3aGF0IHByaW1pdGl2ZSB0byBkcmF3XG4gKiBAcGFyYW0ge051bWJlcn0gaWQgSUQgb2YgZ2VvbWV0cnkgYmVpbmcgZHJhd24uXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZHJhd0J1ZmZlcnMgPSBmdW5jdGlvbiBkcmF3QnVmZmVycyh2ZXJ0ZXhCdWZmZXJzLCBtb2RlLCBpZCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgdmFyIGF0dHJpYnV0ZTtcbiAgICB2YXIgbG9jYXRpb247XG4gICAgdmFyIHNwYWNpbmc7XG4gICAgdmFyIG9mZnNldDtcbiAgICB2YXIgYnVmZmVyO1xuICAgIHZhciBpdGVyO1xuICAgIHZhciBqO1xuICAgIHZhciBpO1xuXG4gICAgaXRlciA9IHZlcnRleEJ1ZmZlcnMua2V5cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGl0ZXI7IGkrKykge1xuICAgICAgICBhdHRyaWJ1dGUgPSB2ZXJ0ZXhCdWZmZXJzLmtleXNbaV07XG5cbiAgICAgICAgLy8gRG8gbm90IHNldCB2ZXJ0ZXhBdHRyaWJQb2ludGVyIGlmIGluZGV4IGJ1ZmZlci5cblxuICAgICAgICBpZiAoYXR0cmlidXRlID09PSAnaW5kaWNlcycpIHtcbiAgICAgICAgICAgIGogPSBpOyBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHJlaXZlIHRoZSBhdHRyaWJ1dGUgbG9jYXRpb24gYW5kIG1ha2Ugc3VyZSBpdCBpcyBlbmFibGVkLlxuXG4gICAgICAgIGxvY2F0aW9uID0gdGhpcy5wcm9ncmFtLmF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyaWJ1dGVdO1xuXG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gLTEpIGNvbnRpbnVlO1xuICAgICAgICBpZiAobG9jYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0ucHJvZ3JhbSwgYXR0cmlidXRlKTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnNbYXR0cmlidXRlXSA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgaWYgKGxvY2F0aW9uID09PSAtMSkgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNbYXR0cmlidXRlXSkge1xuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5lbmFibGVkQXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNLZXlzLnB1c2goYXR0cmlidXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHJlaXZlIGJ1ZmZlciBpbmZvcm1hdGlvbiB1c2VkIHRvIHNldCBhdHRyaWJ1dGUgcG9pbnRlci5cblxuICAgICAgICBidWZmZXIgPSB2ZXJ0ZXhCdWZmZXJzLnZhbHVlc1tpXTtcbiAgICAgICAgc3BhY2luZyA9IHZlcnRleEJ1ZmZlcnMuc3BhY2luZ1tpXTtcbiAgICAgICAgb2Zmc2V0ID0gdmVydGV4QnVmZmVycy5vZmZzZXRbaV07XG4gICAgICAgIGxlbmd0aCA9IHZlcnRleEJ1ZmZlcnMubGVuZ3RoW2ldO1xuXG4gICAgICAgIC8vIFNraXAgYmluZEJ1ZmZlciBpZiBidWZmZXIgaXMgY3VycmVudGx5IGJvdW5kLlxuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmJvdW5kQXJyYXlCdWZmZXIgIT09IGJ1ZmZlcikge1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihidWZmZXIudGFyZ2V0LCBidWZmZXIuYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuYm91bmRBcnJheUJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmxhc3REcmF3biAhPT0gaWQpIHtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jYXRpb24sIHNwYWNpbmcsIGdsLkZMT0FULCBnbC5GQUxTRSwgMCwgNCAqIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIGFueSBhdHRyaWJ1dGVzIHRoYXQgbm90IGN1cnJlbnRseSBiZWluZyB1c2VkLlxuXG4gICAgdmFyIGxlbiA9IHRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNLZXlzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNLZXlzW2ldO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5lbmFibGVkQXR0cmlidXRlc1trZXldICYmIHZlcnRleEJ1ZmZlcnMua2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5wcm9ncmFtLmF0dHJpYnV0ZUxvY2F0aW9uc1trZXldKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNba2V5XSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCkge1xuXG4gICAgICAgIC8vIElmIGluZGV4IGJ1ZmZlciwgdXNlIGRyYXdFbGVtZW50cy5cblxuICAgICAgICBpZiAoaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBidWZmZXIgPSB2ZXJ0ZXhCdWZmZXJzLnZhbHVlc1tqXTtcbiAgICAgICAgICAgIG9mZnNldCA9IHZlcnRleEJ1ZmZlcnMub2Zmc2V0W2pdO1xuICAgICAgICAgICAgc3BhY2luZyA9IHZlcnRleEJ1ZmZlcnMuc3BhY2luZ1tqXTtcbiAgICAgICAgICAgIGxlbmd0aCA9IHZlcnRleEJ1ZmZlcnMubGVuZ3RoW2pdO1xuXG4gICAgICAgICAgICAvLyBTa2lwIGJpbmRCdWZmZXIgaWYgYnVmZmVyIGlzIGN1cnJlbnRseSBib3VuZC5cblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuYm91bmRFbGVtZW50QnVmZmVyICE9PSBidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGJ1ZmZlci50YXJnZXQsIGJ1ZmZlci5idWZmZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuYm91bmRFbGVtZW50QnVmZmVyID0gYnVmZmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2xbbW9kZV0sIGxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDIgKiBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbFttb2RlXSwgMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUubGFzdERyYXduID0gaWQ7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiBwYXJlbnQgY2FudmFzLCBzZXRzIHRoZSB2aWV3cG9ydCBzaXplIG9uXG4gKiB0aGUgV2ViR0wgY29udGV4dCBhbmQgdXBkYXRlcyB0aGUgcmVzb2x1dGlvbiB1bmlmb3JtIGZvciB0aGUgc2hhZGVyIHByb2dyYW0uXG4gKiBTaXplIGlzIHJldHJlaXZlZCBmcm9tIHRoZSBjb250YWluZXIgb2JqZWN0IG9mIHRoZSByZW5kZXJlci5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2l6ZSB3aWR0aCwgaGVpZ2h0IGFuZCBkZXB0aCBvZiBjYW52YXNcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gdXBkYXRlU2l6ZShzaXplKSB7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICB2YXIgZGlzcGxheVdpZHRoID0gfn4oc2l6ZVswXSAqIHBpeGVsUmF0aW8pO1xuICAgICAgICB2YXIgZGlzcGxheUhlaWdodCA9IH5+KHNpemVbMV0gKiBwaXhlbFJhdGlvKTtcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG4gICAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgZGlzcGxheVdpZHRoLCBkaXNwbGF5SGVpZ2h0KTtcblxuICAgICAgICB0aGlzLmNhY2hlZFNpemVbMF0gPSBzaXplWzBdO1xuICAgICAgICB0aGlzLmNhY2hlZFNpemVbMV0gPSBzaXplWzFdO1xuICAgICAgICB0aGlzLmNhY2hlZFNpemVbMl0gPSAoc2l6ZVswXSA+IHNpemVbMV0pID8gc2l6ZVswXSA6IHNpemVbMV07XG4gICAgICAgIHRoaXMucmVzb2x1dGlvblZhbHVlc1swXSA9IHRoaXMuY2FjaGVkU2l6ZTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2dyYW0uc2V0VW5pZm9ybXModGhpcy5yZXNvbHV0aW9uTmFtZSwgdGhpcy5yZXNvbHV0aW9uVmFsdWVzKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgV2ViR0wgZHJhd2luZyBjb250ZXh0IGJhc2VkIG9uIGN1c3RvbSBwYXJhbWV0ZXJzXG4gKiBkZWZpbmVkIG9uIGEgbWVzaC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgRHJhdyBzdGF0ZSBvcHRpb25zIHRvIGJlIHNldCB0byB0aGUgY29udGV4dC5cbiAqIEBwYXJhbSB7TWVzaH0gbWVzaCBBc3NvY2lhdGVkIE1lc2hcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVPcHRpb25zID0gZnVuY3Rpb24gaGFuZGxlT3B0aW9ucyhvcHRpb25zLCBtZXNoKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBpZiAoIW9wdGlvbnMpIHJldHVybjtcblxuICAgIGlmIChvcHRpb25zLmJsZW5kaW5nKSBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gICAgaWYgKG9wdGlvbnMuc2lkZSA9PT0gJ2RvdWJsZScpIHtcbiAgICAgICAgdGhpcy5nbC5jdWxsRmFjZSh0aGlzLmdsLkZST05UKTtcbiAgICAgICAgdGhpcy5kcmF3QnVmZmVycyh0aGlzLmJ1ZmZlclJlZ2lzdHJ5LnJlZ2lzdHJ5W21lc2guZ2VvbWV0cnldLCBtZXNoLmRyYXdUeXBlLCBtZXNoLmdlb21ldHJ5KTtcbiAgICAgICAgdGhpcy5nbC5jdWxsRmFjZSh0aGlzLmdsLkJBQ0spO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNpZGUgPT09ICdiYWNrJykgZ2wuY3VsbEZhY2UoZ2wuRlJPTlQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIHN0YXRlIG9mIHRoZSBXZWJHTCBkcmF3aW5nIGNvbnRleHQgdG8gZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIERyYXcgc3RhdGUgb3B0aW9ucyB0byBiZSBzZXQgdG8gdGhlIGNvbnRleHQuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUucmVzZXRPcHRpb25zID0gZnVuY3Rpb24gcmVzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGlmICghb3B0aW9ucykgcmV0dXJuO1xuICAgIGlmIChvcHRpb25zLmJsZW5kaW5nKSBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICBpZiAob3B0aW9ucy5zaWRlID09PSAnYmFjaycpIGdsLmN1bGxGYWNlKGdsLkJBQ0spO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHTFJlbmRlcmVyO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHR5cGVzID0ge1xuICAgIDE6ICdmbG9hdCAnLFxuICAgIDI6ICd2ZWMyICcsXG4gICAgMzogJ3ZlYzMgJyxcbiAgICA0OiAndmVjNCAnXG59O1xuXG4vKipcbiAqIFRyYXZlcnNlcyBtYXRlcmlhbCB0byBjcmVhdGUgYSBzdHJpbmcgb2YgZ2xzbCBjb2RlIHRvIGJlIGFwcGxpZWQgaW5cbiAqIHRoZSB2ZXJ0ZXggb3IgZnJhZ21lbnQgc2hhZGVyLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcm90ZWN0ZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWwgTWF0ZXJpYWwgdG8gYmUgY29tcGlsZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gdGV4dHVyZVNsb3QgTmV4dCBhdmFpbGFibGUgdGV4dHVyZSBzbG90IGZvciBNZXNoLlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVNYXRlcmlhbChtYXRlcmlhbCwgdGV4dHVyZVNsb3QpIHtcbiAgICB2YXIgZ2xzbCA9ICcnO1xuICAgIHZhciB1bmlmb3JtcyA9IHt9O1xuICAgIHZhciB2YXJ5aW5ncyA9IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgdmFyIGRlZmluZXMgPSBbXTtcbiAgICB2YXIgdGV4dHVyZXMgPSBbXTtcblxuICAgIF90cmF2ZXJzZShtYXRlcmlhbCwgZnVuY3Rpb24gKG5vZGUsIGRlcHRoKSB7XG4gICAgICAgIGlmICghIG5vZGUuY2h1bmspIHJldHVybjtcblxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW19nZXRPdXRwdXRMZW5ndGgobm9kZSldO1xuICAgICAgICB2YXIgbGFiZWwgPSBfbWFrZUxhYmVsKG5vZGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gX3Byb2Nlc3NHTFNMKG5vZGUuY2h1bmsuZ2xzbCwgbm9kZS5pbnB1dHMsIHRleHR1cmVzLmxlbmd0aCArIHRleHR1cmVTbG90KTtcblxuICAgICAgICBnbHNsICs9IHR5cGUgKyBsYWJlbCArICcgPSAnICsgb3V0cHV0ICsgJ1xcbiAnO1xuXG4gICAgICAgIGlmIChub2RlLnVuaWZvcm1zKSBfZXh0ZW5kKHVuaWZvcm1zLCBub2RlLnVuaWZvcm1zKTtcbiAgICAgICAgaWYgKG5vZGUudmFyeWluZ3MpIF9leHRlbmQodmFyeWluZ3MsIG5vZGUudmFyeWluZ3MpO1xuICAgICAgICBpZiAobm9kZS5hdHRyaWJ1dGVzKSBfZXh0ZW5kKGF0dHJpYnV0ZXMsIG5vZGUuYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChub2RlLmNodW5rLmRlZmluZXMpIGRlZmluZXMucHVzaChub2RlLmNodW5rLmRlZmluZXMpO1xuICAgICAgICBpZiAobm9kZS50ZXh0dXJlKSB0ZXh0dXJlcy5wdXNoKG5vZGUudGV4dHVyZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBfaWQ6IG1hdGVyaWFsLl9pZCxcbiAgICAgICAgZ2xzbDogZ2xzbCArICdyZXR1cm4gJyArIF9tYWtlTGFiZWwobWF0ZXJpYWwpICsgJzsnLFxuICAgICAgICBkZWZpbmVzOiBkZWZpbmVzLmpvaW4oJ1xcbicpLFxuICAgICAgICB1bmlmb3JtczogdW5pZm9ybXMsXG4gICAgICAgIHZhcnlpbmdzOiB2YXJ5aW5ncyxcbiAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgdGV4dHVyZXM6IHRleHR1cmVzXG4gICAgfTtcbn1cblxuLy8gUmVjdXJzaXZlbHkgaXRlcmF0ZXMgb3ZlciBhIG1hdGVyaWFsJ3MgaW5wdXRzLCBpbnZva2luZyBhIGdpdmVuIGNhbGxiYWNrXG4vLyB3aXRoIHRoZSBjdXJyZW50IG1hdGVyaWFsXG5mdW5jdGlvbiBfdHJhdmVyc2UobWF0ZXJpYWwsIGNhbGxiYWNrKSB7XG5cdHZhciBpbnB1dHMgPSBtYXRlcmlhbC5pbnB1dHM7XG4gICAgdmFyIGxlbiA9IGlucHV0cyAmJiBpbnB1dHMubGVuZ3RoO1xuICAgIHZhciBpZHggPSAtMTtcblxuICAgIHdoaWxlICgrK2lkeCA8IGxlbikgX3RyYXZlcnNlKGlucHV0c1tpZHhdLCBjYWxsYmFjayk7XG5cbiAgICBjYWxsYmFjayhtYXRlcmlhbCk7XG5cbiAgICByZXR1cm4gbWF0ZXJpYWw7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB1c2VkIHRvIGluZmVyIGxlbmd0aCBvZiB0aGUgb3V0cHV0XG4vLyBmcm9tIGEgZ2l2ZW4gbWF0ZXJpYWwgbm9kZS5cbmZ1bmN0aW9uIF9nZXRPdXRwdXRMZW5ndGgobm9kZSkge1xuXG4gICAgLy8gSGFuZGxlIGNvbnN0YW50IHZhbHVlc1xuXG4gICAgaWYgKHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykgcmV0dXJuIDE7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHJldHVybiBub2RlLmxlbmd0aDtcblxuICAgIC8vIEhhbmRsZSBtYXRlcmlhbHNcblxuICAgIHZhciBvdXRwdXQgPSBub2RlLmNodW5rLm91dHB1dDtcbiAgICBpZiAodHlwZW9mIG91dHB1dCA9PT0gJ251bWJlcicpIHJldHVybiBvdXRwdXQ7XG5cbiAgICAvLyBIYW5kbGUgcG9seW1vcnBoaWMgb3V0cHV0XG5cbiAgICB2YXIga2V5ID0gbm9kZS5pbnB1dHMubWFwKGZ1bmN0aW9uIHJlY3Vyc2Uobm9kZSkge1xuICAgICAgICByZXR1cm4gX2dldE91dHB1dExlbmd0aChub2RlKTtcbiAgICB9KS5qb2luKCcsJyk7XG5cbiAgICByZXR1cm4gb3V0cHV0W2tleV07XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBydW4gcmVwbGFjZSBpbnB1dHMgYW5kIHRleHR1cmUgdGFncyB3aXRoXG4vLyBjb3JyZWN0IGdsc2wuXG5mdW5jdGlvbiBfcHJvY2Vzc0dMU0woc3RyLCBpbnB1dHMsIHRleHR1cmVTbG90KSB7XG4gICAgcmV0dXJuIHN0clxuICAgICAgICAucmVwbGFjZSgvJVxcZC9nLCBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIF9tYWtlTGFiZWwoaW5wdXRzW3NbMV0tMV0pO1xuICAgICAgICB9KVxuICAgICAgICAucmVwbGFjZSgvXFwkVEVYVFVSRS8sICd1X3RleHR1cmVzWycgKyB0ZXh0dXJlU2xvdCArICddJyk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBnbHNsIGRlZmluaXRpb24gb2YgdGhlXG4vLyBpbnB1dCBtYXRlcmlhbCBub2RlLlxuZnVuY3Rpb24gX21ha2VMYWJlbCAobikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG4pKSByZXR1cm4gX2FycmF5VG9WZWMobik7XG4gICAgaWYgKHR5cGVvZiBuID09PSAnb2JqZWN0JykgcmV0dXJuICdmYV8nICsgKG4uX2lkKTtcbiAgICBlbHNlIHJldHVybiBuLnRvRml4ZWQoNik7XG59XG5cbi8vIEhlbHBlciB0byBjb3B5IHRoZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBvbnRvIGFub3RoZXIgb2JqZWN0LlxuZnVuY3Rpb24gX2V4dGVuZCAoYSwgYikge1xuXHRmb3IgKHZhciBrIGluIGIpIGFba10gPSBiW2tdO1xufVxuXG4vLyBIZWxwZXIgdG8gY3JlYXRlIGdsc2wgdmVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIGEgamF2YXNjcmlwdCBhcnJheS5cbmZ1bmN0aW9uIF9hcnJheVRvVmVjKGFycmF5KSB7XG4gICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gJ3ZlYycgKyBsZW4gKyAnKCcgKyBhcnJheS5qb2luKCcsJykgICsgJyknO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGVNYXRlcmlhbDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gR2VuZXJhdGVzIGEgY2hlY2tlcmJvYXJkIHBhdHRlcm4gdG8gYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIHRleHR1cmUgd2hpbGUgYW5cbi8vIGltYWdlIGxvYWRzIG92ZXIgdGhlIG5ldHdvcmsuXG5mdW5jdGlvbiBjcmVhdGVDaGVja2VyQm9hcmQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQuY2FudmFzLndpZHRoID0gY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gMTI4O1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY29udGV4dC5jYW52YXMuaGVpZ2h0OyB5ICs9IDE2KSB7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY29udGV4dC5jYW52YXMud2lkdGg7IHggKz0gMTYpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gKHggXiB5KSAmIDE2ID8gJyNGRkYnIDogJyNEREQnO1xuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCh4LCB5LCAxNiwgMTYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHQuY2FudmFzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNoZWNrZXJCb2FyZDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciByYWRpeEJpdHMgPSAxMSxcbiAgICBtYXhSYWRpeCA9IDEgPDwgKHJhZGl4Qml0cyksXG4gICAgcmFkaXhNYXNrID0gbWF4UmFkaXggLSAxLFxuICAgIGJ1Y2tldHMgPSBuZXcgQXJyYXkobWF4UmFkaXggKiBNYXRoLmNlaWwoNjQgLyByYWRpeEJpdHMpKSxcbiAgICBtc2JNYXNrID0gMSA8PCAoKDMyIC0gMSkgJSByYWRpeEJpdHMpLFxuICAgIGxhc3RNYXNrID0gKG1zYk1hc2sgPDwgMSkgLSAxLFxuICAgIHBhc3NDb3VudCA9ICgoMzIgLyByYWRpeEJpdHMpICsgMC45OTk5OTk5OTk5OTk5OTkpIHwgMCxcbiAgICBtYXhPZmZzZXQgPSBtYXhSYWRpeCAqIChwYXNzQ291bnQgLSAxKSxcbiAgICBub3JtYWxpemVyID0gTWF0aC5wb3coMjAsIDYpO1xuXG52YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xudmFyIGZsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbnZhciBpbnRWaWV3ID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcblxuLy8gY29tcGFyYXRvciBwdWxscyByZWxldmFudCBzb3J0aW5nIGtleXMgb3V0IG9mIG1lc2hcbmZ1bmN0aW9uIGNvbXAobGlzdCwgcmVnaXN0cnksIGkpIHtcbiAgICB2YXIga2V5ID0gbGlzdFtpXTtcbiAgICB2YXIgaXRlbSA9IHJlZ2lzdHJ5W2tleV07XG4gICAgcmV0dXJuIChpdGVtLmRlcHRoID8gaXRlbS5kZXB0aCA6IHJlZ2lzdHJ5W2tleV0udW5pZm9ybVZhbHVlc1sxXVsxNF0pICsgbm9ybWFsaXplcjtcbn1cblxuLy9tdXRhdG9yIGZ1bmN0aW9uIHJlY29yZHMgbWVzaCdzIHBsYWNlIGluIHByZXZpb3VzIHBhc3NcbmZ1bmN0aW9uIG11dGF0b3IobGlzdCwgcmVnaXN0cnksIGksIHZhbHVlKSB7XG4gICAgdmFyIGtleSA9IGxpc3RbaV07XG4gICAgcmVnaXN0cnlba2V5XS5kZXB0aCA9IGludFRvRmxvYXQodmFsdWUpIC0gbm9ybWFsaXplcjtcbiAgICByZXR1cm4ga2V5O1xufVxuXG4vL2NsZWFuIGZ1bmN0aW9uIHJlbW92ZXMgbXV0YXRvciBmdW5jdGlvbidzIHJlY29yZFxuZnVuY3Rpb24gY2xlYW4obGlzdCwgcmVnaXN0cnksIGkpIHtcbiAgICByZWdpc3RyeVtsaXN0W2ldXS5kZXB0aCA9IG51bGw7XG59XG5cbi8vY29udmVydHMgYSBqYXZhc2NyaXB0IGZsb2F0IHRvIGEgMzJiaXQgaW50ZWdlciB1c2luZyBhbiBhcnJheSBidWZmZXJcbi8vb2Ygc2l6ZSBvbmVcbmZ1bmN0aW9uIGZsb2F0VG9JbnQoaykge1xuICAgIGZsb2F0Vmlld1swXSA9IGs7XG4gICAgcmV0dXJuIGludFZpZXdbMF07XG59XG4vL2NvbnZlcnRzIGEgMzIgYml0IGludGVnZXIgdG8gYSByZWd1bGFyIGphdmFzY3JpcHQgZmxvYXQgdXNpbmcgYW4gYXJyYXkgYnVmZmVyXG4vL29mIHNpemUgb25lXG5mdW5jdGlvbiBpbnRUb0Zsb2F0KGspIHtcbiAgICBpbnRWaWV3WzBdID0gaztcbiAgICByZXR1cm4gZmxvYXRWaWV3WzBdO1xufVxuXG4vL3NvcnRzIGEgbGlzdCBvZiBtZXNoIElEcyBhY2NvcmRpbmcgdG8gdGhlaXIgei1kZXB0aFxuZnVuY3Rpb24gcmFkaXhTb3J0KGxpc3QsIHJlZ2lzdHJ5KSB7XG4gICAgdmFyIHBhc3MgPSAwO1xuICAgIHZhciBvdXQgPSBbXTtcblxuICAgIHZhciBpLCBqLCBrLCBuLCBkaXYsIG9mZnNldCwgc3dhcCwgaWQsIHN1bSwgdHN1bSwgc2l6ZTtcblxuICAgIHBhc3NDb3VudCA9ICgoMzIgLyByYWRpeEJpdHMpICsgMC45OTk5OTk5OTk5OTk5OTkpIHwgMDtcblxuICAgIGZvciAoaSA9IDAsIG4gPSBtYXhSYWRpeCAqIHBhc3NDb3VudDsgaSA8IG47IGkrKykgYnVja2V0c1tpXSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gbGlzdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgZGl2ID0gZmxvYXRUb0ludChjb21wKGxpc3QsIHJlZ2lzdHJ5LCBpKSk7XG4gICAgICAgIGRpdiBePSBkaXYgPj4gMzEgfCAweDgwMDAwMDAwO1xuICAgICAgICBmb3IgKGogPSAwLCBrID0gMDsgaiA8IG1heE9mZnNldDsgaiArPSBtYXhSYWRpeCwgayArPSByYWRpeEJpdHMpIHtcbiAgICAgICAgICAgIGJ1Y2tldHNbaiArIChkaXYgPj4+IGsgJiByYWRpeE1hc2spXSsrO1xuICAgICAgICB9XG4gICAgICAgIGJ1Y2tldHNbaiArIChkaXYgPj4+IGsgJiBsYXN0TWFzayldKys7XG4gICAgfVxuXG4gICAgZm9yIChqID0gMDsgaiA8PSBtYXhPZmZzZXQ7IGogKz0gbWF4UmFkaXgpIHtcbiAgICAgICAgZm9yIChpZCA9IGosIHN1bSA9IDA7IGlkIDwgaiArIG1heFJhZGl4OyBpZCsrKSB7XG4gICAgICAgICAgICB0c3VtID0gYnVja2V0c1tpZF0gKyBzdW07XG4gICAgICAgICAgICBidWNrZXRzW2lkXSA9IHN1bSAtIDE7XG4gICAgICAgICAgICBzdW0gPSB0c3VtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgtLXBhc3NDb3VudCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBuID0gbGlzdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGRpdiA9IGZsb2F0VG9JbnQoY29tcChsaXN0LCByZWdpc3RyeSwgaSkpO1xuICAgICAgICAgICAgb3V0WysrYnVja2V0c1tkaXYgJiByYWRpeE1hc2tdXSA9IG11dGF0b3IobGlzdCwgcmVnaXN0cnksIGksIGRpdiBePSBkaXYgPj4gMzEgfCAweDgwMDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3dhcCA9IG91dDtcbiAgICAgICAgb3V0ID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IHN3YXA7XG4gICAgICAgIHdoaWxlICgrK3Bhc3MgPCBwYXNzQ291bnQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBsaXN0Lmxlbmd0aCwgb2Zmc2V0ID0gcGFzcyAqIG1heFJhZGl4LCBzaXplID0gcGFzcyAqIHJhZGl4Qml0czsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGRpdiA9IGZsb2F0VG9JbnQoY29tcChsaXN0LCByZWdpc3RyeSwgaSkpO1xuICAgICAgICAgICAgICAgIG91dFsrK2J1Y2tldHNbb2Zmc2V0ICsgKGRpdiA+Pj4gc2l6ZSAmIHJhZGl4TWFzayldXSA9IGxpc3RbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3YXAgPSBvdXQ7XG4gICAgICAgICAgICBvdXQgPSBsaXN0O1xuICAgICAgICAgICAgbGlzdCA9IHN3YXA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gbGlzdC5sZW5ndGgsIG9mZnNldCA9IHBhc3MgKiBtYXhSYWRpeCwgc2l6ZSA9IHBhc3MgKiByYWRpeEJpdHM7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgZGl2ID0gZmxvYXRUb0ludChjb21wKGxpc3QsIHJlZ2lzdHJ5LCBpKSk7XG4gICAgICAgIG91dFsrK2J1Y2tldHNbb2Zmc2V0ICsgKGRpdiA+Pj4gc2l6ZSAmIGxhc3RNYXNrKV1dID0gbXV0YXRvcihsaXN0LCByZWdpc3RyeSwgaSwgZGl2IF4gKH5kaXYgPj4gMzEgfCAweDgwMDAwMDAwKSk7XG4gICAgICAgIGNsZWFuKGxpc3QsIHJlZ2lzdHJ5LCBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJhZGl4U29ydDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbnZhciBzaGFkZXJzID0ge1xuICAgIHZlcnRleDogXCIjZGVmaW5lIEdMU0xJRlkgMVxcbi8qKlxcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqIFxcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXFxuICogXFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsXFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbiAqIFxcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuICogXFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuICogVEhFIFNPRlRXQVJFLlxcbiAqL1xcblxcbi8qKlxcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqIFxcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXFxuICogXFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsXFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbiAqIFxcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuICogXFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuICogVEhFIFNPRlRXQVJFLlxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGN1bGF0ZXMgdHJhbnNwb3NlIGludmVyc2UgbWF0cml4IGZyb20gdHJhbnNmb3JtXFxuICogXFxuICogQG1ldGhvZCByYW5kb21cXG4gKiBAcHJpdmF0ZVxcbiAqXFxuICpcXG4gKi9cXG5cXG5cXG5tYXQzIGdldE5vcm1hbE1hdHJpeF8xXzAoaW4gbWF0NCB0KSB7XFxuICAgbWF0MyBtYXROb3JtO1xcbiAgIG1hdDQgYSA9IHQ7XFxuXFxuICAgZmxvYXQgYTAwID0gYVswXVswXSwgYTAxID0gYVswXVsxXSwgYTAyID0gYVswXVsyXSwgYTAzID0gYVswXVszXSxcXG4gICBhMTAgPSBhWzFdWzBdLCBhMTEgPSBhWzFdWzFdLCBhMTIgPSBhWzFdWzJdLCBhMTMgPSBhWzFdWzNdLFxcbiAgIGEyMCA9IGFbMl1bMF0sIGEyMSA9IGFbMl1bMV0sIGEyMiA9IGFbMl1bMl0sIGEyMyA9IGFbMl1bM10sXFxuICAgYTMwID0gYVszXVswXSwgYTMxID0gYVszXVsxXSwgYTMyID0gYVszXVsyXSwgYTMzID0gYVszXVszXSxcXG4gICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXFxuICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxcbiAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcXG4gICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXFxuICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxcbiAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcXG4gICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXFxuICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxcbiAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcXG4gICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXFxuICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxcbiAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcXG5cXG4gICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XFxuICAgZGV0ID0gMS4wIC8gZGV0O1xcblxcbiAgIG1hdE5vcm1bMF1bMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcXG4gICBtYXROb3JtWzBdWzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XFxuICAgbWF0Tm9ybVswXVsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xcblxcbiAgIG1hdE5vcm1bMV1bMF0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcXG4gICBtYXROb3JtWzFdWzFdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XFxuICAgbWF0Tm9ybVsxXVsyXSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xcblxcbiAgIG1hdE5vcm1bMl1bMF0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcXG4gICBtYXROb3JtWzJdWzFdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XFxuICAgbWF0Tm9ybVsyXVsyXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xcblxcbiAgIHJldHVybiBtYXROb3JtO1xcbn1cXG5cXG5cXG5cXG4vKipcXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKiBcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxcbiAqIFxcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbFxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4gKiBcXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbiAqIFxcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbiAqIFRIRSBTT0ZUV0FSRS5cXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxjdWxhdGVzIGEgbWF0cml4IHRoYXQgY3JlYXRlcyB0aGUgaWRlbnRpdHkgd2hlbiBtdWx0aXBsaWVkIGJ5IG1cXG4gKiBcXG4gKiBAbWV0aG9kIGludmVyc2VcXG4gKiBAcHJpdmF0ZVxcbiAqXFxuICpcXG4gKi9cXG5cXG5cXG5mbG9hdCBpbnZlcnNlXzJfMShmbG9hdCBtKSB7XFxuICAgIHJldHVybiAxLjAgLyBtO1xcbn1cXG5cXG5tYXQyIGludmVyc2VfMl8xKG1hdDIgbSkge1xcbiAgICByZXR1cm4gbWF0MihtWzFdWzFdLC1tWzBdWzFdLFxcbiAgICAgICAgICAgICAgIC1tWzFdWzBdLCBtWzBdWzBdKSAvIChtWzBdWzBdKm1bMV1bMV0gLSBtWzBdWzFdKm1bMV1bMF0pO1xcbn1cXG5cXG5tYXQzIGludmVyc2VfMl8xKG1hdDMgbSkge1xcbiAgICBmbG9hdCBhMDAgPSBtWzBdWzBdLCBhMDEgPSBtWzBdWzFdLCBhMDIgPSBtWzBdWzJdO1xcbiAgICBmbG9hdCBhMTAgPSBtWzFdWzBdLCBhMTEgPSBtWzFdWzFdLCBhMTIgPSBtWzFdWzJdO1xcbiAgICBmbG9hdCBhMjAgPSBtWzJdWzBdLCBhMjEgPSBtWzJdWzFdLCBhMjIgPSBtWzJdWzJdO1xcblxcbiAgICBmbG9hdCBiMDEgPSAgYTIyICogYTExIC0gYTEyICogYTIxO1xcbiAgICBmbG9hdCBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwO1xcbiAgICBmbG9hdCBiMjEgPSAgYTIxICogYTEwIC0gYTExICogYTIwO1xcblxcbiAgICBmbG9hdCBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XFxuXFxuICAgIHJldHVybiBtYXQzKGIwMSwgKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpLCAoYTEyICogYTAxIC0gYTAyICogYTExKSxcXG4gICAgICAgICAgICAgICAgYjExLCAoYTIyICogYTAwIC0gYTAyICogYTIwKSwgKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApLFxcbiAgICAgICAgICAgICAgICBiMjEsICgtYTIxICogYTAwICsgYTAxICogYTIwKSwgKGExMSAqIGEwMCAtIGEwMSAqIGExMCkpIC8gZGV0O1xcbn1cXG5cXG5tYXQ0IGludmVyc2VfMl8xKG1hdDQgbSkge1xcbiAgICBmbG9hdFxcbiAgICAgICAgYTAwID0gbVswXVswXSwgYTAxID0gbVswXVsxXSwgYTAyID0gbVswXVsyXSwgYTAzID0gbVswXVszXSxcXG4gICAgICAgIGExMCA9IG1bMV1bMF0sIGExMSA9IG1bMV1bMV0sIGExMiA9IG1bMV1bMl0sIGExMyA9IG1bMV1bM10sXFxuICAgICAgICBhMjAgPSBtWzJdWzBdLCBhMjEgPSBtWzJdWzFdLCBhMjIgPSBtWzJdWzJdLCBhMjMgPSBtWzJdWzNdLFxcbiAgICAgICAgYTMwID0gbVszXVswXSwgYTMxID0gbVszXVsxXSwgYTMyID0gbVszXVsyXSwgYTMzID0gbVszXVszXSxcXG5cXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcXG5cXG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcXG5cXG4gICAgcmV0dXJuIG1hdDQoXFxuICAgICAgICBhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDksXFxuICAgICAgICBhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDksXFxuICAgICAgICBhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMsXFxuICAgICAgICBhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMsXFxuICAgICAgICBhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcsXFxuICAgICAgICBhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcsXFxuICAgICAgICBhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEsXFxuICAgICAgICBhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEsXFxuICAgICAgICBhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYsXFxuICAgICAgICBhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYsXFxuICAgICAgICBhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDAsXFxuICAgICAgICBhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDAsXFxuICAgICAgICBhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYsXFxuICAgICAgICBhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYsXFxuICAgICAgICBhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDAsXFxuICAgICAgICBhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApIC8gZGV0O1xcbn1cXG5cXG5cXG5cXG4vKipcXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKiBcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxcbiAqIFxcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbFxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4gKiBcXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbiAqIFxcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbiAqIFRIRSBTT0ZUV0FSRS5cXG4gKi9cXG5cXG4vKipcXG4gKiBSZWZsZWN0cyBhIG1hdHJpeCBvdmVyIGl0cyBtYWluIGRpYWdvbmFsLlxcbiAqIFxcbiAqIEBtZXRob2QgdHJhbnNwb3NlXFxuICogQHByaXZhdGVcXG4gKlxcbiAqXFxuICovXFxuXFxuXFxuZmxvYXQgdHJhbnNwb3NlXzNfMihmbG9hdCBtKSB7XFxuICAgIHJldHVybiBtO1xcbn1cXG5cXG5tYXQyIHRyYW5zcG9zZV8zXzIobWF0MiBtKSB7XFxuICAgIHJldHVybiBtYXQyKG1bMF1bMF0sIG1bMV1bMF0sXFxuICAgICAgICAgICAgICAgIG1bMF1bMV0sIG1bMV1bMV0pO1xcbn1cXG5cXG5tYXQzIHRyYW5zcG9zZV8zXzIobWF0MyBtKSB7XFxuICAgIHJldHVybiBtYXQzKG1bMF1bMF0sIG1bMV1bMF0sIG1bMl1bMF0sXFxuICAgICAgICAgICAgICAgIG1bMF1bMV0sIG1bMV1bMV0sIG1bMl1bMV0sXFxuICAgICAgICAgICAgICAgIG1bMF1bMl0sIG1bMV1bMl0sIG1bMl1bMl0pO1xcbn1cXG5cXG5tYXQ0IHRyYW5zcG9zZV8zXzIobWF0NCBtKSB7XFxuICAgIHJldHVybiBtYXQ0KG1bMF1bMF0sIG1bMV1bMF0sIG1bMl1bMF0sIG1bM11bMF0sXFxuICAgICAgICAgICAgICAgIG1bMF1bMV0sIG1bMV1bMV0sIG1bMl1bMV0sIG1bM11bMV0sXFxuICAgICAgICAgICAgICAgIG1bMF1bMl0sIG1bMV1bMl0sIG1bMl1bMl0sIG1bM11bMl0sXFxuICAgICAgICAgICAgICAgIG1bMF1bM10sIG1bMV1bM10sIG1bMl1bM10sIG1bM11bM10pO1xcbn1cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBDb252ZXJ0cyB2ZXJ0ZXggZnJvbSBtb2RlbHNwYWNlIHRvIHNjcmVlbnNwYWNlIHVzaW5nIHRyYW5zZm9ybVxcbiAqIGluZm9ybWF0aW9uIGZyb20gY29udGV4dC5cXG4gKlxcbiAqIEBtZXRob2QgYXBwbHlUcmFuc2Zvcm1cXG4gKiBAcHJpdmF0ZVxcbiAqXFxuICpcXG4gKi9cXG5cXG52ZWM0IGFwcGx5VHJhbnNmb3JtKHZlYzQgcG9zKSB7XFxuICAgIC8vVE9ETzogbW92ZSB0aGlzIG11bHRpcGxpY2F0aW9uIHRvIGFwcGxpY2F0aW9uIGNvZGUuIFxcblxcbiAgICAvKipcXG4gICAgICogQ3VycmVudGx5IG11bHRpcGxpZWQgaW4gdGhlIHZlcnRleCBzaGFkZXIgdG8gYXZvaWQgY29uc3VtaW5nIHRoZSBjb21wbGV4aXR5IG9mIGhvbGRpbmcgYW4gYWRkaXRpb25hbFxcbiAgICAgKiB0cmFuc2Zvcm0gYXMgc3RhdGUgb24gdGhlIG1lc2ggb2JqZWN0IGluIFdlYkdMUmVuZGVyZXIuIE11bHRpcGxpZXMgdGhlIG9iamVjdCdzIHRyYW5zZm9ybWF0aW9uIGZyb20gb2JqZWN0IHNwYWNlXFxuICAgICAqIHRvIHdvcmxkIHNwYWNlIHdpdGggaXRzIHRyYW5zZm9ybWF0aW9uIGZyb20gd29ybGQgc3BhY2UgdG8gZXllIHNwYWNlLlxcbiAgICAgKi9cXG4gICAgbWF0NCBNVk1hdHJpeCA9IHVfdmlldyAqIHVfdHJhbnNmb3JtO1xcblxcbiAgICAvL1RPRE86IG1vdmUgdGhlIG9yaWdpbiwgc2l6ZVNjYWxlIGFuZCB5IGF4aXMgaW52ZXJzaW9uIHRvIGFwcGxpY2F0aW9uIGNvZGUgaW4gb3JkZXIgdG8gYW1vcnRpemUgcmVkdW5kYW50IHBlci12ZXJ0ZXggY2FsY3VsYXRpb25zLlxcblxcbiAgICAvKipcXG4gICAgICogVGhlIHRyYW5zZm9ybSB1bmlmb3JtIHNob3VsZCBiZSBjaGFuZ2VkIHRvIHRoZSByZXN1bHQgb2YgdGhlIHRyYW5zZm9ybWF0aW9uIGNoYWluOlxcbiAgICAgKlxcbiAgICAgKiB2aWV3ICogbW9kZWxUcmFuc2Zvcm0gKiBpbnZlcnRZQXhpcyAqIHNpemVTY2FsZSAqIG9yaWdpblxcbiAgICAgKlxcbiAgICAgKiB3aGljaCBjb3VsZCBiZSBzaW1wbGlmaWVkIHRvOlxcbiAgICAgKlxcbiAgICAgKiB2aWV3ICogbW9kZWxUcmFuc2Zvcm0gKiBjb252ZXJ0VG9ET01TcGFjZVxcbiAgICAgKlxcbiAgICAgKiB3aGVyZSBjb252ZXJ0VG9ET01TcGFjZSByZXByZXNlbnRzIHRoZSB0cmFuc2Zvcm0gbWF0cml4OlxcbiAgICAgKlxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUueCAwICAgICAgIDAgICAgICAgc2l6ZS54IFxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgICAgICAtc2l6ZS55IDAgICAgICAgc2l6ZS55XFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAgICAgIDAgICAgICAgMSAgICAgICAwXFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAgICAgIDAgICAgICAgMCAgICAgICAxXFxuICAgICAqXFxuICAgICAqL1xcblxcbiAgICAvKipcXG4gICAgICogQXNzdW1pbmcgYSB1bml0IHZvbHVtZSwgbW92ZXMgdGhlIG9iamVjdCBzcGFjZSBvcmlnaW4gWzAsIDAsIDBdIHRvIHRoZSBcXFwidG9wIGxlZnRcXFwiIFsxLCAtMSwgMF0sIHRoZSBET00gc3BhY2Ugb3JpZ2luLlxcbiAgICAgKiBMYXRlciBpbiB0aGUgdHJhbnNmb3JtYXRpb24gY2hhaW4sIHRoZSBwcm9qZWN0aW9uIHRyYW5zZm9ybSBuZWdhdGVzIHRoZSByaWdpZGJvZHkgdHJhbnNsYXRpb24uXFxuICAgICAqIEVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKSBtdWx0aXBseWluZyBhIHRyYW5zbGF0aW9uIG1hdHJpeCBcXFwib3JpZ2luXFxcIlxcbiAgICAgKlxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDEgMCAwIDEgXFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAxIDAgLTFcXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAwIDAgMSAwXFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAwIDAgMVxcbiAgICAgKlxcbiAgICAgKiBpbiB0aGUgdHJhbnNmb3JtIGNoYWluOiBwcm9qZWN0aW9uICogdmlldyAqIG1vZGVsVHJhbnNmb3JtICogaW52ZXJ0WUF4aXMgKiBzaXplU2NhbGUgKiBvcmlnaW4gKiBwb3NpdGlvblZlY3Rvci5cXG4gICAgICovXFxuICAgIHBvcy54ICs9IDEuMDtcXG4gICAgcG9zLnkgLT0gMS4wO1xcblxcbiAgICAvKipcXG4gICAgICogQXNzdW1pbmcgYSB1bml0IHZvbHVtZSwgc2NhbGVzIGFuIG9iamVjdCB0byB0aGUgYW1vdW50IG9mIHBpeGVscyBpbiB0aGUgc2l6ZSB1bmlmb3JtIHZlY3RvcidzIHNwZWNpZmllZCBkaW1lbnNpb25zLlxcbiAgICAgKiBMYXRlciBpbiB0aGUgdHJhbnNmb3JtYXRpb24gY2hhaW4sIHRoZSBwcm9qZWN0aW9uIHRyYW5zZm9ybSB0cmFuc2Zvcm1zIHRoZSBwb2ludCBpbnRvIGNsaXAgc3BhY2UgYnkgc2NhbGluZ1xcbiAgICAgKiBieSB0aGUgaW52ZXJzZSBvZiB0aGUgY2FudmFzJyByZXNvbHV0aW9uLlxcbiAgICAgKiBFcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbikgbXVsdGlwbHlpbmcgYSBzY2FsZSBtYXRyaXggXFxcInNpemVTY2FsZVxcXCJcXG4gICAgICpcXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplLnggMCAgICAgIDAgICAgICAwIFxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgICAgICBzaXplLnkgMCAgICAgIDBcXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAwICAgICAgMCAgICAgIHNpemUueiAwXFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAgICAgIDAgICAgICAwICAgICAgMVxcbiAgICAgKlxcbiAgICAgKiBpbiB0aGUgdHJhbnNmb3JtIGNoYWluOiBwcm9qZWN0aW9uICogdmlldyAqIG1vZGVsVHJhbnNmb3JtICogaW52ZXJ0WUF4aXMgKiBzaXplU2NhbGUgKiBvcmlnaW4gKiBwb3NpdGlvblZlY3Rvci5cXG4gICAgICovXFxuICAgIHBvcy54eXogKj0gdV9zaXplICogMC41O1xcblxcbiAgICAvKipcXG4gICAgICogSW52ZXJ0cyB0aGUgb2JqZWN0IHNwYWNlJ3MgeSBheGlzIGluIG9yZGVyIHRvIG1hdGNoIERPTSBzcGFjZSBjb252ZW50aW9ucy4gXFxuICAgICAqIExhdGVyIGluIHRoZSB0cmFuc2Zvcm1hdGlvbiBjaGFpbiwgdGhlIHByb2plY3Rpb24gdHJhbnNmb3JtIHJlaW52ZXJ0cyB0aGUgeSBheGlzIHRvIGNvbnZlcnQgdG8gY2xpcCBzcGFjZS5cXG4gICAgICogRXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pIG11bHRpcGx5aW5nIGEgc2NhbGUgbWF0cml4IFxcXCJpbnZlcnRZQXhpc1xcXCJcXG4gICAgICpcXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAxIDAgMCAwIFxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgLTEgMCAwXFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAwIDEgMFxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgMCAwIDFcXG4gICAgICpcXG4gICAgICogaW4gdGhlIHRyYW5zZm9ybSBjaGFpbjogcHJvamVjdGlvbiAqIHZpZXcgKiBtb2RlbFRyYW5zZm9ybSAqIGludmVydFlBeGlzICogc2l6ZVNjYWxlICogb3JpZ2luICogcG9zaXRpb25WZWN0b3IuXFxuICAgICAqL1xcbiAgICBwb3MueSAqPSAtMS4wO1xcblxcbiAgICAvKipcXG4gICAgICogRXhwb3J0aW5nIHRoZSB2ZXJ0ZXgncyBwb3NpdGlvbiBhcyBhIHZhcnlpbmcsIGluIERPTSBzcGFjZSwgdG8gYmUgdXNlZCBmb3IgbGlnaHRpbmcgY2FsY3VsYXRpb25zLiBUaGlzIGhhcyB0byBiZSBpbiBET00gc3BhY2VcXG4gICAgICogc2luY2UgbGlnaHQgcG9zaXRpb24gYW5kIGRpcmVjdGlvbiBpcyBkZXJpdmVkIGZyb20gdGhlIHNjZW5lIGdyYXBoLCBjYWxjdWxhdGVkIGluIERPTSBzcGFjZS5cXG4gICAgICovXFxuXFxuICAgIHZfcG9zaXRpb24gPSAoTVZNYXRyaXggKiBwb3MpLnh5ejtcXG5cXG4gICAgLyoqXFxuICAgICogRXhwb3J0aW5nIHRoZSBleWUgdmVjdG9yIChhIHZlY3RvciBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIHNjcmVlbikgYXMgYSB2YXJ5aW5nLCB0byBiZSB1c2VkIGZvciBsaWdodGluZyBjYWxjdWxhdGlvbnMuXFxuICAgICogSW4gY2xpcCBzcGFjZSBkZXJpdmluZyB0aGUgZXllIHZlY3RvciBpcyBhIG1hdHRlciBvZiBzaW1wbHkgdGFraW5nIHRoZSBpbnZlcnNlIG9mIHRoZSBwb3NpdGlvbiwgYXMgdGhlIHBvc2l0aW9uIGlzIGEgdmVjdG9yXFxuICAgICogZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW4uIEhvd2V2ZXIsIHNpbmNlIG91ciBwb2ludHMgYXJlIHJlcHJlc2VudGVkIGluIERPTSBzcGFjZSxcXG4gICAgKiB0aGUgcG9zaXRpb24gaXMgYSB2ZWN0b3IgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBzY3JlZW4sIHNvIHNvbWUgYWRkaXRpb25hbCBtYXRoIGlzIG5lZWRlZCAoc3BlY2lmaWNhbGx5LCBzdWJ0cmFjdGluZ1xcbiAgICAqIHRoZSBwb3NpdGlvbiBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIHNjcmVlbiwgaS5lLiBoYWxmIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMpLlxcbiAgICAqL1xcblxcbiAgICB2X2V5ZVZlY3RvciA9ICh1X3Jlc29sdXRpb24gKiAwLjUpIC0gdl9wb3NpdGlvbjtcXG5cXG4gICAgLyoqXFxuICAgICAqIFRyYW5zZm9ybWluZyB0aGUgcG9zaXRpb24gKGN1cnJlbnRseSByZXByZXNlbnRlZCBpbiBkb20gc3BhY2UpIGludG8gdmlldyBzcGFjZSAod2l0aCBvdXIgZG9tIHNwYWNlIHZpZXcgdHJhbnNmb3JtKVxcbiAgICAgKiBhbmQgdGhlbiBwcm9qZWN0aW5nIHRoZSBwb2ludCBpbnRvIHJhc3RlciBib3RoIGJ5IGFwcGx5aW5nIGEgcGVyc3BlY3RpdmUgdHJhbnNmb3JtYXRpb24gYW5kIGNvbnZlcnRpbmcgdG8gY2xpcCBzcGFjZVxcbiAgICAgKiAodGhlIHBlcnNwZWN0aXZlIG1hdHJpeCBpcyBhIGNvbWJpbmF0aW9uIG9mIGJvdGggdHJhbnNmb3JtYXRpb25zLCB0aGVyZWZvcmUgaXQncyBwcm9iYWJseSBtb3JlIGFwdCB0byByZWZlciB0byBpdCBhcyBhXFxuICAgICAqIHByb2plY3Rpb24gdHJhbnNmb3JtKS5cXG4gICAgICovXFxuXFxuICAgIHBvcyA9IHVfcGVyc3BlY3RpdmUgKiBNVk1hdHJpeCAqIHBvcztcXG5cXG4gICAgcmV0dXJuIHBvcztcXG59XFxuXFxuLyoqXFxuICogUGxhY2Vob2xkZXIgZm9yIHBvc2l0aW9uT2Zmc2V0IGNodW5rcyB0byBiZSB0ZW1wbGF0ZWQgaW4uXFxuICogVXNlZCBmb3IgbWVzaCBkZWZvcm1hdGlvbi5cXG4gKlxcbiAqIEBtZXRob2QgY2FsY3VsYXRlT2Zmc2V0XFxuICogQHByaXZhdGVcXG4gKlxcbiAqXFxuICovXFxuI3ZlcnRfZGVmaW5pdGlvbnNcXG52ZWMzIGNhbGN1bGF0ZU9mZnNldCh2ZWMzIElEKSB7XFxuICAgICN2ZXJ0X2FwcGxpY2F0aW9uc1xcbiAgICByZXR1cm4gdmVjMygwLjApO1xcbn1cXG5cXG4vKipcXG4gKiBXcml0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXggb250byB0aGUgc2NyZWVuLlxcbiAqIFBhc3NlcyB0ZXh0dXJlIGNvb3JkaW5hdGUgYW5kIG5vcm1hbCBhdHRyaWJ1dGVzIGFzIHZhcnlpbmdzXFxuICogYW5kIHBhc3NlcyB0aGUgcG9zaXRpb24gYXR0cmlidXRlIHRocm91Z2ggcG9zaXRpb24gcGlwZWxpbmUuXFxuICpcXG4gKiBAbWV0aG9kIG1haW5cXG4gKiBAcHJpdmF0ZVxcbiAqXFxuICpcXG4gKi9cXG52b2lkIG1haW4oKSB7XFxuICAgIHZfdGV4dHVyZUNvb3JkaW5hdGUgPSBhX3RleENvb3JkO1xcbiAgICB2ZWMzIGludmVydGVkTm9ybWFscyA9IGFfbm9ybWFscyArICh1X25vcm1hbHMueCA8IDAuMCA/IGNhbGN1bGF0ZU9mZnNldCh1X25vcm1hbHMpICogMi4wIC0gMS4wIDogdmVjMygwLjApKTtcXG4gICAgaW52ZXJ0ZWROb3JtYWxzLnkgKj0gLTEuMDtcXG4gICAgdl9ub3JtYWwgPSB0cmFuc3Bvc2VfM18yKG1hdDMoaW52ZXJzZV8yXzEodV90cmFuc2Zvcm0pKSkgKiBpbnZlcnRlZE5vcm1hbHM7XFxuICAgIHZlYzMgb2Zmc2V0UG9zID0gYV9wb3MgKyBjYWxjdWxhdGVPZmZzZXQodV9wb3NpdGlvbk9mZnNldCk7XFxuICAgIGdsX1Bvc2l0aW9uID0gYXBwbHlUcmFuc2Zvcm0odmVjNChvZmZzZXRQb3MsIDEuMCkpO1xcbn1cXG5cIixcbiAgICBmcmFnbWVudDogXCIjZGVmaW5lIEdMU0xJRlkgMVxcbi8qKlxcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqIFxcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXFxuICogXFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsXFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbiAqIFxcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuICogXFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuICogVEhFIFNPRlRXQVJFLlxcbiAqL1xcblxcbi8qKlxcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqIFxcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXFxuICogXFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsXFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbiAqIFxcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuICogXFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuICogVEhFIFNPRlRXQVJFLlxcbiAqL1xcblxcbi8qKlxcbiAqIFBsYWNlaG9sZGVyIGZvciBmcmFnbWVudFNoYWRlciAgY2h1bmtzIHRvIGJlIHRlbXBsYXRlZCBpbi5cXG4gKiBVc2VkIGZvciBub3JtYWwgbWFwcGluZywgZ2xvc3MgbWFwcGluZyBhbmQgY29sb3JzLlxcbiAqIFxcbiAqIEBtZXRob2QgYXBwbHlNYXRlcmlhbFxcbiAqIEBwcml2YXRlXFxuICpcXG4gKlxcbiAqL1xcblxcbiNmbG9hdF9kZWZpbml0aW9uc1xcbmZsb2F0IGFwcGx5TWF0ZXJpYWxfMV8wKGZsb2F0IElEKSB7XFxuICAgICNmbG9hdF9hcHBsaWNhdGlvbnNcXG4gICAgcmV0dXJuIDEuO1xcbn1cXG5cXG4jdmVjM19kZWZpbml0aW9uc1xcbnZlYzMgYXBwbHlNYXRlcmlhbF8xXzAodmVjMyBJRCkge1xcbiAgICAjdmVjM19hcHBsaWNhdGlvbnNcXG4gICAgcmV0dXJuIHZlYzMoMCk7XFxufVxcblxcbiN2ZWM0X2RlZmluaXRpb25zXFxudmVjNCBhcHBseU1hdGVyaWFsXzFfMCh2ZWM0IElEKSB7XFxuICAgICN2ZWM0X2FwcGxpY2F0aW9uc1xcblxcbiAgICByZXR1cm4gdmVjNCgwKTtcXG59XFxuXFxuXFxuXFxuLyoqXFxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICogXFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cXG4gKiBcXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWxcXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuICogXFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4gKiBcXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4gKiBUSEUgU09GVFdBUkUuXFxuICovXFxuXFxuLyoqXFxuICogQ2FsY3VsYXRlcyB0aGUgaW50ZW5zaXR5IG9mIGxpZ2h0IG9uIGEgc3VyZmFjZS5cXG4gKlxcbiAqIEBtZXRob2QgYXBwbHlMaWdodFxcbiAqIEBwcml2YXRlXFxuICpcXG4gKi9cXG52ZWM0IGFwcGx5TGlnaHRfMl8xKGluIHZlYzQgYmFzZUNvbG9yLCBpbiB2ZWMzIG5vcm1hbCwgaW4gdmVjNCBnbG9zc2luZXNzLCBpbnQgbnVtTGlnaHRzLCB2ZWMzIGFtYmllbnRDb2xvciwgdmVjMyBleWVWZWN0b3IsIG1hdDQgbGlnaHRQb3NpdGlvbiwgbWF0NCBsaWdodENvbG9yLCB2ZWMzIHZfcG9zaXRpb24pIHtcXG4gICAgdmVjMyBkaWZmdXNlID0gdmVjMygwLjApO1xcbiAgICBib29sIGhhc0dsb3NzaW5lc3MgPSBnbG9zc2luZXNzLmEgPiAwLjA7XFxuICAgIGJvb2wgaGFzU3BlY3VsYXJDb2xvciA9IGxlbmd0aChnbG9zc2luZXNzLnJnYikgPiAwLjA7XFxuXFxuICAgIGZvcihpbnQgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG4gICAgICAgIGlmIChpID49IG51bUxpZ2h0cykgYnJlYWs7XFxuICAgICAgICB2ZWMzIGxpZ2h0RGlyZWN0aW9uID0gbm9ybWFsaXplKGxpZ2h0UG9zaXRpb25baV0ueHl6IC0gdl9wb3NpdGlvbik7XFxuICAgICAgICBmbG9hdCBsYW1iZXJ0aWFuID0gbWF4KGRvdChsaWdodERpcmVjdGlvbiwgbm9ybWFsKSwgMC4wKTtcXG5cXG4gICAgICAgIGlmIChsYW1iZXJ0aWFuID4gMC4wKSB7XFxuICAgICAgICAgICAgZGlmZnVzZSArPSBsaWdodENvbG9yW2ldLnJnYiAqIGJhc2VDb2xvci5yZ2IgKiBsYW1iZXJ0aWFuO1xcbiAgICAgICAgICAgIGlmIChoYXNHbG9zc2luZXNzKSB7XFxuICAgICAgICAgICAgICAgIHZlYzMgaGFsZlZlY3RvciA9IG5vcm1hbGl6ZShsaWdodERpcmVjdGlvbiArIGV5ZVZlY3Rvcik7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHNwZWN1bGFyV2VpZ2h0ID0gcG93KG1heChkb3QoaGFsZlZlY3Rvciwgbm9ybWFsKSwgMC4wKSwgZ2xvc3NpbmVzcy5hKTtcXG4gICAgICAgICAgICAgICAgdmVjMyBzcGVjdWxhckNvbG9yID0gaGFzU3BlY3VsYXJDb2xvciA/IGdsb3NzaW5lc3MucmdiIDogbGlnaHRDb2xvcltpXS5yZ2I7XFxuICAgICAgICAgICAgICAgIGRpZmZ1c2UgKz0gc3BlY3VsYXJDb2xvciAqIHNwZWN1bGFyV2VpZ2h0ICogbGFtYmVydGlhbjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHZlYzQoYW1iaWVudENvbG9yICsgZGlmZnVzZSwgYmFzZUNvbG9yLmEpO1xcbn1cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBXcml0ZXMgdGhlIGNvbG9yIG9mIHRoZSBwaXhlbCBvbnRvIHRoZSBzY3JlZW5cXG4gKlxcbiAqIEBtZXRob2QgbWFpblxcbiAqIEBwcml2YXRlXFxuICpcXG4gKlxcbiAqL1xcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjNCBtYXRlcmlhbCA9IHVfYmFzZUNvbG9yLnIgPj0gMC4wID8gdV9iYXNlQ29sb3IgOiBhcHBseU1hdGVyaWFsXzFfMCh1X2Jhc2VDb2xvcik7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBcHBseSBsaWdodHMgb25seSBpZiBmbGF0IHNoYWRpbmcgaXMgZmFsc2VcXG4gICAgICogYW5kIGF0IGxlYXN0IG9uZSBsaWdodCBpcyBhZGRlZCB0byB0aGUgc2NlbmVcXG4gICAgICovXFxuICAgIGJvb2wgbGlnaHRzRW5hYmxlZCA9ICh1X2ZsYXRTaGFkaW5nID09IDAuMCkgJiYgKHVfbnVtTGlnaHRzID4gMC4wIHx8IGxlbmd0aCh1X2FtYmllbnRMaWdodCkgPiAwLjApO1xcblxcbiAgICB2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSh2X25vcm1hbCk7XFxuICAgIHZlYzQgZ2xvc3NpbmVzcyA9IHVfZ2xvc3NpbmVzcy54IDwgMC4wID8gYXBwbHlNYXRlcmlhbF8xXzAodV9nbG9zc2luZXNzKSA6IHVfZ2xvc3NpbmVzcztcXG5cXG4gICAgdmVjNCBjb2xvciA9IGxpZ2h0c0VuYWJsZWQgP1xcbiAgICBhcHBseUxpZ2h0XzJfMShtYXRlcmlhbCwgbm9ybWFsaXplKHZfbm9ybWFsKSwgZ2xvc3NpbmVzcyxcXG4gICAgICAgICAgICAgICBpbnQodV9udW1MaWdodHMpLFxcbiAgICAgICAgICAgICAgIHVfYW1iaWVudExpZ2h0ICogdV9iYXNlQ29sb3IucmdiLFxcbiAgICAgICAgICAgICAgIG5vcm1hbGl6ZSh2X2V5ZVZlY3RvciksXFxuICAgICAgICAgICAgICAgdV9saWdodFBvc2l0aW9uLFxcbiAgICAgICAgICAgICAgIHVfbGlnaHRDb2xvciwgICBcXG4gICAgICAgICAgICAgICB2X3Bvc2l0aW9uKVxcbiAgICA6IG1hdGVyaWFsO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4gICAgZ2xfRnJhZ0NvbG9yLmEgKj0gdV9vcGFjaXR5OyAgIFxcbn1cXG5cIlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzaGFkZXJzO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgc2VjdGlvbnM6IFt7XG4gICAgICAgaWQ6ICdIb21lJyxcbiAgICAgICB0d2VldE51bWJlcjogNTBcbiAgIH0sIHtcbiAgICAgICBpZDogJ0Rpc2NvdmVyJyxcbiAgICAgICB0d2VldE51bWJlcjogNTBcbiAgIH0sIHtcbiAgICAgICBpZDogJ0Nvbm5lY3QnLFxuICAgICAgIHR3ZWV0TnVtYmVyOiA1MFxuICAgfSwge1xuICAgICAgIGlkOiAnTWUnLFxuICAgICAgIHR3ZWV0TnVtYmVyOiAyNVxuICAgfV0sXG5cbiAgICB1c2VybmFtZXM6IFsnQExvdWllQmxvb1Jhc3BiZXJyeScsJ0BQb25jaG9QdW5jaCcsJ0BTaXJJc2FhY0xpbWUnLCdAU3RyYXdiZXJyeVNob3J0S29vaycsJ0BBbGV4YW5kZXJ0aGVHcmFwZScsICdATGl0dGxlT3JwaGFuT3JhbmdlJ10sXG4gICAgYmVnaW46IFsnV2FsayB0b3dhcmRzICcsICdKdW1wIG9uICcgLCdTaW5nIHRvICcsICdEYW5jZSB3aXRoICcsICdTdGFyZSBkb3duICcsICdQaWNrIHVwICcsICdIb2xkIGhhbmRzIHdpdGggJywgJ1dhbGsgYXJvdW5kICcsICdTaGFrZSBoYW5kcyB3aXRoICcsICdUYWxrIHRvICcsICdQb2ludCBhdCAnLCAnUmVhZCB0byAnLCAnSGlnaCBmaXZlICcsICdXYXZlIHRvICcgXSxcbiAgICBtaWRkbGU6IFsnYSBkdWNrICcsICdzb21lIGZpc2ggJywgJ2EgemVicmEgJywgJ25pbmUgaG9uZXkgYmFkZ2VycyAnLCAnYW4gb2xkIGdvcmlsbGEgJywgJ2EgaGFtIHNhbmR3aWNoICcsICdhIHBlYW51dCAnLCAnTmljb2xhcyBDYWdlICcsICdhIHNvY2sgJywgJ2EgcGlsbG93ICcsICcxMiBmaXNoICcsJ2EgcG90YXRvICcsICd5b3VyIG5laWdoYm9yICcsICdhIHNuYWlsICddLFxuICAgIGVuZDogWydxdWlja2x5JywnYW5kIGRvblxcJ3QgbG9vayBiYWNrJywnd2l0aG91dCBzaG9lcycsICdhbmQgY2xhcCB5b3VyIGhhbmRzJywgJ2FuZCBwYXQgeW91ciBiZWxseScsICdhbmQgZG8gYSBqaWcnLCAndG9tb3Jyb3cnLCAnd2hpbGUgZWF0aW5nIGljZSBjcmVhbScsICdpbiB0aGUgZGFyaycsICdhdCB0aGUgcGFyaycsICd3aXRoIGEgZnJpZW5kJywgJ2Rvd24gYnkgdGhlIGJheScsICdpbiB0aGUgY2FyJywgJ2FuZCB5ZWxsJ10sXG4gICAgaGFzaHRhZ3M6IFsnI2hhcnJ5c3R5bGVzJywgJyNsaXZlJywgJyNib3JlZG9tJywgJyNteWxpZmUnLCAnI2hpcGhvcCcsICcjdGV4YXMnLCAnI25vdmVtYmVyJywgJyNzY2FyeScsICcjYmVzdCcsJyAjc25vd21hbicsICcjc2h1ZmZsZScsICcjc3F1YXRzJywgJyNzZWxmaWUnIF1cblxuXG59O1xuXG4iLCJ2YXIgZGF0YSA9IHJlcXVpcmUoJy4vRGF0YScpO1xudmFyIE5hdkJ1dHRvbiA9IHJlcXVpcmUoJy4vTmF2QnV0dG9uJyk7XG52YXIgTm9kZSA9IHJlcXVpcmUoJ2ZhbW91cy9jb3JlL05vZGUnKTtcblxuLy8gdGhlIG51bWJlciBvZiBzZWN0aW9ucyBpbiB0aGUgYXBwXG52YXIgbnVtU2VjdGlvbnMgPSBkYXRhLnNlY3Rpb25zLmxlbmd0aDtcblxuLy8gdGhlIGZvb3RlciB3aWxsIGhvbGQgdGhlIG5hdiBidXR0b25zXG5mdW5jdGlvbiBGb290ZXIgKCkge1xuICAgIC8vIHN1YmNsYXNzIE5vZGVcbiAgICBOb2RlLmNhbGwodGhpcyk7XG5cbiAgICAvLyBvYmplY3QgdG8gc3RvcmUgdGhlIGJ1dHRvbnNcbiAgICB0aGlzLmJ1dHRvbnMgPSB7fTtcblxuICAgIC8vIGZvciBldmVyeSBzZWN0aW9uIGNyZWF0ZSBhIE5hdkJ1dHRvblxuICAgIC8vIGFuZCBzZXQgaXRzIHNpemUgYW5kIGFsaWduXG4gICAgZGF0YS5zZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzZWN0aW9uLCBpKSB7XG4gICAgICAgIHRoaXMuYnV0dG9uc1tzZWN0aW9uLmlkXSA9IHRoaXMuYWRkQ2hpbGQobmV3IE5hdkJ1dHRvbihzZWN0aW9uLmlkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRQcm9wb3J0aW9uYWxTaXplKDEgLyBudW1TZWN0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRBbGlnbihpIC8gbnVtU2VjdGlvbnMpO1xuICAgIH0uYmluZCh0aGlzKSk7XG59XG5cbi8vIHN1YmNsYXNzIE5vZGVcbkZvb3Rlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGb290ZXI7IiwidmFyIE5vZGUgPSByZXF1aXJlKCdmYW1vdXMvY29yZS9Ob2RlJyk7XG52YXIgRE9NRWxlbWVudCA9IHJlcXVpcmUoJ2ZhbW91cy9kb20tcmVuZGVyYWJsZXMvRE9NRWxlbWVudCcpO1xudmFyIEFsaWduID0gcmVxdWlyZSgnZmFtb3VzL2NvbXBvbmVudHMvQWxpZ24nKTtcblxuZnVuY3Rpb24gSGVhZGVyICgpIHtcbiAgICBOb2RlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5lbCA9IG5ldyBET01FbGVtZW50KHRoaXMsIHtcbiAgICAgICAgY2xhc3NlczogWydoZWFkZXInXVxuICAgIH0pO1xuXG4gICAgdGhpcy50aXRsZSA9IHRoaXMuYWRkQ2hpbGQoKTtcbiAgICB0aGlzLnRpdGxlRWwgPSBuZXcgRE9NRWxlbWVudCh0aGlzLnRpdGxlKS5zZXRQcm9wZXJ0eSgndGV4dEFsaWduJywgJ2NlbnRlcicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0UHJvcGVydHkoJ2xpbmVIZWlnaHQnLCAnMTAwcHgnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldFByb3BlcnR5KCdmb250U2l6ZScsICczMHB4Jyk7XG5cbiAgICB0aGlzLnRpdGxlQWxpZ24gPSBuZXcgQWxpZ24odGhpcy50aXRsZSk7XG59XG5cbkhlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlKTtcblxuSGVhZGVyLnByb3RvdHlwZS5vblJlY2VpdmUgPSBmdW5jdGlvbiBvblJlY2VpdmUgKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgaWYgKGV2ZW50ID09PSAnY2hhbmdlU2VjdGlvbicpIHRoaXMuY2hhbmdlU2VjdGlvbihwYXlsb2FkLnRvKTtcbn07XG5cbkhlYWRlci5wcm90b3R5cGUuY2hhbmdlU2VjdGlvbiA9IGZ1bmN0aW9uIGNoYW5nZVNlY3Rpb24gKHRvKSB7XG4gICAgLy8gLTEgaW4gWSB3aWxsIHB1dCB0aGUgdGl0bGUgZGlyZWN0bHkgYWJvdmUgaXRzIHBhcmVudFxuICAgIHRoaXMudGl0bGVBbGlnbi5zZXQoMCwgLTEsIDAsIHtkdXJhdGlvbjogMjUwfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB3aGlsZSB0aGUgdGl0bGUgaXMgb2Zmc2NyZWVuXG4gICAgICAgIC8vIGNoYW5nZSB0aGUgY29udGVudFxuICAgICAgICB0aGlzLnRpdGxlRWwuc2V0Q29udGVudCh0byk7XG5cbiAgICAgICAgLy8gYWxpZ24gMCwgMCwgMCBwbGFjZXMgdGhlIHRpdGxlIGJhY2sgaW50byBpdHMgcGFyZW50XG4gICAgICAgIC8vIGV4YWN0bHlcbiAgICAgICAgdGhpcy50aXRsZUFsaWduLnNldCgwLCAwLCAwLCB7ZHVyYXRpb246IDI1MH0pO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYWRlcjsiLCJ2YXIgTm9kZSA9IHJlcXVpcmUoJ2ZhbW91cy9jb3JlL05vZGUnKTtcbnZhciBET01FbGVtZW50ID0gcmVxdWlyZSgnZmFtb3VzL2RvbS1yZW5kZXJhYmxlcy9ET01FbGVtZW50Jyk7XG5cbi8vIFRoZSBuYXYgYnV0dG9uIGNsYXNzIHdpbGwgc2hvdyB0aGUgbmFtZSBvZiBhIHNlY3Rpb25cbi8vIGFuZCBlbWl0IGEgY2xpY2sgZXZlbnQgd2hlbiBjbGlja2VkXG5mdW5jdGlvbiBOYXZCdXR0b24gKGlkLCBzdGF0dXMpIHtcbiAgICAvLyBTdWJjbGFzcyBub2RlXG4gICAgTm9kZS5jYWxsKHRoaXMpO1xuXG4gICAgLy8gbWFrZSBhbmQgc3R5bGUgYW4gZWxlbWVudFxuICAgIHRoaXMuZWwgPSBtYWtlRWwodGhpcyk7XG5cbiAgICAvLyBob2xkIHRoZSBpZCBvZiB0aGUgc2VjdGlvblxuICAgIC8vIHRoaXMgTmF2QnV0dG9uIHBvaW50cyB0by5cbiAgICB0aGlzLmlkID0gaWQ7XG5cbiAgICAvLyBzZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGVsZW1lbnRcbiAgICAvLyB0byB0aGUgdGFyZ2V0IHNlY3Rpb24uXG4gICAgdGhpcy5lbC5zZXRDb250ZW50KGlkKTtcblxuICAgIHRoaXMuYWRkVUlFdmVudCgnY2xpY2snKTtcbn1cblxuTmF2QnV0dG9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xuXG4vLyBvdmVyd3JpdGUgb25SZWNlaXZlIHRvIHJlc3BvbmQgdG8gdGhlIGNoYW5nZVNlY3Rpb24gZXZlbnRcbk5hdkJ1dHRvbi5wcm90b3R5cGUub25SZWNlaXZlID0gZnVuY3Rpb24gb25SZWNlaXZlIChldmVudCwgcGF5bG9hZCkge1xuICAgIGlmIChldmVudCA9PT0gJ2NoYW5nZVNlY3Rpb24nKSB7XG4gICAgICAgIC8vIHN3YXAgb24vb2ZmIGRlcGVuZCBpZiB0aGlzIGJ1dHRvbiBwb2ludHNcbiAgICAgICAgLy8gdG8gdGhlIGFwcHMgY3VycmVudCBzZWN0aW9uXG4gICAgICAgIGlmIChwYXlsb2FkLnRvID09PSB0aGlzLmdldElkKCkpIHRoaXMub24oKTtcbiAgICAgICAgZWxzZSB0aGlzLm9mZigpO1xuICAgIH1cbn07XG5cbi8vIGFwcGx5IHRoZSBvbiBjbGFzc1xuTmF2QnV0dG9uLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uICgpIHtcbiAgICB0aGlzLmVsLnJlbW92ZUNsYXNzKCdvZmYnKS5hZGRDbGFzcygnb24nKTtcbn07XG5cbi8vIGFwcGx5IHRoZSBvZmYgY2xhc3Ncbk5hdkJ1dHRvbi5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmICgpIHtcbiAgICB0aGlzLmVsLnJlbW92ZUNsYXNzKCdvbicpLmFkZENsYXNzKCdvZmYnKTtcbn07XG5cbk5hdkJ1dHRvbi5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiBnZXRJZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQ7XG59O1xuXG4vLyBtYWtlIGFuZCBzdHlsZSBhbiBlbGVtZW50XG5mdW5jdGlvbiBtYWtlRWwgKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IERPTUVsZW1lbnQobm9kZSwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgbGluZUhlaWdodDogJzEwMHB4JyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMThweCcsXG4gICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgICB9LFxuICAgICAgICBjbGFzc2VzOiBbJ25hdmlnYXRpb24nXVxuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYXZCdXR0b247IiwidmFyIGRhdGEgPSByZXF1aXJlKCcuL0RhdGEnKTtcbnZhciBOb2RlID0gcmVxdWlyZSgnZmFtb3VzL2NvcmUvTm9kZScpO1xudmFyIERPTUVsZW1lbnQgPSByZXF1aXJlKCdmYW1vdXMvZG9tLXJlbmRlcmFibGVzL0RPTUVsZW1lbnQnKTtcbnZhciBUd2VldCA9IHJlcXVpcmUoJy4vVHdlZXQnKTtcblxuZnVuY3Rpb24gU2VjdGlvbiAoaSkge1xuICAgIC8vIHN1YmNsYXNzIE5vZGVcbiAgICBOb2RlLmNhbGwodGhpcyk7XG5cbiAgICAvLyBjcmVhdGUgYW5kIHN0eWxlIGEgbmV3IERPTUVsZW1lbnRcbiAgICB0aGlzLmVsID0gbmV3IERPTUVsZW1lbnQodGhpcykuc2V0UHJvcGVydHkoJ292ZXJmbG93LXknLCAnc2Nyb2xsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0UHJvcGVydHkoJ292ZXJmbG93LXgnLCAnaGlkZGVuJyk7XG5cbiAgICAvLyBjcmVhdGUgdGhlIHR3ZWV0cyBpbiB0aGUgc2VjdGlvbi5cbiAgICB0aGlzLnR3ZWV0cyA9IGNyZWF0ZVR3ZWV0cy5jYWxsKHRoaXMsIGkpO1xufVxuXG5TZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVUd2VldHMgKGlkKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBudW1iZXJPZlR3ZWV0cyA9IGRhdGEuc2VjdGlvbnNbaWRdLnR3ZWV0TnVtYmVyO1xuICAgIHZhciB0d2VldDtcblxuICAgIC8vIGNyZWF0ZSBhbiBhcnJheSBvZiBsZW5ndGggZXF1YWwgdG8gdGhlIG51bWJlciBvZiB0d2VldHMgYW5kIHRoZW5cbiAgICAvLyBtYXAgb3ZlciBpdCB0byBjcmVhdGUgYW4gYXJyYXkgb2YgdHdlZXRzLlxuICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IG51bWJlck9mVHdlZXRzIDsgaSsrKSB7XG4gICAgICAgIC8vIHRoaXMgbm9kZSB3aWxsIGJlIDEwMHB4IHRhbGwgYW5kIHBvc2l0aW9uZWQgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICAvLyBpbiB0aGUgYXJyYXlcbiAgICAgICAgdHdlZXQgPSB0aGlzLmFkZENoaWxkKClcbiAgICAgICAgICAgICAgICAgICAgLnNldFNpemVNb2RlKCdkZWZhdWx0JywgJ2Fic29sdXRlJylcbiAgICAgICAgICAgICAgICAgICAgLnNldEFic29sdXRlU2l6ZShudWxsLCAxMDApXG4gICAgICAgICAgICAgICAgICAgIC5zZXRQb3NpdGlvbigwLCAxMDAgKiBpKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2hpbGQobmV3IFR3ZWV0KCkpO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKHR3ZWV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlY3Rpb247IiwidmFyIGRhdGEgPSByZXF1aXJlKCcuL0RhdGEnKTtcbnZhciBTZWN0aW9uID0gcmVxdWlyZSgnLi9TZWN0aW9uJyk7XG52YXIgTm9kZSA9IHJlcXVpcmUoJ2ZhbW91cy9jb3JlL05vZGUnKTtcbnZhciBBbGlnbiA9IHJlcXVpcmUoJ2ZhbW91cy9jb21wb25lbnRzL0FsaWduJyk7XG52YXIgRE9NRWxlbWVudCA9IHJlcXVpcmUoJ2ZhbW91cy9kb20tcmVuZGVyYWJsZXMvRE9NRWxlbWVudCcpO1xuXG4vLyBUaGUgc3dhcHBlciB3aWxsIGhvbGQgdGhlIHNlY3Rpb25zIGFuZCBzd2FwIGJldHdlZW4gdGhlbVxuLy8gb24gZXZlbnRzXG5mdW5jdGlvbiBTd2FwcGVyICgpIHtcbiAgICAvLyBzdWJjbGFzcyBOb2RlXG4gICAgTm9kZS5jYWxsKHRoaXMpO1xuXG4gICAgLy8gY3JlYXRlIGEgbmV3IGRvbSBlbGVtZW50IFxuICAgIHRoaXMuZWwgPSBuZXcgRE9NRWxlbWVudCh0aGlzKTtcblxuICAgIC8vIHN0b3JlIHRoZSBjdXJyZW50IHNlY3Rpb25cbiAgICB0aGlzLmN1cnJlbnRTZWN0aW9uID0gbnVsbDtcblxuICAgIC8vIGNyZWF0ZSB0aGUgc2VjdGlvbnNcbiAgICB0aGlzLnNlY3Rpb25zID0gY3JlYXRlU2VjdGlvbnMuY2FsbCh0aGlzKTtcbn1cblxuLy8gc3ViY2xhc3MgTm9kZVxuU3dhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlKTtcblxuU3dhcHBlci5wcm90b3R5cGUuY2hhbmdlU2VjdGlvbiA9IGZ1bmN0aW9uIGNoYW5nZVNlY3Rpb24gKHRvKSB7XG4gICAgLy8gU3dhcCBvdXQgYW55IHNlY3Rpb24gdGhhdCBpc24ndCB0aGUgbmV3IHNlY3Rpb25cbiAgICAvLyBhbmQgc3dhcCBpbiB0aGUgbmV3IHNlY3Rpb25cbiAgICBkYXRhLnNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlY3Rpb24uaWQgPT09IHRvKSBcbiAgICAgICAgICAgIC8vIDUwMCBtaWxsaXNlY29uZCB0cmFuc2l0aW9uXG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25zW3NlY3Rpb24uaWRdLmFsaWduLnNldCgwLCAwLCAwLCB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDUwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC8vIDEgaW4geCB3aWxsIHB1dCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBcbiAgICAgICAgICAgIC8vIHNlY3Rpb24gZGlyZWN0bHkgb2ZmIHRoZSBzY3JlZW5cbiAgICAgICAgICAgIHRoaXMuc2VjdGlvbnNbc2VjdGlvbi5pZF0uYWxpZ24uc2V0KDEsIDAsIDAsIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogNTAwXG4gICAgICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5jdXJyZW50U2VjdGlvbiA9IHRvO1xufTtcblxuLy8gb3ZlcndyaXRlIG9uUmVjZWl2ZSB0byBpbnRlcmNlcHQgZXZlbnRzIGluIHRoZSBzY2VuZSBncmFwaFxuU3dhcHBlci5wcm90b3R5cGUub25SZWNlaXZlID0gZnVuY3Rpb24gb25SZWNlaXZlIChldmVudCwgcGF5bG9hZCkge1xuICAgIGlmIChldmVudCA9PT0gJ2NoYW5nZVNlY3Rpb24nKSB0aGlzLmNoYW5nZVNlY3Rpb24ocGF5bG9hZC50byk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTZWN0aW9ucyAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGFsbCB0aGUgc2VjdGlvbnMgaW4gb3VyIGRhdGFcbiAgICBkYXRhLnNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNlY3Rpb24sIGkpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5hZGRDaGlsZCgpO1xuICAgICAgICByZXN1bHRbc2VjdGlvbi5pZF0gPSB7XG4gICAgICAgICAgICBhbGlnbjogbmV3IEFsaWduKGNoaWxkKSxcbiAgICAgICAgICAgIHNlY3Rpb246IGNoaWxkLmFkZENoaWxkKG5ldyBTZWN0aW9uKGkpKVxuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3dhcHBlcjsiLCJ2YXIgTm9kZSA9IHJlcXVpcmUoJ2ZhbW91cy9jb3JlL05vZGUnKTtcbnZhciBET01FbGVtZW50ID0gcmVxdWlyZSgnZmFtb3VzL2RvbS1yZW5kZXJhYmxlcy9ET01FbGVtZW50Jyk7XG52YXIgZGF0YSA9IHJlcXVpcmUoJy4vRGF0YScpO1xuXG4vLyBUaGUgdHdlZXQgY2xhc3MgdGhhdCB3aWxsIHJlbmRlciBhIHBhcnRpY3VsYXIgdHdlZXRcbmZ1bmN0aW9uIFR3ZWV0ICgpIHtcbiAgICAvLyBzdWJjbGFzcyBOb2RlXG4gICAgTm9kZS5jYWxsKHRoaXMpO1xuXG4gICAgLy8gY3JlYXRlIGEgbmV3IERPTUVsZW1lbnQgYW5kIHN0eWxlIGl0LlxuICAgIHRoaXMuZWwgPSBuZXcgRE9NRWxlbWVudCh0aGlzKS5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZENvbG9yJywgZ2V0UmFuZG9tQ29sb3IoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0UHJvcGVydHkoJ2JveFNpemluZycsICdib3JkZXItYm94JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0UHJvcGVydHkoJ2xpbmVIZWlnaHQnLCAnMTAwcHgnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRQcm9wZXJ0eSgnYm9yZGVyQm90dG9tJywgJzFweCBzb2xpZCBibGFjaycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldFByb3BlcnR5KCdmb250LXNpemUnLCAnMTJweCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldENvbnRlbnQoZ2V0UmFuZG9tTWVzc2FnZSgpKTtcbn1cblxuLy8gc3ViY2xhc3MgTm9kZVxuVHdlZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlLnByb3RvdHlwZSk7XG5cbi8vIFBpY2sgYSByYW5kb20gZWxlbWVudCBmcm9tIGFuIGFycmF5XG5mdW5jdGlvbiByYW5kb20gKGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5WyhNYXRoLnJhbmRvbSgpICogYXJyYXkubGVuZ3RoKXwwXTtcbn1cblxuLy8gY3JlYXRlIFJhbmRvbSBtZXNzYWdlXG5mdW5jdGlvbiBnZXRSYW5kb21NZXNzYWdlICgpIHtcbiAgICByZXR1cm4gJzxiPicgKyByYW5kb20oZGF0YS51c2VybmFtZXMpICtcbiAgICAgICAgICAgJzo8L2I+JyArIHJhbmRvbShkYXRhLmJlZ2luKSArIHJhbmRvbShkYXRhLm1pZGRsZSkgKyByYW5kb20oZGF0YS5lbmQpICtcbiAgICAgICAgICAgJyAnICsgcmFuZG9tKGRhdGEuaGFzaHRhZ3MpICsgJyAnICsgcmFuZG9tKGRhdGEuaGFzaHRhZ3MpO1xufVxuXG4vLyBDcmVhdGUgYSByYW5kb20gaGV4IGNvbG9yXG5mdW5jdGlvbiBnZXRSYW5kb21Db2xvcigpIHtcbiAgICAvLyB0cmljayB0byBjcmVhdGUgYSByYW5nZS5cbiAgICByZXR1cm4gJyMnICsgQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoNikpLm1hcChmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICByZXR1cm4gcmFuZG9tKCcwMTIzNDU2Nzg5QUJDREVGJyk7XG4gICAgfSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHdlZXQ7IiwidmFyIE5vZGUgPSByZXF1aXJlKCdmYW1vdXMvY29yZS9Ob2RlJyk7XG52YXIgZGF0YSA9IHJlcXVpcmUoJy4vRGF0YScpO1xudmFyIEhlYWRlciA9IHJlcXVpcmUoJy4vSGVhZGVyJyk7XG52YXIgRm9vdGVyID0gcmVxdWlyZSgnLi9Gb290ZXInKTtcbnZhciBTd2FwcGVyID0gcmVxdWlyZSgnLi9Td2FwcGVyJyk7XG5cbmZ1bmN0aW9uIFR3aXR0ZXJ1cyhtb3VudCkge1xuICAgIC8vIEV4dGVuZCBOb2RlXG4gICAgTm9kZS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5jdXJyZW50U2VjdGlvbiA9IGRhdGEuc2VjdGlvbnNbMF0uaWQ7XG5cbiAgICBtYWtlSGVhZGVyKHRoaXMpO1xuICAgIG1ha2VGb290ZXIodGhpcyk7XG4gICAgbWFrZVN3YXBwZXIodGhpcyk7XG59XG5cbi8vIEV4dGVuZCB0aGUgcHJvdG90eXBlXG5Ud2l0dGVydXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlLnByb3RvdHlwZSk7XG5cbi8vIE92ZXJ3cml0ZSBvbiBtb3VudCB0byBlbWl0IHRoZSBjaGFuZ2VTZWN0aW9uIGV2ZW50IHRoZSBtb21lbnRcbi8vIHR3aXR0ZXIgaXMgYWRkZWQgdG8gdGhlIHNjZW5lIGdyYXBoLlxuVHdpdHRlcnVzLnByb3RvdHlwZS5vbk1vdW50ID0gZnVuY3Rpb24gb25Nb3VudCAocGFyZW50LCBpZCkge1xuICAgdGhpcy5lbWl0KCdjaGFuZ2VTZWN0aW9uJywge2Zyb206IG51bGwsIHRvOiB0aGlzLmN1cnJlbnRTZWN0aW9ufSk7XG59O1xuXG4vLyBPdmVyd3JpdGUgdGhlIG9uUmVjZWl2ZSBtZXRob2QgdG8gaW50ZXJjZXB0IGV2ZW50cyBmbG93aW5nIHdpdGhpbiBcbi8vIHRoZSBzY2VuZSBncmFwaFxuVHdpdHRlcnVzLnByb3RvdHlwZS5vblJlY2VpdmUgPSBmdW5jdGlvbiBvblJlY2VpdmUgKGV2ZW50LCBwYXlsb2FkKSB7XG5cbiAgICAvLyBpZiB0aGUgZXZlbnQgaXMgY2xpY2sgdGhlbiB3ZSBrbm93XG4gICAgLy8gdGhhdCBhIE5hdkJ1dHRvbiB3YXMgY2xpY2tlZFxuICAgIC8vIChOYXZCdXR0b25zIGFyZSB0aGUgb25seSBlbGVtZW50KVxuICAgIC8vIFdpdGggdGhlIGNsaWNrIGV2ZW50LlxuICAgIGlmIChldmVudCA9PT0gJ2NsaWNrJykge1xuXG4gICAgICAgIC8vIGdldCB0aGUgaWQgb2YgdGhlIG5hdiBidXR0b25cbiAgICAgICAgdmFyIHRvID0gcGF5bG9hZC5ub2RlLmdldElkKCk7XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgY2hhbmdlU2VjdGlvbiBldmVudCB0byB0aGUgc3VidHJlZVxuICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZVNlY3Rpb24nLCB7XG4gICAgICAgICAgICBmcm9tOiB0aGlzLmN1cnJlbnRTZWN0aW9uLFxuICAgICAgICAgICAgdG86IHRvXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNldCB0aGUgY3VycmVudCBzZWN0aW9uXG4gICAgICAgIHRoaXMuY3VycmVudFNlY3Rpb24gPSB0bztcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBtYWtlSGVhZGVyKG5vZGUpIHtcbiAgICAvLyB0aGUgaGVhZGVyIHdpbGwgYmUgcG9zaXRpb25lZCBkZWZhdWx0bHlcbiAgICAvLyBhbG9uZyB0aGUgdG9wIG9mIGl0cyBwYXJlbnQuXG4gICAgLy8gSXQgd2lsbCBiZSB0aGUgY29tcGxldGUgd2lkdGggb2YgaXRzIHBhcmVudFxuICAgIC8vIGFuZCAxMDAgcGl4ZWxzIHRhbGwuXG4gICAgbm9kZS5hZGRDaGlsZCgpXG4gICAgICAgIC5zZXRTaXplTW9kZSgnZGVmYXVsdCcsICdhYnNvbHV0ZScpXG4gICAgICAgIC5zZXRBYnNvbHV0ZVNpemUobnVsbCwgMTAwKVxuICAgICAgICAuYWRkQ2hpbGQobmV3IEhlYWRlcigpKTtcbn1cblxuLy8gbWFrZSB0aGUgc3dhcHBlclxuZnVuY3Rpb24gbWFrZVN3YXBwZXIgKG5vZGUpIHtcbiAgICAvLyB0aGUgc3dhcHBlciB3aWxsIGJlIDIwMCBwaXhlbHMgc21hbGxlciB0aGFuXG4gICAgLy8gaXRzIHBhcmVudCBpbiBZIGFuZCBvdGhlcndpc2UgdGhlIHNhbWUgc2l6ZS5cbiAgICAvLyBJdCB3aWxsIGJlIHBvc2l0aW9uIDEwMCBwaXhlbHMgYmVsb3cgaXRzIHBhcmVudFxuICAgIC8vIHN1Y2ggdGhhdCBpdCBjbGVhcnMgdGhlIGhlYWRlclxuICAgIG5vZGUuYWRkQ2hpbGQoKVxuICAgICAgICAuc2V0RGlmZmVyZW50aWFsU2l6ZShudWxsLCAtMjAwLCBudWxsKVxuICAgICAgICAuc2V0UG9zaXRpb24oMCwgMTAwKVxuICAgICAgICAuYWRkQ2hpbGQobmV3IFN3YXBwZXIoKSk7XG59XG5cbi8vIG1ha2UgdGhlIGZvb3RlclxuZnVuY3Rpb24gbWFrZUZvb3RlciAobm9kZSkge1xuICAgIC8vIHRoZSBmb290ZXIgd2lsbCBiZSBhbGlnbmVkXG4gICAgLy8gdG8gdGhlIGJvdHRvbSBvZiBpdHMgcGFyZW50LlxuICAgIC8vIExpa2UgdGhlIGhlYWRlciBpdCB3aWxsIGJlXG4gICAgLy8gMTAwcHggdGFsbCBhbmQgdGhlIGNvbXBsZXRlIHdpZHRoLlxuICAgIC8vIG5vdGUgaG93IHdlIHVzZSBNb3VudFBvaW50IGFuZCBBbGlnblxuICAgIC8vIHRvZ2V0aGVyIHRvIGxpbmUgdXAgdGhlIGJvdHRvbSBvZiB0aGUgZm9vdGVyXG4gICAgLy8gd2l0aCB0aGUgYm90dG9tIG9mIHRoZSBwYXJlbnRcbiAgICBub2RlLmFkZENoaWxkKClcbiAgICAgICAgLnNldFNpemVNb2RlKCdkZWZhdWx0JywgJ2Fic29sdXRlJylcbiAgICAgICAgLnNldEFic29sdXRlU2l6ZShudWxsLCAxMDApXG4gICAgICAgIC5zZXRNb3VudFBvaW50KDAsIDEpXG4gICAgICAgIC5zZXRBbGlnbigwLCAxKVxuICAgICAgICAuYWRkQ2hpbGQobmV3IEZvb3RlcigpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUd2l0dGVydXM7XG4iLCJ2YXIgVHdpdHRlcnVzID0gcmVxdWlyZSgnLi9Ud2l0dGVydXMnKTtcbnZhciBGYW1vdXNFbmdpbmUgPSByZXF1aXJlKCdmYW1vdXMvY29yZS9GYW1vdXNFbmdpbmUnKTtcbiBGYW1vdXNFbmdpbmUuaW5pdCgpO1xuIC8vY3JlYXRlIHRoZSBhcHAgYW5kIHBhc3MgaW4gdGhlIHRhcmdldCBlbGVtZW50XG52YXIgdHdpdHRlcnVzID0gRmFtb3VzRW5naW5lLmNyZWF0ZVNjZW5lKCkuYWRkQ2hpbGQobmV3IFR3aXR0ZXJ1cygpKTtcbiJdfQ==
