(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
    components: require('famous-components'),
    core: require('famous-core'),
    engine: require('famous-engine'),
    domRenderables: require('famous-dom-renderables'),
    math: require('famous-math'),
    physics: require('famous-physics'),
    renderers: require('famous-renderers'),
    stylesheets: require('famous-stylesheets'),
    router: require('famous-router'),
    transitions: require('famous-transitions'),
    utilities: require('famous-utilities'),
    webglRenderables: require('famous-webgl-renderables'),
    webglGeometries: require('famous-webgl-geometries'),
    webglMaterials: require('famous-webgl-materials'),
    webglShaders: require('famous-webgl-shaders'),
    polyfills: require('famous-polyfills')
};

},{"famous-components":41,"famous-core":50,"famous-dom-renderables":69,"famous-engine":72,"famous-math":77,"famous-physics":126,"famous-polyfills":128,"famous-renderers":255,"famous-router":258,"famous-stylesheets":261,"famous-transitions":266,"famous-utilities":279,"famous-webgl-geometries":308,"famous-webgl-materials":322,"famous-webgl-renderables":361,"famous-webgl-shaders":367}],2:[function(require,module,exports){
'use strict';

/**
 * A 3x3 numerical matrix, represented as an array.
 *
 * @class Mat33
 * @constructor
 *
 * @param {Number[]} values
 */
function Mat33(values) {
    this.values = values || [1,0,0,0,1,0,0,0,1];

    return this;
}

/**
 * Return the values in the Mat33 as an array.
 *
 * @method get
 * @return {Number[]} matrix values as array of rows.
 */
Mat33.prototype.get = function get() {
    return this.values;
};

/**
 * Set the values of the current Mat33.
 *
 * @method set
 * @param {Number[]} values Array of nine numbers to set in the Mat33.
 * @chainable
 */
Mat33.prototype.set = function set(values) {
    this.values = values;
    return this;
};

/**
 * Copy the values of the input Mat33.
 *
 * @method copy
 * @param {Mat33} matrix The Mat33 to copy.
 * @chainable
 */
Mat33.prototype.copy = function copy(matrix) {
    var A = this.values;
    var B = matrix.values;

    A[0] = B[0];
    A[1] = B[1];
    A[2] = B[2];
    A[3] = B[3];
    A[4] = B[4];
    A[5] = B[5];
    A[6] = B[6];
    A[7] = B[7];
    A[8] = B[8];

    return this;
};

/**
 * Take this Mat33 as A, input vector V as a column vector, and return Mat33 product (A)(V).
 *
 * @method vectorMultiply
 * @param {Vec3} v Vector to rotate.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The input vector after multiplication.
 */
Mat33.prototype.vectorMultiply = function vectorMultiply(v, output) {
    var M = this.values;
    var v0 = v.x;
    var v1 = v.y;
    var v2 = v.z;

    output.x = M[0]*v0 + M[1]*v1 + M[2]*v2;
    output.y = M[3]*v0 + M[4]*v1 + M[5]*v2;
    output.z = M[6]*v0 + M[7]*v1 + M[8]*v2;

    return output;
};

/**
 * Multiply the provided Mat33 with the current Mat33.  Result is (this) * (matrix).
 *
 * @method multiply
 * @param {Mat33} matrix Input Mat33 to multiply on the right.
 * @chainable
 */
Mat33.prototype.multiply = function multiply(matrix) {
    var A = this.values;
    var B = matrix.values;

    var A0 = A[0];
    var A1 = A[1];
    var A2 = A[2];
    var A3 = A[3];
    var A4 = A[4];
    var A5 = A[5];
    var A6 = A[6];
    var A7 = A[7];
    var A8 = A[8];

    var B0 = B[0];
    var B1 = B[1];
    var B2 = B[2];
    var B3 = B[3];
    var B4 = B[4];
    var B5 = B[5];
    var B6 = B[6];
    var B7 = B[7];
    var B8 = B[8];

    A[0] = A0*B0 + A1*B3 + A2*B6;
    A[1] = A0*B1 + A1*B4 + A2*B7;
    A[2] = A0*B2 + A1*B5 + A2*B8;
    A[3] = A3*B0 + A4*B3 + A5*B6;
    A[4] = A3*B1 + A4*B4 + A5*B7;
    A[5] = A3*B2 + A4*B5 + A5*B8;
    A[6] = A6*B0 + A7*B3 + A8*B6;
    A[7] = A6*B1 + A7*B4 + A8*B7;
    A[8] = A6*B2 + A7*B5 + A8*B8;

    return this;
};

/**
 * Transposes the Mat33.
 *
 * @method transpose
 * @chainable
 */
Mat33.prototype.transpose = function transpose() {
    var M = this.values;

    var M1 = M[1];
    var M2 = M[2];
    var M3 = M[3];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];

    M[1] = M3;
    M[2] = M6;
    M[3] = M1;
    M[5] = M7;
    M[6] = M2;
    M[7] = M5;

    return this;
};

/**
 * The determinant of the Mat33.
 *
 * @method getDeterminant
 * @return {Number} The determinant.
 */
Mat33.prototype.getDeterminant = function getDeterminant() {
    var M = this.values;

    var M3 = M[3];
    var M4 = M[4];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];
    var M8 = M[8];

    var det = M[0]*(M4*M8 - M5*M7)
            - M[1]*(M3*M8 - M5*M6)
            + M[2]*(M3*M7 - M4*M6);

    return det;
};

/**
 * The inverse of the Mat33.
 *
 * @method inverse
 * @chainable
 */
Mat33.prototype.inverse = function inverse() {
    var M = this.values;

    var M0 = M[0];
    var M1 = M[1];
    var M2 = M[2];
    var M3 = M[3];
    var M4 = M[4];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];
    var M8 = M[8];

    var det = M0*(M4*M8 - M5*M7)
            - M1*(M3*M8 - M5*M6)
            + M2*(M3*M7 - M4*M6);

    if (Math.abs(det) < 1e-40) return null;

    det = 1 / det;

    M[0] = (M4*M8 - M5*M7) * det;
    M[3] = (-M3*M8 + M5*M6) * det;
    M[6] = (M3*M7 - M4*M6) * det;
    M[1] = (-M1*M8 + M2*M7) * det;
    M[4] = (M0*M8 - M2*M6) * det;
    M[7] = (-M0*M7 + M1*M6) * det;
    M[2] = (M1*M5 - M2*M4) * det;
    M[5] = (-M0*M5 + M2*M3) * det;
    M[8] = (M0*M4 - M1*M3) * det;

    return this;
};

/**
 * Clones the input Mat33.
 *
 * @method clone
 * @param {Mat33} m Mat33 to clone.
 * @return {Mat33} New copy of the original Mat33.
 */
Mat33.clone = function clone(m) {
    return new Mat33(m.values.slice());
};

/**
 * The inverse of the Mat33.
 *
 * @method inverse
 * @param {Mat33} matrix Mat33 to invert.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} The Mat33 after the invert.
 */
Mat33.inverse = function inverse(matrix, output) {
    var M = matrix.values;
    var result = output.values;

    var M0 = M[0];
    var M1 = M[1];
    var M2 = M[2];
    var M3 = M[3];
    var M4 = M[4];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];
    var M8 = M[8];

    var det = M0*(M4*M8 - M5*M7)
            - M1*(M3*M8 - M5*M6)
            + M2*(M3*M7 - M4*M6);

    if (Math.abs(det) < 1e-40) return null;

    det = 1 / det;

    result[0] = (M4*M8 - M5*M7) * det;
    result[3] = (-M3*M8 + M5*M6) * det;
    result[6] = (M3*M7 - M4*M6) * det;
    result[1] = (-M1*M8 + M2*M7) * det;
    result[4] = (M0*M8 - M2*M6) * det;
    result[7] = (-M0*M7 + M1*M6) * det;
    result[2] = (M1*M5 - M2*M4) * det;
    result[5] = (-M0*M5 + M2*M3) * det;
    result[8] = (M0*M4 - M1*M3) * det;

    return output;
};

/**
 * Transposes the Mat33.
 *
 * @method transpose
 * @param {Mat33} matrix Mat33 to transpose.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} The Mat33 after the transpose.
 */
Mat33.transpose = function transpose(matrix, output) {
    var M = matrix.values;
    var result = output.values;

    var M0 = M[0];
    var M1 = M[1];
    var M2 = M[2];
    var M3 = M[3];
    var M4 = M[4];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];
    var M8 = M[8];

    result[0] = M0;
    result[1] = M3;
    result[2] = M6;
    result[3] = M1;
    result[4] = M4;
    result[5] = M7;
    result[6] = M2;
    result[7] = M5;
    result[8] = M8;

    return output;
};

/**
 * Add the provided Mat33's.
 *
 * @method add
 * @param {Mat33} matrix1 The left Mat33.
 * @param {Mat33} matrix2 The right Mat33.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} The result of the addition.
 */
Mat33.add = function add(matrix1, matrix2, output) {
    var A = matrix1.values;
    var B = matrix2.values;
    var result = output.values;

    var A0 = A[0];
    var A1 = A[1];
    var A2 = A[2];
    var A3 = A[3];
    var A4 = A[4];
    var A5 = A[5];
    var A6 = A[6];
    var A7 = A[7];
    var A8 = A[8];

    var B0 = B[0];
    var B1 = B[1];
    var B2 = B[2];
    var B3 = B[3];
    var B4 = B[4];
    var B5 = B[5];
    var B6 = B[6];
    var B7 = B[7];
    var B8 = B[8];

    result[0] = A0 + B0;
    result[1] = A1 + B1;
    result[2] = A2 + B2;
    result[3] = A3 + B3;
    result[4] = A4 + B4;
    result[5] = A5 + B5;
    result[6] = A6 + B6;
    result[7] = A7 + B7;
    result[8] = A8 + B8;

    return output;
};

/**
 * Subtract the provided Mat33's.
 *
 * @method subtract
 * @param {Mat33} matrix1 The left Mat33.
 * @param {Mat33} matrix2 The right Mat33.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} The result of the subtraction.
 */
Mat33.subtract = function subtract(matrix1, matrix2, output) {
    var A = matrix1.values;
    var B = matrix2.values;
    var result = output.values;

    var A0 = A[0];
    var A1 = A[1];
    var A2 = A[2];
    var A3 = A[3];
    var A4 = A[4];
    var A5 = A[5];
    var A6 = A[6];
    var A7 = A[7];
    var A8 = A[8];

    var B0 = B[0];
    var B1 = B[1];
    var B2 = B[2];
    var B3 = B[3];
    var B4 = B[4];
    var B5 = B[5];
    var B6 = B[6];
    var B7 = B[7];
    var B8 = B[8];

    result[0] = A0 - B0;
    result[1] = A1 - B1;
    result[2] = A2 - B2;
    result[3] = A3 - B3;
    result[4] = A4 - B4;
    result[5] = A5 - B5;
    result[6] = A6 - B6;
    result[7] = A7 - B7;
    result[8] = A8 - B8;

    return output;
};
/**
 * Multiply the provided Mat33 M2 with this Mat33.  Result is (this) * (M2).
 *
 * @method multiply
 * @param {Mat33} matrix1 The left Mat33.
 * @param {Mat33} matrix2 The right Mat33.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} the result of the multiplication.
 */
Mat33.multiply = function multiply(matrix1, matrix2, output) {
    var A = matrix1.values;
    var B = matrix2.values;
    var result = output.values;

    var A0 = A[0];
    var A1 = A[1];
    var A2 = A[2];
    var A3 = A[3];
    var A4 = A[4];
    var A5 = A[5];
    var A6 = A[6];
    var A7 = A[7];
    var A8 = A[8];

    var B0 = B[0];
    var B1 = B[1];
    var B2 = B[2];
    var B3 = B[3];
    var B4 = B[4];
    var B5 = B[5];
    var B6 = B[6];
    var B7 = B[7];
    var B8 = B[8];

    result[0] = A0*B0 + A1*B3 + A2*B6;
    result[1] = A0*B1 + A1*B4 + A2*B7;
    result[2] = A0*B2 + A1*B5 + A2*B8;
    result[3] = A3*B0 + A4*B3 + A5*B6;
    result[4] = A3*B1 + A4*B4 + A5*B7;
    result[5] = A3*B2 + A4*B5 + A5*B8;
    result[6] = A6*B0 + A7*B3 + A8*B6;
    result[7] = A6*B1 + A7*B4 + A8*B7;
    result[8] = A6*B2 + A7*B5 + A8*B8;

    return output;
};

module.exports = Mat33;

},{}],3:[function(require,module,exports){
'use strict';

var Matrix = require('./Mat33');

var sin = Math.sin;
var cos = Math.cos;
var asin = Math.asin;
var acos = Math.acos;
var atan2 = Math.atan2;
var sqrt = Math.sqrt;

/**
 * A vector-like object used to represent rotations. If theta is the angle of
 * rotation, and (x', y', z') is a normalized vector representing the axis of
 * rotation, then w = cos(theta/2), x = sin(theta/2)*x', y = sin(theta/2)*y',
 * and z = sin(theta/2)*z'.
 *
 * @class Quaternion
 * @param {Number} w The w component.
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 */
function Quaternion(w, x, y, z) {
    this.w = w || 1;
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
}

/**
 * Multiply the current Quaternion by input Quaternion q.
 * Left-handed multiplication.
 *
 * @method multiply
 * @param {Quaternion} q The Quaternion to multiply by on the right.
 */
Quaternion.prototype.multiply = function multiply(q) {
    var x1 = this.x;
    var y1 = this.y;
    var z1 = this.z;
    var w1 = this.w;
    var x2 = q.x;
    var y2 = q.y;
    var z2 = q.z;
    var w2 = q.w || 0;

    this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
    this.x = x1 * w2 + x2 * w1 + y2 * z1 - y1 * z2;
    this.y = y1 * w2 + y2 * w1 + x1 * z2 - x2 * z1;
    this.z = z1 * w2 + z2 * w1 + x2 * y1 - x1 * y2;
    return this;
};

/**
 * Multiply the current Quaternion by input Quaternion q on the left, i.e. q * this.
 * Left-handed multiplication.
 *
 * @method leftMultiply
 * @param {Quaternion} q The Quaternion to multiply by on the left.
 */
Quaternion.prototype.leftMultiply = function leftMultiply(q) {
    var x1 = q.x;
    var y1 = q.y;
    var z1 = q.z;
    var w1 = q.w || 0;
    var x2 = this.x;
    var y2 = this.y;
    var z2 = this.z;
    var w2 = this.w;

    this.w = w1*w2 - x1*x2 - y1*y2 - z1*z2;
    this.x = x1*w2 + x2*w1 + y2*z1 - y1*z2;
    this.y = y1*w2 + y2*w1 + x1*z2 - x2*z1;
    this.z = z1*w2 + z2*w1 + x2*y1 - x1*y2;
    return this;
};

/**
 * Apply the current Quaternion to input Vec3 v, according to
 * v' = ~q * v * q.
 *
 * @method rotateVector
 * @param {Vec3} v The reference Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The rotated version of the Vec3.
 */
Quaternion.prototype.rotateVector = function rotateVector(v, output) {
    var cw = this.w;
    var cx = -this.x;
    var cy = -this.y;
    var cz = -this.z;

    var vx = v.x;
    var vy = v.y;
    var vz = v.z;

    var tw = -cx * vx - cy * vy - cz * vz;
    var tx = vx * cw + vy * cz - cy * vz;
    var ty = vy * cw + cx * vz - vx * cz;
    var tz = vz * cw + vx * cy - cx * vy;

    var w = cw;
    var x = -cx;
    var y = -cy;
    var z = -cz;

    output.x = tx * w + x * tw + y * tz - ty * z;
    output.y = ty * w + y * tw + tx * z - x * tz;
    output.z = tz * w + z * tw + x * ty - tx * y;
    return output;
};

/**
 * Invert the current Quaternion.
 *
 * @method invert
 * @chainable
 */
Quaternion.prototype.invert = function invert() {
    this.w = -this.w;
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
};

/**
 * Conjugate the current Quaternion.
 *
 * @method conjugate
 * @chainable
 */
Quaternion.prototype.conjugate = function conjugate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
};

/**
 * Compute the length (norm) of the current Quaternion.
 *
 * @method length
 * @return {Number}
 */
Quaternion.prototype.length = function length() {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;
    return sqrt(w * w + x * x + y * y + z * z);
};

/**
 * Alter the current Quaternion to be of unit length;
 *
 * @method normalize
 * @chainable
 */
Quaternion.prototype.normalize = function normalize() {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;
    var length = sqrt(w * w + x * x + y * y + z * z);
    if (length === 0) return;
    length = 1 / length;
    this.w *= length;
    this.x *= length;
    this.y *= length;
    this.z *= length;
    return this;
};

/**
 * Set the w, x, y, z components of the current Quaternion.
 *
 * @method set
 * @param {Number} w The w component.
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 * @chainable
 */
Quaternion.prototype.set = function set(w, x ,y, z) {
    if (w != null) this.w = w;
    if (x != null) this.x = x;
    if (y != null) this.y = y;
    if (z != null) this.z = z;
    return this;
};

/**
 * Copy input Quaternion q onto the current Quaternion.
 *
 * @method copy
 * @param {Quaternion} q The reference Quaternion.
 * @chainable
 */
Quaternion.prototype.copy = function copy(q) {
    this.w = q.w;
    this.x = q.x;
    this.y = q.y;
    this.z = q.z;
    return this;
};

/**
 * Reset the current Quaternion.
 *
 * @method clear
 * @chainable
 */
Quaternion.prototype.clear = function clear() {
    this.w = 1;
    this.x = 0;
    this.y = 0;
    this.z = 0;
    return this;
};

/**
 * The dot product. Can be used to determine the cosine of the angle between
 * the two rotations, assuming both Quaternions are of unit length.
 *
 * @method dot
 * @param {Quaternion} q The other Quaternion.
 * @return {Number}
 */
Quaternion.prototype.dot = function dot(q) {
    return this.w * q.w + this.x * q.x + this.y * q.y + this.z * q.z;
};

/**
 * Spherical linear interpolation.
 *
 * @method slerp
 * @param {Quaternion} q The final orientation.
 * @param {Number} t The tween parameter.
 * @param {Vec3} output Vec3 in which to put the result.
 * @return {Quaternion}
 */
Quaternion.prototype.slerp = function slerp(q, t, output) {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qw = q.w;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;

    var omega;
    var cosomega;
    var sinomega;
    var scaleFrom;
    var scaleTo;

    cosomega = w * qw + x * qx + y * qy + z * qz;
    if ((1.0 - cosomega) > 1e-5) {
        omega = acos(cosomega);
        sinomega = sin(omega);
        scaleFrom = sin((1.0 - t) * omega) / sinomega;
        scaleTo = sin(t * omega) / sinomega;
    }
    else {
        scaleFrom = 1.0 - t;
        scaleTo = t;
    }

    output.w = w * scaleFrom + qw * scaleTo;
    output.x = x * scaleFrom + qx * scaleTo;
    output.y = y * scaleFrom + qy * scaleTo;
    output.z = z * scaleFrom + qz * scaleTo;

    return output;
};

/**
 * Get the Mat33 matrix corresponding to the current Quaternion.
 *
 * @method toMatrix
 * @return {Transform}
 */
Quaternion.prototype.toMatrix = function toMatrix(output) {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var xx = x*x;
    var yy = y*y;
    var zz = z*z;
    var xy = x*y;
    var xz = x*z;
    var yz = y*z;

    return output.set([
        1 - 2 * (yy + zz), 2 * (xy - w*z), 2 * (xz + w*y),
        2 * (xy + w*z), 1 - 2 * (xx + zz), 2 * (yz - w*x),
        2 * (xz - w*y), 2 * (yz + w*x), 1 - 2 * (xx + yy)
    ]);
};

/**
 * The rotation angles about the x, y, and z axes corresponding to the
 * current Quaternion, when applied in the ZYX order.
 *
 * @method toEuler
 * @param {Vec3} output Vec3 in which to put the result.
 * @return {Vec3}
 */

Quaternion.prototype.toEuler = function toEuler(output) {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var xx = x * x;
    var yy = y * y;
    var zz = z * z;
    var ww = w * w;

    var ty = 2 * (x * z + y * w);
    ty = ty < -1 ? -1 : ty > 1 ? 1 : ty;

    output.x = atan2(2 * (x * w - y * z), 1 - 2 * (xx + yy));
    output.y = asin(ty);
    output.z = atan2(2 * (z * w - x * y), 1 - 2 * (yy + zz));

    return output;
};

/**
 * The Quaternion corresponding to the Euler angles x, y, and z,
 * applied in the ZYX order.
 *
 * @method fromEuler
 * @param {Number} x The angle of rotation about the x axis.
 * @param {Number} y The angle of rotation about the y axis.
 * @param {Number} z The angle of rotation about the z axis.
 * @param {Quaternion} output Quaternion in which to put the result.
 * @return {Quaternion} The equivalent Quaternion.
 */
Quaternion.prototype.fromEuler = function fromEuler(x, y, z) {
    var hx = x * 0.5;
    var hy = y * 0.5;
    var hz = z * 0.5;

    var sx = sin(hx);
    var sy = sin(hy);
    var sz = sin(hz);
    var cx = cos(hx);
    var cy = cos(hy);
    var cz = cos(hz);

    this.w = cx * cy * cz - sx * sy * sz;
    this.x = sx * cy * cz + cx * sy * sz;
    this.y = cx * sy * cz - sx * cy * sz;
    this.z = cx * cy * sz + sx * sy * cz;

    return this;
};

/**
 * Alter the current Quaternion to reflect a rotation of input angle about
 * input axis v.
 *
 * @method makeFromAngleAndAxis
 * @param {Number} angle The angle of rotation.
 * @param {Vec3} v The axis of rotation.
 * @chainable
 */
Quaternion.prototype.fromAngleAxis = function fromAngleAxis(angle, x, y, z) {
    var len = sqrt(x * x + y * y + z * z);
    if (len === 0) {
        this.w = 1;
        this.x = this.y = this.z = 0;
    }
    else {
        len = 1 / len;
        var halfTheta = angle * 0.5;
        var s = sin(halfTheta);
        this.w = cos(halfTheta);
        this.x = s * x * len;
        this.y = s * y * len;
        this.z = s * z * len;
    }
    return this;
};

/**
 * Multiply the input Quaternions.
 * Left-handed coordinate system multiplication.
 *
 * @method multiply
 * @param {Quaternion} q1 The left Quaternion.
 * @param {Quaternion} q2 The right Quaternion.
 * @param {Quaternion} output Quaternion in which to place the result.
 * @return {Quaternion} The product of multiplication.
 */
Quaternion.multiply = function multiply(q1, q2, output) {
    var w1 = q1.w || 0;
    var x1 = q1.x;
    var y1 = q1.y;
    var z1 = q1.z;

    var w2 = q2.w || 0;
    var x2 = q2.x;
    var y2 = q2.y;
    var z2 = q2.z;

    output.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
    output.x = x1 * w2 + x2 * w1 + y2 * z1 - y1 * z2;
    output.y = y1 * w2 + y2 * w1 + x1 * z2 - x2 * z1;
    output.z = z1 * w2 + z2 * w1 + x2 * y1 - x1 * y2;
    return output;
};

/**
 * Normalize the input quaternion.
 *
 * @method normalize
 * @return {Quaternion} The normalized quaternion.
 */
Quaternion.normalize = function normalize(q, output) {
    var w = q.w;
    var x = q.x;
    var y = q.y;
    var z = q.z;
    var length = sqrt(w * w + x * x + y * y + z * z);
    if (length === 0) return;
    length = 1 / length;
    output.w *= length;
    output.x *= length;
    output.y *= length;
    output.z *= length;
    return output;
};

/**
 * The conjugate of the input Quaternion.
 *
 * @method conjugate
 * @param {Quaternion} q The reference Quaternion.
 * @param {Quaternion} output Quaternion in which to place the result.
 * @return {Quaternion} The conjugate Quaternion.
 */
Quaternion.conjugate = function conjugate(q, output) {
    output.w = q.w;
    output.x = -q.x;
    output.y = -q.y;
    output.z = -q.z;
    return output;
};

/**
 * Clone the input Quaternion.
 *
 * @method clone
 * @param {Quaternion} q the reference Quaternion.
 * @return {Quaternion} The cloned Quaternion.
 */
Quaternion.clone = function clone(q) {
    return new Quaternion(q.w, q.x, q.y, q.z);
};

/**
 * The dot product of the two input Quaternions.
 *
 * @method dotProduct
 * @param {Quaternion} q1 The left Quaternion.
 * @param {Quaternion} q2 The right Quaternion.
 * @return {Number} The dot product of the two Quaternions.
 */
Quaternion.dot = function dot(q1, q2) {
    return q1.w * q2.w + q1.x * q2.x + q1.y * q2.y + q1.z * q2.z;
};

module.exports = Quaternion;

},{"./Mat33":2}],4:[function(require,module,exports){
'use strict';

var sin = Math.sin;
var cos = Math.cos;
var sqrt = Math.sqrt;

/**
 * A two-dimensional vector.
 *
 * @class Vec2
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 */
var Vec2 = function(x, y){
    if (x instanceof Array || x instanceof Float32Array) {
        this.x = x[0] || 0;
        this.y = x[1] || 0;
    }
    else {
        this.x = x || 0;
        this.y = y || 0;
    }
};

/**
 * Set the components of the current Vec2.
 *
 * @method set
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @chainable
 */
Vec2.prototype.set = function set(x, y) {
    if (x != null) this.x = x;
    if (y != null) this.y = y;
    return this;
};

/**
 * Add the input v to the current Vec2.
 *
 * @method add
 * @param {Vec2} v The Vec2 to add.
 * @chainable
 */
Vec2.prototype.add = function add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
};

/**
 * Subtract the input v from the current Vec2.
 *
 * @method subtract
 * @param {Vec2} v The Vec2 to subtract.
 * @chainable
 */
Vec2.prototype.subtract = function subtract(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
};

/**
 * Scale the current Vec2 by a scalar or Vec2.
 *
 * @method scale
 * @param {Number|Vec2} s The Number or vec2 by which to scale.
 * @chainable
 */
Vec2.prototype.scale = function scale(s) {
    if (s instanceof Vec2) {
        this.x *= s.x;
        this.y *= s.y;
    } else {
        this.x *= s;
        this.y *= s;
    }
    return this;
};

/**
 * Rotate the Vec2 counter-clockwise by theta about the z-axis.
 *
 * @method rotate
 * @param {Number} theta Angle by which to rotate.
 * @chainable
 */
Vec2.prototype.rotate = function(theta) {
    var x = this.x;
    var y = this.y;

    var cosTheta = cos(theta);
    var sinTheta = sin(theta);

    this.x = x * cosTheta - y * sinTheta;
    this.y = x * sinTheta + y * cosTheta;

    return this;
};

/**
 * The dot product of of the current Vec2 with the input Vec2.
 *
 * @method dot
 * @param {Number} v The other Vec2.
 * @chainable
 */
Vec2.prototype.dot = function(v) {
    return this.x * v.x + this.y * v.y;
};

/**
 * The cross product of of the current Vec2 with the input Vec2.
 *
 * @method cross
 * @param {Number} v The other Vec2.
 * @chainable
 */
Vec2.prototype.cross = function(v) {
    return this.x * v.y - this.y * v.x;
};

/**
 * Preserve the magnitude but invert the orientation of the current Vec2.
 *
 * @method invert
 * @chainable
 */
Vec2.prototype.invert = function invert() {
    this.x *= -1;
    this.y *= -1;
    return this;
};

/**
 * Apply a function component-wise to the current Vec2.
 *
 * @method map
 * @param {Function} fn Function to apply.
 * @chainable
 */
Vec2.prototype.map = function map(fn) {
    this.x = fn(this.x);
    this.y = fn(this.y);
    return this;
};

/**
 * The magnitude of the current Vec2.
 *
 * @method length
 * @return {Number}
 */
Vec2.prototype.length = function length() {
    var x = this.x;
    var y = this.y;

    return sqrt(x * x + y * y);
};

/**
 * Copy the input onto the current Vec2.
 *
 * @method copy
 * @param {Vec2} v Vec2 to copy.
 * @chainable
 */
Vec2.prototype.copy = function copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
};

/**
 * Reset the current Vec2.
 *
 * @method clear
 * @chainable
 */
Vec2.prototype.clear = function clear() {
    this.x = 0;
    this.y = 0;
    return this;
};

/**
 * Check whether the magnitude of the current Vec2 is exactly 0.
 *
 * @method isZero
 * @return {Boolean}
 */
Vec2.prototype.isZero = function isZero() {
    if (this.x !== 0 || this.y !== 0) return false;
    else return true;
};

/**
 * The array form of the current Vec2.
 *
 * @method toArray
 * @return {Number[]}
 */
Vec2.prototype.toArray = function toArray() {
    return [this.x, this.y];
};

/**
 * Normalize the input Vec2.
 *
 * @method normalize
 * @param {Vec2} v The reference Vec2.
 * @param {Vec2} output Vec2 in which to place the result.
 * @return {Vec2} The normalize Vec2.
 */
Vec2.normalize = function normalize(v, output) {
    var x = v.x;
    var y = v.y;

    var length = sqrt(x * x + y * y) || 1;
    length = 1 / length;
    output.x = v.x * length;
    output.y = v.y * length;

    return output;
};

/**
 * Clone the input Vec2.
 *
 * @method clone
 * @param {Vec2} v The Vec2 to clone.
 * @return {Vec2} The cloned Vec2.
 */
Vec2.clone = function clone(v) {
    return new Vec2(v.x, v.y);
};

/**
 * Add the input Vec2's.
 *
 * @method add
 * @param {Vec2} v1 The left Vec2.
 * @param {Vec2} v2 The right Vec2.
 * @param {Vec2} output Vec2 in which to place the result.
 * @return {Vec2} The result of the addition.
 */
Vec2.add = function add(v1, v2, output) {
    output.x = v1.x + v2.x;
    output.y = v1.y + v2.y;

    return output;
};

/**
 * Subtract the second Vec2 from the first.
 *
 * @method subtract
 * @param {Vec2} v1 The left Vec2.
 * @param {Vec2} v2 The right Vec2.
 * @param {Vec2} output Vec2 in which to place the result.
 * @return {Vec2} The result of the subtraction.
 */
Vec2.subtract = function subtract(v1, v2, output) {
    output.x = v1.x - v2.x;
    output.y = v1.y - v2.y;
    return output;
};

/**
 * Scale the input Vec2.
 *
 * @method scale
 * @param {Vec2} v The reference Vec2.
 * @param {Number} s Number to scale by.
 * @param {Vec2} output Vec2 in which to place the result.
 * @return {Vec2} The result of the scaling.
 */
Vec2.scale = function scale(v, s, output) {
    output.x = v.x * s;
    output.y = v.y * s;
    return output;
};

/**
 * The dot product of the input Vec2's.
 *
 * @method dot
 * @param {Vec2} v1 The left Vec2.
 * @param {Vec2} v2 The right Vec2.
 * @return {Number} The dot product.
 */
Vec2.dot = function dot(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y;
};

/**
 * The cross product of the input Vec2's.
 *
 * @method cross
 * @param {Number} v The left Vec2.
 * @param {Number} v The right Vec2.
 * @return {Number} The z-component of the cross product.
 */
Vec2.cross = function(v1,v2) {
    return v1.x * v2.y - v1.y * v2.x;
};

module.exports = Vec2;

},{}],5:[function(require,module,exports){
'use strict';

var sin = Math.sin;
var cos = Math.cos;
var sqrt = Math.sqrt;

/**
 * A three-dimensional vector.
 *
 * @class Vec3
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 */
var Vec3 = function(x ,y, z){
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
};

/**
 * Set the components of the current Vec3.
 *
 * @method set
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 * @chainable
 */
Vec3.prototype.set = function set(x, y, z) {
    if (x != null) this.x = x;
    if (y != null) this.y = y;
    if (z != null) this.z = z;

    return this;
};

/**
 * Add the input v to the current Vec3.
 *
 * @method add
 * @param {Vec3} v The Vec3 to add.
 * @chainable
 */
Vec3.prototype.add = function add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;

    return this;
};

/**
 * Subtract the input v from the current Vec3.
 *
 * @method subtract
 * @param {Vec3} v The Vec3 to subtract.
 * @chainable
 */
Vec3.prototype.subtract = function subtract(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;

    return this;
};

/**
 * Rotate the current Vec3 by theta clockwise about the x axis.
 *
 * @method rotateX
 * @param {Number} theta Angle by which to rotate.
 * @chainable
 */
Vec3.prototype.rotateX = function rotateX(theta) {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var cosTheta = cos(theta);
    var sinTheta = sin(theta);

    this.y = y * cosTheta - z * sinTheta;
    this.z = y * sinTheta + z * cosTheta;

    return this;
};

/**
 * Rotate the current Vec3 by theta clockwise about the y axis.
 *
 * @method rotateY
 * @param {Number} theta Angle by which to rotate.
 * @chainable
 */
Vec3.prototype.rotateY = function rotateY(theta) {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var cosTheta = cos(theta);
    var sinTheta = sin(theta);

    this.x = z * sinTheta + x * cosTheta;
    this.z = z * cosTheta - x * sinTheta;

    return this;
};

/**
 * Rotate the current Vec3 by theta clockwise about the z axis.
 *
 * @method rotateZ
 * @param {Number} theta Angle by which to rotate.
 * @chainable
 */
Vec3.prototype.rotateZ = function rotateZ(theta) {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var cosTheta = cos(theta);
    var sinTheta = sin(theta);

    this.x = x * cosTheta - y * sinTheta;
    this.y = x * sinTheta + y * cosTheta;

    return this;
};

/**
 * The dot product of the current Vec3 with input Vec3 v.
 *
 * @method dot
 * @param {Vec3} v The other Vec3.
 * @return {Number}
 */
Vec3.prototype.dot = function dot(v) {
    return this.x*v.x + this.y*v.y + this.z*v.z;
};

/**
 * The dot product of the current Vec3 with input Vec3 v.
 * Stores the result in the current Vec3.
 *
 * @method cross
 * @param {Vec3} v The other Vec3.
 * @chainable
 */
Vec3.prototype.cross = function cross(v) {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var vx = v.x;
    var vy = v.y;
    var vz = v.z;

    this.x = y * vz - z * vy;
    this.y = z * vx - x * vz;
    this.z = x * vy - y * vx;
    return this;
};

/**
 * Scale the current Vec3 by a scalar.
 *
 * @method scale
 * @param {Number} s The Number by which to scale.
 * @chainable
 */
Vec3.prototype.scale = function scale(s) {
    this.x *= s;
    this.y *= s;
    this.z *= s;

    return this;
};

/**
 * Preserve the magnitude but invert the orientation of the current Vec3.
 *
 * @method invert
 * @chainable
 */
Vec3.prototype.invert = function invert() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;

    return this;
};

/**
 * Apply a function component-wise to the current Vec3.
 *
 * @method map
 * @param {Function} fn Function to apply.
 * @chainable
 */
Vec3.prototype.map = function map(fn) {
    this.x = fn(this.x);
    this.y = fn(this.y);
    this.z = fn(this.z);

    return this;
};

/**
 * The magnitude of the current Vec3.
 *
 * @method length
 * @return {Number}
 */
Vec3.prototype.length = function length() {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    return sqrt(x * x + y * y + z * z);
};

/**
 * The magnitude squared of the current Vec3.
 *
 * @method length
 * @return {Number}
 */
Vec3.prototype.lengthSq = function lengthSq() {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    return x * x + y * y + z * z;
};

/**
 * Copy the input onto the current Vec3.
 *
 * @method copy
 * @param {Vec3} v Vec3 to copy.
 * @chainable
 */
Vec3.prototype.copy = function copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
};

/**
 * Reset the current Vec3.
 *
 * @method clear
 * @chainable
 */
Vec3.prototype.clear = function clear() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    return this;
};

/**
 * Check whether the magnitude of the current Vec3 is exactly 0.
 *
 * @method isZero
 * @return {Boolean}
 */
Vec3.prototype.isZero = function isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
};

/**
 * The array form of the current Vec3.
 *
 * @method toArray
 * @return {Number[]}
 */
Vec3.prototype.toArray = function toArray() {
    return [this.x, this.y, this.z];
};

/**
 * Preserve the orientation but change the length of the current Vec3 to 1.
 *
 * @method normalize
 * @chainable
 */
Vec3.prototype.normalize = function normalize() {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var len = sqrt(x * x + y * y + z * z) || 1;
    len = 1 / len;

    this.x *= len;
    this.y *= len;
    this.z *= len;
    return this;
};

/**
 * Apply the rotation corresponding to the input (unit) Quaternion
 * to the current Vec3.
 *
 * @method applyRotation
 * @param {Quaternion} q Unit Quaternion representing the rotation to apply.
 * @chainable
 */
Vec3.prototype.applyRotation = function applyRotation(q) {
    var cw = q.w;
    var cx = -q.x;
    var cy = -q.y;
    var cz = -q.z;

    var vx = this.x;
    var vy = this.y;
    var vz = this.z;

    var tw = -cx * vx - cy * vy - cz * vz;
    var tx = vx * cw + vy * cz - cy * vz;
    var ty = vy * cw + cx * vz - vx * cz;
    var tz = vz * cw + vx * cy - cx * vy;

    var w = cw;
    var x = -cx;
    var y = -cy;
    var z = -cz;

    this.x = tx * w + x * tw + y * tz - ty * z;
    this.y = ty * w + y * tw + tx * z - x * tz;
    this.z = tz * w + z * tw + x * ty - tx * y;
    return this;
};

/**
 * Apply the input Mat33 the the current Vec3.
 *
 * @method applyMatrix
 * @param {Mat33} matrix Mat33 to apply.
 * @chainable
 */
Vec3.prototype.applyMatrix = function applyMatrix(matrix) {
    var M = matrix.get();

    var x = this.x;
    var y = this.y;
    var z = this.z;

    this.x = M[0]*x + M[1]*y + M[2]*z;
    this.y = M[3]*x + M[4]*y + M[5]*z;
    this.z = M[6]*x + M[7]*y + M[8]*z;
    return this;
};

/**
 * Normalize the input Vec3.
 *
 * @method normalize
 * @param {Vec3} v The reference Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The normalize Vec3.
 */
Vec3.normalize = function normalize(v, output) {
    var x = v.x;
    var y = v.y;
    var z = v.z;

    var length = sqrt(x * x + y * y + z * z) || 1;
    length = 1 / length;

    output.x = x * length;
    output.y = y * length;
    output.z = z * length;
    return output;
};

/**
 * Apply a rotation to the input Vec3.
 *
 * @method applyRotation
 * @param {Vec3} v The reference Vec3.
 * @param {Quaternion} q Unit Quaternion representing the rotation to apply.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The rotated version of the input Vec3.
 */
Vec3.applyRotation = function applyRotation(v, q, output) {
    var cw = q.w;
    var cx = -q.x;
    var cy = -q.y;
    var cz = -q.z;

    var vx = v.x;
    var vy = v.y;
    var vz = v.z;

    var tw = -cx * vx - cy * vy - cz * vz;
    var tx = vx * cw + vy * cz - cy * vz;
    var ty = vy * cw + cx * vz - vx * cz;
    var tz = vz * cw + vx * cy - cx * vy;

    var w = cw;
    var x = -cx;
    var y = -cy;
    var z = -cz;

    output.x = tx * w + x * tw + y * tz - ty * z;
    output.y = ty * w + y * tw + tx * z - x * tz;
    output.z = tz * w + z * tw + x * ty - tx * y;
    return output;
};

/**
 * Clone the input Vec3.
 *
 * @method clone
 * @param {Vec3} v The Vec3 to clone.
 * @return {Vec3} The cloned Vec3.
 */
Vec3.clone = function clone(v) {
    return new Vec3(v.x, v.y, v.z);
};

/**
 * Add the input Vec3's.
 *
 * @method add
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The result of the addition.
 */
Vec3.add = function add(v1, v2, output) {
    output.x = v1.x + v2.x;
    output.y = v1.y + v2.y;
    output.z = v1.z + v2.z;
    return output;
};

/**
 * Subtract the second Vec3 from the first.
 *
 * @method subtract
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The result of the subtraction.
 */
Vec3.subtract = function subtract(v1, v2, output) {
    output.x = v1.x - v2.x;
    output.y = v1.y - v2.y;
    output.z = v1.z - v2.z;
    return output;
};

/**
 * Scale the input Vec3.
 *
 * @method scale
 * @param {Vec3} v The reference Vec3.
 * @param {Number} s Number to scale by.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The result of the scaling.
 */
Vec3.scale = function scale(v, s, output) {
    output.x = v.x * s;
    output.y = v.y * s;
    output.z = v.z * s;
    return output;
};

/**
 * The dot product of the input Vec3's.
 *
 * @method dotProduct
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @return {Number} The dot product.
 */
Vec3.dot = function dot(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
};

/**
 * The (right-handed) cross product of the input Vec3's.
 * v1 x v2.
 *
 * @method crossProduct
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3}
 */
Vec3.cross = function cross(v1, v2, output) {
    var x1 = v1.x;
    var y1 = v1.y;
    var z1 = v1.z;
    var x2 = v2.x;
    var y2 = v2.y;
    var z2 = v2.z;

    output.x = y1 * z2 - z1 * y2;
    output.y = z1 * x2 - x1 * z2;
    output.z = x1 * y2 - y1 * x2;
    return output;
};

/**
 * The projection of v1 onto v2.
 *
 * @method project
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3}
 */
Vec3.project = function project(v1, v2, output) {
    var x1 = v1.x;
    var y1 = v1.y;
    var z1 = v1.z;
    var x2 = v2.x;
    var y2 = v2.y;
    var z2 = v2.z;

    var scale = x1 * x2 + y1 * y2 + z1 * z2;
    scale /= x2 * x2 + y2 * y2 + z2 * z2;

    output.x = x2 * scale;
    output.y = y2 * scale;
    output.z = z2 * scale;

    return output;
};

module.exports = Vec3;

},{}],6:[function(require,module,exports){
module.exports = {
    Mat33: require('./Mat33'),
    Quaternion: require('./Quaternion'),
    Vec2: require('./Vec2'),
    Vec3: require('./Vec3')
};


},{"./Mat33":2,"./Quaternion":3,"./Vec2":4,"./Vec3":5}],7:[function(require,module,exports){
/*jshint -W008 */

'use strict';

var Curves = {
    /**
     * @property linear
     * @static
     * @type {Function}
     */
    linear: function(t) {
        return t;
    },

    /**
     * @property easeIn
     * @static
     * @type {Function}
     */
    easeIn: function(t) {
        return t*t;
    },

    /**
     * @property easeOut
     * @static
     * @type {Function}
     */
    easeOut: function(t) {
        return t*(2-t);
    },

    /**
     * @property easeInOut
     * @static
     * @type {Function}
     */
    easeInOut: function(t) {
        if (t <= 0.5) return 2*t*t;
        else return -2*t*t + 4*t - 1;
    },

    /**
     * @property easeOutBounce
     * @static
     * @type {Function}
     */
    easeOutBounce: function(t) {
        return t*(3 - 2*t);
    },

    /**
     * @property spring
     * @static
     * @type {Function}
     */
    spring: function(t) {
        return (1 - t) * Math.sin(6 * Math.PI * t) + t;
    },

    /**
     * @property inQuad
     * @static
     * @type {Function}
     */
    inQuad: function(t) {
        return t*t;
    },

    /**
     * @property outQuad
     * @static
     * @type {Function}
     */
    outQuad: function(t) {
        return -(t-=1)*t+1;
    },

    /**
     * @property inOutQuad
     * @static
     * @type {Function}
     */
    inOutQuad: function(t) {
        if ((t/=.5) < 1) return .5*t*t;
        return -.5*((--t)*(t-2) - 1);
    },

    /**
     * @property inCubic
     * @static
     * @type {Function}
     */
    inCubic: function(t) {
        return t*t*t;
    },

    /**
     * @property outCubic
     * @static
     * @type {Function}
     */
    outCubic: function(t) {
        return ((--t)*t*t + 1);
    },

    /**
     * @property inOutCubic
     * @static
     * @type {Function}
     */
    inOutCubic: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t;
        return .5*((t-=2)*t*t + 2);
    },

    /**
     * @property inQuart
     * @static
     * @type {Function}
     */
    inQuart: function(t) {
        return t*t*t*t;
    },

    /**
     * @property outQuart
     * @static
     * @type {Function}
     */
    outQuart: function(t) {
        return -((--t)*t*t*t - 1);
    },

    /**
     * @property inOutQuart
     * @static
     * @type {Function}
     */
    inOutQuart: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t;
        return -.5 * ((t-=2)*t*t*t - 2);
    },

    /**
     * @property inQuint
     * @static
     * @type {Function}
     */
    inQuint: function(t) {
        return t*t*t*t*t;
    },

    /**
     * @property outQuint
     * @static
     * @type {Function}
     */
    outQuint: function(t) {
        return ((--t)*t*t*t*t + 1);
    },

    /**
     * @property inOutQuint
     * @static
     * @type {Function}
     */
    inOutQuint: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t*t;
        return .5*((t-=2)*t*t*t*t + 2);
    },

    /**
     * @property inSine
     * @static
     * @type {Function}
     */
    inSine: function(t) {
        return -1.0*Math.cos(t * (Math.PI/2)) + 1.0;
    },

    /**
     * @property outSine
     * @static
     * @type {Function}
     */
    outSine: function(t) {
        return Math.sin(t * (Math.PI/2));
    },

    /**
     * @property inOutSine
     * @static
     * @type {Function}
     */
    inOutSine: function(t) {
        return -.5*(Math.cos(Math.PI*t) - 1);
    },

    /**
     * @property inExpo
     * @static
     * @type {Function}
     */
    inExpo: function(t) {
        return (t===0) ? 0.0 : Math.pow(2, 10 * (t - 1));
    },

    /**
     * @property outExpo
     * @static
     * @type {Function}
     */
    outExpo: function(t) {
        return (t===1.0) ? 1.0 : (-Math.pow(2, -10 * t) + 1);
    },

    /**
     * @property inOutExpo
     * @static
     * @type {Function}
     */
    inOutExpo: function(t) {
        if (t===0) return 0.0;
        if (t===1.0) return 1.0;
        if ((t/=.5) < 1) return .5 * Math.pow(2, 10 * (t - 1));
        return .5 * (-Math.pow(2, -10 * --t) + 2);
    },

    /**
     * @property inCirc
     * @static
     * @type {Function}
     */
    inCirc: function(t) {
        return -(Math.sqrt(1 - t*t) - 1);
    },

    /**
     * @property outCirc
     * @static
     * @type {Function}
     */
    outCirc: function(t) {
        return Math.sqrt(1 - (--t)*t);
    },

    /**
     * @property inOutCirc
     * @static
     * @type {Function}
     */
    inOutCirc: function(t) {
        if ((t/=.5) < 1) return -.5 * (Math.sqrt(1 - t*t) - 1);
        return .5 * (Math.sqrt(1 - (t-=2)*t) + 1);
    },

    /**
     * @property inElastic
     * @static
     * @type {Function}
     */
    inElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/ p));
    },

    /**
     * @property outElastic
     * @static
     * @type {Function}
     */
    outElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return a*Math.pow(2,-10*t) * Math.sin((t-s)*(2*Math.PI)/p) + 1.0;
    },

    /**
     * @property inOutElastic
     * @static
     * @type {Function}
     */
    inOutElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if ((t/=.5)===2) return 1.0;  if (!p) p=(.3*1.5);
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p));
        return a*Math.pow(2,-10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p)*.5 + 1.0;
    },

    /**
     * @property inBack
     * @static
     * @type {Function}
     */
    inBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return t*t*((s+1)*t - s);
    },

    /**
     * @property outBack
     * @static
     * @type {Function}
     */
    outBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return ((--t)*t*((s+1)*t + s) + 1);
    },

    /**
     * @property inOutBack
     * @static
     * @type {Function}
     */
    inOutBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        if ((t/=.5) < 1) return .5*(t*t*(((s*=(1.525))+1)*t - s));
        return .5*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
    },

    /**
     * @property inBounce
     * @static
     * @type {Function}
     */
    inBounce: function(t) {
        return 1.0 - Curves.outBounce(1.0-t);
    },

    /**
     * @property outBounce
     * @static
     * @type {Function}
     */
    outBounce: function(t) {
        if (t < (1/2.75)) {
            return (7.5625*t*t);
        } else if (t < (2/2.75)) {
            return (7.5625*(t-=(1.5/2.75))*t + .75);
        } else if (t < (2.5/2.75)) {
            return (7.5625*(t-=(2.25/2.75))*t + .9375);
        } else {
            return (7.5625*(t-=(2.625/2.75))*t + .984375);
        }
    },

    /**
     * @property inOutBounce
     * @static
     * @type {Function}
     */
    inOutBounce: function(t) {
        if (t < .5) return Curves.inBounce(t*2) * .5;
        return Curves.outBounce(t*2-1.0) * .5 + .5;
    },

    flat: function() {
        return 0;
    }
};

module.exports = Curves;

},{}],8:[function(require,module,exports){
/*jshint -W008 */

'use strict';

var _defaultCurves = {
    /**
     * @property linear
     * @static
     * @type {Function}
     */
    linear: function(t) {
        return t;
    },

    /**
     * @property easeIn
     * @static
     * @type {Function}
     */
    easeIn: function(t) {
        return t*t;
    },

    /**
     * @property easeOut
     * @static
     * @type {Function}
     */
    easeOut: function(t) {
        return t*(2-t);
    },

    /**
     * @property easeInOut
     * @static
     * @type {Function}
     */
    easeInOut: function(t) {
        if (t <= 0.5) return 2*t*t;
        else return -2*t*t + 4*t - 1;
    },

    /**
     * @property easeOutBounce
     * @static
     * @type {Function}
     */
    easeOutBounce: function(t) {
        return t*(3 - 2*t);
    },

    /**
     * @property spring
     * @static
     * @type {Function}
     */
    spring: function(t) {
        return (1 - t) * Math.sin(6 * Math.PI * t) + t;
    },

    /**
     * @property inQuad
     * @static
     * @type {Function}
     */
    inQuad: function(t) {
        return t*t;
    },

    /**
     * @property outQuad
     * @static
     * @type {Function}
     */
    outQuad: function(t) {
        return -(t-=1)*t+1;
    },

    /**
     * @property inOutQuad
     * @static
     * @type {Function}
     */
    inOutQuad: function(t) {
        if ((t/=.5) < 1) return .5*t*t;
        return -.5*((--t)*(t-2) - 1);
    },

    /**
     * @property inCubic
     * @static
     * @type {Function}
     */
    inCubic: function(t) {
        return t*t*t;
    },

    /**
     * @property outCubic
     * @static
     * @type {Function}
     */
    outCubic: function(t) {
        return ((--t)*t*t + 1);
    },

    /**
     * @property inOutCubic
     * @static
     * @type {Function}
     */
    inOutCubic: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t;
        return .5*((t-=2)*t*t + 2);
    },

    /**
     * @property inQuart
     * @static
     * @type {Function}
     */
    inQuart: function(t) {
        return t*t*t*t;
    },

    /**
     * @property outQuart
     * @static
     * @type {Function}
     */
    outQuart: function(t) {
        return -((--t)*t*t*t - 1);
    },

    /**
     * @property inOutQuart
     * @static
     * @type {Function}
     */
    inOutQuart: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t;
        return -.5 * ((t-=2)*t*t*t - 2);
    },

    /**
     * @property inQuint
     * @static
     * @type {Function}
     */
    inQuint: function(t) {
        return t*t*t*t*t;
    },

    /**
     * @property outQuint
     * @static
     * @type {Function}
     */
    outQuint: function(t) {
        return ((--t)*t*t*t*t + 1);
    },

    /**
     * @property inOutQuint
     * @static
     * @type {Function}
     */
    inOutQuint: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t*t;
        return .5*((t-=2)*t*t*t*t + 2);
    },

    /**
     * @property inSine
     * @static
     * @type {Function}
     */
    inSine: function(t) {
        return -1.0*Math.cos(t * (Math.PI/2)) + 1.0;
    },

    /**
     * @property outSine
     * @static
     * @type {Function}
     */
    outSine: function(t) {
        return Math.sin(t * (Math.PI/2));
    },

    /**
     * @property inOutSine
     * @static
     * @type {Function}
     */
    inOutSine: function(t) {
        return -.5*(Math.cos(Math.PI*t) - 1);
    },

    /**
     * @property inExpo
     * @static
     * @type {Function}
     */
    inExpo: function(t) {
        return (t===0) ? 0.0 : Math.pow(2, 10 * (t - 1));
    },

    /**
     * @property outExpo
     * @static
     * @type {Function}
     */
    outExpo: function(t) {
        return (t===1.0) ? 1.0 : (-Math.pow(2, -10 * t) + 1);
    },

    /**
     * @property inOutExpo
     * @static
     * @type {Function}
     */
    inOutExpo: function(t) {
        if (t===0) return 0.0;
        if (t===1.0) return 1.0;
        if ((t/=.5) < 1) return .5 * Math.pow(2, 10 * (t - 1));
        return .5 * (-Math.pow(2, -10 * --t) + 2);
    },

    /**
     * @property inCirc
     * @static
     * @type {Function}
     */
    inCirc: function(t) {
        return -(Math.sqrt(1 - t*t) - 1);
    },

    /**
     * @property outCirc
     * @static
     * @type {Function}
     */
    outCirc: function(t) {
        return Math.sqrt(1 - (--t)*t);
    },

    /**
     * @property inOutCirc
     * @static
     * @type {Function}
     */
    inOutCirc: function(t) {
        if ((t/=.5) < 1) return -.5 * (Math.sqrt(1 - t*t) - 1);
        return .5 * (Math.sqrt(1 - (t-=2)*t) + 1);
    },

    /**
     * @property inElastic
     * @static
     * @type {Function}
     */
    inElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/ p));
    },

    /**
     * @property outElastic
     * @static
     * @type {Function}
     */
    outElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return a*Math.pow(2,-10*t) * Math.sin((t-s)*(2*Math.PI)/p) + 1.0;
    },

    /**
     * @property inOutElastic
     * @static
     * @type {Function}
     */
    inOutElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if ((t/=.5)===2) return 1.0;  if (!p) p=(.3*1.5);
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p));
        return a*Math.pow(2,-10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p)*.5 + 1.0;
    },

    /**
     * @property inBack
     * @static
     * @type {Function}
     */
    inBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return t*t*((s+1)*t - s);
    },

    /**
     * @property outBack
     * @static
     * @type {Function}
     */
    outBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return ((--t)*t*((s+1)*t + s) + 1);
    },

    /**
     * @property inOutBack
     * @static
     * @type {Function}
     */
    inOutBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        if ((t/=.5) < 1) return .5*(t*t*(((s*=(1.525))+1)*t - s));
        return .5*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
    },

    /**
     * @property inBounce
     * @static
     * @type {Function}
     */
    inBounce: function(t) {
        return 1.0 - _defaultCurves.outBounce(1.0-t);
    },

    /**
     * @property outBounce
     * @static
     * @type {Function}
     */
    outBounce: function(t) {
        if (t < (1/2.75)) {
            return (7.5625*t*t);
        } else if (t < (2/2.75)) {
            return (7.5625*(t-=(1.5/2.75))*t + .75);
        } else if (t < (2.5/2.75)) {
            return (7.5625*(t-=(2.25/2.75))*t + .9375);
        } else {
            return (7.5625*(t-=(2.625/2.75))*t + .984375);
        }
    },

    /**
     * @property inOutBounce
     * @static
     * @type {Function}
     */
    inOutBounce: function(t) {
        if (t < .5) return _defaultCurves.inBounce(t*2) * .5;
        return _defaultCurves.outBounce(t*2-1.0) * .5 + .5;
    }
};

var _curves = Object.create(_defaultCurves);

/*
 * A library of curves which map an animation explicitly as a function of time.
 *    The following easing curves are available by default and can not be
 *    unregistered or overwritten:
 *
 *    linear,
 *    easeIn, easeOut, easeInOut,
 *    easeOutBounce,
 *    spring,
 *    inQuad, outQuad, inOutQuad,
 *    inCubic, outCubic, inOutCubic,
 *    inQuart, outQuart, inOutQuart,
 *    inQuint, outQuint, inOutQuint,
 *    inSine, outSine, inOutSine,
 *    inExpo, outExpo, inOutExpo,
 *    inCirc, outCirc, inOutCirc,
 *    inElastic, outElastic, inOutElastic,
 *    inBack, outBack, inOutBack,
 *    inBounce, outBounce, inOutBounce
 *
 * @class Easing
 * @deprecated Use curves instead
 */
var Easing = {
    /**
     * Registers a given curve to be available in subsequent transitions by
     *    adding it to the interal dictionary of registered curves.
     *
     * @method registerCurve
     * @chainable
     * @static
     *
     * @throws {Error} Will throw an error when attempting to overwrite default
     *    curve.
     * @throws {Error} Will throw an error if curve has already been registered.
     *
     * @param {String} name unique name for later access
     * @param {Function} curve function of one numeric variable mapping [0,1]
     *    to range inside [0,1]
     * @return {Easing} this
     */
    registerCurve: function(name, curve) {
        console.warn('Easing is deprecated! Use transitions.Curves instead!');
        if (_defaultCurves[name]) throw new Error('Default curves can not be overwritten');
        if (_curves[name]) throw new Error('Curve has already been registered');
        _curves[name] = curve;
        return this;
    },

    /**
     * Unregisters the curve registered under the given name by removing it from
     *    the internal dictionary of registered curves. This won't effect
     *    currently active transitions.
     *
     * @method unregisterCurve
     * @chainable
     * @static
     *
     * @throws {Error} Will throw an error if curve does not exist.
     * @param {String} name name of curve
     * @return {Easing} this
     */
    unregisterCurve: function(name) {
        console.warn('Easing is deprecated! Use transitions.Curves instead!');
        if (_defaultCurves[name]) throw new Error('Default curves can not be unregistered');
        if (!_curves[name]) throw new Error('Curve has not been registered');
        delete _curves[name];
        return this;
    },

    /**
     * Returns the easing curve with the given name.
     *
     * @method getCurve
     * @static
     *
     * @param {String} name name of curve
     * @return {Function} curve function of one numeric variable mapping [0,1]
     *    to range inside [0,1]
     */
    getCurve: function(name) {
        console.warn('Easing is deprecated! Use transitions.Curves instead!');
        return _curves[name];
    },

    /**
     * Retrieves the names of all previously registered easing curves.
     *
     * @method getCurves
     * @static
     *
     * @return {String[]} array of registered easing curves
     */
    getCurves: function() {
        console.warn('Easing is deprecated! Use transitions.Curves instead!');
        return Object.keys(_defaultCurves).concat(Object.keys(_curves));
    },

    createBezierCurve: function(v1, v2) {
        console.warn('Easing is deprecated! Use transitions.Curves instead!');
        v1 = v1 || 0; v2 = v2 || 0;
        return function(t) {
            return v1*t + (-2*v1 - v2 + 3)*t*t + (v1 + v2 - 2)*t*t*t;
        };
    }
};

module.exports = Easing;

},{}],9:[function(require,module,exports){
'use strict';

var Curves = require('./Curves');

/**
 * A state maintainer for a smooth transition between
 *    numerically-specified states. Example numeric states include floats and
 *    arrays of floats objects.
 *
 * An initial state is set with the constructor or using
 *     {@link Transitionable#from}. Subsequent transitions consist of an
 *     intermediate state, easing curve, duration and callback. The final state
 *     of each transition is the initial state of the subsequent one. Calls to
 *     {@link Transitionable#get} provide the interpolated state along the way.
 *
 * Note that there is no event loop here - calls to {@link Transitionable#get}
 *    are the only way to find state projected to the current (or provided)
 *    time and are the only way to trigger callbacks and mutate the internal
 *    transition queue.
 *
 * @example
 * var t = new Transitionable([0, 0]);
 * t
 *     .to([100, 0], 'linear', 1000)
 *     .delay(1000)
 *     .to([200, 0], 'outBounce', 1000);
 *
 * var div = document.createElement('div');
 * div.style.background = 'blue';
 * div.style.width = '100px';
 * div.style.height = '100px';
 * document.body.appendChild(div);
 *
 * div.addEventListener('click', function() {
 *     t.isPaused() ? t.resume() : t.pause();
 * });
 *
 * requestAnimationFrame(function loop() {
 *     div.style.transform = 'translateX(' + t.get()[0] + 'px)' + ' translateY(' + t.get()[1] + 'px)';
 *     requestAnimationFrame(loop);
 * });
 *
 * @class Transitionable
 * @constructor
 * @param {Number|Array.Number} initialState    initial state to transition
 *                                              from - equivalent to a pursuant
 *                                              invocation of
 *                                              {@link Transitionable#from}
 */
function Transitionable(initialState) {
    this._queue = [];
    this._multi = null;
    this._end = null;
    this._startedAt = null;
    this._pausedAt = null;
    if (initialState != null) this.from(initialState);
}

/**
 * Internal Clock used for determining the current time for the ongoing
 * transitions.
 *
 * @type {Performance|Date|Object}
 */
Transitionable.Clock = typeof performance !== 'undefined' ? performance : Date;

/**
 * Registers a transition to be pushed onto the internal queue.
 *
 * @method to
 * @chainable
 *
 * @param  {Number|Array.Number}    finalState              final state to
 *                                                          transiton to
 * @param  {String|Function}        [curve=Curves.linear]   easing function
 *                                                          used for
 *                                                          interpolating
 *                                                          [0, 1]
 * @param  {Number}                 [duration=100]          duration of
 *                                                          transition
 * @param  {Function}               [callback]              callback function
 *                                                          to be called after
 *                                                          the transition is
 *                                                          complete
 * @return {Transitionable}         this
 */
Transitionable.prototype.to = function to(finalState, curve, duration, callback) {
    curve = curve != null && curve.constructor === String ? Curves[curve] : curve;
    if (this._queue.length === 0) {
        this._startedAt = this.constructor.Clock.now();
        this._pausedAt = null;
    }
    this._queue.push(
        finalState,
        curve != null ? curve : Curves.linear,
        duration != null ? duration : 100,
        callback
    );
    return this;
};

/**
 * Resets the transition queue to a stable initial state.
 *
 * @method from
 * @chainable
 *
 * @param  {Number|Array.Number}    initialState    initial state to
 *                                                  transition from
 * @return {Transitionable}         this
 */
Transitionable.prototype.from = function from(initialState) {
    this._end = initialState;
    if (initialState.constructor === Array && this._multi != null && this._multi.constructor === Array) {
        this._multi.length = initialState.length;
    } else {
        this._multi = initialState.constructor === Array ? [] : false;
    }
    this._queue.length = 0;
    this._startedAt = this.constructor.Clock.now();
    this._pausedAt = null;
    return this;
};

/**
 * Delays the execution of the subsequent transition for a certain period of
 * time.
 *
 * @method delay
 * @chainable
 *
 * @param {Number}      duration    delay time in ms
 * @param {Function}    [callback]  Zero-argument function to call on observed
 *                                  completion (t=1)
 * @return {Transitionable}         this
 */
Transitionable.prototype.delay = function delay(duration, callback) {
    var endState = this._queue.length > 0 ? this._queue[this._queue.length - 4] : this._end;
    return this.to(endState, Curves.flat, duration, callback);
};

/**
 * Overrides current transition.
 *
 * @method override
 * @chainable
 *
 * @param  {Number|Array.Number}    [finalState]    final state to transiton to
 * @param  {String|Function}        [curve]         easing function used for
 *                                                  interpolating [0, 1]
 * @param  {Number}                 [duration]      duration of transition
 * @param  {Function}               [callback]      callback function to be
 *                                                  called after the transition
 *                                                  is complete
 * @return {Transitionable}         this
 */
Transitionable.prototype.override = function override(finalState, curve, duration, callback) {
    if (this._queue.length > 0) {
        if (finalState != null) this._queue[0] = finalState;
        if (curve != null)      this._queue[1] = curve.constructor === String ? Curves[curve] : curve;
        if (duration != null)   this._queue[2] = duration;
        if (callback != null)   this._queue[3] = callback;
    }
    return this;
};

Transitionable.prototype._interpolate = function _interpolate(from, to, progress) {
    if (this._multi) {
        for (var i = 0; i < to.length; i++) {
            this._multi[i] = from[i] + progress * (to[i] - from[i]);
        }
        return this._multi;
    } else {
        return from + progress * (to - from);
    }
};

/**
 * Get interpolated state of current action at provided time. If the last
 *    action has completed, invoke its callback.
 *
 * @method get
 *
 * @param {Number=} timestamp Evaluate the curve at a normalized version of this
 *    time. If omitted, use current time. (Unix epoch time)
 * @return {Number|Array.Number} beginning state
 *    interpolated to this point in time.
 */
Transitionable.prototype.get = function get(t) {
    t = this._pausedAt ? this._pausedAt : t;
    t = t ? t : this.constructor.Clock.now();
    if (this._queue.length === 0) return this._end;

    var progress = (t - this._startedAt) / this._queue[2];
    var state = this._interpolate(this._end, this._queue[0], this._queue[1](progress > 1 ? 1 : progress));
    if (progress >= 1) {
        this._startedAt = this._startedAt + this._queue[2];
        this._end = this._queue.shift();
        this._queue.shift();
        this._queue.shift();
        var callback = this._queue.shift();
        if (callback) callback();
    }
    return progress > 1 ? this.get() : state;
};

/**
 * Is there at least one transition pending completion?
 *
 * @method isActive
 *
 * @return {boolean}
 */
Transitionable.prototype.isActive = function isActive() {
    return this._queue.length > 0;
};

/**
 * Halt transition at current state and erase all pending actions.
 *
 * @method halt
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.halt = function halt() {
    return this.from(this.get());
};

/**
 * Pause transition. This will not erase any actions.
 *
 * @method pause
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.pause = function pause() {
    this._pausedAt = this.constructor.Clock.now();
    return this;
};

/**
 * Has the current action been paused?
 *
 * @method isPaused
 * @chainable
 *
 * @return {Boolean} if the current action has been paused
 */
Transitionable.prototype.isPaused = function isPaused() {
    return !!this._pausedAt;
};

/**
 * Resume transition.
 *
 * @method resume
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.resume = function resume() {
    var diff = this._pausedAt - this._startedAt;
    this._startedAt = this.constructor.Clock.now() - diff;
    this._pausedAt = null;
    return this;
};

/**
 * Cancel all transitions and reset to a stable state
 *
 * @method reset
 * @chainable
 * @deprecated Use `.from` instead!
 *
 * @param {Number|Array.Number|Object.<number, number>} startState
 *    stable state to set to
 */
Transitionable.prototype.reset = function(start) {
    return this.from(start);
};

/**
 * Add transition to end state to the queue of pending transitions. Special
 *    Use: calling without a transition resets the object to that state with
 *    no pending actions
 *
 * @method set
 * @chainable
 * @deprecated Use `.to` instead!
 *
 * @param {Number|FamousMatrix|Array.Number|Object.<number, number>} endState
 *    end state to which we interpolate
 * @param {transition=} transition object of type {duration: number, curve:
 *    f[0,1] -> [0,1] or name}. If transition is omitted, change will be
 *    instantaneous.
 * @param {function()=} callback Zero-argument function to call on observed
 *    completion (t=1)
 */
Transitionable.prototype.set = function(state, transition, callback) {
    if (transition == null) {
        this.from(state);
        if (callback) callback();
    } else {
        this.to(state, transition.curve, transition.duration, callback);
    }
    return this;
};

module.exports = Transitionable;

},{"./Curves":7}],10:[function(require,module,exports){
'use strict';

/**
 * Return wrapper around callback function. Once the wrapper is called N
 *   times, invoke the callback function. Arguments and scope preserved.
 *
 * @method after
 * @deprecated
 *
 * @param {number} count number of calls before callback function invoked
 * @param {Function} callback wrapped callback function
 *
 * @return {function} wrapped callback with coundown feature
 */
var after = function after(count, callback) {
    console.warn('transitions.after is deprecated!');
    var counter = count;
    return function() {
        counter--;
        if (counter === 0) callback.apply(this, arguments);
    };
};

module.exports = after;

},{}],11:[function(require,module,exports){
'use strict';

module.exports = {
    after: require('./after'),
    Easing: require('./Easing'),
    Curves: require('./Curves'),
    Transitionable: require('./Transitionable')
};

},{"./Curves":7,"./Easing":8,"./Transitionable":9,"./after":10}],12:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],13:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],14:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./Curves":12,"dup":9}],15:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],16:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./Curves":12,"./Easing":13,"./Transitionable":14,"./after":15,"dup":11}],17:[function(require,module,exports){
'use strict';

/**
 * A lightweight, featureless EventEmitter.
 * 
 * @class CallbackStore
 * @constructor
 */
function CallbackStore () {
    this._events = {};
}

/**
 * Adds a listener for the specified event (= key).
 *
 * @method on
 * @chainable
 * 
 * @param  {String}   key
 * @param  {Function} callback
 * @return {Function} A function to call if you want to remove the callback
 */
CallbackStore.prototype.on = function on (key, callback) {
    if (!this._events[key]) this._events[key] = [];
    var callbackList = this._events[key];
    callbackList.push(callback);
    return function () {
        callbackList.splice(callbackList.indexOf(callback), 1);
    }
};

/**
 * Removes a previously added event listener.
 *
 * @method off
 * @chainable
 * 
 * @param  {String}          key
 * @param  {Function}        callback
 * @return {CallbackStore}   this
 */
CallbackStore.prototype.off = function off (key, callback) {
    var events = this._events[key];
    if (events) events.splice(events.indexOf(callback), 1);
    return this;
};

/**
 * Invokes all the previously for this key registered callbacks.
 *
 * @method trigger
 * @chainable
 * 
 * @param  {String}        key
 * @param  {Object}        payload
 * @return {CallbackStore} this
 */
CallbackStore.prototype.trigger = function trigger (key, payload) {
    var events = this._events[key];
    if (events) {
        var i = 0;
        var len = events.length;
        for (; i < len ; i++) events[i](payload);
    }
    return this;
};

module.exports = CallbackStore;

},{}],18:[function(require,module,exports){
'use strict';

var Transitionable = require('famous-transitions').Transitionable;

/**
 * @class Color
 * @constructor
 * @component
 * @param {Color|String|Array} Optional argument for setting color using
 * Hex, a Color instance, color name or RGB
 * @param {Object} Optional transition
 * @param {Function} Callback
 */
function Color(color, transition, cb) {
    this._r = new Transitionable(0);
    this._g = new Transitionable(0);
    this._b = new Transitionable(0);
    if (color) this.set(color, transition, cb);
};

/**
* Returns the definition of the Class: 'Color'
* @method toString
* @return {String} definition
*/
Color.toString = function toString() {
    return 'Color';
};

/**
* Sets the color. It accepts an optional transition parameter and callback.
* set(Color, transition, callback)
* set('#000000', transition, callback)
* set('black', transition, callback)
* set([r, g, b], transition, callback)
* @method set
 * @param {Color|String|Array} Optional argument for setting color using
 * Hex, a Color instance, color name or RGB
 * @param {Object} Optional transition
 * @param {Function} Callback
* @chainable
*/
Color.prototype.set = function set(color, transition, cb) {
    switch (Color.determineType(color)) {
        case 'hex': return this.setHex(color, transition, cb);
        case 'colorName': return this.setColor(color, transition, cb);
        case 'instance': return this.changeTo(color, transition, cb);
        case 'rgb': return this.setRGB(color[0], color[1], color[2], transition, cb);
    }
};

/**
 * Returns whether Color is still in an animating (transitioning) state.
 *
 * @method isActive
 * @returns {Boolean} boolean
 */
Color.prototype.isActive = function isActive() {
    return this._r.isActive() || this._g.isActive() || this._b.isActive();
};

/**
 * Halt transition at current state and erase all pending actions.
 *
 * @method halt
 * @chainable
 *
 * @return {Color} this
 */
Color.prototype.halt = function halt() {
    this._r.halt();
    this._g.halt();
    this._b.halt();
    return this;
};

/**
 * Sets the color values from another Color instance.
 *
 * @method changeTo
 * @param {Color} Color instance
 * @param {Object} transition Optional transition
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.changeTo = function changeTo(color, transition, cb) {
    if (Color.isColorInstance(color)) {
        var rgb = color.getRGB();
        this.setRGB(rgb[0], rgb[1], rgb[2], transition, cb);
    }
    return this;
};

/**
 * Sets the color based on static color names.
 *
 * @method setColor
 * @param {String} Color name
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setColor = function setColor(name, transition, cb) {
    if (colorNames[name]) {
        this.setHex(colorNames[name], transition, cb);
    }
    return this;
};

/**
 * Returns the color in either RGB or with the requested format.
 *
 * @method getColor
 * @param {String} Optional argument for determining which type of color to get (default is RGB)
 * @returns Color in either RGB or specific option value
 */
Color.prototype.getColor = function getColor(option) {
    if (Color.isString(option)) option = option.toLowerCase();
    return (option === 'hex') ? this.getHex() : this.getRGB();
};

/**
 * Sets the R of the Color's RGB
 *
 * @method setR
 * @param {Integer} R channel of color
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setR = function setR(r, transition, cb) {
    this._r.set(r, transition, cb);
    return this;
};

/**
 * Sets the G of the Color's RGB
 *
 * @method setG
 * @param {Integer} G channel of color
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setG = function setG(g, transition, cb) {
    this._g.set(g, transition, cb);
    return this;
};

/**
 * Sets the B of the Color's RGB
 *
 * @method setB
 * @param {Integer} B channel of color
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setB = function setB(b, transition, cb) {
    this._b.set(b, transition, cb);
    return this;
};

/**
 * Sets RGB
 *
 * @method setRGB
 * @param {Integer} R channel of color
 * @param {Integer} G channel of color
 * @param {Integer} B channel of color
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setRGB = function setRGB(r, g, b, transition, cb) {
    this.setR(r, transition);
    this.setG(g, transition);
    this.setB(b, transition, cb);
    return this;
};

/**
 * Returns R of RGB
 *
 * @method getR
 * @returns R of Color
 */
Color.prototype.getR = function getR() {
    return this._r.get();
};

/**
 * Returns G of RGB
 *
 * @method getG
 * @returns G of Color
 */
Color.prototype.getG = function getG() {
    return this._g.get();
};

/**
 * Returns B of RGB
 *
 * @method getB
 * @returns B of Color
 */
Color.prototype.getB = function getB() {
    return this._b.get();
};

/**
 * Returns RGB
 *
 * @method getRGB
 * @returns RGB
 */
Color.prototype.getRGB = function getRGB() {
    return [this.getR(), this.getG(), this.getB()];
};

/**
 * Returns Normalized RGB
 *
 * @method getNormalizedRGB
 * @returns Normalized RGB
 */
Color.prototype.getNormalizedRGB = function getNormalizedRGB() {
    var r = this.getR() / 255.0;
    var g = this.getG() / 255.0;
    var b = this.getB() / 255.0;
    return [r, g, b];
};

/**
 * Returns the current color in Hex
 *
 * @method getHex
 * @returns Hex value
 */
Color.prototype.getHex = function getHex() {
    var r = Color.toHex(this.getR());
    var g = Color.toHex(this.getG());
    var b = Color.toHex(this.getB());
    return '#' + r + g + b;
};

/**
 * Sets color using Hex
 *
 * @method setHex
 * @param {String} Hex value
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setHex = function setHex(hex, transition, cb) {
    hex = (hex.charAt(0) === '#') ? hex.substring(1, hex.length) : hex;

    if (hex.length === 3) {
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });
    }

    var r = parseInt(hex.substring(0, 2), 16);
    var g = parseInt(hex.substring(2, 4), 16);
    var b = parseInt(hex.substring(4, 6), 16);
    this.setRGB(r, g, b, transition, cb);
    return this;
};

/**
 * Converts a number to a hex value
 *
 * @method toHex
 * @param {Integer} Number
 * @returns Hex value
 */
Color.toHex = function toHex(num) {
    var hex = num.toString(16);
    return hex.length === 1 ? '0' + hex : hex;
};

/**
 * Determines the given input with the appropriate configuration
 *
 * @method determineType
 * @param {Color|String|Array} Color type
 * @returns {String} Appropriate color type
 */
Color.determineType = function determineType(type) {
    if (Color.isColorInstance(type)) return 'instance';
    if (colorNames[type]) return 'colorName';
    if (Color.isHex(type)) return 'hex';
    if (Array.isArray(type)) return 'rgb';
};

/**
 * Returns a boolean checking whether input is a 'String'
 *
 * @method isString
 * @param Primitive
 * @returns {Boolean} Boolean
 */
Color.isString = function isString(val) {
    return (typeof val === 'string');
};

/**
 * Returns a boolean checking whether string input has a hash (#) symbol
 *
 * @method isHex
 * @param String
 * @returns {Boolean} Boolean
 */
Color.isHex = function isHex(val) {
    if (!Color.isString(val)) return false;
    return val[0] === '#';
};

/**
 * Returns boolean whether the input is a Color instance
 *
 * @method isColorInstance
 * @param Color instance
 * @returns {Boolean} Boolean
 */
Color.isColorInstance = function isColorInstance(val) {
    return !!val.getColor;
};

/**
 * Common color names with their associated Hex values
 */
var colorNames = { aliceblue: '#f0f8ff', antiquewhite: '#faebd7', aqua: '#00ffff', aquamarine: '#7fffd4', azure: '#f0ffff', beige: '#f5f5dc', bisque: '#ffe4c4', black: '#000000', blanchedalmond: '#ffebcd', blue: '#0000ff', blueviolet: '#8a2be2', brown: '#a52a2a', burlywood: '#deb887', cadetblue: '#5f9ea0', chartreuse: '#7fff00', chocolate: '#d2691e', coral: '#ff7f50', cornflowerblue: '#6495ed', cornsilk: '#fff8dc', crimson: '#dc143c', cyan: '#00ffff', darkblue: '#00008b', darkcyan: '#008b8b', darkgoldenrod: '#b8860b', darkgray: '#a9a9a9', darkgreen: '#006400', darkgrey: '#a9a9a9', darkkhaki: '#bdb76b', darkmagenta: '#8b008b', darkolivegreen: '#556b2f', darkorange: '#ff8c00', darkorchid: '#9932cc', darkred: '#8b0000', darksalmon: '#e9967a', darkseagreen: '#8fbc8f', darkslateblue: '#483d8b', darkslategray: '#2f4f4f', darkslategrey: '#2f4f4f', darkturquoise: '#00ced1', darkviolet: '#9400d3', deeppink: '#ff1493', deepskyblue: '#00bfff', dimgray: '#696969', dimgrey: '#696969', dodgerblue: '#1e90ff', firebrick: '#b22222', floralwhite: '#fffaf0', forestgreen: '#228b22', fuchsia: '#ff00ff', gainsboro: '#dcdcdc', ghostwhite: '#f8f8ff', gold: '#ffd700', goldenrod: '#daa520', gray: '#808080', green: '#008000', greenyellow: '#adff2f', grey: '#808080', honeydew: '#f0fff0', hotpink: '#ff69b4', indianred: '#cd5c5c', indigo: '#4b0082', ivory: '#fffff0', khaki: '#f0e68c', lavender: '#e6e6fa', lavenderblush: '#fff0f5', lawngreen: '#7cfc00', lemonchiffon: '#fffacd', lightblue: '#add8e6', lightcoral: '#f08080', lightcyan: '#e0ffff', lightgoldenrodyellow: '#fafad2', lightgray: '#d3d3d3', lightgreen: '#90ee90', lightgrey: '#d3d3d3', lightpink: '#ffb6c1', lightsalmon: '#ffa07a', lightseagreen: '#20b2aa', lightskyblue: '#87cefa', lightslategray: '#778899', lightslategrey: '#778899', lightsteelblue: '#b0c4de', lightyellow: '#ffffe0', lime: '#00ff00', limegreen: '#32cd32', linen: '#faf0e6', magenta: '#ff00ff', maroon: '#800000', mediumaquamarine: '#66cdaa', mediumblue: '#0000cd', mediumorchid: '#ba55d3', mediumpurple: '#9370db', mediumseagreen: '#3cb371', mediumslateblue: '#7b68ee', mediumspringgreen: '#00fa9a', mediumturquoise: '#48d1cc', mediumvioletred: '#c71585', midnightblue: '#191970', mintcream: '#f5fffa', mistyrose: '#ffe4e1', moccasin: '#ffe4b5', navajowhite: '#ffdead', navy: '#000080', oldlace: '#fdf5e6', olive: '#808000', olivedrab: '#6b8e23', orange: '#ffa500', orangered: '#ff4500', orchid: '#da70d6', palegoldenrod: '#eee8aa', palegreen: '#98fb98', paleturquoise: '#afeeee', palevioletred: '#db7093', papayawhip: '#ffefd5', peachpuff: '#ffdab9', peru: '#cd853f', pink: '#ffc0cb', plum: '#dda0dd', powderblue: '#b0e0e6', purple: '#800080', rebeccapurple: '#663399', red: '#ff0000', rosybrown: '#bc8f8f', royalblue: '#4169e1', saddlebrown: '#8b4513', salmon: '#fa8072', sandybrown: '#f4a460', seagreen: '#2e8b57', seashell: '#fff5ee', sienna: '#a0522d', silver: '#c0c0c0', skyblue: '#87ceeb', slateblue: '#6a5acd', slategray: '#708090', slategrey: '#708090', snow: '#fffafa', springgreen: '#00ff7f', steelblue: '#4682b4', tan: '#d2b48c', teal: '#008080', thistle: '#d8bfd8', tomato: '#ff6347', turquoise: '#40e0d0', violet: '#ee82ee', wheat: '#f5deb3', white: '#ffffff', whitesmoke: '#f5f5f5', yellow: '#ffff00', yellowgreen: '#9acd32' };

module.exports = Color;

},{"famous-transitions":16}],19:[function(require,module,exports){
'use strict';

/**
 * Collection to map keyboard codes in plain english
 *
 * @class KeyCodes
 * @static
 */
module.exports = {
    0: 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    a: 97,
    b: 98,
    c: 99,
    d: 100,
    e: 101,
    f: 102,
    g: 103,
    h: 104,
    i: 105,
    j: 106,
    k: 107,
    l: 108,
    m: 109,
    n: 110,
    o: 111,
    p: 112,
    q: 113,
    r: 114,
    s: 115,
    t: 116,
    u: 117,
    v: 118,
    w: 119,
    x: 120,
    y: 121,
    z: 122,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    ENTER : 13,
    LEFT_ARROW: 37,
    RIGHT_ARROW: 39,
    UP_ARROW: 38,
    DOWN_ARROW: 40,
    SPACE: 32,
    SHIFT: 16,
    TAB: 9
};


},{}],20:[function(require,module,exports){
'use strict';

function MethodStore () {
    this._events = {};
}

MethodStore.prototype.on = function on (key, cbclass, cbname) {
    var events = this._events[key];
    if (!events) events = [];
    events.push(cbclass, cbname);
    return this;
}

MethodStore.prototype.off = function off (key, cbclass) {
    var events = this._events[key];
    if (events) {
        var index = events.indexOf(cbclass);
        if (index > -1) events.splice(index, 2);
    }
    return this;
}

MethodStore.prototype.trigger = function trigger (key, payload) {
    var events = this._events[key];
    if (events) {
        var i = 0;
        var len = events.length;
        for (; i < len ; i += 2) events[i][events[i + 1]](payload);
    }
    return this;
};

module.exports = MethodStore;

},{}],21:[function(require,module,exports){
'use strict';

/**
 * Singleton object to manage recycling of objects with typically short lifespans, used to cut down on the
 * amount of garbage collection required.
 *
 * @singleton
 */
var ObjectManager = {};

ObjectManager.pools = {};

/**
 * Register request and free functions for the given type.
 *
 * @method register
 * @param {String} type
 * @param {Function} Constructor
 */
ObjectManager.register = function(type, Constructor) {
    var pool = this.pools[type] = [];

    this['request' + type] = _request(pool, Constructor);
    this['free' + type] = _free(pool);
};

function _request(pool, Constructor) {
    return function request() {
        if (pool.length !== 0) return pool.pop();
        else return new Constructor();
    }
}

function _free(pool) {
    return function free(obj) {
        pool.push(obj);
    }
}

/**
 * Untrack all object of the given type. Used to allow allocated objects to be garbage collected.
 *
 * @method disposeOf
 * @param {String}
 */
ObjectManager.disposeOf= function(type) {
    var pool = this.pools[type];
    var i = pool.length;
    while (i--) pool.pop();
};

module.exports = ObjectManager;

},{}],22:[function(require,module,exports){
'use strict';

/**
 *  Deep clone an object.
 *  @memberof Utilities
 *  @param b {Object} Object to clone
 *  @return a {Object} Cloned object.
 */
var clone = function clone(b) {
    var a;
    if (typeof b === 'object') {
        a = (b instanceof Array) ? [] : {};
        for (var key in b) {
            if (typeof b[key] === 'object' && b[key] !== null) {
                if (b[key] instanceof Array) {
                    a[key] = new Array(b[key].length);
                    for (var i = 0; i < b[key].length; i++) {
                        a[key][i] = clone(b[key][i]);
                    }
                }
                else {
                  a[key] = clone(b[key]);
                }
            }
            else {
                a[key] = b[key];
            }
        }
    }
    else {
        a = b;
    }
    return a;
};

module.exports = clone;

},{}],23:[function(require,module,exports){
'use strict';

/**
 * Flat clone an object.
 * @memberof Utilities
 * @param {Object} obj - Object to clone
 * @return {Object} Cloned object
 */
function flatClone(obj) {
    var clone = {};
    for (var key in obj) clone[key] = obj[key];
    return clone;
}

module.exports = flatClone;

},{}],24:[function(require,module,exports){
'use strict';

module.exports = {
    CallbackStore: require('./CallbackStore'),
    clone: require('./clone'),
    flatClone: require('./flatClone'),
    KeyCodes: require('./KeyCodes'),
    loadURL: require('./loadURL'),
    MethodStore: require('./MethodStore'),
    ObjectManager: require('./ObjectManager'),
    Color: require('./Color'),
    strip: require('./strip'),
    keyValueToArrays: require('./keyValueToArrays')
};


},{"./CallbackStore":17,"./Color":18,"./KeyCodes":19,"./MethodStore":20,"./ObjectManager":21,"./clone":22,"./flatClone":23,"./keyValueToArrays":25,"./loadURL":26,"./strip":27}],25:[function(require,module,exports){
/**
 * Takes an object containing keys and values and returns an object
 * comprising two "associate" arrays, one with the keys and the other
 * with the values.
 *
 * @method keyValuesToArrays
 *
 * @param {Object} Object
 * @returns {Object} Object Object containing two arrays, one with the keys and the other for values
 */
module.exports = function keyValuesToArrays(obj) {
    var keysArray = [], valuesArray = [];
    var i = 0;
    for(var key in obj) {
        if (obj.hasOwnProperty(key)) {
            keysArray[i] = key;
            valuesArray[i] = obj[key];
            i++;
        }
    }
    return {
        keys: keysArray,
        values: valuesArray
    };
};

},{}],26:[function(require,module,exports){
'use strict';

/**
 * Load a URL and return its contents in a callback
 *
 * @method loadURL
 * @memberof Utilities
 * @param {string} url URL of object
 * @param {function} callback callback to dispatch with content
 */
var loadURL = function loadURL(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function onreadystatechange() {
        if (this.readyState === 4) {
            if (callback) callback(this.responseText);
        }
    };
    xhr.open('GET', url);
    xhr.send();
};

module.exports = loadURL;

},{}],27:[function(require,module,exports){
'use strict';

/**
 * Removes all values not being of a primitive type from an arbitrary object
 * literal.
 *
 * @method strip
 * @memberof Utilities
 * @param  {any}        primitive or (non-)serializable object without
 *                      circular references
 * @return {any}        primitive or (nested) object only containing primitive
 *                      types (serializable)
 */
function strip(obj) {
    switch (obj) {
        case null:
        case undefined:
            return obj;
    }
    switch (obj.constructor) {
        case Boolean:
        case Number:
        case String:
        case Symbol:
            return obj;
        case Object:
            for (var key in obj) {
                var stripped = strip(obj[key], true);
                obj[key] = stripped;
            }
            return obj;
        default:
            return null;
    }
}

module.exports = strip;

},{}],28:[function(require,module,exports){
'use strict';

var Position = require('./Position');

/**
 * @class Align
 * @constructor
 * @component
 * @param {LocalDispatch} node LocalDispatch to be retrieved from corresponding Render Node of the Align component
 */

function Align(node) {
    Position.call(this, node);
}

/**
*
* stringifies Align
*
* @method
* @return {String} the name of the Component Class: 'Align'
*/
Align.toString = function toString() {
    return Align.toString;
};

Align.prototype = Object.create(Position.prototype);
Align.prototype.constructor = Align;

Align.prototype.update = function update() {
    this._node.setAlign(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Align.prototype.onUpdate = Align.prototype.update;

module.exports = Align;

},{"./Position":36}],29:[function(require,module,exports){
'use strict';

/**
 * @class Camera
 * @constructor
 * @component
 * @param {RenderNode} RenderNode to which the instance of Camera will be a component of
 */
function Camera(node) {
    this._node = node;
    this._projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
    this._focalDepth = 0;
    this._near = 0;
    this._far = 0;
    this._requestingUpdate = false;
    this._id = node.addComponent(this);
    this._viewTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    this._viewDirty = false;
    this._perspectiveDrty = false;
    this.setFlat();
}

Camera.FRUSTUM_PROJECTION = 0;
Camera.PINHOLE_PROJECTION = 1;
Camera.ORTHOGRAPHIC_PROJECTION = 2;

// Return the name of the Element Class: 'Camera'
Camera.toString = function toString() {
    return 'Camera';
};

Camera.prototype.getState = function getState() {
    return {
        component: this.constructor.toString(),
        projectionType: this._projectionType,
        focalDepth: this._focalDepth,
        near: this._near,
        far: this._far
    };
};


Camera.prototype.setState = function setState(state) {
    if (state.component === this.constructor.toString()) {
        this.set(state.projectionType, state.focalDepth, state.near, state.far);
        return true;
    }
    return false;
};

Camera.prototype.set = function set(type, depth, near, far) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._projectionType = type;
    this._focalDepth = depth;
    this._near = near;
    this._far = far;
};

Camera.prototype.setDepth = function setDepth(depth) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._perspectiveDirty = true;
    this._projectionType = Camera.PINHOLE_PROJECTION;
    this._focalDepth = depth;
    this._near = 0;
    this._far = 0;

    return this;
};

Camera.prototype.setFrustum = function setFrustum(near, far) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._perspectiveDirty = true;
    this._projectionType = Camera.FRUSTUM_PROJECTION;
    this._focalDepth = 0;
    this._near = near;
    this._far = far;

    return this;
};

Camera.prototype.setFlat = function setFlat() {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._perspectiveDirty = true;
    this._projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
    this._focalDepth = 0;
    this._near = 0;
    this._far = 0;

    return this;
};

Camera.prototype.onUpdate = function onUpdate() {
    this._requestingUpdate = false;

    var path = this._node.getLocation();

    this._node
        .sendDrawCommand('WITH')
        .sendDrawCommand(path);

    if (this._perspectiveDirty) {
        this._perspectiveDirty = true;
        
        switch (this._projectionType) {
            case Camera.FRUSTUM_PROJECTION:
                this._node.sendDrawCommand('FRUSTUM_PROJECTION');
                this._node.sendDrawCommand(this._near);
                this._node.sendDrawCommand(this._far);
                break;
            case Camera.PINHOLE_PROJECTION:
                this._node.sendDrawCommand('PINHOLE_PROJECTION');
                this._node.sendDrawCommand(this._focalDepth);
                break;
            case Camera.ORTHOGRAPHIC_PROJECTION:
                this._node.sendDrawCommand('ORTHOGRAPHIC_PROJECTION');
                break;
        }
    }

    if (this._viewDirty) {
        this._viewDirty = false;

        this._node.sendDrawCommand('CHANGE_VIEW_TRANSFORM');
        this._node.sendDrawCommand(this._viewTransform[0]);
        this._node.sendDrawCommand(this._viewTransform[1]);
        this._node.sendDrawCommand(this._viewTransform[2]);
        this._node.sendDrawCommand(this._viewTransform[3]);

        this._node.sendDrawCommand(this._viewTransform[4]);
        this._node.sendDrawCommand(this._viewTransform[5]);
        this._node.sendDrawCommand(this._viewTransform[6]);
        this._node.sendDrawCommand(this._viewTransform[7]);

        this._node.sendDrawCommand(this._viewTransform[8]);
        this._node.sendDrawCommand(this._viewTransform[9]);
        this._node.sendDrawCommand(this._viewTransform[10]);
        this._node.sendDrawCommand(this._viewTransform[11]);

        this._node.sendDrawCommand(this._viewTransform[12]);
        this._node.sendDrawCommand(this._viewTransform[13]);
        this._node.sendDrawCommand(this._viewTransform[14]);
        this._node.sendDrawCommand(this._viewTransform[15]);
    }
};


Camera.prototype.onTransformChange = function onTransformChange(transform) {
    var a = transform;
    this._viewDirty = true;

    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
    a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
    a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
    a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

    b00 = a00 * a11 - a01 * a10,
    b01 = a00 * a12 - a02 * a10,
    b02 = a00 * a13 - a03 * a10,
    b03 = a01 * a12 - a02 * a11,
    b04 = a01 * a13 - a03 * a11,
    b05 = a02 * a13 - a03 * a12,
    b06 = a20 * a31 - a21 * a30,
    b07 = a20 * a32 - a22 * a30,
    b08 = a20 * a33 - a23 * a30,
    b09 = a21 * a32 - a22 * a31,
    b10 = a21 * a33 - a23 * a31,
    b11 = a22 * a33 - a23 * a32,

    det = 1/(b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);

    this._viewTransform[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    this._viewTransform[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    this._viewTransform[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    this._viewTransform[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    this._viewTransform[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    this._viewTransform[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    this._viewTransform[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    this._viewTransform[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    this._viewTransform[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    this._viewTransform[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    this._viewTransform[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    this._viewTransform[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    this._viewTransform[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    this._viewTransform[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    this._viewTransform[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    this._viewTransform[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
}

module.exports = Camera;

},{}],30:[function(require,module,exports){
'use strict';

/**
 * Component to manage general event emission.
 *
 * @class EventEmitter
 * @param {Node} node The node to send events through.
 */
function EventEmitter(node) {
    this.node = node;
}

/**
 * Returns the name of EventEmitter as a string.
 *
 * @method toString
 * @static
 * @return {String} 'EventEmitter'
 */
EventEmitter.toString = function toString() {
    return 'EventEmitter';
};

/**
 * Emit an event with a payload.
 *
 * @method emit
 * @param {Object} event The event name.
 * @param {Object} payload The event payload.
 */
EventEmitter.prototype.emit = function emit(event, payload) {
    this.node.emit(event, payload);
    return this;
};

module.exports = EventEmitter;

},{}],31:[function(require,module,exports){
'use strict';

var CallbackStore = require('famous-utilities').CallbackStore;

/**
 * Component to handle general events.
 *
 * @class EventHandler
 * @param {Node} node The node on which this component is registered.
 */
function EventHandler (node, events) {
    this.node = node;
    this.id = node.addComponent(this);
    this._events = new CallbackStore();
}

/**
 * Returns the name of EventHandler as a string.
 *
 * @method toString
 * @static
 * @return {String} 'EventHandler'
 */
EventHandler.toString = function toString() {
    return 'EventHandler';
};

/**
 * Register a callback to be invoked on an event.
 *
 * @method on
 * @param {String} ev The event name.
 * @param {Function} cb The callback.
 */
EventHandler.prototype.on = function on (ev, cb) {
    this._events.on(ev, cb);
};

/**
 * Deregister a callback from an event.
 *
 * @method on
 * @param {String} ev The event name.
 * @param {Function} cb The callback.
 */
EventHandler.prototype.off = function off (ev, cb) {
    this._events.off(ev, cb);
};

/**
 * Trigger the callback associated with an event, passing in a payload.
 *
 * @method trigger
 * @param {String} ev The event name.
 * @param {Object} payload The event payload.
 */
EventHandler.prototype.trigger = function trigger (ev, payload) {
    this._events.trigger(ev, payload);
};

EventHandler.prototype.onReceive = EventHandler.prototype.trigger;

module.exports = EventHandler;

},{"famous-utilities":24}],32:[function(require,module,exports){
'use strict';

var CallbackStore = require('famous-utilities').CallbackStore;
var Vec2 = require('famous-math').Vec2;

var VEC_REGISTER = new Vec2();

var gestures = {drag: true, tap: true, rotate: true, pinch: true};
var progressbacks = [_processPointerStart, _processPointerMove, _processPointerEnd];

var touchEvents = ['touchstart', 'touchmove', 'touchend'];
var mouseEvents = ['mousedown', 'mousemove', 'mouseup'];
var methods = ['preventDefault'];
var touchProperties = [{targetTouches: {0: ['pageX', 'pageY', 'identifier'], 1: ['pageX', 'pageY', 'identifier']}}];
var mouseProperties = ['pageX', 'pageY'];

/**
 * Component to manage gesture events. Will track 'pinch', 'rotate', 'tap', and 'drag' events, on an
 * as-requested basis.
 *
 * @class GestureHandler
 * @param {LocalDispatch} node The node with which to register the handler.
 * @param {Object[]} events An array of event objects specifying .event and .callback properties.
 */

function GestureHandler (node, events) {
    this.node = node;
    this.id = node.addComponent(this);

    this._events = new CallbackStore();

    this.last1 = new Vec2();
    this.last2 = new Vec2();

    this.delta1 = new Vec2();
    this.delta2 = new Vec2();

    this.velocity1 = new Vec2();
    this.velocity2 = new Vec2();

    this.dist = 0;
    this.diff12 = new Vec2();

    this.center = new Vec2();
    this.centerDelta = new Vec2();
    this.centerVelocity = new Vec2();

    this.pointer1 = {
        position: this.last1,
        delta: this.delta1,
        velocity: this.velocity1,
    };

    this.pointer2 = {
        position: this.last2,
        delta: this.delta2,
        velocity: this.velocity2,
    };

    this.event = {
        status: null,
        time: 0,
        pointers: [],
        center: this.center,
        centerDelta: this.centerDelta,
        centerVelocity: this.centerVelocity,
        points: 0,
        current: 0
    };

    this.trackedPointerIDs = [-1, -1];
    this.timeOfPointer = 0;
    this.multiTap = 0;

    this.mice = [];

    this.gestures = [];
    this.options = {};
    this.trackedGestures = {};

    if (events) {
        for (var i = 0, len = events.length; i < len; i++) {
            this.on(events[i], events[i].callback);
        }
    }

    for (var i = 0 ; i < 3 ; i++) {
        var touchEvent = touchEvents[i];
        var mouseEvent = mouseEvents[i];
        node.addUIEvent(touchEvent);
        node.addUIEvent(mouseEvent);
    }

    node.addUIEvent('mouseleave');
}

GestureHandler.prototype.onReceive = function onReceive (event, payload) {
    var index = mouseEvents.indexOf(event);
    index = index !== -1 ? index : touchEvents.indexOf(event);
    
    if (index !== -1) progressbacks[index].call(this, payload);
    else if (event === 'mouseleave') _processMouseLeave.call(this, payload);
};

/**
 * Returns the name of GestureHandler as a string.
 *
 * @method toString
 * @static
 * @return {String} 'GestureHandler'
 */
GestureHandler.toString = function toString() {
    return 'GestureHandler';
};

/**
 * Register a callback to be invoked on an event.
 *
 * @method on
 * @param {Object|String} ev The event object or event name.
 * @param {Function} cb The callback.
 */
GestureHandler.prototype.on = function on(ev, cb) {
    var gesture = ev.event || ev;
    if (gestures[gesture]) {
        this.trackedGestures[gesture] = true;
        this.gestures.push(gesture);
        if (ev.event) this.options[gesture] = ev;
        this._events.on(gesture, cb);
    }
};

/**
 * Deregister a callback from an event.
 *
 * @method on
 * @param {String} ev The event name.
 * @param {Function} cb The callback.
 */
GestureHandler.prototype.off = function off(ev, cb) {
    this._events.off(gesture, cb);
};

/**
 * Trigger gestures in the order they were requested, if they occured.
 *
 * @method triggerGestures
 */
GestureHandler.prototype.triggerGestures = function() {
    var payload = this.event;
    for (var i = 0, len = this.gestures.length; i < len; i++) {
        var gesture = this.gestures[i];
        switch (gesture) {
            case 'rotate':
            case 'pinch':
                if (payload.points === 2) this.trigger(gesture, payload);
                break;
            case 'tap':
                if (payload.status === 'start') {
                    if (this.options['tap']) {
                        var pts = this.options['tap'].points || 1;
                        if(this.multiTap >= pts && payload.points >= pts) this.trigger(gesture, payload);
                    }
                    else this.trigger(gesture, payload);
                }
                break;
            default:
                this.trigger(gesture, payload);
                break;
        }
    }
};

/**
 * Trigger the callback associated with an event, passing in a payload.
 *
 * @method trigger
 * @param {String} ev The event name.
 * @param {Object} payload The event payload.
 */
GestureHandler.prototype.trigger = function trigger (ev, payload) {
    this._events.trigger(ev, payload);
};

/**
 * Process up to the first two touch/mouse move events. Exit out if the first two points are already being tracked.
 *
 * @method _processPointerStart
 * @private
 * @param {Object} e The event object.
 */
function _processPointerStart(e) {
    var t;
    if (!e.targetTouches) {
        this.mice[0] = e;
        t = this.mice;
        e.identifier = 1;
    }
    else t = e.targetTouches;

    if (t[0] && t[1] && this.trackedPointerIDs[0] === t[0].identifier && this.trackedPointerIDs[1] === t[1].identifier) {
        return;
    }

    this.event.time = Date.now();

    if (this.trackedPointerIDs[0] !== t[0].identifier) {
        if (this.trackedGestures['tap']) {
            var threshold = (this.options['tap'] && this.options['tap'].threshold) || 250;
            if (this.event.time - this.timeOfPointer < threshold) this.event.taps++;
            else this.event.taps = 1;
            this.timeOfPointer = this.event.time;
            this.multiTap = 1;
        }
        this.event.current = 1;
        this.event.points = 1;
        var id = t[0].identifier;
        this.trackedPointerIDs[0] = id;

        this.last1.set(t[0].pageX, t[0].pageY);
        this.velocity1.clear();
        this.delta1.clear();
        this.event.pointers.push(this.pointer1);
    }
    if (t[1] && this.trackedPointerIDs[1] !== t[1].identifier) {
        if (this.trackedGestures['tap']) {
            var threshold = (this.options['tap'] && this.options['tap'].threshold) || 250;
            if (this.event.time - this.timeOfPointer < threshold) this.multiTap = 2;
        }
        this.event.current = 2;
        this.event.points = 2;
        var id = t[1].identifier;
        this.trackedPointerIDs[1] = id;

        this.last2.set(t[1].pageX, t[1].pageY);
        this.velocity2.clear();
        this.delta2.clear();

        Vec2.add(this.last1, this.last2, this.center).scale(0.5);
        this.centerDelta.clear();
        this.centerVelocity.clear();

        Vec2.subtract(this.last2, this.last1, this.diff12);
        this.dist = this.diff12.length();

        if (this.trackedGestures['pinch']) {
            this.event.scale = this.event.scale || 1;
            this.event.scaleDelta = 0;
            this.event.scaleVelocity = 0;
        }
        if (this.trackedGestures['rotate']) {
            this.event.rotation = this.event.rotation || 0;
            this.event.rotationDelta = 0;
            this.event.rotationVelocity = 0;
        }
        this.event.pointers.push(this.pointer2);
    }

    this.event.status = 'start';
    if (this.event.points === 1) {
        this.center.copy(this.last1);
        this.centerDelta.clear();
        this.centerVelocity.clear();
        if (this.trackedGestures['pinch']) {
            this.event.scale = 1;
            this.event.scaleDelta = 0;
            this.event.scaleVelocity = 0;
        }
        if (this.trackedGestures['rotate']) {
            this.event.rotation = 0;
            this.event.rotationDelta = 0;
            this.event.rotationVelocity = 0;
        }
    }
    this.triggerGestures();
}

/**
 * Process up to the first two touch/mouse move events.
 *
 * @method _processPointerMove
 * @private
 * @param {Object} e The event object.
 */
function _processPointerMove(e) {
    var t;
    if (!e.targetTouches) {
        if (!this.event.current) return;
        this.mice[0] = e;
        t = this.mice;
        e.identifier = 1;
    }
    else t = e.targetTouches;

    var time = Date.now();
    var dt = time - this.event.time;
    if (dt === 0) return;
    var invDt = 1000 / dt;
    this.event.time = time;

    this.event.current = 1;
    this.event.points = 1;
    if (this.trackedPointerIDs[0] === t[0].identifier) {
        VEC_REGISTER.set(t[0].pageX, t[0].pageY);
        Vec2.subtract(VEC_REGISTER, this.last1, this.delta1);
        Vec2.scale(this.delta1, invDt, this.velocity1);
        this.last1.copy(VEC_REGISTER);

    }
    if (t[1]) {
        this.event.current = 2;
        this.event.points = 2;
        VEC_REGISTER.set(t[1].pageX, t[1].pageY);
        Vec2.subtract(VEC_REGISTER, this.last2, this.delta2);
        Vec2.scale(this.delta2, invDt, this.velocity2);
        this.last2.copy(VEC_REGISTER);

        Vec2.add(this.last1, this.last2, VEC_REGISTER).scale(0.5);
        Vec2.subtract(VEC_REGISTER, this.center, this.centerDelta);
        Vec2.add(this.velocity1, this.velocity2, this.centerVelocity).scale(0.5);
        this.center.copy(VEC_REGISTER);

        Vec2.subtract(this.last2, this.last1, VEC_REGISTER);

        if (this.trackedGestures['rotate']) {
            var dot = VEC_REGISTER.dot(this.diff12);
            var cross = VEC_REGISTER.cross(this.diff12);
            var theta = -Math.atan2(cross, dot);
            this.event.rotation += theta;
            this.event.rotationDelta = theta;
            this.event.rotationVelocity = theta * invDt;
        }

        var dist = VEC_REGISTER.length();
        var scale = dist / this.dist;
        this.diff12.copy(VEC_REGISTER);
        this.dist = dist;

        if (this.trackedGestures['pinch']) {
            this.event.scale *= scale;
            scale -= 1.0;
            this.event.scaleDelta = scale;
            this.event.scaleVelocity = scale * invDt;
        }
    }

    this.event.status = 'move';
    if (this.event.points === 1) {
        this.center.copy(this.last1);
        this.centerDelta.copy(this.delta1);
        this.centerVelocity.copy(this.velocity1);
        if (this.trackedGestures['pinch']) {
            this.event.scale = 1;
            this.event.scaleDelta = 0;
            this.event.scaleVelocity = 0;
        }
        if (this.trackedGestures['rotate']) {
            this.event.rotation = 0;
            this.event.rotationDelta = 0;
            this.event.rotationVelocity = 0;
        }
    }
    this.triggerGestures();
}

/**
 * Process up to the first two touch/mouse end events. Exit out if the two points being tracked are still active.
 *
 * @method _processPointerEnd
 * @private
 * @param {Object} e The event object.
 */
function _processPointerEnd(e) {
    var t;
    if (!e.targetTouches) {
        if (!this.event.current) return;
        this.mice.pop();
        t = this.mice;
    }
    else t = e.targetTouches;

    if (t[0] && t[1] && this.trackedPointerIDs[0] === t[0].identifier && this.trackedPointerIDs[1] === t[1].identifier) {
            return;
    }

    this.event.status = 'end';
    if (!t[0]) {
        this.event.current = 0;
        this.trackedPointerIDs[0] = -1;
        this.trackedPointerIDs[1] = -1;
        this.triggerGestures();
        this.event.pointers.pop();
        this.event.pointers.pop();
        return;
    }
    else if(this.trackedPointerIDs[0] !== t[0].identifier) {
        this.trackedPointerIDs[0] = -1;
        var id = t[0].identifier;
        this.trackedPointerIDs[0] = id;

        this.last1.set(t[0].pageX, t[0].pageY);
        this.velocity1.clear();
        this.delta1.clear();
    }
    if (!t[1]) {
        this.event.current = 1;
        this.trackedPointerIDs[1] = -1;
        this.triggerGestures();
        this.event.points = 1;
        this.event.pointers.pop();
    }
    else if (this.trackedPointerIDs[1] !== t[1].identifier) {
        this.trackedPointerIDs[1] = -1;
        this.event.points = 2;
        var id = t[1].identifier;
        this.trackedPointerIDs[1] = id;

        this.last2.set(t[1].pageX, t[1].pageY);
        this.velocity2.clear();
        this.delta2.clear();

        Vec2.add(this.last1, this.last2, this.center).scale(0.5);
        this.centerDelta.clear();
        this.centerVelocity.clear();

        Vec2.subtract(this.last2, this.last1, this.diff12);
        this.dist = this.diff12.length();
    }
}

/**
 * Treats a mouseleave event as a gesture end.
 *
 * @method _processMouseLeave
 * @private
 * @param {Object} e The event object.
 */
function _processMouseLeave(e) {
    if (this.event.current) {
        this.event.status = 'end';
        this.event.current = 0;
        this.trackedPointerIDs[0] = -1;
        this.triggerGestures();
        this.event.pointers.pop();
    }
}

module.exports = GestureHandler;

},{"famous-math":6,"famous-utilities":24}],33:[function(require,module,exports){
'use strict';

var Position = require('./Position');

/**
 * @class MountPoint
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the MountPoint component
 */
function MountPoint(node) {
    Position.call(this, node);
}

/**
*
* Stringifies MountPoint
*
* @method
* @return {String} the name of the Component Class: 'MountPoint'
*/
MountPoint.toString = function toString() {
    return 'MountPoint';
};

MountPoint.prototype = Object.create(Position.prototype);
MountPoint.prototype.constructor = MountPoint;

MountPoint.prototype.update = function update() {
    this._node.setMountPoint(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

MountPoint.prototype.onUpdate = MountPoint.prototype.update;

module.exports = MountPoint;

},{"./Position":36}],34:[function(require,module,exports){
'use strict';

var Transitionable = require('famous-transitions').Transitionable;


/**
 * @class Opacity
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Opacity component
 */
function Opacity(node) {
    this._node = node;
    this._id = node.addComponent(this);
    this._value = new Transitionable(1);

    this._requestingUpdate = false;
}

/**
*
* returns stringified Opacity
*
* @method
* @return {String} the name of the Component Class: 'Opacity'
*/
Opacity.toString = function toString() {
    return 'Opacity';
};

/**
*
* Retrieves state of Opacity
*
* @method
* @return {Object} contains component key which holds the stringified constructor 
* and value key which contains the numeric value
*/
Opacity.prototype.getState = function getState() {
    return {
        component: this.constructor.toString(),
        value: this._value.get()
    };
};

/**
*
* Setter for Opacity state
*
* @method
* @param {Object} state contains component key, which holds stringified constructor, and a value key, which contains a numeric value used to set opacity if the constructor value matches
* @return {Boolean} true if set is successful, false otherwise
*/
Opacity.prototype.setState = function setState(state) {
    if (this.constructor.toString() === state.component) {
        this.set(state.value);
        return true;
    }
    return false;
};

/**
*
* Setter for Opacity with callback
*
* @method
* @param {Number} value value used to set Opacity
* @param {Object} options options hash
* @param {Function} callback to be called following Opacity set
* @chainable
*/
Opacity.prototype.set = function set(value, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._value.set(value, options, callback);
    return this;
};

/**
*
* Getter for Opacity
*
* @method
* @return {Number}
*/
Opacity.prototype.get = function get() {
    return this._value.get();
};

/**
*
* Stops Opacity transition
*
* @method
* @chainable
*/
Opacity.prototype.halt = function halt() {
    this._value.halt();
    return this;
};

Opacity.prototype.isActive = function isActive(){
    return this._value.isActive();
};

Opacity.prototype.update = function update () {
    this._node.setOpacity(this._value.get());
    this._checkUpdate();    
};

Opacity.prototype.onUpdate = Opacity.prototype.update;

module.exports = Opacity;

},{"famous-transitions":11}],35:[function(require,module,exports){
'use strict';

var Position = require('./Position');

/**
 * @class Origin
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Origin component
 */
function Origin(node) {
    Position.call(this, node);
}


/**
*
* returns stringified Origin
*
* @method
* @return {String} the name of the Component Class: 'Origin'
*/
Origin.toString = function toString() {
    return 'Origin';
};

Origin.prototype = Object.create(Position.prototype);
Origin.prototype.constructor = Origin;

Origin.prototype.update = function update() {
    this._node.setOrigin(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Origin.prototype.onUpdate = Origin.prototype.update;

module.exports = Origin;

},{"./Position":36}],36:[function(require,module,exports){
'use strict';

var Transitionable = require('famous-transitions').Transitionable;

/**
 * @class Position
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Position component
 */
function Position(node) {
    this._node = node;
    this._id = node.addComponent(this);
  
    this._requestingUpdate = false;
    
    var initialPosition = node.getPosition();

    this._x = new Transitionable(initialPosition[0]);
    this._y = new Transitionable(initialPosition[1]);
    this._z = new Transitionable(initialPosition[2]);
}

/** 
*
* stringifies Position constructor
*
* @method
* @return {String} the definition of the Component Class: 'Position'
*/
Position.toString = function toString() {
    return 'Position';
};

/**
*
* Gets object containing stringified constructor, x, y, z coordinates
*
* @method
* @return {Object}
*/
Position.prototype.getValue = function getValue() {
    return {
        component: this.constructor.toString(),
        x: this._x.get(),
        y: this._y.get(),
        z: this._z.get()
    };
};

/**
*
* Setter for position coordinates
*
* @method
* @param {Object} state Object -- component: stringified constructor, x: number, y: number, z: number
* @return {Boolean} true on success
*/
Position.prototype.setState = function setState(state) {
    if (state.component === this.constructor.toString()) {
        this.set(state.x, state.y, state.z);
        return true;
    }
    return false;
};

/**
*
* Getter for X position
*
* @method
* @return {Number}
*/
Position.prototype.getX = function getX() {
    return this._x.get();
};

/**
*
* Getter for Y position
*
* @method
* @return {Number}
*/
Position.prototype.getY = function getY() {
    return this._y.get();
};

/**
*
* Getter for Z position
*
* @method
* @return {Number}
*/
Position.prototype.getZ = function getZ() {
    return this._z.get();
};

/**
*
* Getter for any active coordinates
*
* @method
* @return {Boolean}
*/
Position.prototype.isActive = function isActive() {
    return this._x.isActive() || this._y.isActive() || this._z.isActive();
};

Position.prototype._checkUpdate = function _checkUpdate() {
    if (this.isActive()) this._node.requestUpdateOnNextTick(this._id);
    else this._requestingUpdate = false;
};


Position.prototype.update = function update () {
    this._node.setPosition(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

/** 
*
* If true, component is to be updated on next engine tick
*
* @method
*/
Position.prototype.onUpdate = Position.prototype.update;

/** 
*
* Setter for X position
*
* @method
* @param {Number} val used to set x coordinate
* @param {Object} options options hash
* @param {Function} callback function to execute after setting X
* @chainable
*/
Position.prototype.setX = function setX(val, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._x.set(val, options, callback);
    return this;
};

/** 
*
* Setter for Y position
*
* @method
* @param {Number} val used to set y coordinate
* @param {Object} options options hash
* @param {Function} callback function to execute after setting Y
* @chainable
*/
Position.prototype.setY = function setY(val, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._y.set(val, options, callback);
    return this;
};

/** 
*
* Setter for Z position
*
* @method
* @param {Number} val used to set z coordinate
* @param {Object} options options hash
* @param {Function} callback function to execute after setting Z
* @chainable
*/
Position.prototype.setZ = function setZ(val, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._z.set(val, options, callback);
    return this;
};


/**
*
* Setter for XYZ position with callback
*
* @method
* @param {Number} x used to set x coordinate
* @param {Number} y used to set y coordinate
* @param {Number} z used to set z coordinate
* @param {Object} options options hash
* @param {Function} callback function to execute after setting each coordinate
* @chainable
*/
Position.prototype.set = function set(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    if (x != null) this._x.set(x, options, xCallback);
    if (y != null) this._y.set(y, options, yCallback);
    if (z != null) this._z.set(z, options, zCallback);

    return this;
};

/**
*
* Stops transition of Position component
*
* @method
* @chainable
*/
Position.prototype.halt = function halt() {
    this._x.halt();
    this._y.halt();
    this._z.halt();
    return this;
};

module.exports = Position;

},{"famous-transitions":11}],37:[function(require,module,exports){
'use strict';

var Position = require('./Position');

/**
 * @class Rotation
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Rotation component
 */
function Rotation(node) {
    Position.call(this, node);
}

/**
*
* stringifies Rotation
*
* @method
* @return {String} the name of the Component Class: 'Rotation'
*/
Rotation.toString = function toString() {
    return 'Rotation';
};

Rotation.prototype = Object.create(Position.prototype);
Rotation.prototype.constructor = Rotation;

Rotation.prototype.update = function update() {
    this._node.setRotation(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Rotation.prototype.onUpdate = Rotation.prototype.update;

module.exports = Rotation;

},{"./Position":36}],38:[function(require,module,exports){
'use strict';

var Position = require('./Position');

/**
 * @class Scale
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Scale component
 */
function Scale(node) {
    Position.call(this, node);
    this._x.set(1);
    this._y.set(1);
    this._z.set(1);
}

/**
*
* stringifies Scale
*
* @method 
* @return {String} the name of the Component Class: 'Scale'
*/
Scale.toString = function toString() {
    return 'Scale';
};

Scale.prototype = Object.create(Position.prototype);
Scale.prototype.constructor = Scale;

Scale.prototype.update = function update() {
    this._node.setScale(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Scale.prototype.onUpdate = Scale.prototype.update;

module.exports = Scale;

},{"./Position":36}],39:[function(require,module,exports){
'use strict';

var Transitionable = require('famous-transitions').Transitionable;
var CoreSize = require('famous-core').Size;

/**
 * Size component used for managing the size of the underlying RenderContext.
 * Supports absolute and relative (proportional and differential) sizing.
 * 
 * @class Size
 * @constructor
 * @component
 * 
 * @param {LocalDispatch} node LocalDispatch to be retrieved from
 *                                 corresponding RenderNode of the Size
 *                                 component
 */
function Size(node) {
    this._node = node;
    this._id = node.addComponent(this);
    this._requestingUpdate = false;
    this._proportional = {
        x: new Transitionable(1),
        y: new Transitionable(1),
        z: new Transitionable(1)
    };
    this._differential = {
        x: new Transitionable(0),
        y: new Transitionable(0),
        z: new Transitionable(0)
    };
    this._absolute = {
        x: new Transitionable(0),
        y: new Transitionable(0),
        z: new Transitionable(0)
    };
}

Size.RELATIVE = CoreSize.RELATIVE;
Size.ABSOLUTE = CoreSize.ABSOLUTE;
Size.RENDER = CoreSize.RENDER;
Size.DEFAULT = CoreSize.DEFAULT;

Size.prototype.setMode = function setMode(x, y, z) {
    this._node.setSizeMode(x, y, z);
    return this;
};

/** 
* Stringifies Size.
*
* @method toString
* 
* @return {String} `Size`
*/
Size.toString = function toString() {
    return 'Size';
};

/**
 * @typedef absoluteSizeState
 * @type {Object}
 * @property {String} type current type of sizing being applied ('absolute')
 * @property {String} component component name ('Size')
 * @property {number} x
 * @property {number} y
 * @property {number} z
 */

/**
 * @typedef relativeSizeState
 * @type {Object}
 * @property {String} type current type of sizing being applied ('relative')
 * @property {String} component component name ('Size')
 * @property {Object} differential
 * @property {number} differential.x
 * @property {number} differential.y
 * @property {number} differential.z
 * @property {Object} proportional
 * @property {number} proportional.x
 * @property {number} proportional.y
 * @property {number} proportional.z
 */

/**
* Returns serialized state of the component.
*
* @method getState
* 
* @return {absoluteSizeState|relativeSizeState}
*/
Size.prototype.getState = function getState() {
    return {
        sizeMode: this._node.value.sizeMode,
        absolute: {
            x: this._absolute.x.get(),
            y: this._absolute.y.get(),
            z: this._absolute.z.get()
        },
        differential: {
            x: this._differential.x.get(),
            y: this._differential.y.get(),
            z: this._differential.z.get()
        },
        proportional: {
            x: this._proportional.x.get(),
            y: this._proportional.y.get(),
            z: this._proportional.z.get()
        }
    };
};

/**
* Updates state of component.
*
* @method setState
* 
* @param {absoluteSizeState|relativeSizeState} state state encoded in same
*                                                    format as state retrieved
*                                                    through `getState`
* @return {Boolean}                                  boolean indicating
*                                                    whether the new state has
*                                                    been applied
*/
Size.prototype.setState = function setState(state) {
    if (state.component === this.constructor.toString()) {
        this.setMode.apply(this, state.sizeMode);
        if (state.absolute) {
            this.setAbsolute(state.absolute.x, state.absolute.y, state.absolute.z);
        }
        if (state.differential) {
            this.setAbsolute(state.differential.x, state.differential.y, state.differential.z);
        }
        if (state.proportional) {
            this.setAbsolute(state.proportional.x, state.proportional.y, state.proportional.z);
        }
    }
    return false;
};

Size.prototype._isActive = function _isActive(type) {
    return type.x.isActive() || type.y.isActive() || type.z.isActive();
};

Size.prototype.isActive = function isActive(){
    return (
        this._isActive(this._absolute) ||
        this._isActive(this._proportional) ||
        this._isActive(this._differential)
    );
};

Size.prototype.onUpdate = function onUpdate() {
    var abs = this._absolute;
    this._node.setAbsoluteSize(
        abs.x.get(),
        abs.y.get(),
        abs.z.get()
    );
    var prop = this._proportional;
    var diff = this._differential;
    this._node.setProportionalSize(
        prop.x.get(),
        prop.y.get(),
        prop.z.get()
    );
    this._node.setDifferentialSize(
        diff.x.get(),
        diff.y.get(),
        diff.z.get()
    );

    if (this.isActive()) this._node.requestUpdateOnNextTick(this._id);
    else this._requestingUpdate = false;
};


/**
* Applies absolute size.
*
* @method setAbsolute
* @chainable
* 
* @param {Number} x used to set absolute size in x-direction (width)
* @param {Number} y used to set absolute size in y-direction (height)
* @param {Number} z used to set absolute size in z-direction (depth)
* @param {Object} options options hash
* @param {Function} callback callback function to be executed after the
*                            transitions have been completed
* @return {Size} this
*/
Size.prototype.setAbsolute = function setAbsolute(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    var abs = this._absolute;
    if (x != null) {
        abs.x.set(x, options, callback);
    }
    if (y != null) {
        abs.y.set(y, options, callback);
    }
    if (z != null) {
        abs.z.set(z, options, callback);
    }
};

/**
* Applies proportional size.
*
* @method setProportional
* @chainable
* 
* @param {Number} x used to set proportional size in x-direction (width)
* @param {Number} y used to set proportional size in y-direction (height)
* @param {Number} z used to set proportional size in z-direction (depth)
* @param {Object} options options hash
* @param {Function} callback callback function to be executed after the
*                            transitions have been completed
* @return {Size} this
*/
Size.prototype.setProportional = function setProportional(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    var prop = this._proportional;
    if (x != null) {
        prop.x.set(x, options, callback);
    }
    if (y != null) {
        prop.y.set(y, options, callback);
    }
    if (z != null) {
        prop.z.set(z, options, callback);
    }
    return this;
};

/**
* Applies differential size to Size component.
*
* @method setDifferential
* @chainable
* 
* @param {Number} x used to set differential size in x-direction (width)
* @param {Number} y used to set differential size in y-direction (height)
* @param {Number} z used to set differential size in z-direction (depth)
* @param {Object} options options hash
* @param {Function} callback callback function to be executed after the
*                            transitions have been completed
*/
Size.prototype.setDifferential = function setDifferential(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    var diff = this._differential;
    if (x != null) {
        diff.x.set(x, options, callback);
    }
    if (y != null) {
        diff.y.set(y, options, callback);
    }
    if (z != null) {
        diff.z.set(z, options, callback);
    }
    return this;
};

/**
* Retrieves the computed size applied to the underlying RenderContext.
*
* @method get
* 
* @return {Number[]} size three dimensional computed size
*/
Size.prototype.get = function get () {
    return this._node.getSize();
};

/**
 * Halts all currently active size transitions.
 * 
 * @method halt
 * @chainable
 * 
 * @return {Size} this
 */
Size.prototype.halt = function halt () {
    this._proportional.x.halt();
    this._proportional.y.halt();
    this._proportional.z.halt();
    this._differential.x.halt();
    this._differential.y.halt();
    this._differential.z.halt();
    this._absolute.x.halt();
    this._absolute.y.halt();
    this._absolute.z.halt();
    return this;
};

module.exports = Size;

},{"famous-core":50,"famous-transitions":11}],40:[function(require,module,exports){
'use strict';

var CallbackStore = require('famous-utilities').CallbackStore;

/**
 * Component to manage DOM events. When registering an event, the user may specify .methods and
 * .properties to preprocess the event object.
 *
 * @class UIEventHandler
 * @param {LocalDispatch} dispatch The dispatch with which to register the handler.
 * @param {Object[]} events An array of event objects specifying .event and .callback properties.
 */
function UIEventHandler (dispatch, events) {
    this.dispatch = dispatch;
    this._events = new CallbackStore();

    if (events) {
        for (var i = 0, len = events.length; i < len; i++) {
            this.on(events[i], events[i].callback);
        }
    }
}

/**
 * Returns the name of UIEventHandler as a string.
 *
 * @method toString
 * @static
 * @return {String} 'UIEventHandler'
 */
UIEventHandler.toString = function toString() {
    return 'UIEventHandler';
};

/**
 * Register a callback to be invoked on an event.
 *
 * @method on
 * @param {Object|String} ev The event object or event name.
 * @param {Function} cb The callback.
 */
UIEventHandler.prototype.on = function on(ev, cb) {
    var renderables = this.dispatch.getRenderables();
    var eventName = ev.event || ev;
    var methods = ev.methods;
    var properties = ev.properties;
    for (var i = 0, len = renderables.length; i < len; i++) {
        if (renderables[i].on) renderables[i].on(eventName, methods, properties);
    }
    this._events.on(eventName, cb);
    this.dispatch.registerTargetedEvent(eventName, this.trigger.bind(this, eventName));
};

/**
 * Deregister a callback from an event.
 *
 * @method on
 * @param {String} ev The event name.
 * @param {Function} cb The callback.
 */
UIEventHandler.prototype.off = function off(ev, cb) {
    this._events.off(ev, cb);
    this.dispatch.deregisterGlobalEvent(ev, this.trigger.bind(this, ev))
};

/**
 * Trigger the callback associated with an event, passing in a payload.
 *
 * @method trigger
 * @param {String} ev The event name.
 * @param {Object} payload The event payload.
 */
UIEventHandler.prototype.trigger = function trigger (ev, payload) {
    this._events.trigger(ev, payload);
};

module.exports = UIEventHandler;

},{"famous-utilities":24}],41:[function(require,module,exports){
'use strict';

module.exports = {
    Align: require('./Align'),
    Camera: require('./Camera'),
    EventEmitter: require('./EventEmitter'),
    EventHandler: require('./EventHandler'),
    GestureHandler: require('./GestureHandler'),
    UIEventHandler: require('./UIEventHandler'),
    MountPoint: require('./MountPoint'),
    Opacity: require('./Opacity'),
    Origin: require('./Origin'),
    Position: require('./Position'),
    Rotation: require('./Rotation'),
    Scale: require('./Scale'),
    Size: require('./Size')
};

},{"./Align":28,"./Camera":29,"./EventEmitter":30,"./EventHandler":31,"./GestureHandler":32,"./MountPoint":33,"./Opacity":34,"./Origin":35,"./Position":36,"./Rotation":37,"./Scale":38,"./Size":39,"./UIEventHandler":40}],42:[function(require,module,exports){
'use strict';

/**
 * Equivalent of an Engine in the Worker Thread. Used to synchronize and manage
 * time across different Threads.
 *
 * @class  Clock
 * @constructor
 * @private
 */
function Clock () {
    this._time = 0;
    this._frame = 0;
    this._timerQueue = [];
    this._updatingIndex = 0;
}

/**
 * Updates the internal clock time.
 *
 * @method  step
 * @chainable
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 * @return {Clock}       this
 */
Clock.prototype.step = function step (time) {
    this._frame++;
    this._time = time;
    for (var i = 0; i < this._timerQueue.length; i++) {
        if (this._timerQueue[i](this._time)) {
            this._timerQueue.splice(i, 1);
        }
    }
    return this;
};

/**
 * Returns the internal clock time.
 *
 * @method  getTime
 * @deprecated Use #now instead
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 */
Clock.prototype.getTime = function getTime() {
    return this._time;
};

/**
 * Returns the internal clock time.
 *
 * @method  now
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 */
Clock.prototype.now = function now () {
    return this._time;
};

/**
 * Returns the number of frames elapsed so far.
 *
 * @method getFrame
 * 
 * @return {Number} frames
 */
Clock.prototype.getFrame = function getFrame () {
    return this._frame;
};

/**
 * Wraps a function to be invoked after a certain amount of time.
 * After a set duration has passed, it executes the function and
 * removes it as a listener to 'prerender'.
 *
 * @method setTimeout
 *
 * @param {Function} callback function to be run after a specified duration
 * @param {Number} delay milliseconds from now to execute the function
 *
 * @return {Function} timer function used for Clock#clearTimer
 */
Clock.prototype.setTimeout = function (callback, delay) {
    var params = Array.prototype.slice.call(arguments, 2);
    var startedAt = this._time;
    var timer = function(time) {
        if (time - startedAt >= delay) {
            callback.apply(null, params);
            return true;
        }
        return false;
    };
    this._timerQueue.push(timer);
    return timer;
};


/**
 * Wraps a function to be invoked after a certain amount of time.
 *  After a set duration has passed, it executes the function and
 *  resets the execution time.
 *
 * @method setInterval
 *
 * @param {Function} callback function to be run after a specified duration
 * @param {Number} duration interval to execute function in milliseconds
 *
 * @return {Function} timer function used for Clock#clearTimer
 */
Clock.prototype.setInterval = function setInterval(callback, delay) {
    var params = Array.prototype.slice.call(arguments, 2);
    var startedAt = this._time;
    var timer = function(time) {
        if (time - startedAt >= delay) {
            callback.apply(null, params);
            startedAt = time;
        }
        return false;
    };
    this._timerQueue.push(timer);
    return timer;
};

/**
 * Removes previously via `Clock#setTimeout` or `Clock#setInterval`
 * registered callback function
 *
 * @method clearTimer
 * @chainable
 * 
 * @param  {Function} callback  previously by `Clock#setTimeout` or
 *                              `Clock#setInterval` returned callback function
 * @return {Clock}              this
 */
Clock.prototype.clearTimer = function (timer) {
    var index = this._timerQueue.indexOf(timer);
    if (index !== -1) {
        this._timerQueue.splice(index, 1);
    }
    return this;
};

/**
 * Wraps a function to be invoked after a certain amount of time.
 *  After a set duration has passed, it executes the function and
 *  resets the execution time.
 *
 * @method setInterval
 *
 * @param {Function} callback function to be run after a specified duration
 * @param {Number} duration interval to execute function in milliseconds
 *
 * @return {Function} decorated passed in callback function
 */
Clock.prototype.setInterval = function setInterval(callback, delay) {
    var params = Array.prototype.slice.call(arguments, 2);
    var startedAt = this._time;

    var looper = {
        update: function update (time) {
            if (time - startedAt >= delay) {
                callback.apply(this, params);
                startedAt = time;
            }
        }
    };
    callback.__looper = looper;
    this.update(looper);
    return callback;
};


module.exports = Clock;

},{}],43:[function(require,module,exports){
'use strict';

var Dispatch = require('./Dispatcher');
var Node = require('./Node');
var Size = require('./Size');

/**
 * Context is the bottom of the scene graph. It is it's own
 * parent and provides the global updater to the scene graph.
 *
 * @class Context
 * @constructor
 *
 * @param {String} selector a string which is a dom selector
 *                 signifying which dom element the context
 *                 should be set upon
 * @param {Famous} a class which conforms to Famous' interface
 *                 it needs to be able to send methods to
 *                 the renderers and update nodes in the scene graph
 */
function Context (selector, updater) {
    if (!selector) throw new Error('Context needs to be created with a DOM selector');
    if (!updater) throw new Error('Context needs to be created with a class like Famous');

    Node.call(this);         // Context inherits from node

    this._updater = updater; // The updater that will both
                             // send messages to the renderers
                             // and update dirty nodes 

    this._dispatch = new Dispatch(this); // instantiates a dispatcher
                                         // to send events to the scene
                                         // graph below this context
    
    this._selector = selector; // reference to the DOM selector
                               // that represents the elemnent
                               // in the dom that this context
                               // inhabits

    this.onMount(this, selector); // Mount the context to itself
                                  // (it is its own parent)
    
    this._updater                  // message a request for the dom
        .message('NEED_SIZE_FOR')  // size of the context so that
        .message(selector);        // the scene graph has a total size

    this.show(); // the context begins shown (it's already present in the dom)

}

// Context inherits from node
Context.prototype = Object.create(Node.prototype);
Context.prototype.constructor = Context;

/**
 * Context getUpdater function returns the passed in updater
 *
 * @return {Famous} the updater for this Context
 */
Context.prototype.getUpdater = function getUpdater () {
    return this._updater;
};

/**
 * Returns the selector that the context was instantiated with
 *
 * @return {String} dom selector
 */
Context.prototype.getSelector = function getSelector () {
    return this._selector;
};

/**
 * Returns the dispatcher of the context. Used to send events
 * to the nodes in the scene graph.
 *
 * @return {Dispatcher} the Context's Dispatcher
 */
Context.prototype.getDispatch = function getDispatch () {
    return this._dispatch;
};

/**
 * Receives an event. If the event is 'CONTEXT_RESIZE' it sets the size of the scene
 * graph to the payload, which must be an array of numbers of at least
 * length three representing the pixel size in 3 dimensions.
 *
 * @param {String} event
 * @param {*} payload
 */
Context.prototype.onReceive = function onReceive (event, payload) {
    // TODO: In the future the dom element that the context is attached to
    // should have a representation as a component. It would be render sized
    // and the context would receive its size the same way that any render size
    // component receives its size.
    if (event === 'CONTEXT_RESIZE') {
        
        if (payload.length < 2) 
            throw new Error(
                    'CONTEXT_RESIZE\'s payload needs to be at least a pair' +
                    ' of pixel sizes'
            );

        this.setSizeMode(Size.ABSOLUTE, Size.ABSOLUTE, Size.ABSOLUTE);
        this.setAbsoluteSize(payload[0],
                             payload[1],
                             payload[2] ? payload[2] : 0);

    }
};

module.exports = Context;


},{"./Dispatcher":44,"./Node":47,"./Size":48}],44:[function(require,module,exports){
'use strict';

// TODO: Dispatcher should be generalized so that it can work on any Node
// not just Contexts.


/**
 * The Dispatcher class is used to propogate events down the
 * scene graph.
 *
 * @param {Context} Context on which it operates
 */
function Dispatcher (context) {

    if (!context) throw new Error('Dispatch needs to be instantiated on a node');
    
    this._context = context; // A reference to the context
                             // on which the dispatcher
                             // operates

    this._queue = []; // The queue is used for two purposes
                      // 1. It is used to list indicies in the
                      //    Nodes path which are then used to lookup
                      //    a node in the scene graph.
                      // 2. It is used to assist dispatching
                      //    such that it is possible to do a breadth first
                      //    traversal of the scene graph.
}

/**
 * lookupNode takes a path and returns the node at the location specified
 * by the path, if one exists. If not, it returns undefined.
 *
 * @param {String} The location of the node specified by its path
 * 
 * @return {Node | undefined} The node at the requested path
 */
Dispatcher.prototype.lookupNode = function lookupNode (location) {
    if (!location) throw new Error('lookupNode must be called with a path');

    var path = this._queue;

    _splitTo(location, path);
    
    if (path[0] !== this._context.getSelector()) return void 0;

    var children = this._context.getChildren();
    var child;
    var i = 1;
    path[0] = this._context;

    while (i < path.length) {
        child = children[path[i]];
        path[i] = child;
        if (child) children = child.getChildren();
        else return void 0;
        i++;
    }

    return child;
};

/**
 * dispatch takes an event name and a payload and dispatches it to the
 * entire scene graph below the node that the dispatcher is on. The nodes
 * receive the events in a breadth first traversal, meaning that parents
 * have the opportunity to react to the event before children.
 *
 * @param {String} event name
 * @param {Any} payload
 */
Dispatcher.prototype.dispatch = function dispatch (event, payload) {
    if (!event) throw new Error('dispatch requires an event name as it\'s first argument');

    var queue = this._queue;
    var item;
    var i;
    var len;
    var children;

    queue.length = 0;
    queue.push(this._context);

    while (queue.length) {
        item = queue.shift();
        if (item.onReceive) item.onReceive(event, payload);
        children = item.getChildren();
        for (i = 0, len = children.length ; i < len ; i++) queue.push(children[i]);
    }
};

/**
 * dispatchUIevent takes a path, an event name, and a payload and dispatches them in
 * a manner anologous to DOM bubbling. It first traverses down to the node specified at
 * the path. That node receives the event first, and then every ancestor receives the event
 * until the context.
 *
 * @param {String} the path of the node
 * @param {String} the event name
 * @param {Any} the payload
 */
Dispatcher.prototype.dispatchUIEvent = function dispatchUIEvent (path, event, payload) {
    if (!path) throw new Error('dispatchUIEvent needs a valid path to dispatch to');
    if (!event) throw new Error('dispatchUIEvent needs an event name as its second argument');

    var queue = this._queue;
    var node;

    payload.node = this.lookupNode(path); // After this call, the path is loaded into the queue
                                          // (lookUp node doesn't clear the queue after the lookup)

    while (queue.length) {
        node = queue.pop(); // pop nodes off of the queue to move up the ancestor chain.
        if (node.onReceive) node.onReceive(event, payload);
    }
};

/**
 * _splitTo is a private method which takes a path and splits it at every '/'
 * pushing the result into the supplied array. This is a destructive change.
 *
 * @private
 * @param {String} the specified path
 * @param {Array} the array to which the result should be written
 */
function _splitTo (string, target) {
    target.length = 0; // clears the array first.
    var last = 0;

    for (var i = 0, len = string.length ; i < len ; i++) {
        if (string[i] === '/') {
            target.push(string.substring(last, i));
            last = i + 1;
        }
    }

    if (i - last > 0) target.push(string.substring(last, i));

    return target;
}


module.exports = Dispatcher;


},{}],45:[function(require,module,exports){
// TODO: This will wrap UI events as the bubble in the scene graph to allow .stopPropogation() to be called

},{}],46:[function(require,module,exports){
'use strict';

// Check to see if we're in a worker
var isWorker = typeof self !== 'undefined' && self.window !== self;

var Clock = require('./Clock');
var Context = require('./Context');

/**
 * Famous has two responsibilities, one to act as the highest level
 * updater and another to send messages over to the renderers. It is
 * a singleton.
 */
function Famous () {
    this._updateQueue = []; // The updateQueue is a place where nodes
                            // can place themselves in order to be
                            // updated on the frame.
    
    this._nextUpdateQueue = []; // the nextUpdateQueue is used to queue
                                // updates for the next tick.
                                // this prevents infinite loops where during
                                // an update a node continuously puts itself
                                // back in the update queue.

    this._contexts = {}; // a hash of all of the context's that this famous
                         // is responsible for.

    this._messages = []; // a queue of all of the draw commands to send to the
                         // the renderers this frame.

    this._inUpdate = false; // when the famous is updating this is true.
                            // all requests for updates will get put in the
                            // nextUpdateQueue

    this._clock = new Clock(); // a clock to keep track of time for the scene
                               // graph.

    var _this = this;
    if (isWorker)
        self.addEventListener('message', function (ev) {
            _this.postMessage(ev.data);
        });
}

/**
 * _update is the body of the update loop. The frame consists of
 * pulling in appending the nextUpdateQueue to the currentUpdate queue
 * then moving through the updateQueue and calling onUpdate with the current
 * time on all nodes. While _update is called _inUpdate is set to true and 
 * all requests to be placed in the update queue will be forwarded to the 
 * nextUpdateQueue.
 *
 * @param {Number} The current time
 */
Famous.prototype._update = function _update (time) {
    this._inUpdate = true;
    var nextQueue = this._nextUpdateQueue;
    var queue = this._updateQueue;
    var item;

    while (nextQueue.length) queue.unshift(nextQueue.pop());

    while (queue.length) {
        item = queue.shift();
        if (item && item.onUpdate) item.onUpdate(time);
    }

    this._inUpdate = false;
};

Famous.prototype.requestUpdate = function requestUpdate (requester) {
    if (!requester)
        throw new Error(
            'requestUpdate must be called with a class to be updated'
        );

    if (this._inUpdate) this.requestUpdateOnNextTick(requester);
    else this._updateQueue.push(requester);
};

Famous.prototype.requestUpdateOnNextTick = function requestUpdateOnNextTick (requester) {
    this._nextUpdateQueue.push(requester);
};

Famous.prototype.postMessage = function postMessage (messages) {
    if (!messages)
        throw new Error(
            'postMessage must be called with an array of messages'
        );

    while (messages.length > 0) {
        var command = messages.shift();
        switch (command) {
            case 'WITH':
                this.handleWith(messages);
                break;
            case 'FRAME':
                this.handleFrame(messages);
                break;
            case 'INVOKE':
                this.handleInvoke(message);
                break;
            default:
                throw new Error('received unknown command: ' + command);
                break;
        }
    }
    return this;
};

Famous.prototype.handleWith = function handleWith (messages) {
    var path = messages.shift();
    var command = messages.shift();
    var i;
    var len;

    switch (command) {
        case 'TRIGGER':
            var type = messages.shift();
            var ev = messages.shift();
            
            this.getContext(path).getDispatch().dispatchUIEvent(path, type, ev);
            break;
        default:
            throw new Error('received unknown command: ' + command);
            break;
    }
    return this;
};

Famous.prototype.handleFrame = function handleFrame (messages) {
    if (!messages) throw new Error('handleFrame must be called with an array of messages');
    if (!messages.length) throw new Error('FRAME must be sent with a time');

    this.step(messages.shift());
    return this;
};

Famous.prototype.step = function step (time) {
    if (time == null) throw new Error('step must be called with a time');

    this._clock.step(time);

    this._update(time);

    if (this._messages.length) {
        if (isWorker) self.postMessage(this._messages);
        else this.onmessage(this._messages);
    }
    
    this._messages.length = 0;

    return this;
};

Famous.prototype.getContext = function getContext (selector) {
    if (!selector) throw new Error('getContext must be called with a selector');

    return this._contexts[selector.split('/')[0]];
};

Famous.prototype.getClock = function getClock () {
    return this._clock;
};

Famous.prototype.message = function message (command) {
    this._messages.push(command);
    return this;
};

Famous.prototype.createContext = function createContext (selector) {
    selector = selector || 'body';

    if (this._contexts[selector]) this._contexts[selector].dismount();
    this._contexts[selector] = new Context(selector, this);
    return this._contexts[selector];
};

module.exports = new Famous();


},{"./Clock":42,"./Context":43}],47:[function(require,module,exports){
'use strict';

var Transform = require('./Transform');
var Size = require('./Size');

var TRANSFORM_PROCESSOR = new Transform();
var SIZE_PROCESSOR = new Size();

var IDENT = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
];

var ONES = [1, 1, 1];

function Node () {
    this._calculatedValues = {
        transform: new Float32Array(IDENT),
        size: new Float32Array(3)
    };

    this._requestingUpdate = false;
    this._inUpdate = false;

    this._updateQueue = [];
    this._nextUpdateQueue = [];

    this._freedComponentIndicies = [];
    this._components = [];

    this._freedChildIndicies = [];
    this._children = [];

    this._parent = null;
    this._globalUpdater = null;

    this.value = new Node.Spec();
}

Node.RELATIVE_SIZE = Size.RELATIVE;
Node.ABSOLUTE_SIZE = Size.ABSOLUTE;
Node.RENDER_SIZE = Size.RENDER;
Node.DEFAULT_SIZE = Size.DEFAULT;

Node.Spec = function Spec () {
    this.location = null;
    this.showState = {
        mounted: false,
        shown: false,
        opacity: 1
    };
    this.offsets = {
        mountPoint: new Float32Array(3),
        align: new Float32Array(3),
        origin: new Float32Array(3)
    };
    this.vectors = {
        position: new Float32Array(3),
        rotation: new Float32Array(3),
        scale: new Float32Array(ONES)
    };
    this.size = {
        sizeMode: new Float32Array([Size.RELATIVE, Size.RELATIVE, Size.RELATIVE]),
        proportional: new Float32Array(ONES),
        differential: new Float32Array(3),
        absolute: new Float32Array(3),
        render: new Float32Array(3)
    };
    this.UIEvents = [];
};

/**
 * @method getContext
 * @chainable
 * 
 * @deprecated Node can be used directly instead!
 * @return {Node} this
 */
Node.prototype.getContext = function getContext () {
    console.warn(
        'Node#getContext is deprecated!\n' +
        'Nodes can be used directly!'
    );
    return this;
};

/**
 * @method getDispatch
 * @chainable
 * 
 * @deprecated Node can be used directly instead!
 * @return {Node} this
 */
Node.prototype.getDispatch = function getDispatch () {
    console.warn(
        'Node#getDispatch is deprecated!\n' +
        'Component constructors accept a Node instead!' +
        'Use new Component(node) instead of new Component(node.getDispatch())!'
    );
    return this;
};

/**
 * @method getRenderProxy
 * @chainable
 * 
 * @deprecated Node can be used directly instead!
 * @return {Node} this
 */
Node.prototype.getRenderProxy = function getRenderProxy () {
    console.warn(
        'Node#getRenderProxy is deprecated!\n' +
        'RenderProxy functionality has been merged into Node!'
    );
    return this;
};

/**
 * @method getRenderPath
 * @chainable
 *
 * @deprecated Use #getLocation()
 * @return {string} render path
 */
Node.prototype.getRenderPath = function getRenderPath () {
    console.warn(
        'Node#getRenderPath is deprecated!\n' +
        'Use Node#getLocation instead!'
    );
    return this.getLocation();
}

/**
 * @method addRenderable
 * @chainable
 *
 * @deprecated Use addComponent
 * @param {*} component component to be added
 * @return this
 */
Node.prototype.addRenderable = function addRenderable (component) {
    console.warn("Node#addRenderable is depricated!\n use node.addComponent instead");
    this.addComponent(component);
    return this;
};


Node.prototype.getLocation = function getLocation () {
    return this.value.location;
};

Node.prototype.getId = Node.prototype.getLocation;

Node.prototype.emit = function emit (event, payload) {
    var p = this.getParent();
    while ((p = p.getParent()) !== p);
    p.getDispatch().dispatch(event, payload);
};

// THIS WILL BE DEPRICATED
Node.prototype.sendDrawCommand = function sendDrawCommand (message) {
    this._globalUpdater.message(message);
    return this;
};

Node.prototype.getValue = function getValue () {
    var numberOfChildren = this._children.length;
    var numberOfComponents = this._components.length;
    var i = 0;

    var value = {
        location: this.value.location,
        spec: this.value,
        components: new Array(numberOfComponents),
        children: new Array(numberOfChildren)
    };

    for (; i < numberOfChildren ; i++)
        value.children[i] = this._children[i].getValue();

    for (i = 0 ; i < numberOfComponents ; i++)
        if (this._components[i].getValue) 
            value.components[i] = this._components[i].getValue();

    return value;
};

Node.prototype.getComputedValue = function getComputedValue () {
    var numberOfChildren = this._children.length;

    var value = {
        location: this.value.location,
        computedValues: this._calculatedValues,
        children: new Array(numberOfChildren)
    };

    for (var i = 0 ; i < numberOfChildren ; i++)
        value.children[i] = this._children[i].getComputedValue();

    return value;
};

Node.prototype.getChildren = function getChildren () {
    return this._children;
};

Node.prototype.getParent = function getParent () {
    return this._parent;
};

Node.prototype.requestUpdate = function requestUpdate (id) {
    if (this._inUpdate) return this.requestUpdateOnNextTick(id);
    this._updateQueue.push(id);
    if (!this._requestingUpdate) this._requestUpdate();
};

Node.prototype.requestUpdateOnNextTick = function requestUpdateOnNextTick (id) {
    this._nextUpdateQueue.push(id);
};

Node.prototype.getUpdater = function getUpdater () {
    return this._globalUpdater;
};

Node.prototype.isMounted = function isMounted () {
    return this.value.showState.mounted;
};

Node.prototype.isShown = function isShown () {
    return this.value.showState.shown;
};

Node.prototype.getOpacity = function getOpacity () {
    return this.value.showState.opacity;
};

Node.prototype.getMountPoint = function getMountPoint () {
    return this.value.offsets.mountPoint;
};

Node.prototype.getAlign = function getAlign () {
    return this.value.offsets.align;
};

Node.prototype.getOrigin = function getOrigin () {
    return this.value.offsets.origin;
};

Node.prototype.getPosition = function getPosition () {
    return this.value.vectors.position;
};

Node.prototype.getRotation = function getRotation () {
    return this.value.vectors.rotation;
};

Node.prototype.getScale = function getScale () {
    return this.value.vectors.scale;
};

Node.prototype.getSizeMode = function getSizeMode () {
    return this.value.size.sizeMode;
};

Node.prototype.getProportionalSize = function getProportionalSize () {
    return this.value.size.proportional;
};

Node.prototype.getDifferentialSize = function getDifferentialSize () {
    return this.value.size.differential;
};

Node.prototype.getAbsoluteSize = function getAbsoluteSize () {
    return this.value.size.absolute;
};

Node.prototype.getRenderSize = function getRenderSize () {
    return this.value.size.render;
};

Node.prototype.getSize = function getSize () {
    return this._calculatedValues.size;
};

Node.prototype.getTransform = function getTransform () {
    return this._calculatedValues.transform;
};

Node.prototype.getUIEvents = function getUIEvents () {
    return this.value.UIEvents;
};

Node.prototype.addChild = function addChild (child) {
    var index = child ? this._children.indexOf(child) : -1;
    child = child ? child : new Node();

    if (index === -1) {
        index = this._freedChildIndicies.length ? this._freedChildIndicies.pop() : this._children.length;
        this._children[index] = child;

        if (this.isMounted() && child.onMount) {
            var myId = this.getId();
            var childId = myId + '/' + index;
            child.onMount(this, childId);
        }
    
    }

    return child;
};

Node.prototype.removeChild = function removeChild (child) {
    var index = this._children.indexOf(child);
    if (index !== -1) {
        this._freedChildIndicies.push(index);

        if (this.isMounted() && child.onDismount)
            child.onDismount();

        this._children[index] = null;
    }
};

Node.prototype.addComponent = function addComponent (component) {
    var index = this._components.indexOf(component);
    if (index === -1) {
        index = this._freedComponentIndicies.length ? this._freedComponentIndicies.pop() : this._components.length;
        this._components[index] = component;

        if (this.isMounted() && component.onMount)
            component.onMount(this, index);

        if (this.isShown() && component.onShow)
            component.onShow();
    }

    return index;
};

Node.prototype.removeComponent = function removeComponent (component) {
    var index = this._components.indexOf(component);
    if (index !== -1) {
        this._freedComponentIndicies.push(index);
        if (this.isShown() && component.onHide)
            component.onHide();

        if (this.isMounted() && component.onDismount)
            component.onDismount();

        this._components[index] = null;
    }
};

Node.prototype.addUIEvent = function addUIEvent (eventName) {
    var UIEvents = this.getUIEvents();
    var components = this._components;
    var component;

    if (UIEvents.indexOf(eventName) === -1) {
        UIEvents.push(eventName);
        for (var i = 0, len = components.length ; i < len ; i++) {
            component = components[i];
            if (component.onAddUIEvent) component.onAddUIEvent(eventName);
        }
    }
};

Node.prototype._requestUpdate = function _requestUpdate (force) {
    if (force || (!this._requestingUpdate && this._globalUpdater)) {
        this._globalUpdater.requestUpdate(this);
        this._requestingUpdate = true;
    }
};

Node.prototype._vec3OptionalSet = function _vec3OptionalSet (vec3, index, val) {
    if (val != null && vec3[index] !== val) {
        vec3[index] = val;
        if (!this._requestingUpdate) this._requestUpdate();
        return true;
    }
    return false;
};

Node.prototype.show = function show () {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    this.value.showState.shown = true;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onShow) item.onShow();
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentShow) item.onParentShow();
    }
};

Node.prototype.hide = function hide () {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    this.value.showState.shown = false;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onHide) item.onHide();
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentHide) item.onParentHide();
    }
};

Node.prototype.setAlign = function setAlign (x, y, z) {
    var vec3 = this.value.offsets.align;
    var propogate = false;

    propogate = this._vec3OptionalSet(vec3, 0, x) || propogate;
    propogate = this._vec3OptionalSet(vec3, 1, y) || propogate;
    propogate = this._vec3OptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onAlignChange) item.onAlignChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setMountPoint = function setMountPoint (x, y, z) {
    var vec3 = this.value.offsets.mountPoint;
    var propogate = false;

    propogate = this._vec3OptionalSet(vec3, 0, x) || propogate;
    propogate = this._vec3OptionalSet(vec3, 1, y) || propogate;
    propogate = this._vec3OptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onMountPointChange) item.onMountPointChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setOrigin = function setOrigin (x, y, z) {
    var vec3 = this.value.offsets.origin;
    var propogate = false;

    propogate = this._vec3OptionalSet(vec3, 0, x) || propogate;
    propogate = this._vec3OptionalSet(vec3, 1, y) || propogate;
    propogate = this._vec3OptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onOriginChange) item.onOriginChange(x, y, z);
        }
    }
    return this;
};


Node.prototype.setPosition = function setPosition (x, y, z) {
    var vec3 = this.value.vectors.position;
    var propogate = false;

    propogate = this._vec3OptionalSet(vec3, 0, x) || propogate;
    propogate = this._vec3OptionalSet(vec3, 1, y) || propogate;
    propogate = this._vec3OptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onPositionChange) item.onPositionChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setRotation = function setRotation (x, y, z) {
    var vec3 = this.value.vectors.rotation;
    var propogate = false;

    propogate = this._vec3OptionalSet(vec3, 0, x) || propogate;
    propogate = this._vec3OptionalSet(vec3, 1, y) || propogate;
    propogate = this._vec3OptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onRotationChange) item.onRotationChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setScale = function setScale (x, y, z) {
    var vec3 = this.value.vectors.scale;
    var propogate = false;

    propogate = this._vec3OptionalSet(vec3, 0, x) || propogate;
    propogate = this._vec3OptionalSet(vec3, 1, y) || propogate;
    propogate = this._vec3OptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onScaleChange) item.onScaleChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setOpacity = function setOpacity (val) {
    if (val != this.value.showState.opacity) {
        this.value.showState.opacity = val;
        if (!this._requestingUpdate) this._requestUpdate();

        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onOpacityChange) item.onOpacityChange(val);
        }
    }
    return this;
};

Node.prototype.setSizeMode = function setSizeMode (x, y, z) {
    var vec3 = this.value.size.sizeMode;
    var propogate = false;

    propogate = this._vec3OptionalSet(vec3, 0, x) || propogate;
    propogate = this._vec3OptionalSet(vec3, 1, y) || propogate;
    propogate = this._vec3OptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onSizeModeChange) item.onSizeModeChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setProportionalSize = function setProportionalSize (x, y, z) {
    var vec3 = this.value.size.proportional;
    var propogate = false;

    propogate = this._vec3OptionalSet(vec3, 0, x) || propogate;
    propogate = this._vec3OptionalSet(vec3, 1, y) || propogate;
    propogate = this._vec3OptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onProportionalSizeChange) item.onProportionalSizeChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setDifferentialSize = function setDifferentialSize (x, y, z) {
    var vec3 = this.value.size.differential;
    var propogate = false;

    propogate = this._vec3OptionalSet(vec3, 0, x) || propogate;
    propogate = this._vec3OptionalSet(vec3, 1, y) || propogate;
    propogate = this._vec3OptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onDifferentialSizeChange) item.onDifferentialSizeChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setAbsoluteSize = function setAbsoluteSize (x, y, z) {
    var vec3 = this.value.size.absolute;
    var propogate = false;

    propogate = this._vec3OptionalSet(vec3, 0, x) || propogate;
    propogate = this._vec3OptionalSet(vec3, 1, y) || propogate;
    propogate = this._vec3OptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onAbsoluteSizeChange) item.onAbsoluteSizeChange(x, y, z);
        }
    }
    return this;
};

Node.prototype._transformChanged = function _transformChanged (transform) {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onTransformChange) item.onTransformChange(transform);
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentTransformChange) item.onParentTransformChange(transform);
    }
};

Node.prototype._sizeChanged = function _sizeChanged (size) {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onSizeChange) item.onSizeChange(size);
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentSizeChange) item.onParentSizeChange(size);
    }
};

// DEPRICATE
Node.prototype.getFrame = function getFrame () {
    return this._globalUpdater.getFrame();
};

Node.prototype.update = function update (time){
    this._inUpdate = true;
    var nextQueue = this._nextUpdateQueue;
    var queue = this._updateQueue;
    var item;

    while (nextQueue.length) queue.unshift(nextQueue.pop());

    while (queue.length) {
        item = this._components[queue.shift()];
        if (item && item.onUpdate) item.onUpdate(time);
    }

    var mySize = this.getSize();
    var parent = this.getParent();
    var parentSize = parent.getSize();
    var myTransform = this.getTransform();
    var parentTransform = parent.getTransform();
    var sizeChanged = SIZE_PROCESSOR.fromSpecWithParent(parentSize, this.value, mySize);
    mySize = this.getSize();
 
    var transformChanged = TRANSFORM_PROCESSOR.fromSpecWithParent(this.getParent().getTransform(), this.value, mySize, parentSize, this.getTransform());
    if (transformChanged) this._transformChanged(this.getTransform());
    if (sizeChanged) this._sizeChanged(this.getSize());

    this._inUpdate = false;
    this._requestingUpdate = false;

    if (this._nextUpdateQueue.length) {
        this._globalUpdater.requestUpdateOnNextTick(this);
        this._requestingUpdate = true;
    }
};

Node.prototype.mount = function mount (parent, myId) {
    if (this.isMounted()) return; 
    var i = 0;
    var list = this._components;
    var len = list.length;
    var item;

    this._parent = parent;
    this._globalUpdater = parent.getUpdater();
    this.value.location = myId;
    this.value.showState.mounted = true;

    for (; i < len ; i++) {
        item = list[i];
        if (item.onMount) item.onMount(this, i);
    }
    
    i = 0;
    list = this._children;
    len = list.length;
    for (; i < len ; i++) {
        item = list[i];
        if (item.onParentMount) item.onParentMount(this, myId, i);
    }

    if (this._requestingUpdate) this._requestUpdate(true);
};

Node.prototype.dismount = function dismount () {
    if (!this.isMounted()) return; 
    var i = 0;
    var list = this._components;
    var len = list.length;
    var item;

    this.value.showState.mounted = false;
    this.value.location = null;

    this._parent.removeChild(this);

    this._parent = null;

    for (; i < len ; i++) {
        item = list[i];
        if (item.onDismount) item.onDismount();
    }
    
    i = 0;
    list = this._children;
    len = list.length;
    for (; i < len ; i++) {
        item = list[i];
        if (item.onParentDismount) item.onParentDismount();
    }

    if (!this._requestingUpdate) this._requestUpdate();
    this._globalUpdater = null;
};

Node.prototype.onParentMount = function onParentMount (parent, parentId, index) {
    this.mount(parent, parentId + '/' + index);
};

Node.prototype.onParentDismount = function onParentDismount () {
    this.dismount();
};

Node.prototype.receive = function receive (type, ev) {
    var i = 0;
    var list = this._components;
    var len = list.length;
    var item;
    for (; i < len ; i++) {
        item = list[i];
        if (item && item.onReceive) item.onReceive(type, ev);
    }
};

Node.prototype.onUpdate = Node.prototype.update;

Node.prototype.onParentShow = Node.prototype.show;

Node.prototype.onParentHide = Node.prototype.hide;

Node.prototype.onParentTransformChange = _requestUpdateWithoutArgs;

Node.prototype.onParentSizeChange = _requestUpdateWithoutArgs;

Node.prototype.onShow = Node.prototype.show;

Node.prototype.onHide = Node.prototype.hide;

Node.prototype.onMount = Node.prototype.mount;

Node.prototype.onDismount = Node.prototype.dismount;

Node.prototype.onReceive = Node.prototype.receive;

function _requestUpdateWithoutArgs () {
    if (!this._requestingUpdate) this._requestUpdate();
}

module.exports = Node;

},{"./Size":48,"./Transform":49}],48:[function(require,module,exports){
function Size (dispatch) {
    this._size = new Float32Array(3);
}

Size.RELATIVE = 0;
Size.ABSOLUTE = 1;
Size.RENDER = 2;
Size.DEFAULT = 0;

Size.prototype.fromSpecWithParent = function fromSpecWithParent (parentSize, spec, target) {
    var mode = spec.size.sizeMode;
    var prev;
    var changed = false;
    for (var i = 0 ; i < 3 ; i++) {
        switch (mode[i]) {
            case Size.RELATIVE:
                prev = target[i];
                target[i] = parentSize[i] * spec.size.proportional[i] + spec.size.differential[i];
                changed = changed || prev !== target[i];
                break;
            case Size.ABSOLUTE:
                prev = target[i];
                target[i] = spec.size.absolute[i];
                changed = changed || prev !== target[i];
                break;
            case Size.Render:
                break;
        }
    }
    return changed;
};

module.exports = Size;

},{}],49:[function(require,module,exports){
'use strict';

function Transform () {
    this._matrix = new Float32Array(16);
    this._scratch = new Float32Array(67);
}

Transform.prototype.get = function get () {
    return this._matrix;
};

Transform.prototype.fromSpecWithParent = function fromSpecWithParent (parentMatrix, spec, mySize, parentSize, target) {
    target = target ? target : this._matrix;

    // local cache of everything
    var t00         = target[0];
    var t01         = target[1];
    var t02         = target[2];
    var t03         = target[3];
    var t10         = target[4];
    var t11         = target[5];
    var t12         = target[6];
    var t13         = target[7];
    var t20         = target[8];
    var t21         = target[9];
    var t22         = target[10];
    var t23         = target[11];
    var t30         = target[12];
    var t31         = target[13];
    var t32         = target[14];
    var t33         = target[15];
    var p00         = parentMatrix[0];
    var p01         = parentMatrix[1];
    var p02         = parentMatrix[2];
    var p03         = parentMatrix[3];
    var p10         = parentMatrix[4];
    var p11         = parentMatrix[5];
    var p12         = parentMatrix[6];
    var p13         = parentMatrix[7];
    var p20         = parentMatrix[8];
    var p21         = parentMatrix[9];
    var p22         = parentMatrix[10];
    var p23         = parentMatrix[11];
    var p30         = parentMatrix[12];
    var p31         = parentMatrix[13];
    var p32         = parentMatrix[14];
    var p33         = parentMatrix[15];
    var posX        = spec.vectors.position[0];
    var posY        = spec.vectors.position[1];
    var posZ        = spec.vectors.position[2];
    var rotX        = spec.vectors.rotation[0];
    var rotY        = spec.vectors.rotation[1];
    var rotZ        = spec.vectors.rotation[2];
    var scaleX      = spec.vectors.scale[0];
    var scaleY      = spec.vectors.scale[1];
    var scaleZ      = spec.vectors.scale[2];
    var alignX      = spec.offsets.align[0] * parentSize[0];
    var alignY      = spec.offsets.align[1] * parentSize[1];
    var alignZ      = spec.offsets.align[2] * parentSize[2];
    var mountPointX = spec.offsets.mountPoint[0] * mySize[0];
    var mountPointY = spec.offsets.mountPoint[1] * mySize[1];
    var mountPointZ = spec.offsets.mountPoint[2] * mySize[2];
    var originX     = spec.offsets.origin[0] * mySize[0];
    var originY     = spec.offsets.origin[1] * mySize[1];
    var originZ     = spec.offsets.origin[2] * mySize[2];
    var cosX        = Math.cos(rotX);
    var cosY        = Math.cos(rotY);
    var cosZ        = Math.cos(rotZ);
    var sinX        = Math.sin(rotX);
    var sinY        = Math.sin(rotY);
    var sinZ        = Math.sin(rotZ);
    var expr1       = (cosY * cosZ);
    var expr2       = (cosX * sinZ + sinX * sinY * cosZ);
    var expr3       = (sinX * sinZ - cosX * sinY * cosZ);
    var expr4       = (-cosY * sinZ);
    var expr5       = (cosX * cosZ - sinX * sinY * sinZ);
    var expr6       = (sinX * cosZ + cosX * sinY * sinZ);
    var expr7       = (-sinX * cosY);
    var expr8       = (cosX * cosY);

    target[0]  = ((((p00) * expr1) + ((p10) * expr2)) + ((p20) * expr3)) * (scaleX);
    target[1]  = ((((p01) * expr1) + ((p11) * expr2)) + ((p21) * expr3)) * (scaleX);
    target[2]  = ((((p02) * expr1) + ((p12) * expr2)) + ((p22) * expr3)) * (scaleX);
    target[3]  = ((((p03) * expr1) + ((p13) * expr2)) + ((p23) * expr3)) * (scaleX);
    target[4]  = ((((p00) * expr4) + ((p10) * expr5)) + ((p20) * expr6)) * (scaleY);
    target[5]  = ((((p01) * expr4) + ((p11) * expr5)) + ((p21) * expr6)) * (scaleY);
    target[6]  = ((((p02) * expr4) + ((p12) * expr5)) + ((p22) * expr6)) * (scaleY);
    target[7]  = ((((p03) * expr4) + ((p13) * expr5)) + ((p23) * expr6)) * (scaleY);
    target[8]  = ((((p00) * (sinY)) + ((p10) * expr7)) + ((p20) * expr8)) * (scaleZ);
    target[9]  = ((((p01) * (sinY)) + ((p11) * expr7)) + ((p21) * expr8)) * (scaleZ);
    target[10] = ((((p02) * (sinY)) + ((p12) * expr7)) + ((p22) * expr8)) * (scaleZ);
    target[11] = ((((p03) * (sinY)) + ((p13) * expr7)) + ((p23) * expr8)) * (scaleZ);
    target[12] = (((((((p00) * expr1) + ((p10) * expr2)) + ((p20) * expr3)) * (scaleX)) * ((-originX))) + ((((((p00) * expr4) + ((p10) * expr5)) + ((p20) * expr6)) * (scaleY)) * ((-originY)))) + (((((((p00) * (sinY)) + ((p10) * expr7)) + ((p20) * expr8)) * (scaleZ)) * ((-originZ))) + ((((p00) * (posX)) + ((p10) * (posY))) + (((p20) * (posZ)) + ((((p00) * (originX)) + ((p10) * (originY))) + (((p20) * (originZ)) + ((((p00) * ((-mountPointX))) + ((p10) * ((-mountPointY)))) + (((p20) * ((-mountPointZ))) + ((((p00) * (alignX)) + ((p10) * (alignY))) + (((p20) * (alignZ)) + (p30))))))))));
    target[13] = (((((((p01) * expr1) + ((p11) * expr2)) + ((p21) * expr3)) * (scaleX)) * ((-originX))) + ((((((p01) * expr4) + ((p11) * expr5)) + ((p21) * expr6)) * (scaleY)) * ((-originY)))) + (((((((p01) * (sinY)) + ((p11) * expr7)) + ((p21) * expr8)) * (scaleZ)) * ((-originZ))) + ((((p01) * (posX)) + ((p11) * (posY))) + (((p21) * (posZ)) + ((((p01) * (originX)) + ((p11) * (originY))) + (((p21) * (originZ)) + ((((p01) * ((-mountPointX))) + ((p11) * ((-mountPointY)))) + (((p21) * ((-mountPointZ))) + ((((p01) * (alignX)) + ((p11) * (alignY))) + (((p21) * (alignZ)) + (p31))))))))));
    target[14] = (((((((p02) * expr1) + ((p12) * expr2)) + ((p22) * expr3)) * (scaleX)) * ((-originX))) + ((((((p02) * expr4) + ((p12) * expr5)) + ((p22) * expr6)) * (scaleY)) * ((-originY)))) + (((((((p02) * (sinY)) + ((p12) * expr7)) + ((p22) * expr8)) * (scaleZ)) * ((-originZ))) + ((((p02) * (posX)) + ((p12) * (posY))) + (((p22) * (posZ)) + ((((p02) * (originX)) + ((p12) * (originY))) + (((p22) * (originZ)) + ((((p02) * ((-mountPointX))) + ((p12) * ((-mountPointY)))) + (((p22) * ((-mountPointZ))) + ((((p02) * (alignX)) + ((p12) * (alignY))) + (((p22) * (alignZ)) + (p32))))))))));
    target[15] = (((((((p03) * expr1) + ((p13) * expr2)) + ((p23) * expr3)) * (scaleX)) * ((-originX))) + ((((((p03) * expr4) + ((p13) * expr5)) + ((p23) * expr6)) * (scaleY)) * ((-originY)))) + (((((((p03) * (sinY)) + ((p13) * expr7)) + ((p23) * expr8)) * (scaleZ)) * ((-originZ))) + ((((p03) * (posX)) + ((p13) * (posY))) + (((p23) * (posZ)) + ((((p03) * (originX)) + ((p13) * (originY))) + (((p23) * (originZ)) + ((((p03) * ((-mountPointX))) + ((p13) * ((-mountPointY)))) + (((p23) * ((-mountPointZ))) + ((((p03) * (alignX)) + ((p13) * (alignY))) + (((p23) * (alignZ)) + (p33))))))))));

    return t00 !== target[0] ||
        t01 !== target[1] ||
        t02 !== target[2] ||
        t03 !== target[3] ||
        t10 !== target[4] ||
        t11 !== target[5] ||
        t12 !== target[6] ||
        t13 !== target[7] ||
        t20 !== target[8] ||
        t21 !== target[9] ||
        t22 !== target[10] ||
        t23 !== target[11] ||
        t30 !== target[12] ||
        t31 !== target[13] ||
        t32 !== target[14] ||
        t33 !== target[15];

};

module.exports = Transform;

},{}],50:[function(require,module,exports){
'use strict';

module.exports = {
    Clock: require('./Clock'),
    Event: require('./Event'),
    Context: require('./Context'),
    Famous: require('./Famous'),
    Dispatcher: require('./Dispatcher'),
    Node: require('./Node'),
    Size: require('./Size'),
    Transform: require('./Transform')
};

},{"./Clock":42,"./Context":43,"./Dispatcher":44,"./Event":45,"./Famous":46,"./Node":47,"./Size":48,"./Transform":49}],51:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],52:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],53:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./Curves":51,"dup":9}],54:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],55:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./Curves":51,"./Easing":52,"./Transitionable":53,"./after":54,"dup":11}],56:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17}],57:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"famous-transitions":55}],58:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],59:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],60:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],61:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],62:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],63:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./CallbackStore":56,"./Color":57,"./KeyCodes":58,"./MethodStore":59,"./ObjectManager":60,"./clone":61,"./flatClone":62,"./keyValueToArrays":64,"./loadURL":65,"./strip":66,"dup":24}],64:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],65:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],66:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],67:[function(require,module,exports){
var CallbackStore = require('famous-utilities').CallbackStore;

function DOMElement (node, options) {
    if (typeof options === 'string') {
        console.warn(
            'HTMLElement constructor signature changed!\n' +
            'Pass in an options object with {tagName: ' + options + '} instead.'
        );
        options = {
            tagName: options
        };
    }

    this._node = node;

    this._requestingUpdate = false;

    this._changeQueue = [];
    
    this._classes = ['fa-surface'];
    this._requestingEventListeners = [];
    this._styles = {
        display: node.isShown() 
    };
    this._attributes = {};
    this._content = '';

    this._tagName = options && options.tagName ? options.tagName : 'div';
    this._id = node.addComponent(this);

    this._callbacks = new CallbackStore();

    if (!options) return;

    if (options.classes) {
        for (var i = 0; i < options.classes.length; i++)
            this.addClass(options.classes[i]);
    }

    if (options.attributes) {
        for (var key in options.attributes)
            this.setAttribute(key, options.attributes[key]);
    }

    if (options.properties) {
        for (var key in options.properties)
            this.setProperty(key, options.properties[key]);
    }

    if (options.id) this.setId(options.id);
    if (options.content) this.setContent(options.content);
}

DOMElement.prototype.getValue = function getValue () {
    return {
        classes: this._classes,
        styles: this._styles,
        attributes: this._attributes,
        content: this._content
    };
};

DOMElement.prototype.onUpdate = function onUpdate () {
    var node = this._node;
    var queue = this._changeQueue;
    var len = queue.length;

    if (len && node) {
        node.sendDrawCommand('WITH');
        node.sendDrawCommand(node.getLocation());
        node.sendDrawCommand('DOM');

        while (len--) node.sendDrawCommand(queue.shift());
    }

    this._requestingUpdate = false;
};

DOMElement.prototype.onMount = function onMount (node, id) {
    this._node = node;
    this._id = id;
    this.draw();
    this.setAttribute('data-fa-path', node.getLocation());
};

DOMElement.prototype.onDismount = function onDismount () {
    this.setProperty('display', 'none');
    this.setAttribute('data-fa-path', '');
    this._initialized = false;
};

DOMElement.prototype.onShow = function onShow () {
    this.setProperty('display', 'block');
};

DOMElement.prototype.onHide = function onHide () {
    this.setProperty('display', 'none');
};

DOMElement.prototype.onTransformChange = function onTransformChange (transform) {
    this._changeQueue.push('CHANGE_TRANSFORM');
    for (var i = 0, len = transform.length ; i < len ; i++)
        this._changeQueue.push(transform[i]);

    if (!this._requestingUpdate) this._requestUpdate();
};

DOMElement.prototype.onSizeChange = function onSizeChange (size) {
    var sizeMode = this._node.getSizeMode();
    var sizedX = sizeMode[0] !== Node.RENDER_SIZE;
    var sizedY = sizeMode[1] !== Node.RENDER_SIZE;
    if (this._initialized) 
        this._changeQueue.push('CHANGE_SIZE',
            sizedX ? size[0] : sizedX,
            sizedY ? size[1] : sizedY);

    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};

DOMElement.prototype.onAddUIEvent = function onAddUIEvent (UIEvent) {
    this._changeQueue.push('ADD_EVENT_LISTENER', UIEvent, void 0, true, 'EVENT_END');
    if (!this._requestingUpdate) this._requestUpdate();
};

DOMElement.prototype.onSizeModeChange = function onSizeModeChange (sizeMode) {
    this.onSizeChange(this._node.getSize());
}; 

DOMElement.prototype._requestUpdate = function _requestUpdate () {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
};

DOMElement.prototype.init = function init () {
    this._changeQueue.push('INIT_DOM', this._tagName);
    this._initialized = true;
    this.onTransformChange(this._node.getTransform());
    this.onSizeChange(this._node.getSize());
    if (!this._requestingUpdate) this._requestUpdate();
};

DOMElement.prototype.setId = function setId (id) {
    this.setAttribute('id', id);
    return this;
};

DOMElement.prototype.addClass = function addClass (value) {
    if (this._classes.indexOf(value) < 0) {
        if (this._initialized) this._changeQueue.push('ADD_CLASS', value);
        this._classes.push(value);
        if (!this._requestingUpdate) this._requestUpdate();
        return this;
    }

    if (this._inDraw) {
        if (this._initialized) this._changeQueue.push('ADD_CLASS', value);
        if (!this._requestingUpdate) this._requestUpdate();
    }
    return this;
};

DOMElement.prototype.removeClass = function removeClass (value) {
    var index = this._classes.indexOf(value);

    if (index < 0) return this;

    this._changeQueue.push('REMOVE_CLASS', value);

    this._classes.splice(index, 1);

    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};

DOMElement.prototype.setAttribute = function setAttribute (name, value) {
    if (this._attributes[name] !== value || this._inDraw) {
        this._attributes[name] = value;
        if (this._initialized) this._changeQueue.push('CHANGE_ATTRIBUTE', name, value);
        if (!this._requestUpdate) this._requestUpdate();
    }
    return this;
};

DOMElement.prototype.setProperty = function setProperty (name, value) {
    if (this._styles[name] !== value || this._inDraw) {
        this._styles[name] = value;
        if (this._initialized) this._changeQueue.push('CHANGE_PROPERTY', name, value);
        if (!this._requestingUpdate) this._requestUpdate();
    }
    return this;
};

DOMElement.prototype.setContent = function setContent (content) {
    if (this._content !== content || this._inDraw) {
        this._content = content;
        if (this._initialized) this._changeQueue.push('CHANGE_CONTENT', content);
        if (!this._requestingUpdate) this._requestUpdate();
    }
    return this;
};

DOMElement.prototype.on = function on (event, listener) {
    return this._callbacks.on(event, listener);
};

DOMElement.prototype.onReceive = function onReceive (event, payload) {
    this._callbacks.trigger(event, payload);
};

DOMElement.prototype.draw = function draw () {
    var key;
    var i;
    var len;

    this._inDraw = true;

    this.init();

    for (i = 0, len = this._classes.length ; i < len ; i++)
        this.addClass(this._classes[i]);

    this.setContent(this._content);

    for (key in this._styles) 
        if (this._styles[key])
            this.setProperty(key, this._styles[key]);

    for (key in this._attributes)
        if (this._attributes[key])
            this.setAttribute(key, this._attributes[key]);

    this._inDraw = false;
};

module.exports = DOMElement;


},{"famous-utilities":63}],68:[function(require,module,exports){
'use strict';

var DOMElement = require('./DOMElement');
var CallbackStore = require('famous-utilities').CallbackStore;

var WITH = 'WITH';
var CHANGE_TRANSFORM = 'CHANGE_TRANSFORM';
var CHANGE_PROPERTY = 'CHANGE_PROPERTY';
var INIT_DOM = 'INIT_DOM';
var CHANGE_ATTRIBUTE = 'CHANGE_ATTRIBUTE';
var ADD_CLASS = 'ADD_CLASS';
var REMOVE_CLASS = 'REMOVE_CLASS';
var CHANGE_ATTRIBUTE = 'CHANGE_ATTRIBUTE';
var CHANGE_CONTENT = 'CHANGE_CONTENT';
var ADD_EVENT_LISTENER = 'ADD_EVENT_LISTENER';
var EVENT_PROPERTIES = 'EVENT_PROPERTIES';
var EVENT_END = 'EVENT_END';
var RECALL = 'RECALL';

/**
 * The Element class is responsible for providing the API for how
 *   a RenderNode will interact with the DOM API's.  The element is
 *   responsible for adding a set of commands to the renderer.
 *
 * @class HTMLElement
 * @constructor
 * @component
 * @param {RenderNode} RenderNode to which the instance of Element will be a component of
 */
function HTMLElement(node, tagName) {
    console.warn("HTMLElement was depricated\n use DOMElement");
    return new DOMElement(node, tagName);
} 

module.exports = HTMLElement;

},{"./DOMElement":67,"famous-utilities":63}],69:[function(require,module,exports){
'use strict';

module.exports = {
    HTMLElement: require('./HTMLElement'),
    DOMElement: require('./DOMElement')
};

},{"./DOMElement":67,"./HTMLElement":68}],70:[function(require,module,exports){
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
 
// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
 
// MIT license

'use strict';

var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];

var rAF, cAF;

if (typeof window === 'object') {
    rAF = window.requestAnimationFrame;
    cAF = window.cancelAnimationFrame || window.cancelRequestAnimationFrame;
    for (var x = 0; x < vendors.length && !rAF; ++x) {
        rAF = window[vendors[x] + 'RequestAnimationFrame'];
        cAF = window[vendors[x] + 'CancelRequestAnimationFrame']
            || window[vendors[x] + 'CancelAnimationFrame'];
    }

    if (rAF && !cAF) {
        // cAF not supported.
        // Fall back to setInterval for now (very rare).
        rAF = null;
    }
}

var now = Date.now ? Date.now : function () {
    return new Date().getTime();
};

if (!rAF) {
    rAF = function(callback) {
        var currTime = now();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = setTimeout(function () {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };

    cAF = function (id) {
        clearTimeout(id);
    };
}

module.exports = {
    requestAnimationFrame: rAF,
    cancelAnimationFrame: cAF
};

},{}],71:[function(require,module,exports){
'use strict';

module.exports = {
    requestAnimationFrame: require('./animationFrame').requestAnimationFrame,
    cancelAnimationFrame: require('./animationFrame').cancelAnimationFrame
};

},{"./animationFrame":70}],72:[function(require,module,exports){
'use strict';

var polyfills = require('famous-polyfills');
var rAF = polyfills.requestAnimationFrame;
var cAF = polyfills.cancelAnimationFrame;

var _now;
if (typeof performance !== 'undefined') {
    _now = function() {
        return performance.now();
    };
}
else {
    _now = Date.now;
}

if (typeof document !== 'undefined') {
    var VENDOR_HIDDEN, VENDOR_VISIBILITY_CHANGE;

    // Opera 12.10 and Firefox 18 and later support
    if (typeof document.hidden !== 'undefined') {
        VENDOR_HIDDEN = 'hidden';
        VENDOR_VISIBILITY_CHANGE = 'visibilitychange';
    }
    else if (typeof document.mozHidden !== 'undefined') {
        VENDOR_HIDDEN = 'mozHidden';
        VENDOR_VISIBILITY_CHANGE = 'mozvisibilitychange';
    }
    else if (typeof document.msHidden !== 'undefined') {
        VENDOR_HIDDEN = 'msHidden';
        VENDOR_VISIBILITY_CHANGE = 'msvisibilitychange';
    }
    else if (typeof document.webkitHidden !== 'undefined') {
        VENDOR_HIDDEN = 'webkitHidden';
        VENDOR_VISIBILITY_CHANGE = 'webkitvisibilitychange';
    }
}

/**
 * Engine class used for updating objects on a frame-by-frame. Synchronizes the
 * `update` method invocations to the refresh rate of the screen. Manages
 * the `requestAnimationFrame`-loop by normalizing the passed in timestamp
 * when switching tabs.
 * 
 * @class Engine
 * @constructor
 */
function Engine() {
    this._updates = [];
    var _this = this;
    this._looper = function(time) {
        _this.loop(time);
    };
    this._stoppedAt = _now();
    this._sleep = 0;
    this._startOnVisibilityChange = true;
    this._rAF = null;
    this.start();

    if (typeof document !== 'undefined') {
        document.addEventListener(VENDOR_VISIBILITY_CHANGE, function() {
            if (document[VENDOR_HIDDEN]) {
                cAF(this._rAF);
                var startOnVisibilityChange = _this._startOnVisibilityChange;
                _this.stop();
                _this._startOnVisibilityChange = startOnVisibilityChange;
            }
            else {
                if (_this._startOnVisibilityChange) {
                    _this.start();
                }
            }
        });
    }
}

/**
 * Starts the Engine.
 *
 * @method start
 * @chainable
 * 
 * @return {Engine} this
 */
Engine.prototype.start = function start() {
    if (!this._running) {
        this._startOnVisibilityChange = true;
        this._running = true;
        this._sleep += _now() - this._stoppedAt;
        this._rAF = rAF(this._looper);
    }
    return this;
};

/**
 * Stops the Engine.
 *
 * @method stop
 * @chainable
 * 
 * @return {Engine} this
 */
Engine.prototype.stop = function stop() {
    if (this._running) {
        this._startOnVisibilityChange = false;
        this._running = false;
        this._stoppedAt = _now();
        cAF(this._rAF);
    }
    return this;
};

/**
 * Determines whether the Engine is currently running or not.
 *
 * @method isRunning
 * 
 * @return {Boolean}    boolean value indicating whether the Engine is
 *                      currently running or not
 */
Engine.prototype.isRunning = function isRunning() {
    return this._running;
};

/**
 * Updates all registered objects.
 *
 * @method step
 * @chainable
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 * @return {Engine}      this
 */
Engine.prototype.step = function step (time) {
    for (var i = 0, len = this._updates.length ; i < len ; i++) {
        this._updates[i].update(time);
    }
    return this;
};

/**
 * Method being called by `requestAnimationFrame` on every paint. Indirectly
 * recursive by scheduling a future invocation of itself on the next paint.
 *
 * @method loop
 * @chainable
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 * @return {Engine}      this
 */
Engine.prototype.loop = function loop(time) {
    this.step(time - this._sleep);
    this._rAF = rAF(this._looper);
    return this;
};

/**
 * Registeres an updateable object which `update` method should be invoked on
 * every paint, starting on the next paint (assuming the Engine is running).
 *
 * @method update
 * @chainable
 * 
 * @param  {Object} updateable          object to be updated
 * @param  {Function} updateable.update update function to be called on the
 *                                      registered object
 * @return {Engine}                     this
 */
Engine.prototype.update = function update(updateable) {
    if (this._updates.indexOf(updateable) === -1) {
        this._updates.push(updateable);
    }
    return this;
};

/**
 * Deregisters an updateable object previously registered using `update` to be
 * no longer updated.
 *
 * @method noLongerUpdate
 * @chainable
 * 
 * @param  {Object} updateable          updateable object previously
 *                                      registered using `update`
 * @return {Engine}                     this
 */
Engine.prototype.noLongerUpdate = function noLongerUpdate(updateable) {
    var index = this._updates.indexOf(updateable);
    if (index > -1) {
        this._updates.splice(index, 1);
    }
    return this;
};

module.exports = Engine;

},{"famous-polyfills":71}],73:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],74:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./Mat33":73,"dup":3}],75:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],76:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],77:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"./Mat33":73,"./Quaternion":74,"./Vec2":75,"./Vec3":76,"dup":6}],78:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],79:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./Mat33":78,"dup":3}],80:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],81:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],82:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"./Mat33":78,"./Quaternion":79,"./Vec2":80,"./Vec3":81,"dup":6}],83:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],84:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],85:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./Curves":83,"dup":9}],86:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],87:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./Curves":83,"./Easing":84,"./Transitionable":85,"./after":86,"dup":11}],88:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17}],89:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"famous-transitions":87}],90:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],91:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],92:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],93:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],94:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],95:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./CallbackStore":88,"./Color":89,"./KeyCodes":90,"./MethodStore":91,"./ObjectManager":92,"./clone":93,"./flatClone":94,"./keyValueToArrays":96,"./loadURL":97,"./strip":98,"dup":24}],96:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],97:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],98:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],99:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var Mat33 = require('famous-math').Mat33;

var ObjectManager = require('famous-utilities').ObjectManager;
ObjectManager.register('DynamicGeometry', DynamicGeometry);
ObjectManager.register('DynamicGeometryFeature', DynamicGeometryFeature);
var OMRequestDynamicGeometryFeature = ObjectManager.requestDynamicGeometryFeature;
var OMFreeDynamicGeometryFeature = ObjectManager.freeDynamicGeometryFeature;

var TRIPLE_REGISTER = new Vec3();

/**
 * The so called triple product. Used to find a vector perpendicular to (v2 - v1) in the direction of v3.
 * (v1 x v2) x v3.
 *
 * @method tripleProduct
 * @private
 * @param {Vec3} v1 The first Vec3.
 * @param {Vec3} v2 The second Vec3.
 * @param {Vec3} v3 The third Vec3.
 * @return {Vec3} The result of the triple product.
 */
function tripleProduct(v1, v2, v3) {
    var v = TRIPLE_REGISTER;

    Vec3.cross(v1, v2, v);
    Vec3.cross(v, v3, v);

    return v;
}

/**
 * Of a set of vertices, retrieves the vertex furthest in the given direction.
 *
 * @method _hullSupport
 * @private
 * @param {Vec3[]} vertices The reference set of Vec3's.
 * @param {Vec3} direction The direction to compare against.
 * @return {Object} The vertex and its index in the vertex array.
 */
function _hullSupport(vertices, direction) {
    var furthest;
    var max = -Infinity;
    var dot;
    var vertex;
    var index;
    for (var i = 0; i < vertices.length; i++) {
        vertex = vertices[i];
        dot = Vec3.dot(vertex, direction);
        if (dot > max) {
            furthest = vertex;
            max = dot;
            index = i;
        }
    }

    return {
        vertex: furthest,
        index: index
    };
}

var VEC_REGISTER = new Vec3();
var POINTCHECK_REGISTER = new Vec3();
var AO_REGISTER = new Vec3();
var AB_REGISTER = new Vec3();
var AC_REGISTER = new Vec3();
var AD_REGISTER = new Vec3();
var BC_REGISTER = new Vec3();
var BD_REGISTER = new Vec3();

/**
 * Used internally to represent polyhedral facet information.
 *
 * @class DynamicGeometryFeature
 * @param {Number} distance The distance of the feature from the origin.
 * @param {Vec3} normal The Vec3 orthogonal to the feature, pointing out of the geometry.
 * @param {Number[]} vertexIndices The indices of the vertices which compose the feature.
 */
function DynamicGeometryFeature(distance, normal, vertexIndices) {
    this.distance = distance;
    this.normal = normal;
    this.vertexIndices = vertexIndices;
}

/**
 * Used by ObjectManager to reset objects.
 *
 * @method reset
 * @param {Array} args Argument array analogous to that used in instantiation.
 * @chainable
 */
DynamicGeometryFeature.prototype.reset = function(distance, normal, vertexIndices) {
    this.distance = distance;
    this.normal = normal;
    this.vertexIndices = vertexIndices;

    return this;
};

/**
 * Abstract object representing a growing polyhedron. Used in ConvexHull and in GJK+EPA collision detection.
 *
 * @class DynamicGeometry
 */
function DynamicGeometry() {
    this.vertices = [];
    this.numVertices = 0;
    this.features = [];
    this.numFeatures = 0;
    this.lastVertexIndex = 0;

    this._IDPool = {
        vertices: [],
        features: []
    };
}

/**
 * Used by ObjectManager to reset objects.
 *
 * @method reset
 * @param {Array} args Argument array analogous to that used in instantiation.
 * @chainable
 */
DynamicGeometry.prototype.reset = function reset() {
    this.vertices = [];
    this.numVertices = 0;
    this.features = [];
    this.numFeatures = 0;
    this.lastVertexIndex = 0;

    this._IDPool = {
        vertices: [],
        features: []
    };

    return this;
};

/**
 * Add a vertex to the polyhedron.
 *
 * @method addVertex
 * @param {Object} vertexObj Object returned by the support function.
 */
DynamicGeometry.prototype.addVertex = function(vertexObj) {
    var index = this._IDPool.vertices.length ? this._IDPool.vertices.pop() : this.vertices.length;
    this.vertices[index] = vertexObj;
    this.lastVertexIndex = index;
    this.numVertices++;
};

/**
 * Remove a vertex and push its location in the vertex array to the IDPool for later use.
 *
 * @method removeVertex
 * @param {Number} index Index of the vertex to remove.
 */
DynamicGeometry.prototype.removeVertex = function(index) {
    var vertex = this.vertices[index];
    this.vertices[index] = null;
    this._IDPool.vertices.push(index);
    this.numVertices--;

    return vertex;
};

/**
 * Add a feature (facet) to the polyhedron. Used internally in the reshaping process.
 *
 * @method addFeature
 * @param {Number} distance The distance of the feature from the origin.
 * @param {Vec3} normal The facet normal.
 * @param {Number[]} vertexIndices The indices of the vertices which compose the feature.
 */
DynamicGeometry.prototype.addFeature = function(distance, normal, vertexIndices) {
    var index = this._IDPool.features.length ? this._IDPool.features.pop() : this.features.length;
    this.features[index] = OMRequestDynamicGeometryFeature().reset(distance, normal, vertexIndices);
    this.numFeatures++;
};

/**
 * Remove a feature and push its location in the feature array to the IDPool for later use.
 *
 * @method removeFeature
 * @param {Number} index Index of the feature to remove.
 */
DynamicGeometry.prototype.removeFeature = function(index) {
    var feature = this.features[index];
    this.features[index] = null;
    this._IDPool.features.push(index);
    this.numFeatures--;

    OMFreeDynamicGeometryFeature(feature);
};

/**
 * Retrieve the last vertex object added to the geometry.
 *
 * @method getLastVertex
 * @return {Object}
 */
DynamicGeometry.prototype.getLastVertex = function() {
    return this.vertices[this.lastVertexIndex];
};

/**
 * Of the closest face to the origin, returns the normal vector pointed away from the origin.
 *
 * @method getFeatureClosestToOrigin
 * @return {Object}
 */
DynamicGeometry.prototype.getFeatureClosestToOrigin = function() {
    var min = Infinity;
    var closest = null;
    var features = this.features;
    for (var i = 0, len = features.length; i < len; i++) {
        var feature = features[i];
        if (!feature) continue;
        if (feature.distance < min) {
            min = feature.distance;
            closest = feature;
        }
    }
    return closest;
};

/**
 * Adds edge if not already on the frontier, removes if the edge or its reverse are on the frontier.
 * Used when reshaping DynamicGeometry's.
 *
 * @method _validateEdge
 * @private
 * @param {Object[]} vertices Vec3 reference array.
 * @param {Number[][]} frontier Current edges potentially separating the features to remove from the persistant shape.
 * @param {Number} start The index of the starting Vec3 on the edge.
 * @param {Number} end The index of the culminating Vec3.
 */
function _validateEdge(vertices, frontier, start, end) {
    var e0 = vertices[start].vertex;
    var e1 = vertices[end].vertex;
    for (var i = 0, len = frontier.length; i < len; i++) {
        var edge = frontier[i];
        if (!edge) continue;
        var v0 = vertices[edge[0]].vertex;
        var v1 = vertices[edge[1]].vertex;
        if ((e0 === v0 && (e1 === v1)) || (e0 === v1 && (e1 === v0))) {
            frontier[i] = null;
            return;
        }
    }
    frontier.push([start, end]);
}

/**
 * Based on the last (exterior) point added to the polyhedron, removes features as necessary and redetermines
 * its (convex) shape to include the new point by adding triangle features. Uses referencePoint, a point on the shape's
 * interior, to ensure feature normals point outward, else takes referencePoint to be the origin.
 *
 * @method reshape
 * @param {Vec3} referencePoint Point known to be in the interior, used to orient feature normals.
 */
DynamicGeometry.prototype.reshape = function(referencePoint) {
    var vertices = this.vertices;
    var point = this.getLastVertex().vertex;
    var features = this.features;
    var vertexOnFeature;
    var featureVertices;

    var i, j, len;

    // The removal of features creates a hole in the polyhedron -- frontierEdges maintains the edges
    // of this hole, each of which will form one edge of a new feature to be created
    var frontierEdges = [];

    for (i = 0, len = features.length; i < len; i++) {
        if (!features[i]) continue;
        featureVertices = features[i].vertexIndices;
        vertexOnFeature = vertices[featureVertices[0]].vertex;
        // If point is 'above' the feature, remove that feature, and check to add its edges to the frontier.
        if (Vec3.dot(features[i].normal, Vec3.subtract(point, vertexOnFeature, POINTCHECK_REGISTER)) > -0.001) {
            _validateEdge(vertices, frontierEdges, featureVertices[0], featureVertices[1]);
            _validateEdge(vertices, frontierEdges, featureVertices[1], featureVertices[2]);
            _validateEdge(vertices, frontierEdges, featureVertices[2], featureVertices[0]);
            this.removeFeature(i);
        }
    }

    var A = point;
    var a = this.lastVertexIndex;
    for (j = 0, len = frontierEdges.length; j < len; j++) {
        if (!frontierEdges[j]) continue;
        var b = frontierEdges[j][0];
        var c = frontierEdges[j][1];
        var B = vertices[b].vertex;
        var C = vertices[c].vertex;

        var AB = Vec3.subtract(B, A, AB_REGISTER);
        var AC = Vec3.subtract(C, A, AC_REGISTER);
        var ABC = Vec3.cross(AB, AC, new Vec3());
        ABC.normalize();

        if (!referencePoint) {
            var distance = Vec3.dot(ABC, A);
            if (distance < 0) {
                ABC.invert();
                distance *= -1;
            }
            this.addFeature(distance, ABC, [a, b, c]);
        }
        else {
            var reference = Vec3.subtract(referencePoint, A, VEC_REGISTER);
            if (Vec3.dot(ABC, reference) > -0.001) ABC.invert();
            this.addFeature(null, ABC, [a, b, c]);
        }
    }
};

/**
 * Checks if the Simplex instance contains the origin, returns true or false.
 * If false, removes a point and, as a side effect, changes input direction to be both
 * orthogonal to the current working simplex and point toward the origin.
 * Calls callback on the removed point.
 *
 * @method simplexContainsOrigin
 * @param {Vec3} direction Vector used to store the new search direction.
 * @param {Function} callback Function invoked with the removed vertex, used e.g. to free the vertex object
 * in the object manager.
 * @return {Boolean} The result of the containment check.
 */
DynamicGeometry.prototype.simplexContainsOrigin = function(direction, callback) {
    var numVertices = this.vertices.length;

    var a = this.lastVertexIndex;
    var b = a - 1;
    var c = a - 2;
    var d = a - 3;

    b = b < 0 ? b + numVertices : b;
    c = c < 0 ? c + numVertices : c;
    d = d < 0 ? d + numVertices : d;

    var A = this.vertices[a].vertex;
    var B = this.vertices[b].vertex;
    var C = this.vertices[c].vertex;
    var D = this.vertices[d].vertex;

    var AO = Vec3.scale(A, -1, AO_REGISTER);
    var AB = Vec3.subtract(B, A, AB_REGISTER);
    var AC, AD, BC, BD;
    var ABC, ACD, ABD, BCD;
    var distanceABC, distanceACD, distanceABD, distanceBCD;

    var vertexToRemove;

    if (numVertices === 4) {
        // Tetrahedron
        AC = Vec3.subtract(C, A, AC_REGISTER);
        AD = Vec3.subtract(D, A, AD_REGISTER);

        ABC = Vec3.cross(AB, AC, new Vec3());
        ACD = Vec3.cross(AC, AD, new Vec3());
        ABD = Vec3.cross(AB, AD, new Vec3());
        ABC.normalize();
        ACD.normalize();
        ABD.normalize();
        if (Vec3.dot(ABC, AD) > 0) ABC.invert();
        if (Vec3.dot(ACD, AB) > 0) ACD.invert();
        if (Vec3.dot(ABD, AC) > 0) ABD.invert();
        // Don't need to check BCD because we would have just checked that in the previous iteration
        // -- we added A to the BCD triangle because A was in the direction of the origin.

        distanceABC = Vec3.dot(ABC, AO);
        distanceACD = Vec3.dot(ACD, AO);
        distanceABD = Vec3.dot(ABD, AO);

        // Norms point away from origin -> origin is inside tetrahedron
        if (distanceABC < 0.001 && distanceABD < 0.001 && distanceACD < 0.001) {
            BC = Vec3.subtract(C, B, BC_REGISTER);
            BD = Vec3.subtract(D, B, BD_REGISTER);
            BCD = Vec3.cross(BC, BD, new Vec3());
            BCD.normalize();
            if (Vec3.dot(BCD, AB) <= 0) BCD.invert();
            distanceBCD = -1 * Vec3.dot(BCD,B);
            // Prep features for EPA
            this.addFeature(-distanceABC, ABC, [a,b,c]);
            this.addFeature(-distanceACD, ACD, [a,c,d]);
            this.addFeature(-distanceABD, ABD, [a,d,b]);
            this.addFeature(-distanceBCD, BCD, [b,c,d]);
            return true;
        }
        else if (distanceABC >= 0.001) {
            vertexToRemove = this.removeVertex(d);
            direction.copy(ABC);
        }
        else if (distanceACD >= 0.001) {
            vertexToRemove = this.removeVertex(b);
            direction.copy(ACD);
        }
        else {
            vertexToRemove = this.removeVertex(c);
            direction.copy(ABD);
        }
    }
    else if (numVertices === 3) {
        // Triangle
        AC = Vec3.subtract(C, A, AC_REGISTER);
        Vec3.cross(AB, AC, direction);
        if (Vec3.dot(direction, AO) <= 0) direction.invert();
    }
    else {
        // Line
        direction.copy(tripleProduct(AB, AO, AB));
    }
    if (vertexToRemove && callback) callback(vertexToRemove);
    return false;
};

/**
 * Given an array of Vec3's, computes the convex hull. Used in constructing bodies in the physics system and to
 * create custom GL meshes.
 *
 * @class ConvexHull
 * @constructor
 * @param {Vec3[]} vertices Cloud of vertices of which the enclosing convex hull is desired.
 * @param {Number} [iterations = 1e3] Maximum number of vertices to compose the convex hull.
 */
function ConvexHull(vertices, iterations) {
    iterations = iterations || 1e3;
    var hull = _computeConvexHull(vertices, iterations);

    var i, len;

    var indices = [];
    for (i = 0, len = hull.features.length; i < len; i++) {
        var f = hull.features[i];
        if (f) indices.push(f.vertexIndices);
    }

    var polyhedralProperties = _computePolyhedralProperties(hull.vertices, indices);
    var centroid = polyhedralProperties.centroid;

    var worldVertices = [];
    for (i = 0, len = hull.vertices.length; i < len; i++) {
        worldVertices.push(Vec3.subtract(hull.vertices[i].vertex, centroid, new Vec3()));
    }

    var normals = [];
    for (i = 0, len = worldVertices.length; i < len; i++) {
        normals.push(Vec3.normalize(worldVertices[i], new Vec3()));
    }

    var graph = {};
    var _neighborMatrix = {};
    for (i = 0; i < indices.length; i++) {
        var a = indices[i][0];
        var b = indices[i][1];
        var c = indices[i][2];

        _neighborMatrix[a] = _neighborMatrix[a] || {};
        _neighborMatrix[b] = _neighborMatrix[b] || {};
        _neighborMatrix[c] = _neighborMatrix[c] || {};

        graph[a] = graph[a] || [];
        graph[b] = graph[b] || [];
        graph[c] = graph[c] || [];

        if (!_neighborMatrix[a][b]) {
            _neighborMatrix[a][b] = 1;
            graph[a].push(b);
        }
        if (!_neighborMatrix[a][c]) {
            _neighborMatrix[a][c] = 1;
            graph[a].push(c);
        }
        if (!_neighborMatrix[b][a]) {
            _neighborMatrix[b][a] = 1;
            graph[b].push(a);
        }
        if (!_neighborMatrix[b][c]) {
            _neighborMatrix[b][c] = 1;
            graph[b].push(c);
        }
        if (!_neighborMatrix[c][a]) {
            _neighborMatrix[c][a] = 1;
            graph[c].push(a);
        }
        if (!_neighborMatrix[c][b]) {
            _neighborMatrix[c][b] = 1;
            graph[c].push(b);
        }
    }

    this.indices = indices;
    this.vertices = worldVertices;
    this.normals = normals;
    this.polyhedralProperties = polyhedralProperties;
    this.graph = graph;
}

/**
 * Performs the actual computation of the convex hull.
 *
 * @method _computeConvexHull
 * @private
 * @param {Vec3[]} vertices Cloud of vertices of which the enclosing convex hull is desired.
 * @param {Number} maxIterations Maximum number of vertices to compose the convex hull.
 * @return {DynamicGeometry} The computed hull.
 */
function _computeConvexHull(vertices, maxIterations) {
    var hull = new DynamicGeometry();

    hull.addVertex(_hullSupport(vertices, new Vec3(1, 0, 0)));
    hull.addVertex(_hullSupport(vertices, new Vec3(-1, 0, 0)));
    var A = hull.vertices[0].vertex;
    var B = hull.vertices[1].vertex;
    var AB = Vec3.subtract(B, A, AB_REGISTER);

    var dot;
    var vertex;
    var furthest;
    var index;
    var i, len;

    var max = -Infinity;
    for (i = 0; i < vertices.length; i++) {
        vertex = vertices[i];
        if (vertex === A || vertex === B) continue;
        var AV = Vec3.subtract(vertex, A, VEC_REGISTER);
        dot = Vec3.dot(AV, tripleProduct(AB, AV, AB));
        dot = dot < 0 ? dot * -1 : dot;
        if (dot > max) {
            max = dot;
            furthest = vertex;
            index = i;
        }
    }
    hull.addVertex({
        vertex: furthest,
        index: index
    });

    var C = furthest;
    var AC = Vec3.subtract(C, A, AC_REGISTER);
    var ABC = Vec3.cross(AB, AC, new Vec3());
    ABC.normalize();

    max = -Infinity;
    for (i = 0; i < vertices.length; i++) {
        vertex = vertices[i];
        if (vertex === A || vertex === B || vertex === C) continue;
        dot = Vec3.dot(Vec3.subtract(vertex, A, VEC_REGISTER), ABC);
        dot = dot < 0 ? dot * -1 : dot;
        if (dot > max) {
            max = dot;
            furthest = vertex;
            index = i;
        }
    }
    hull.addVertex({
        vertex: furthest,
        index: index
    });

    var D = furthest;
    var AD = Vec3.subtract(D, A, AD_REGISTER);
    var BC = Vec3.subtract(C, B, BC_REGISTER);
    var BD = Vec3.subtract(D, B, BD_REGISTER);

    var ACD = Vec3.cross(AC, AD, new Vec3());
    var ABD = Vec3.cross(AB, AD, new Vec3());
    var BCD = Vec3.cross(BC, BD, new Vec3());
    ACD.normalize();
    ABD.normalize();
    BCD.normalize();
    if (Vec3.dot(ABC, AD) > 0) ABC.invert();
    if (Vec3.dot(ACD, AB) > 0) ACD.invert();
    if (Vec3.dot(ABD, AC) > 0) ABD.invert();
    if (Vec3.dot(BCD, AB) < 0) BCD.invert();

    var a = 0;
    var b = 1;
    var c = 2;
    var d = 3;

    hull.addFeature(null, ABC, [a, b, c]);
    hull.addFeature(null, ACD, [a, c, d]);
    hull.addFeature(null, ABD, [a, b, d]);
    hull.addFeature(null, BCD, [b, c, d]);

    var assigned = {};
    for (i = 0, len = hull.vertices.length; i < len; i++) {
       assigned[hull.vertices[i].index] = true;
    }


    var cx = A.x + B.x + C.x + D.x;
    var cy = A.y + B.y + C.y + D.y;
    var cz = A.z + B.z + C.z + D.z;
    var referencePoint = new Vec3(cx, cy, cz);
    referencePoint.scale(0.25);

    var features = hull.features;
    var iteration = 0;
    while (iteration++ < maxIterations) {
        var currentFeature = null;
        for (i = 0, len = features.length; i < len; i++) {
            if (!features[i] || features[i].done) continue;
            currentFeature = features[i];
            furthest = null;
            index = null;
            A = hull.vertices[currentFeature.vertexIndices[0]].vertex;
            var s = _hullSupport(vertices, currentFeature.normal);
            furthest = s.vertex;
            index = s.index;
            var dist = Vec3.dot(Vec3.subtract(furthest, A, VEC_REGISTER), currentFeature.normal);

            if (dist < 0.001 || assigned[index]) {
                currentFeature.done = true;
                continue;
            }

            assigned[index] = true;
            hull.addVertex(s);
            hull.reshape(referencePoint);
        }
            // No feature has points 'above' it -> finished
        if (currentFeature === null) break;
    }

    return hull;
}

/**
 * Helper function used in _computePolyhedralProperties.
 * Sets f0 - f2 and g0 - g2 depending on w0 - w2.
 *
 * @method _subexpressions
 * @private
 * @param {Number} w0 Reference x coordinate.
 * @param {Number} w1 Reference y coordinate.
 * @param {Number} w2 Reference z coordinate.
 * @param {Number[]} f One of two output registers to contain the result of the calculation.
 * @param {Number[]} g One of two output registers to contain the result of the calculation.
 */
function _subexpressions(w0, w1, w2, f, g) {
    var t0 = w0 + w1;
    f[0] = t0 + w2;
    var t1 = w0 * w0;
    var t2 = t1 + w1 * t0;
    f[1] = t2 + w2 * f[0];
    f[2] = w0 * t1 + w1 * t2 + w2 * f[1];
    g[0] = f[1] + w0 * (f[0] + w0);
    g[1] = f[1] + w1 * (f[0] + w1);
    g[2] = f[1] + w2 * (f[0] + w2);
}

/**
 * Determines various properties of the volume.
 *
 * @method _computePolyhedralProperties
 * @private
 * @param {Vec3[]} vertices The vertices of the polyhedron.
 * @param {Number[][]} indices Array of arrays of indices of vertices composing the triangular features of the polyhedron,
 * one array for each feature.
 * @return {Object} Object holding the calculated span, volume, center, and euler tensor.
 */
function _computePolyhedralProperties(vertices, indices) {
    // Order: 1, x, y, z, x^2, y^2, z^2, xy, yz, zx
    var integrals = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var fx = [];
    var fy = [];
    var fz = [];
    var gx = [];
    var gy = [];
    var gz = [];

    var i, len;

    for (i = 0, len = indices.length; i < len; i++) {
        var A = vertices[indices[i][0]].vertex;
        var B = vertices[indices[i][1]].vertex;
        var C = vertices[indices[i][2]].vertex;
        var AB = Vec3.subtract(B, A, AB_REGISTER);
        var AC = Vec3.subtract(C, A, AC_REGISTER);
        var ABC = AB.cross(AC);
        if (Vec3.dot(A, ABC) < 0) ABC.invert();

        var d0 = ABC.x;
        var d1 = ABC.y;
        var d2 = ABC.z;

        var x0 = A.x;
        var y0 = A.y;
        var z0 = A.z;
        var x1 = B.x;
        var y1 = B.y;
        var z1 = B.z;
        var x2 = C.x;
        var y2 = C.y;
        var z2 = C.z;

        _subexpressions(x0, x1, x2, fx, gx);
        _subexpressions(y0, y1, y2, fy, gy);
        _subexpressions(z0, z1, z2, fz, gz);

        integrals[0] += d0 * fx[0];
        integrals[1] += d0 * fx[1];
        integrals[2] += d1 * fy[1];
        integrals[3] += d2 * fz[1];
        integrals[4] += d0 * fx[2];
        integrals[5] += d1 * fy[2];
        integrals[6] += d2 * fz[2];
        integrals[7] += d0 * (y0 * gx[0] + y1 * gx[1] + y2 * gx[2]);
        integrals[8] += d1 * (z0 * gy[0] + z1 * gy[1] + z2 * gy[2]);
        integrals[9] += d2 * (x0 * gz[0] + x1 * gz[1] + x2 * gz[2]);
    }

    integrals[0] /= 6;
    integrals[1] /= 24;
    integrals[2] /= 24;
    integrals[3] /= 24;
    integrals[4] /= 60;
    integrals[5] /= 60;
    integrals[6] /= 60;
    integrals[7] /= 120;
    integrals[8] /= 120;
    integrals[9] /= 120;

    var minX = Infinity, maxX = -Infinity;
    var minY = Infinity, maxY = -Infinity;
    var minZ = Infinity, maxZ = -Infinity;

    for (i = 0, len = vertices.length; i < len; i++) {
        var vertex = vertices[i].vertex;
        if (vertex.x < minX) minX = vertex.x;
        if (vertex.x > maxX) maxX = vertex.x;
        if (vertex.y < minY) minY = vertex.y;
        if (vertex.y > maxY) maxY = vertex.y;
        if (vertex.z < minZ) minZ = vertex.z;
        if (vertex.z > maxZ) maxZ = vertex.z;
    }

    var size = [maxX - minX, maxY - minY, maxZ - minZ];
    var volume = integrals[0];
    var centroid = new Vec3(integrals[1], integrals[2], integrals[3]);
    centroid.scale(1 / volume);

    var eulerTensor = new Mat33([
                                  integrals[4], integrals[7], integrals[9],
                                  integrals[7], integrals[5], integrals[8],
                                  integrals[9], integrals[8], integrals[6]
                                 ]);

    return {
        size: size,
        volume: volume,
        centroid: centroid,
        eulerTensor: eulerTensor
    };
}

module.exports = {
    DynamicGeometry: DynamicGeometry,
    ConvexHull: ConvexHull
};

},{"famous-math":82,"famous-utilities":95}],100:[function(require,module,exports){
'use strict';

var Particle = require('./bodies/Particle');
var Constraint = require('./constraints/Constraint');
var Force = require('./forces/Force');

var Vec3 = require('famous-math').Vec3;
var Quaternion = require('famous-math').Quaternion;

var VEC_REGISTER = new Vec3();
var ZYX_REGISTER = new Vec3();
var QUAT_REGISTER = new Quaternion();
var DELTA_REGISTER = new Vec3();

/**
 * Singleton PhysicsEngine object.
 * Manages bodies, forces, constraints.
 *
 * @class PhysicsEngine
 * @param {Object} options A hash of configurable options.
 */
function PhysicsEngine(options) {
    options = options || {};
    /** @prop bodies The bodies currently active in the engine. */
    this.bodies = [];
    /** @prop forces The forces currently active in the engine. */
    this.forces = [];
    /** @prop constraints The constraints currently active in the engine. */
    this.constraints = [];

    /** @prop step The time between frames in the engine. */
    this.step = options.step || 1000/60;
    /** @prop iterations The number of times each constraint is solved per frame. */
    this.iterations = options.iterations || 10;
    /** @prop _indexPool Pools of indicies to track holes in the arrays. */
    this._indexPools = {
        bodies: [],
        forces: [],
        constraints: []
    };

    this._entityMaps = {
        bodies: {},
        forces: {},
        constraints: {}
    };

    this.speed = options.speed || 1.0;
    this.time = 0;
    this.delta = 0;

    this.origin = options.origin || new Vec3();
    this.orientation = options.orientation ? options.orientation.normalize() :  new Quaternion();

    this.prestep = [];
    this.poststep = [];

    this.frameDependent = options.frameDependent || false;

    this.transformBuffers = {
        position: [0, 0, 0],
        rotation: [0, 0, 0]
    };
}

/**
 * Set the origin of the world.
 *
 * @method setOrigin
 * @chainable
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 */
PhysicsEngine.prototype.setOrigin = function setOrigin(x, y, z) {
    this.origin.set(x, y, z);
    return this;
};

/**
 * Set the orientation of the world.
 *
 * @method setOrientation
 * @chainable
 * @param {Number} w The w component.
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 */
PhysicsEngine.prototype.setOrientation = function setOrientation(w, x, y, z) {
    this.orientation.set(w, x, y, z).normalize();
    return this;
};

/**
 * Private helper method to store an element in a library array.
 *
 * @method _addElement
 * @private
 * @param {Object} element The body, force, or constraint to add.
 * @param {String} key Where to store the element.
 */
function _addElement(context, element, key) {
    var map = context._entityMaps[key];
    if (map[element._ID] == null) {
        var library = context[key];
        var indexPool = context._indexPools[key];
        if (indexPool.length) map[element._ID] = indexPool.pop();
        else map[element._ID] = library.length;
        library[map[element._ID]] = element;
    }
}

/**
 * Private helper method to remove an element from a library array.
 *
 * @method _removeElement
 * @private
 * @param {Object} element The body, force, or constraint to remove.
 * @param {String} key Where to store the element.
 */
function _removeElement(context, element, key) {
    var map = context._entityMaps[key];
    var index = map[element._ID];
    if (index != null) {
        context._indexPools[key].push(index);
        context[key][index] = null;
        map[element._ID] = null;
    }
}

/**
 * Add a group of bodies, force, or constraints to the engine.
 *
 * @method add
 * @chainable
 */
PhysicsEngine.prototype.add = function add() {
    for (var j = 0, lenj = arguments.length; j < lenj; j++) {
        var entity = arguments[j];
        if (entity instanceof Array) {
            for (var i = 0, len = entity.length; i < len; i++) {
                var e = entity[i];
                this.add(e);
            }
        } else {
            if (entity instanceof Particle) this.addBody(entity);
            else if (entity instanceof Constraint) this.addConstraint(entity);
            else if (entity instanceof Force) this.addForce(entity);
        }
    }
    return this;
};

/**
 * Remove a group of bodies, force, or constraints from the engine.
 *
 * @method remove
 * @chainable
 */
PhysicsEngine.prototype.remove = function remove() {
    for (var j = 0, lenj = arguments.length; j < lenj; j++) {
        var entity = arguments[j];
        if (entity instanceof Array) {
            for (var i = 0, len = entity.length; i < len; i++) {
                var e = entity[i];
                this.add(e);
            }
        } else {
            if (entity instanceof Particle) this.removeBody(entity);
            else if (entity instanceof Constraint) this.removeConstraint(entity);
            else if (entity instanceof Force) this.removeForce(entity);
        }
    }
    return this;
};

/**
 * Begin tracking a body.
 *
 * @method addBody
 * @param {Particle} body The body to track.
 */
PhysicsEngine.prototype.addBody = function addBody(body) {
    _addElement(this, body, 'bodies');
};

/**
 * Begin tracking a force.
 *
 * @method addForce
 * @param {Force} force The force to track.
 */
PhysicsEngine.prototype.addForce = function addForce(force) {
    _addElement(this, force, 'forces');
};

/**
 * Begin tracking a constraint.
 *
 * @method addConstraint
 * @param {Constraint} constraint The constraint to track.
 */
PhysicsEngine.prototype.addConstraint = function addConstraint(constraint) {
    _addElement(this, constraint, 'constraints');
};

/**
 * Stop tracking a body.
 *
 * @method removeBody
 * @param {Particle} body The body to stop tracking.
 */
PhysicsEngine.prototype.removeBody = function removeBody(body) {
    _removeElement(this, body, 'bodies');
};

/**
 * Stop tracking a force.
 *
 * @method removeForce
 * @param {Force} force The force to stop tracking.
 */
PhysicsEngine.prototype.removeForce = function removeForce(force) {
    _removeElement(this, force, 'forces');
};

/**
 * Stop tracking a constraint.
 *
 * @method removeConstraint
 * @param {Constraint} constraint The constraint to stop tracking.
 */
PhysicsEngine.prototype.removeConstraint = function removeConstraint(constraint) {
    _removeElement(this, constraint, 'constraints');
};

/**
 * Update the physics system to reflect the changes since the last frame. Steps forward in increments of
 * PhysicsEngine.step.
 *
 * @method update
 * @param {Number} time
 */
PhysicsEngine.prototype.update = function update(time) {
    if (this.time === 0) this.time = time;

    var bodies = this.bodies;
    var forces = this.forces;
    var constraints = this.constraints;

    var frameDependent = this.frameDependent;
    var step = this.step;
    var dt = step * 0.001;
    var speed = this.speed;

    var delta = this.delta;
    delta += (time - this.time) * speed;
    this.time = time;

    var i, len;
    var force, body, constraint;

    while(delta > step) {
        for (i = 0, len = this.prestep.length; i < len; i++) {
            this.prestep[i](time, dt);
        }

        // Update Forces on particles
        for (i = 0, len = forces.length; i < len; i++) {
            force = forces[i];
            if (force === null) continue;
            force.update(time, dt);
        }

        // Tentatively update velocities
        for (i = 0, len = bodies.length; i < len; i++) {
            body = bodies[i];
            if (body === null) continue;
            _integrateVelocity(body, dt);
        }

        // Prep constraints for solver
        for (i = 0, len = constraints.length; i < len; i++) {
            constraint = constraints[i];
            if (constraint === null) continue;
            constraint.update(time, dt);
        }

        // Iteratively resolve constraints
        for (var j = 0, numIterations = this.iterations; j < numIterations; j++) {
            for (i = 0, len = constraints.length; i < len; i++) {
                constraint = constraints[i];
                if (constraint === null) continue;
                constraint.resolve(time, dt);
            }
        }

        // Increment positions and orientations
        for (i = 0, len = bodies.length; i < len; i++) {
            body = bodies[i];
            if (body === null) continue;
            _integratePose(body, dt);
        }

        for (i = 0, len = this.poststep.length; i < len; i++) {
            this.poststep[i](time, dt);
        }

        if (frameDependent) delta = 0;
        else delta -= step;
    }

    this.delta = delta;
};

/**
 * Get the transform equivalent to the Particle's position and orientation.
 *
 * @method getTransform
 * @return {Object} Position and rotation of the boy, taking into account
 * the origin and orientation of the world.
 */
PhysicsEngine.prototype.getTransform = function getTransform(body) {
    var o = this.origin;
    var oq = this.orientation;
    var transform = this.transformBuffers;

    var p = body.position;
    var q = body.orientation;
    var rot = q;
    var loc = p;

    if (oq.w !== 1) {
        rot = Quaternion.multiply(q, oq, QUAT_REGISTER);
        loc = oq.rotateVector(p, VEC_REGISTER);
    }
    var ZYX = rot.toEuler(ZYX_REGISTER);

    transform.position[0] = o.x+loc.x;
    transform.position[1] = o.y+loc.y;
    transform.position[2] = o.z+loc.z;

    transform.rotation[0] = ZYX.x;
    transform.rotation[1] = ZYX.y;
    transform.rotation[2] = ZYX.z;

    return transform;
};

/**
 * Update the Particle momenta based off of current incident force and torque.
 *
 * @method _integrateVelocity
 * @private
 * @param {Particle} body
 * @param {Number} dt delta time
 */
function _integrateVelocity(body, dt) {
    body.momentum.add(Vec3.scale(body.force, dt, DELTA_REGISTER));
    body.angularMomentum.add(Vec3.scale(body.torque, dt, DELTA_REGISTER));
    Vec3.scale(body.momentum, body.inverseMass, body.velocity);
    body.inverseInertia.vectorMultiply(body.angularMomentum, body.angularVelocity);
    body.force.clear();
    body.torque.clear();
}

/**
 * Update the Particle position and orientation based off current translational and angular velocities.
 *
 * @method _integratePose
 * @private
 * @param {Particle} body
 * @param dt {Number} delta time
 */
function _integratePose(body, dt) {
    if (body.restrictions !== 0) {
        var restrictions = body.restrictions;
        var x = null;
        var y = null;
        var z = null;
        var ax = null;
        var ay = null;
        var az = null;

        if (restrictions & 32) x = 0;
        if (restrictions & 16) y = 0;
        if (restrictions & 8) z = 0;
        if (restrictions & 4) ax = 0;
        if (restrictions & 2) ay = 0;
        if (restrictions & 1) az = 0;

        if (x !== null || y !== null || z !== null) body.setVelocity(x,y,z);
        if (ax !== null || ay !== null || az !== null) body.setAngularVelocity(ax, ay, az);
    }

    body.position.add(Vec3.scale(body.velocity, dt, DELTA_REGISTER));

    var w = body.angularVelocity;
    var q = body.orientation;
    var wx = w.x;
    var wy = w.y;
    var wz = w.z;

    var qw = q.w;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;

    var hdt = dt * 0.5;
    q.w += (-wx * qx - wy * qy - wz * qz) * hdt;
    q.x += (wx * qw + wy * qz - wz * qy) * hdt;
    q.y += (wy * qw + wz * qx - wx * qz) * hdt;
    q.z += (wz * qw + wx * qy - wy * qx) * hdt;

    q.normalize();

    body.updateInertia();
}

module.exports = PhysicsEngine;

},{"./bodies/Particle":103,"./constraints/Constraint":108,"./forces/Force":120,"famous-math":82}],101:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var ConvexBodyFactory = require('./ConvexBodyFactory');

var _Box = ConvexBodyFactory([
            // Order: back-left,back-right,front-left,front-right
            // Top half
            new Vec3(-100, -100, -100),
            new Vec3(100, -100, -100),
            new Vec3(-100, -100, 100),
            new Vec3(100, -100, 100),
            // Bottom half
            new Vec3(-100, 100, -100),
            new Vec3(100, 100, -100),
            new Vec3(-100, 100, 100),
            new Vec3(100, 100, 100),
        ]);

/**
 * @class Box
 * @extends Particle
 * @param {Object} options
 */
function Box(options) {
    _Box.call(this, options);
    this.normals = [
        // Order: top, right, front
        new Vec3(0, 1, 0),
        new Vec3(1, 0, 0),
        new Vec3(0, 0, 1)
    ];

    this.type = 1 << 1;
}

Box.prototype = Object.create(_Box.prototype);
Box.prototype.constructor = Box;

module.exports = Box;

},{"./ConvexBodyFactory":102,"famous-math":82}],102:[function(require,module,exports){
'use strict';

var Particle = require('../bodies/Particle');
var Mat33 = require('famous-math').Mat33;
var Vec3 = require('famous-math').Vec3;
var Geometry = require('../Geometry');
var ConvexHull = Geometry.ConvexHull;

var TEMP_REGISTER = new Vec3();

/**
 * Returns a constructor for a physical body reflecting the shape defined by input ConvexHull or Vec3 array.
 *
 * @method ConvexBodyFactory
 * @param {ConvexHull | Vec3[]} hull
 * @return {Function} The constructor.
 */
function ConvexBodyFactory(hull) {
    if (!(hull instanceof ConvexHull)) {
        if (!(hull instanceof Array)) throw new Error('ConvexBodyFactory requires a ConvexHull object or an array of Vec3\'s as input.');
        else hull = new ConvexHull(hull);
    }

    /**
     * The body class with inertia and vertices inferred from the input ConvexHull or Vec3 array.
     *
     * @class ConvexBody
     * @param {Object} options The options hash.
     */
    function ConvexBody(options) {
        Particle.call(this, options);

        var originalSize = hull.polyhedralProperties.size;
        var size = options.size || originalSize;

        var scaleX = size[0] / originalSize[0];
        var scaleY = size[1] / originalSize[1];
        var scaleZ = size[2] / originalSize[2];

        this._scale = [scaleX, scaleY, scaleZ];

        var T = new Mat33([scaleX, 0, 0, 0, scaleY, 0, 0, 0, scaleZ]);

        this.hull = hull;

        this.vertices = [];
        for (var i = 0, len = hull.vertices.length; i < len; i++) {
            this.vertices.push(T.vectorMultiply(hull.vertices[i], new Vec3()));
        }

        _computeInertiaProperties.call(this, T);
        this.inverseInertia.copy(this.localInverseInertia);
        this.updateInertia();
    }

    ConvexBody.prototype = Object.create(Particle.prototype);
    ConvexBody.prototype.constructor = ConvexBody;

    /**
     * Set the size and recalculate
     *
     * @method setSize
     * @chainable
     * @param {Number} x The x span.
     * @param {Number} y The y span.
     * @param {Number} z The z span.
     */
    ConvexBody.prototype.setSize = function setSize(x,y,z) {
        var originalSize = hull.polyhedralProperties.size;

        this.size[0] = x;
        this.size[1] = y;
        this.size[2] = z;

        var scaleX = x / originalSize[0];
        var scaleY = y / originalSize[1];
        var scaleZ = z / originalSize[2];

        this._scale = [scaleX, scaleY, scaleZ];

        var T = new Mat33([scaleX, 0, 0, 0, scaleY, 0, 0, 0, scaleZ]);

        var vertices = this.vertices;
        for (var i = 0, len = hull.vertices.length; i < len; i++) {
            T.vectorMultiply(hull.vertices[i], vertices[i]);
        }

        return this;
    };

    /**
     * Update the local inertia and inverse inertia to reflect the current size.
     *
     * @method updateLocalInertia
     * @chainable
     */
    ConvexBody.prototype.updateLocalInertia = function updateInertia() {
        var scaleX = this._scale[0];
        var scaleY = this._scale[1];
        var scaleZ = this._scale[2];

        var T = new Mat33([scaleX, 0, 0, 0, scaleY, 0, 0, 0, scaleZ]);

        _computeInertiaProperties.call(this, T);

        return this;
    };

    /**
     * Retrieve the vertex furthest in a direction. Used internally for collision detection.
     *
     * @method support
     * @return {Vec3} The furthest vertex.
     */
    ConvexBody.prototype.support = function support(direction) {
        var vertices = this.vertices;
        var vertex, dot, furthest;
        var max = -Infinity;
        for (var i = 0, len = vertices.length; i < len; i++) {
            vertex = vertices[i];
            dot = Vec3.dot(vertex,direction);
            if (dot > max) {
                furthest = vertex;
                max = dot;
            }
        }
        return furthest;
    };

    /**
     * Update vertices to reflect current orientation.
     *
     * @method updateShape
     * @chainable
     */
    ConvexBody.prototype.updateShape = function updateShape() {
        var vertices = this.vertices;
        var q = this.orientation;
        var modelVertices = this.hull.vertices;

        var scaleX = this._scale[0];
        var scaleY = this._scale[1];
        var scaleZ = this._scale[2];

        var t = TEMP_REGISTER;
        for (var i = 0, len = vertices.length; i < len; i++) {
            t.copy(modelVertices[i]);
            t.x *= scaleX;
            t.y *= scaleY;
            t.z *= scaleZ;
            Vec3.applyRotation(t, q, vertices[i]);
        }

        return this;
    };

    return ConvexBody;
}

/**
 * Determines mass and inertia tensor based off the density, size, and facet information of the polyhedron.
 *
 * @method _computeInertiaProperties
 * @private
 * @param {Mat33} T The matrix transforming the intial set of vertices to a set reflecting the body size.
 */
function _computeInertiaProperties(T) {
    var polyhedralProperties = this.hull.polyhedralProperties;
    var T_values = T.get();
    var detT = T_values[0] * T_values[4] * T_values[8];

    var E_o = polyhedralProperties.eulerTensor;

    var E = new Mat33();
    Mat33.multiply(T, E_o, E);
    Mat33.multiply(E, T, E);
    var E_values = E.get();

    var Exx = E_values[0];
    var Eyy = E_values[4];
    var Ezz = E_values[8];
    var Exy = E_values[1];
    var Eyz = E_values[7];
    var Exz = E_values[2];

    var newVolume = polyhedralProperties.volume * detT;
    var mass = this.mass;
    var density = mass / newVolume;

    var Ixx = Eyy + Ezz;
    var Iyy = Exx + Ezz;
    var Izz = Exx + Eyy;
    var Ixy = -Exy;
    var Iyz = -Eyz;
    var Ixz = -Exz;

    var centroid = polyhedralProperties.centroid;

    Ixx -= newVolume * (centroid.y * centroid.y + centroid.z * centroid.z);
    Iyy -= newVolume * (centroid.z * centroid.z + centroid.x * centroid.x);
    Izz -= newVolume * (centroid.x * centroid.x + centroid.y * centroid.y);
    Ixy += newVolume * centroid.x * centroid.y;
    Iyz += newVolume * centroid.y * centroid.z;
    Ixz += newVolume * centroid.z * centroid.x;

    Ixx *= density * detT;
    Iyy *= density * detT;
    Izz *= density * detT;
    Ixy *= density * detT;
    Iyz *= density * detT;
    Ixz *= density * detT;

    var inertia = [
        Ixx, Ixy, Ixz,
        Ixy, Iyy, Iyz,
        Ixz, Iyz, Izz
    ];

    this.localInertia.set(inertia);
    Mat33.inverse(this.localInertia, this.localInverseInertia);
}

module.exports = ConvexBodyFactory;

},{"../Geometry":99,"../bodies/Particle":103,"famous-math":82}],103:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var Quaternion = require('famous-math').Quaternion;
var Mat33 = require('famous-math').Mat33;

var CallbackStore = require('famous-utilities').CallbackStore;

var ZERO_VECTOR = new Vec3();

var MAT1_REGISTER = new Mat33();

var _ID = 0;
/**
 * Fundamental physical body. Maintains translational and angular momentum, position and orientation, and other properties
 * such as size and coefficients of restitution and friction used in collision response.
 *
 * @class Particle
 * @extends Particle
 * @param {Object} options sets the initial state of the Particle
 * @constructor
 */
function Particle(options) {
    options = options || {};

    this.events = new CallbackStore();

    this.position = options.position || new Vec3();
    this.orientation = options.orientation || new Quaternion();

    this.velocity = new Vec3();
    this.momentum = new Vec3();
    this.angularVelocity = new Vec3();
    this.angularMomentum = new Vec3();

    this.mass = options.mass || 1;
    this.inverseMass = 1 / this.mass;

    this.force = new Vec3();
    this.torque = new Vec3();

    this.restitution = options.restitution != null ? options.restitution : 0.4;
    this.friction = options.friction != null ? options.friction : 0.2;

    this.inverseInertia = new Mat33([0,0,0,0,0,0,0,0,0]);

    this.localInertia = new Mat33([0,0,0,0,0,0,0,0,0]);
    this.localInverseInertia = new Mat33([0,0,0,0,0,0,0,0,0]);

    this.size = options.size || [0, 0, 0];

    var v = options.velocity;
    var w = options.angularVelocity;
    if (v) this.setVelocity(v.x, v.y, v.z);
    if (w) this.setAngularVelocity(w.x, w.y, w.z);

    this.restrictions = 0;
    this.setRestrictions.apply(this, options.restrictions || []);

    this.collisionMask = options.collisionMask || 1;
    this.collisionGroup = options.collisionGroup || 1;

    this.type = 1 << 0;

    this._ID = _ID++;
}

/**
 * Getter for the restriction bitmask. Converts the restrictions to their string representation.
 *
 * @method getRestrictions
 * @return {String[]} restrictions
 */
Particle.prototype.getRestrictions = function getRestrictions() {
    var linear = '';
    var angular = '';
    var restrictions = this.restrictions;
    if (restrictions & 32) linear += 'x';
    if (restrictions & 16) linear += 'y';
    if (restrictions & 8) linear += 'z';
    if (restrictions & 4) angular += 'x';
    if (restrictions & 2) angular += 'y';
    if (restrictions & 1) angular += 'z';

    return [linear, angular];
};

/**
 * Setter for the particle restriction bitmask.
 *
 * @method setRestrictions
 * @param {String} transRestrictions
 * @param {String} rotRestrictions
 * @chainable
 */
Particle.prototype.setRestrictions = function setRestrictions(transRestrictions, rotRestrictions) {
    transRestrictions = transRestrictions || '';
    rotRestrictions = rotRestrictions || '';
    this.restrictions = 0;
    if (transRestrictions.indexOf('x') > -1) this.restrictions |= 32;
    if (transRestrictions.indexOf('y') > -1) this.restrictions |= 16;
    if (transRestrictions.indexOf('z') > -1) this.restrictions |= 8;
    if (rotRestrictions.indexOf('x') > -1) this.restrictions |= 4;
    if (rotRestrictions.indexOf('y') > -1) this.restrictions |= 2;
    if (rotRestrictions.indexOf('z') > -1) this.restrictions |= 1;
    return this;
};

/**
 * Getter for mass
 *
 * @method getMass
 * @return {Number} mass
 */
Particle.prototype.getMass = function getMass() {
    return this.mass;
};

/**
 * Set the mass of the Particle.  Can be used to change the mass several times
 *
 * @method setMass
 * @param {Number} mass
 * @chainable
 */
Particle.prototype.setMass = function setMass(mass) {
    this.mass = mass;
    this.inverseMass = 1 / mass;
    return this;
};

/**
 * Getter for inverse mass
 *
 * @method getInverseMass
 * @return {Number} inverse mass
 */
Particle.prototype.getInverseMass = function() {
    return this.inverseMass;
};

/**
 * Resets the inertia tensor and its inverse to reflect the current shape.
 *
 * @method updateLocalInertia
 * @chainable
 * @param {Mat33} Mat33
 */
Particle.prototype.updateLocalInertia = function updateLocalInertia() {
    this.localInertia.set([0,0,0,0,0,0,0,0,0]);
    this.localInverseInertia.set([0,0,0,0,0,0,0,0,0]);
    return this;
};

/**
 * Updates the world inverse inertia tensor.
 *
 * @method updateInertia
 * @chainable
 */
Particle.prototype.updateInertia = function updateInertia() {
    var localInvI = this.localInverseInertia;
    var q = this.orientation;
    if (localInvI[0] === localInvI[4] && localInvI[4] === localInvI[8]) return;
    if (q.w === 1) return;
    var R = q.toMatrix(MAT1_REGISTER);
    Mat33.multiply(R, this.inverseInertia, this.inverseInertia);
    Mat33.multiply(this.localInverseInertia, R.transpose(), this.inverseInertia);
    return this;
};

/**
 * Getter for position
 *
 * @method getPosition
 * @return {Vec3} position
 */
Particle.prototype.getPosition = function getPosition() {
    return this.position;
};

/**
 * Setter for position
 *
 * @method setPosition
 * @param {Number} x the x coordinate for position
 * @param {Number} y the y coordinate for position
 * @param {Number} z the z coordinate for position
 * @return {Particle} this
 * @chainable
 */
Particle.prototype.setPosition = function setPosition(x, y, z) {
    this.position.set(x, y, z);
    return this;
};

/**
 * Getter for velocity
 *
 * @method getVelocity
 * @return {Vec3} velocity
 */
Particle.prototype.getVelocity = function getVelocity() {
    return this.velocity;
};

/**
 * Setter for velocity
 *
 * @method setvelocity
 * @param {Number} x the x coordinate for velocity
 * @param {Number} y the y coordinate for velocity
 * @param {Number} z the z coordinate for velocity
 * @chainable
 */
Particle.prototype.setVelocity = function setVelocity(x, y, z) {
    this.velocity.set(x, y, z);
    Vec3.scale(this.velocity, this.mass, this.momentum);
    return this;
};

/**
 * Getter for momenutm
 *
 * @method getMomentum
 * @return {Vec3} momentum
 */
Particle.prototype.getMomentum = function getMomentum() {
    return this.momentum;
};

/**
 * Setter for momentum
 *
 * @method setMomentum
 * @param {Number} x the x coordinate for momentum
 * @param {Number} y the y coordinate for momentum
 * @param {Number} z the z coordinate for momentum
 * @chainable
 */
Particle.prototype.setMomentum = function setMomentum(x, y, z) {
    this.momentum.set(x, y, z);
    Vec3.scale(this.momentum, this.inverseMass, this.velocity);
    return this;
};

/**
 * Getter for orientation
 *
 * @method getOrientation
 * @return {Quaternion} orientation
 */
Particle.prototype.getOrientation = function getOrientation() {
    return this.orientation;
};

/**
 * Setter for orientation
 *
 * @method setOrientation
 * @param {Number} w
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @chainable
 */
Particle.prototype.setOrientation = function setOrientation(w,x,y,z) {
    this.orientation.set(w,x,y,z).normalize();
    this.updateInertia();
    return this;
};

/**
 * Getter for angular velocity
 *
 * @method getAngularVelocity
 * @return {Vec3} angularVelocity
 */
Particle.prototype.getAngularVelocity = function getAngularVelocity() {
    return this.angularVelocity;
};

/**
 * Setter for angular velocity
 *
 * @method setAngularVelocity
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Particle.prototype.setAngularVelocity = function setAngularVelocity(x,y,z) {
    this.angularVelocity.set(x,y,z);
    var I = Mat33.inverse(this.inverseInertia, MAT1_REGISTER);
    if (I) I.vectorMultiply(this.angularVelocity, this.angularMomentum);
    else this.angularMomentum.clear();
    return this;
};

/**
 * Getter for angular momentum
 *
 * @method getAngularMomentum
 * @return {Vec3} angular momentum
 */
Particle.prototype.getAngularMomentum = function getAngularMomentum() {
    return this.angularMomentum;
};

/**
 * Setter for angular momentum
 *
 * @method setAngularMomentum
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Particle.prototype.setAngularMomentum = function setAngularMomentum(x,y,z) {
    this.angularMomentum.set(x,y,z);
    this.inverseInertia.vectorMultiply(this.angularMomentum, this.angularVelocity);
    return this;
};

/**
 * Getter for the force on the Particle
 *
 * @method getForce
 * @return {Vec3} force
 */
Particle.prototype.getForce = function getForce() {
    return this.force;
};

/**
 * Setter for the force on the Particle
 *
 * @method setForce
 * @param {Vec3} v the new Force
 * @chainable
 */
Particle.prototype.setForce = function setForce(x, y, z) {
    this.force.set(x, y, z);
    return this;
};

/**
 * Getter for torque.
 *
 * @method getTorque
 */
Particle.prototype.getTorque = function getTorque() {
    return this.torque;
};

/**
 * Setter for torque.
 *
 * @method setTorque
 * @param {Vec3} v
 * @chainable
 */
Particle.prototype.setTorque = function setTorque(x, y, z) {
    this.torque.set(x, y, z);
    return this;
};

/**
 * Extends Particle.applyForce with an optional argument
 * to apply the force at an off-centered location, resulting in a torque.
 *
 * @method applyForce
 * @param force {Vec3} force
 * @param {Vec3} location off-center location on the Particle (optional)
 */
Particle.prototype.applyForce = function applyForce(force) {
    this.force.add(force);
    return this;
};

/**
 * Applied a torque force to a Particle, inducing a rotation.
 *
 * @method applyTorque
 * @param torque {Vec3} torque
 */
Particle.prototype.applyTorque = function applyTorque(torque) {
    this.torque.add(torque);
    return this;
};

/**
 * Applies an impulse to momentum and updates velocity.
 *
 * @method applyImpulse
 * @param {Vec3} impulse
 */
Particle.prototype.applyImpulse = function applyImpulse(impulse) {
    this.momentum.add(impulse);
    Vec3.scale(this.momentum, this.inverseMass, this.velocity);
    return this;
};

/**
 * Applies an angular impulse to angular momentum and updates angular velocity.
 *
 * @method applyAngularImpulse
 * @param {Vec3} angularImpulse
 */
Particle.prototype.applyAngularImpulse = function applyAngularImpulse(angularImpulse) {
    this.angularMomentum.add(angularImpulse);
    this.inverseInertia.vectorMultiply(this.angularMomentum, this.angularVelocity);
    return this;
};

/**
 * Used in collision detection. The support function should accept a Vec3 direction
 * and return the point on the body's shape furthest in that direction. For point particles,
 * this returns the zero vector.
 *
 * @method support
 * @return {Vec3}
 */
Particle.prototype.support = function support() {
    return ZERO_VECTOR;
};

/**
 * Update the body's shape to reflect current orientation. Called in _integratePose.
 * Noop for point particles.
 *
 * @method updateShape
 */
Particle.prototype.updateShape = function updateShape() {};

module.exports = Particle;

},{"famous-math":82,"famous-utilities":95}],104:[function(require,module,exports){
'use strict';

var Particle = require('./Particle');
var Vec3 = require('famous-math').Vec3;

var SUPPORT_REGISTER = new Vec3();

/**
 * Spherical Rigid body
 *
 * @class Sphere
 * @extends Particle
 * @param {Object} options
 */
function Sphere(options) {
    Particle.call(this, options);
    var r  = options.radius || 1;
    this.radius = r;
    this.size = [2*r, 2*r, 2*r];
    this.updateLocalInertia();
    this.inverseInertia.copy(this.localInverseInertia);

    this.type = 1 << 2;
}

Sphere.prototype = Object.create(Particle.prototype);
Sphere.prototype.constructor = Sphere;

/**
 * Getter for radius.
 *
 * @method getRadius
 * @return {Number} radius
 */
Sphere.prototype.getRadius = function getRadius() {
    return this.radius;
};

/**
 * Setter for radius.
 *
 * @method setRadius
 * @param {Number} radius The intended radius of the sphere.
 * @chainable
 */
Sphere.prototype.setRadius = function setRadius(radius) {
    this.radius = radius;
    this.size = [2*this.radius, 2*this.radius, 2*this.radius];
    return this;
};

/**
 * Infers the inertia tensor.
 *
 * @override
 * @method updateInertia
 */
Sphere.prototype.updateLocalInertia = function updateInertia() {
    var m = this.mass;
    var r = this.radius;

    var mrr = m * r * r;

    this.localInertia.set([
        0.4 * mrr, 0, 0,
        0, 0.4 * mrr, 0,
        0, 0, 0.4 * mrr
    ]);

    this.localInverseInertia.set([
        2.5 / mrr, 0, 0,
        0, 2.5 / mrr, 0,
        0, 0, 2.5 / mrr
    ]);
};

/**
 * Returns the point on the sphere furthest in a given direction.
 *
 * @method support
 * @param {Vec3} direction
 * @param {Vec3}
 */
Sphere.prototype.support = function support(direction) {
    return Vec3.scale(direction, this.radius, SUPPORT_REGISTER);
};

/**
 * @exports Sphere
 * @module Sphere
 */
module.exports = Sphere;

},{"./Particle":103,"famous-math":82}],105:[function(require,module,exports){
'use strict';

var Particle = require('./Particle');
var Vec3 = require('famous-math').Vec3;

/**
 * @enum directions
 */
Wall.DOWN = 0;
Wall.UP = 1;
Wall.LEFT = 2;
Wall.RIGHT = 3;
Wall.FORWARD = 4;
Wall.BACKWARD = 5;

/**
 * An axis-aligned boundary. Will not respond to forces or impulses.
 *
 * @class Wall
 * @extends Particle
 * @param {Object} options
 */
function Wall(options) {
    Particle.call(this, options);

    var n = this.normal = new Vec3();

    var d = this.direction = options.direction;
    switch (d) {
        case Wall.DOWN:
            n.set(0, 1, 0);
            break;
        case Wall.UP:
            n.set(0, -1, 0);
            break;
        case Wall.LEFT:
            n.set(-1, 0, 0);
            break;
        case Wall.RIGHT:
            n.set(1, 0, 0);
            break;
        case Wall.FORWARD:
            n.set(0, 0, -1);
            break;
        case Wall.BACKWARD:
            n.set(0, 0, 1);
            break;
        default:
            break;
    }

    this.invNormal = Vec3.clone(n, new Vec3()).invert();

    this.mass = Infinity;
    this.inverseMass = 0;

    this.type = 1 << 3;
}

Wall.prototype = Object.create(Particle.prototype);
Wall.prototype.constructor = Wall;

module.exports = Wall;

},{"./Particle":103,"famous-math":82}],106:[function(require,module,exports){
'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('famous-math').Vec3;
var Mat33 = require('famous-math').Mat33;

var DELTA_REGISTER = new Vec3();

/**
 *  A constraint that keeps a physics body a given direction away from a given
 *  anchor, or another attached body.
 *
 *  @class Angle
 *  @extends Constraint
 *  @param {Particle} a One of the bodies.
 *  @param {Particle} b The other body.
 *  @param {Object} options An object of configurable options.
 */
function Angle(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.effectiveInertia = new Mat33();
    this.angularImpulse = new Vec3();
    this.error = 0;
}

Angle.prototype = Object.create(Constraint.prototype);
Angle.prototype.constructor = Angle;

/**
 * Initialize the Angle. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Angle.prototype.init = function() {
    this.cosAngle = this.cosAngle || this.a.orientation.dot(this.b.orientation);
};

/**
 * Warmstart the constraint and prepare calculations used in .resolve.
 *
 * @method update
 */
Angle.prototype.update = function update() {
    var a = this.a;
    var b = this.b;

    var q1 = a.orientation;
    var q2 = b.orientation;

    var cosTheta = q1.dot(q2);
    var diff = 2*(cosTheta - this.cosAngle);

    this.error = diff;

    var angularImpulse = this.angularImpulse;
    b.applyAngularImpulse(angularImpulse);
    a.applyAngularImpulse(angularImpulse.invert());

    Mat33.add(a.inverseInertia, b.inverseInertia, this.effectiveInertia);
    this.effectiveInertia.inverse();

    angularImpulse.clear();
};

/**
 * Adds an angular impulse to a physics body's angular velocity.
 *
 * @method resolve
 */
Angle.prototype.resolve = function update() {
    var a = this.a;
    var b = this.b;

    var diffW = DELTA_REGISTER;

    var w1 = a.angularVelocity;
    var w2 = b.angularVelocity;

    Vec3.subtract(w1, w2, diffW);
    diffW.scale(1 + this.error);

    var angularImpulse = diffW.applyMatrix(this.effectiveInertia);

    b.applyAngularImpulse(angularImpulse);
    a.applyAngularImpulse(angularImpulse.invert());
    angularImpulse.invert();
    this.angularImpulse.add(angularImpulse);
};

module.exports = Angle;

},{"./Constraint":108,"famous-math":82}],107:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var Constraint = require('./Constraint');

var SweepAndPrune = require('./collision/SweepAndPrune');
var BruteForce = require('./collision/BruteForce');
var ConvexCollision = require('./collision/ConvexCollisionDetection');
var GJK = ConvexCollision.GJK;
var EPA = ConvexCollision.EPA;
var ContactManifoldTable = require('./collision/ContactManifold');

var ObjectManager = require('famous-utilities').ObjectManager;
ObjectManager.register('CollisionData', CollisionData);
var OMRequestCollisionData = ObjectManager.requestCollisionData;

var VEC_REGISTER = new Vec3();

/**
 * Helper function to clamp a value to a given range.
 *
 * @method clamp
 * @private
 * @param {Number} value
 * @param {Number} lower
 * @param {Number} upper
 * @return {Number}
 */
function clamp(value, lower, upper) {
    return value < lower ? lower : value > upper ? upper : value;
}

/**
 * Object maintaining various figures of a collision. Registered in ObjectManager.
 *
 * @class CollisionData
 * @param {Number} penetration
 * @param {Vec3} normal
 * @param {Vec3} worldContactA
 * @param {Vec3} worldContactB
 * @param {Vec3} localContactA
 * @param {Vec3} localContactB
 */
function CollisionData(penetration, normal, worldContactA, worldContactB, localContactA, localContactB) {
    this.penetration = penetration;
    this.normal = normal;
    this.worldContactA = worldContactA;
    this.worldContactB = worldContactB;
    this.localContactA = localContactA;
    this.localContactB = localContactB;
}

/**
 * Used by ObjectManager to reset the object with different data.
 *
 * @method reset
 * @param {Object[]} args
 * @chainable
 */
CollisionData.prototype.reset = function reset(penetration, normal, worldContactA, worldContactB, localContactA, localContactB) {
    this.penetration = penetration;
    this.normal = normal;
    this.worldContactA = worldContactA;
    this.worldContactB = worldContactB;
    this.localContactA = localContactA;
    this.localContactB = localContactB;

    return this;
};

/**
 * Ridid body Elastic Collision
 *
 * @class Collision
 * @extends Constraint
 * @param {Object} options
 */
function Collision(targets, options) {
    this.targets = [].concat(targets);

    Constraint.call(this, options);
}

Collision.prototype = Object.create(Constraint.prototype);
Collision.prototype.constructor = Collision;

/**
 * Initialize the Collision tracker. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Collision.prototype.init = function() {
    if (this.broadPhase) {
        if (this.broadPhase instanceof Function) this.broadPhase = new this.broadPhase(this.targets);
    }
    else this.broadPhase = new SweepAndPrune(this.targets);
    this.contactManifoldTable = this.contactManifoldTable || new ContactManifoldTable();
};

/**
 * Collison detection. Updates the existing contact manifolds, runs the broadphase, and performs narrowphase
 * collision detection. Warm starts the contacts based on the results of the previous physics frame
 * and prepares necesssary calculations for the resolution.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
 Collision.prototype.update = function update(time, dt) {
    this.contactManifoldTable.update(dt);
    if (this.targets.length === 0) return;
    var i, len;
    for (i = 0, len = this.targets.length; i < len; i++) {
        this.targets[i].updateShape();
    }
    var potentialCollisions = this.broadPhase.update();
    var pair;
    for (i = 0, len = potentialCollisions.length; i < len; i++) {
        (pair = potentialCollisions[i]) && this.applyNarrowPhase(pair);
    }
    this.contactManifoldTable.prepContacts(dt);
};

/**
 * Apply impulses to resolve all Contact constraints.
 *
 * @method resolve
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Collision.prototype.resolve = function resolve(time, dt) {
    this.contactManifoldTable.resolveManifolds(dt);
};

/**
 * Add a target or targets to the collision system.
 *
 * @method addTarget
 * @param {Particle}
 */
Collision.prototype.addTarget = function addTarget(target) {
    this.targets.push(target);
    this.broadPhase.add(target);
};

/**
 * Remove a target or targets from the collision system.
 *
 * @method addTarget
 * @param {Particle}
 */
Collision.prototype.removeTarget = function removeTarget(target) {
    var index = this.targets.indexOf(target);
    if (index < 0) return;
    this.targets.splice(index, 1);
    this.broadPhase.remove(target);
};


var CONVEX = 1 << 0;
var BOX = 1 << 1;
var SPHERE = 1 << 2;
var WALL = 1 << 3;

var CONVEX_CONVEX = CONVEX | CONVEX;
var BOX_BOX = BOX | BOX;
var BOX_CONVEX = BOX | CONVEX;
var SPHERE_SPHERE = SPHERE | SPHERE;
var BOX_SPHERE = BOX | SPHERE;
var CONVEX_SPHERE = CONVEX | SPHERE;
var CONVEX_WALL = CONVEX | WALL;
var BOX_WALL = BOX | WALL;
var SPHERE_WALL = SPHERE | WALL;

var dispatch = {};
dispatch[CONVEX_CONVEX] = convexIntersectConvex;
dispatch[BOX_BOX] = convexIntersectConvex;
dispatch[BOX_CONVEX] = convexIntersectConvex;
dispatch[CONVEX_SPHERE] = convexIntersectConvex;
dispatch[SPHERE_SPHERE] = sphereIntersectSphere;
dispatch[BOX_SPHERE] = boxIntersectSphere;
dispatch[CONVEX_WALL] = convexIntersectWall;
dispatch[BOX_WALL] = convexIntersectWall;
dispatch[SPHERE_WALL] = convexIntersectWall;

/**
 * Narrowphase collision detection,
 * registers the Contact constraints for colliding bodies.
 *
 * Will detect the type of bodies in the collision.
 *
 * @method applyNarrowPhase
 * @param {Particle[]} targets
 */
Collision.prototype.applyNarrowPhase = function applyNarrowPhase(targets) {
    for (var i = 0, len = targets.length; i < len; i++) {
        for (var j = i + 1; j < len; j++) {
            var  a = targets[i];
            var b = targets[j];

            if ((a.collisionMask & b.collisionGroup && a.collisionGroup & b.collisionMask) === 0) continue;

            var collisionType = a.type | b.type;

            dispatch[collisionType] && dispatch[collisionType](this, a, b);
        }
    }
};

/**
 * Detects sphere-sphere collisions and registers the Contact.
 *
 * @private
 * @method sphereIntersectSphere
 * @param {Object} context
 * @param {Sphere} sphere1
 * @param {Sphere} sphere2
 */
function sphereIntersectSphere(context, sphere1, sphere2) {
    var p1 = sphere1.position;
    var p2 = sphere2.position;
    var relativePosition = Vec3.subtract(p2, p1, new Vec3());
    var distance = relativePosition.length();
    var sumRadii = sphere1.radius + sphere2.radius;
    var n = relativePosition.scale(1/distance);

    var overlap = sumRadii - distance;

    // Distance check
    if (overlap < 0) return;

    var rSphere1 = Vec3.scale(n, sphere1.radius, new Vec3());
    var rSphere2 = Vec3.scale(n, -sphere2.radius, new Vec3());

    var wSphere1 = Vec3.add(p1, rSphere1, new Vec3());
    var wSphere2 = Vec3.add(p2, rSphere2, new Vec3());

    var collisionData = OMRequestCollisionData().reset(overlap, n, wSphere1, wSphere2, rSphere1, rSphere2);

    context.contactManifoldTable.registerContact(sphere1, sphere2, collisionData);
}

/**
* Detects box-sphere collisions and registers the Contact.
*
* @param {Object} context
* @param {Box} box
* @param {Sphere} sphere
*/
function boxIntersectSphere(context, box, sphere) {
    if (box.type === SPHERE) {
        var temp = sphere;
        sphere = box;
        box = temp;
    }

    var pb = box.position;
    var ps = sphere.position;
    var relativePosition = Vec3.subtract(ps, pb, VEC_REGISTER);

    var q = box.orientation;

    var r = sphere.radius;

    var bsize = box.size;
    var halfWidth = bsize[0]*0.5;
    var halfHeight = bsize[1]*0.5;
    var halfDepth = bsize[2]*0.5;

    // x, y, z
    var bnormals = box.normals;
    var n1 = q.rotateVector(bnormals[1], new Vec3());
    var n2 = q.rotateVector(bnormals[0], new Vec3());
    var n3 = q.rotateVector(bnormals[2], new Vec3());

    // Find the point on the cube closest to the center of the sphere
    var closestPoint = new Vec3();
    closestPoint.x = clamp(Vec3.dot(relativePosition,n1), -halfWidth, halfWidth);
    closestPoint.y = clamp(Vec3.dot(relativePosition,n2), -halfHeight, halfHeight);
    closestPoint.z = clamp(Vec3.dot(relativePosition,n3), -halfDepth, halfDepth);
    // The vector found is relative to the center of the unrotated box -- rotate it
    // to find the point w.r.t. to current orientation
    closestPoint.applyRotation(q);

    // The impact point in world space
    var impactPoint = Vec3.add(pb, closestPoint, new Vec3());
    var sphereToImpact = Vec3.subtract(impactPoint, ps, impactPoint);
    var distanceToSphere = sphereToImpact.length();

    // If impact point is not closer to the sphere's center than its radius -> no collision
    var overlap = r - distanceToSphere;
    if (overlap < 0) return;

    var n = Vec3.scale(sphereToImpact, -1 / distanceToSphere, new Vec3());
    var rBox = closestPoint;
    var rSphere = sphereToImpact;

    var wBox = Vec3.add(pb, rBox, new Vec3());
    var wSphere = Vec3.add(ps, rSphere, new Vec3());

    var collisionData = OMRequestCollisionData().reset(overlap, n, wBox, wSphere, rBox, rSphere);

    context.contactManifoldTable.registerContact(box, sphere, collisionData);
}

/**
* Detects convex-convex collisions and registers the Contact. Uses GJK to determine overlap and then
* EPA to determine the actual collision data.
*
* @param {Object} context
* @param {ConvexBody} convex1
* @param {ConvexBody} convex2
*/
function convexIntersectConvex(context, convex1, convex2) {
    var glkSimplex = GJK(convex1, convex2);

    // No simplex -> no collision
    if (!glkSimplex) return;

    var collisionData = EPA(convex1, convex2, glkSimplex);
    if (collisionData !== null) context.contactManifoldTable.registerContact(convex1, convex2, collisionData);
}

/**
* Detects convex-wall collisions and registers the Contact.
*
* @param {Object} context
* @param {ConvexBody} convex
* @param {ConvexBody} wall
*/
function convexIntersectWall(context, convex, wall) {
    if (convex.type === WALL) {
        var temp = wall;
        wall = convex;
        convex = temp;
    }

    var convexPos = convex.position;
    var wallPos = wall.position;

    var n = wall.normal;
    var invN = wall.invNormal;

    var rConvex = convex.support(invN);
    var wConvex = Vec3.add(convexPos, rConvex, new Vec3());

    var diff = Vec3.subtract(wConvex, wallPos, VEC_REGISTER);

    var penetration = Vec3.dot(diff, invN);

    if (penetration < 0) return;

    var wWall = Vec3.scale(n, penetration, new Vec3()).add(wConvex);
    var rWall = Vec3.subtract(wWall, wall.position, new Vec3());

    var collisionData = OMRequestCollisionData().reset(penetration, invN, wConvex, wWall, rConvex, rWall);

    context.contactManifoldTable.registerContact(convex, wall, collisionData);
}

Collision.SweepAndPrune = SweepAndPrune;
Collision.BruteForce = BruteForce.BruteForce;
Collision.BruteForceAABB = BruteForce.BruteForceAABB;

module.exports = Collision;

},{"./Constraint":108,"./collision/BruteForce":115,"./collision/ContactManifold":116,"./collision/ConvexCollisionDetection":117,"./collision/SweepAndPrune":118,"famous-math":82,"famous-utilities":95}],108:[function(require,module,exports){
'use strict';

var _ID = 0;
/**
 * Base Constraint class to be used in the Physics
 * Subclass this class to implement a constraint
 *
 * @virtual
 * @class Constraint
 */
function Constraint(options) {
    options = options || {};
    this.setOptions(options);

    this._ID = _ID++;
}

/**
 * Decorates the Constraint with the options object.
 *
 * @method setOptions
 * @param {Object} Options
 */
Constraint.prototype.setOptions = function setOptions(options) {
    for (var key in options) this[key] = options[key];
    this.init(options);
};

/**
 * Method invoked upon instantiation and the setting of options.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Constraint.prototype.init = function init(options) {};

/**
 * Detect violations of the constraint. Warm start the constraint, if possible.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Constraint.prototype.update = function update(time, dt) {};

/**
 * Apply impulses to resolve the constraint.
 *
 * @method resolve
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Constraint.prototype.resolve = function resolve(time, dt) {};

module.exports = Constraint;

},{}],109:[function(require,module,exports){
'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('famous-math').Vec3;

var IMPULSE_REGISTER = new Vec3();
var NORMAL_REGISTER = new Vec3();

/** @const */
var EPSILSON = 1e-7;
/** @const */
var PI = Math.PI;


/**
 *  A constraint that keeps a physics body on a given implicit curve.
 *
 *  @class Curve
 *  @constructor
 *  @extends Constraint
 */
function Curve(targets, options) {
    if (targets) {
        if (targets instanceof Array) this.targets = targets;
        else this.targets = [targets];
    }
    else this.targets = [];

    Constraint.call(this, options);

    this.impulses = {};
    this.normals = {};
    this.velocityBiases = {};
    this.divisors = {};
}

Curve.prototype = Object.create(Constraint.prototype);
Curve.prototype.constructor = Curve;

/**
 * Initialize the Curve. Sets defaults if a property was not already set.
 *
 * @method init
 */
Curve.prototype.init = function() {
    this.equation1 = this.equation1 || function() {
        return 0;
    };
    this.equation2 = this.equation2 || function(x, y, z) {
        return z;
    };
    this.period = this.period || 1;
    this.dampingRatio = this.dampingRatio || 0.5;

    this.stiffness = 4 * PI * PI / (this.period * this.period);
    this.damping = 4 * PI * this.dampingRatio / this.period;
};

/**
 * Warmstart the constraint and prepare calculations used in the .resolve step.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Curve.prototype.update = function update(time, dt) {
    var targets = this.targets;

    var normals = this.normals;
    var velocityBiases = this.velocityBiases;
    var divisors = this.divisors;
    var impulses = this.impulses;

    var impulse = IMPULSE_REGISTER;
    var n = NORMAL_REGISTER;

    var f = this.equation1;
    var g = this.equation2;

    var _c = this.damping;
    var _k = this.stiffness;

    for (var i = 0, len = targets.length; i < len; i++) {
        var body = targets[i];
        var ID = body._ID;
        if (body.immune) continue;

        var p = body.position;
        var m = body.mass;

        var gamma;
        var beta;

        if (this.period === 0) {
            gamma = 0;
            beta = 1;
        } else {
            var c = _c * m;
            var k = _k * m;

            gamma = 1 / (dt*(c + dt*k));
            beta  = dt*k / (c + dt*k);
        }

        var x = p.x;
        var y = p.y;
        var z = p.z;

        var f0 = f(x, y, z);
        var dfx = (f(x + EPSILSON, y, z) - f0) / EPSILSON;
        var dfy = (f(x, y + EPSILSON, z) - f0) / EPSILSON;
        var dfz = (f(x, y, z + EPSILSON) - f0) / EPSILSON;

        var g0 = g(x, y, z);
        var dgx = (g(x + EPSILSON, y, z) - g0) / EPSILSON;
        var dgy = (g(x, y + EPSILSON, z) - g0) / EPSILSON;
        var dgz = (g(x, y, z + EPSILSON) - g0) / EPSILSON;

        n.set(dfx + dgx, dfy + dgy, dfz + dgz);
        n.normalize();

        var baumgarte = beta * (f0 + g0) / dt;
        var divisor = gamma + 1 / m;

        var lambda = impulses[ID] || 0;
        Vec3.scale(n, lambda, impulse);
        body.applyImpulse(impulse);

        normals[ID] = normals[ID] || new Vec3();
        normals[ID].copy(n);
        velocityBiases[ID] = baumgarte;
        divisors[ID] = divisor;
        impulses[ID] = 0;
    }
};

/**
 * Adds a curve impulse to a physics body.
 *
 * @method resolve
 */
Curve.prototype.resolve = function resolve() {
    var targets = this.targets;

    var normals = this.normals;
    var velocityBiases = this.velocityBiases;
    var divisors = this.divisors;
    var impulses = this.impulses;

    var impulse = IMPULSE_REGISTER;

    for (var i = 0, len = targets.length; i < len; i++) {
        var body = targets[i];
        var ID = body._ID;
        if (body.immune) continue;

        var v = body.velocity;
        var n = normals[ID];

        var lambda = -(Vec3.dot(n, v) + velocityBiases[ID]) / divisors[ID];

        Vec3.scale(n, lambda, impulse);
        body.applyImpulse(impulse);


        impulses[ID] += lambda;
    }
};

module.exports = Curve;
},{"./Constraint":108,"famous-math":82}],110:[function(require,module,exports){
'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('famous-math').Vec3;

var NORMAL_REGISTER = new Vec3();
var IMPULSE_REGISTER = new Vec3();
var V_REGISTER = new Vec3();
var P_REGISTER = new Vec3();
var DIRECTION_REGISTER = new Vec3();

/** @const */
var PI = Math.PI;

/**
 *  A constraint that maintains the direction of one body from another.
 *
 *  @class Direction
 *  @extends Constraint
 *  @param {Particle} a One of the bodies.
 *  @param {Particle} b The other body.
 *  @param {Object} options An object of configurable options.
 */
function Direction(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.impulse = 0;
    this.distance = 0;
    this.normal = new Vec3();
    this.velocityBias = 0;
    this.divisor = 0;
}

Direction.prototype = Object.create(Constraint.prototype);
Direction.prototype.constructor = Direction;

/**
 * Initialize the Direction. Sets defaults if a property was not already set.
 *
 * @method init
 */
Direction.prototype.init = function() {
    this.direction = this.direction || Vec3.subtract(this.b.position, this.a.position, new Vec3());
    this.direction.normalize();
    this.minLength = this.minLength || 0;
    this.period = this.period || 0.2;
    this.dampingRatio = this.dampingRatio || 0.5;

    this.stiffness = 4 * PI * PI / (this.period * this.period);
    this.damping = 4 * PI * this.dampingRatio / this.period;
};

/**
 * Warmstart the constraint and prepare calculations used in .resolve.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Direction.prototype.update = function update(time, dt) {
    var a = this.a;
    var b = this.b;

    var n = NORMAL_REGISTER;
    var diffP = P_REGISTER;
    var impulse = IMPULSE_REGISTER;
    var directionVector = DIRECTION_REGISTER;

    var p1 = a.position;
    var w1 = a.inverseMass;

    var p2 = b.position;
    var w2 = b.inverseMass;

    var direction = this.direction;

    Vec3.subtract(p2, p1, diffP);
    Vec3.scale(direction, Vec3.dot(direction, diffP), directionVector);
    var goal = directionVector.add(p1);

    Vec3.subtract(p2, goal, n);
    var dist = n.length();
    n.normalize();

    var invEffectiveMass = w1 + w2;
    var effectiveMass = 1 / invEffectiveMass;
    var gamma;
    var beta;

    if (this.period === 0) {
        gamma = 0;
        beta  = 1;
    }
    else {
        var c = this.damping * effectiveMass;
        var k = this.stiffness * effectiveMass;

        gamma = 1 / (dt*(c + dt*k));
        beta  = dt*k / (c + dt*k);
    }

    var baumgarte = beta * dist / dt;
    var divisor = gamma + invEffectiveMass;

    var lambda = this.impulse;
    Vec3.scale(n, lambda, impulse);
    b.applyImpulse(impulse);
    a.applyImpulse(impulse.invert());

    this.normal.copy(n);
    this.distance = dist;
    this.velocityBias = baumgarte;
    this.divisor = divisor;
    this.impulse = 0;
};

/**
 * Adds an impulse to a physics body's velocity due to the constraint
 *
 * @method resolve
 */
Direction.prototype.resolve = function update() {
    var a = this.a;
    var b = this.b;

    var impulse  = IMPULSE_REGISTER;
    var diffV = V_REGISTER;

    var minLength = this.minLength;

    var dist = this.distance;
    if (Math.abs(dist) < minLength) return;

    var v1 = a.velocity;
    var v2 = b.velocity;
    var n = this.normal;

    Vec3.subtract(v2, v1, diffV);

    var lambda = -(Vec3.dot(n, diffV) + this.velocityBias) / this.divisor;
    Vec3.scale(n, lambda, impulse);
    b.applyImpulse(impulse);
    a.applyImpulse(impulse.invert());

    this.impulse += lambda;
};

module.exports = Direction;

},{"./Constraint":108,"famous-math":82}],111:[function(require,module,exports){
'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('famous-math').Vec3;

var NORMAL_REGISTER = new Vec3();
var IMPULSE_REGISTER = new Vec3();
var V_REGISTER = new Vec3();
var P_REGISTER = new Vec3();

/** @const */
var PI = Math.PI;

/**
 *  A constraint that keeps two bodies within a certain distance.
 *
 *  @class Distance
 *  @extends Constraint
 *  @param {Particle} a One of the bodies.
 *  @param {Particle} b The other body.
 *  @param {Object} options An object of configurable options.
 */
function Distance(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.impulse = 0;
    this.distance = 0;
    this.normal = new Vec3();
    this.velocityBias = 0;
    this.divisor = 0;
}

Distance.prototype = Object.create(Constraint.prototype);
Distance.prototype.constructor = Distance;

/**
 * Initialize the Distance. Sets defaults if a property was not already set.
 *
 * @method init
 */
Distance.prototype.init = function() {
    this.length = this.length || Vec3.subtract(this.b.position, this.a.position, P_REGISTER).length();
    this.minLength = this.minLength || 0;
    this.period = this.period || 0.2;
    this.dampingRatio = this.dampingRatio || 0.5;

    this.stiffness = 4 * PI * PI / (this.period * this.period);
    this.damping = 4 * PI * this.dampingRatio / this.period;
};

/**
 * Detect violations of the constraint. Warm start the constraint, if possible.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Distance.prototype.update = function(time, dt) {
    var a = this.a;
    var b = this.b;

    var n = NORMAL_REGISTER;
    var diffP = P_REGISTER;
    var impulse = IMPULSE_REGISTER;

    var length = this.length;

    var p1 = a.position;
    var w1 = a.inverseMass;

    var p2 = b.position;
    var w2 = b.inverseMass;

    Vec3.subtract(p2, p1, diffP);

    var separation = diffP.length();

    Vec3.scale(diffP, 1 / separation, n);

    var dist = separation - length;

    var invEffectiveMass = w1 + w2;
    var effectiveMass = 1 / invEffectiveMass;
    var gamma;
    var beta;

    if (this.period === 0) {
        gamma = 0;
        beta  = 1;
    }
    else {
        var c = this.damping * effectiveMass;
        var k = this.stiffness * effectiveMass;

        gamma = 1 / (dt*(c + dt*k));
        beta  = dt*k / (c + dt*k);
    }

    var baumgarte = beta * dist / dt;
    var divisor = gamma + invEffectiveMass;

    var lambda = this.impulse;
    Vec3.scale(n, lambda, impulse);
    b.applyImpulse(impulse);
    a.applyImpulse(impulse.invert());

    this.normal.copy(n);
    this.distance = dist;
    this.velocityBias = baumgarte;
    this.divisor = divisor;
    this.impulse = 0;
};

/**
 * Apply impulses to resolve the constraint.
 *
 * @method resolve
 */
Distance.prototype.resolve = function resolve() {
    var a = this.a;
    var b = this.b;

    var impulse = IMPULSE_REGISTER;
    var diffV = V_REGISTER;

    var minLength = this.minLength;

    var dist = this.distance;
    if (Math.abs(dist) < minLength) return;

    var v1 = a.getVelocity();
    var v2 = b.getVelocity();

    var n = this.normal;

    Vec3.subtract(v2, v1, diffV);
    var lambda = -(Vec3.dot(n, diffV) + this.velocityBias) / this.divisor;
    Vec3.scale(n, lambda, impulse);
    b.applyImpulse(impulse);
    a.applyImpulse(impulse.invert());

    this.impulse += lambda;
};

module.exports = Distance;

},{"./Constraint":108,"famous-math":82}],112:[function(require,module,exports){
'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('famous-math').Vec3;
var Mat33 = require('famous-math').Mat33;
var Quaternion = require('famous-math').Quaternion;

var VEC1_REGISTER = new Vec3();
var VEC2_REGISTER = new Vec3();
var VEC3_REGISTER = new Vec3();
var VEC4_REGISTER = new Vec3();
var VB1_REGISTER = new Vec3();
var VB2_REGISTER = new Vec3();
var WxR_REGISTER = new Vec3();
var DELTA_REGISTER = new Vec3();

/**
 *  A constraint that confines two bodies to the plane defined by the axis of the hinge.
 *
 *  @class Hinge
 *  @extends Constraint
 *  @param {Options} [options] An object of configurable options.
 *
 */
function Hinge(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.impulse = new Vec3();
    this.angImpulseA = new Vec3();
    this.angImpulseB = new Vec3();
    this.error = new Vec3();
    this.errorRot = [0,0];
    this.effMassMatrix = new Mat33();
    this.effMassMatrixRot = [];
}

Hinge.prototype = Object.create(Constraint.prototype);
Hinge.prototype.constructor = Hinge;

/**
 * Initialize the Hinge. Sets defaults if a property was not already set.
 *
 * @method init
 */
Hinge.prototype.init = function() {
    var w = this.anchor;

    var u = this.axis.normalize();

    var a = this.a;
    var b = this.b;

    var q1t = Quaternion.conjugate(a.orientation, new Quaternion());
    var q2t = Quaternion.conjugate(b.orientation, new Quaternion());

    this.rA = Vec3.subtract(w, a.position, new Vec3());
    this.rB = Vec3.subtract(w, b.position, new Vec3());

    this.bodyRA = q1t.rotateVector(this.rA, new Vec3());
    this.bodyRB = q2t.rotateVector(this.rB, new Vec3());

    this.axisA = Vec3.clone(u);
    this.axisB = Vec3.clone(u);

    this.axisBTangent1 = new Vec3();
    this.axisBTangent2 = new Vec3();

    this.t1xA = new Vec3();
    this.t2xA = new Vec3();

    this.bodyAxisA = q1t.rotateVector(u, new Vec3());
    this.bodyAxisB = q2t.rotateVector(u, new Vec3());
};

/**
 * Detect violations of the constraint. Warm start the constraint, if possible.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Hinge.prototype.update = function(time, dt) {
    var a = this.a;
    var b = this.b;

    var axisA = a.orientation.rotateVector(this.bodyAxisA, this.axisA);
    var axisB = b.orientation.rotateVector(this.bodyAxisB, this.axisB);
    this.axis.copy(axisB);

    var n = axisB;
    var t1 = this.axisBTangent1;
    var t2 = this.axisBTangent2;

    if (n.x >= 0.57735) {
        t1.set(n.y, -n.x, 0);
    }
    else {
        t1.set(0, n.z, -n.y);
    }
    t1.normalize();
    Vec3.cross(n, t1, t2);

    var t1xA = Vec3.cross(t1, axisA, this.t1xA);
    var t2xA = Vec3.cross(t2, axisA, this.t2xA);

    var rA = a.orientation.rotateVector(this.bodyRA, this.rA);
    var rB = b.orientation.rotateVector(this.bodyRB, this.rB);

    var xRA = new Mat33([0,rA.z,-rA.y,-rA.z,0,rA.x,rA.y,-rA.x,0]);
    var xRB = new Mat33([0,rB.z,-rB.y,-rB.z,0,rB.x,rB.y,-rB.x,0]);

    var RIaRt = Mat33.multiply(xRA, a.inverseInertia, new Mat33()).multiply(xRA.transpose());
    var RIbRt = Mat33.multiply(xRB, b.inverseInertia, new Mat33()).multiply(xRB.transpose());

    var invEffInertia = Mat33.add(RIaRt, RIbRt, RIaRt);

    var worldA = Vec3.add(a.position, this.rA, this.anchor);
    var worldB = Vec3.add(b.position, this.rB, VEC1_REGISTER);

    var invDt = 1/dt;
    Vec3.subtract(worldB, worldA, this.error);
    this.error.scale(0.2*invDt);

    var imA = a.inverseMass;
    var imB = b.inverseMass;

    var invEffMass = new Mat33([imA + imB,0,0,0,imA + imB,0,0,0,imA + imB]);

    Mat33.add(invEffInertia, invEffMass, this.effMassMatrix);
    this.effMassMatrix.inverse();

    var invIAt1xA = a.inverseInertia.vectorMultiply(t1xA, VEC1_REGISTER);
    var invIAt2xA = a.inverseInertia.vectorMultiply(t2xA, VEC2_REGISTER);
    var invIBt1xA = b.inverseInertia.vectorMultiply(t1xA, VEC3_REGISTER);
    var invIBt2xA = b.inverseInertia.vectorMultiply(t2xA, VEC4_REGISTER);

    var a11 = Vec3.dot(t1xA, invIAt1xA) + Vec3.dot(t1xA, invIBt1xA);
    var a12 = Vec3.dot(t1xA, invIAt2xA) + Vec3.dot(t1xA, invIBt2xA);
    var a21 = Vec3.dot(t2xA, invIAt1xA) + Vec3.dot(t2xA, invIBt1xA);
    var a22 = Vec3.dot(t2xA, invIAt2xA) + Vec3.dot(t2xA, invIBt2xA);

    var det = 1 / (a11*a22 - a12*a21);

    this.effMassMatrixRot[0] = a22 * det;
    this.effMassMatrixRot[1] = -a21 * det;
    this.effMassMatrixRot[2] = -a12 * det;
    this.effMassMatrixRot[3] = a11 * det;

    this.errorRot[0] = Vec3.dot(axisA, t1) * 0.2*invDt;
    this.errorRot[1] = Vec3.dot(axisA, t2) * 0.2*invDt;

    var impulse = this.impulse.scale(0.5);
    var angImpulseA = this.angImpulseA.scale(0.5);
    var angImpulseB = this.angImpulseB.scale(0.5);

    b.applyImpulse(impulse);
    b.applyAngularImpulse(angImpulseB);
    impulse.invert();
    a.applyImpulse(impulse);
    a.applyAngularImpulse(angImpulseA);

    impulse.clear();
    angImpulseA.clear();
    angImpulseB.clear();
};

/**
 * Apply impulses to resolve the constraint.
 *
 * @method resolve
 */
Hinge.prototype.resolve = function resolve() {
    var a = this.a;
    var b = this.b;

    var rA = this.rA;
    var rB = this.rB;

    var t1xA = this.t1xA;
    var t2xA = this.t2xA;

    var w1 = a.angularVelocity;
    var w2 = b.angularVelocity;

    var v1 = Vec3.add(a.velocity, Vec3.cross(w1, rA, WxR_REGISTER), VB1_REGISTER);
    var v2 = Vec3.add(b.velocity, Vec3.cross(w2, rB, WxR_REGISTER), VB2_REGISTER);

    var impulse = v1.subtract(v2).subtract(this.error).applyMatrix(this.effMassMatrix);

    var diffW = Vec3.subtract(w2, w1, DELTA_REGISTER);

    var errorRot = this.errorRot;
    var jv1 = Vec3.dot(t1xA, diffW) + errorRot[0];
    var jv2 = Vec3.dot(t2xA, diffW) + errorRot[1];

    var K = this.effMassMatrixRot;

    var l1 = -(K[0]*jv1 + K[1]*jv2);
    var l2 = -(K[2]*jv1 + K[3]*jv2);

    var angImpulse = Vec3.scale(t1xA, l1, VEC2_REGISTER).add(Vec3.scale(t2xA, l2, VEC3_REGISTER));

    var angImpulseB = Vec3.cross(rB, impulse, VEC1_REGISTER).add(angImpulse);
    var angImpulseA = Vec3.cross(rA, impulse, VEC4_REGISTER).invert().subtract(angImpulse);

    b.applyImpulse(impulse);
    b.applyAngularImpulse(angImpulseB);
    impulse.invert();
    a.applyImpulse(impulse);
    a.applyAngularImpulse(angImpulseA);
    impulse.invert();

    this.impulse.add(impulse);
    this.angImpulseA.add(angImpulseA);
    this.angImpulseB.add(angImpulseB);
};

module.exports = Hinge;

},{"./Constraint":108,"famous-math":82}],113:[function(require,module,exports){
'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('famous-math').Vec3;
var Mat33 = require('famous-math').Mat33;
var Quaternion = require('famous-math').Quaternion;

var VEC1_REGISTER = new Vec3();
var VEC2_REGISTER = new Vec3();
var VB1_REGISTER = new Vec3();
var VB2_REGISTER = new Vec3();
var WxR_REGISTER = new Vec3();

/**
 *  A constraint that maintains positions and orientations with respect to a specific anchor point.
 *
 *  @class Point2Point
 *  @extends Constraint
 *  @param {Particle} a One of the bodies.
 *  @param {Particle} b The other body.
 *  @param {Options} options An object of configurable options.
 */
function Point2Point(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.impulse = new Vec3();
    this.angImpulseA = new Vec3();
    this.angImpulseB = new Vec3();
    this.error = new Vec3();
    this.effMassMatrix = new Mat33();
}

Point2Point.prototype = Object.create(Constraint.prototype);
Point2Point.prototype.constructor = Point2Point;

/**
 * Initialize the Point2Point. Sets defaults if a property was not already set.
 *
 * @method init
 */
Point2Point.prototype.init = function() {
    var w = this.anchor;

    var a = this.a;
    var b = this.b;

    var q1t = Quaternion.conjugate(a.orientation, new Quaternion());
    var q2t = Quaternion.conjugate(b.orientation, new Quaternion());

    this.rA = Vec3.subtract(w, a.position, new Vec3());
    this.rB = Vec3.subtract(w, b.position, new Vec3());

    this.bodyRA = q1t.rotateVector(this.rA, new Vec3());
    this.bodyRB = q2t.rotateVector(this.rB, new Vec3());
};

/**
 * Detect violations of the constraint. Warm start the constraint, if possible.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Point2Point.prototype.update = function(time, dt) {
    var a = this.a;
    var b = this.b;

    var rA = a.orientation.rotateVector(this.bodyRA, this.rA);
    var rB = b.orientation.rotateVector(this.bodyRB, this.rB);

    var xRA = new Mat33([0,rA.z,-rA.y,-rA.z,0,rA.x,rA.y,-rA.x,0]);
    var xRB = new Mat33([0,rB.z,-rB.y,-rB.z,0,rB.x,rB.y,-rB.x,0]);

    var RIaRt = Mat33.multiply(xRA, a.inverseInertia, new Mat33()).multiply(xRA.transpose());
    var RIbRt = Mat33.multiply(xRB, b.inverseInertia, new Mat33()).multiply(xRB.transpose());

    var invEffInertia = Mat33.add(RIaRt, RIbRt, RIaRt);

    var worldA = Vec3.add(a.position, this.rA, this.anchor);
    var worldB = Vec3.add(b.position, this.rB, VEC2_REGISTER);

    Vec3.subtract(worldB, worldA, this.error);
    this.error.scale(0.2/dt);

    var imA = a.inverseMass;
    var imB = b.inverseMass;

    var invEffMass = new Mat33([imA + imB,0,0,0,imA + imB,0,0,0,imA + imB]);

    Mat33.add(invEffInertia, invEffMass, this.effMassMatrix);
    this.effMassMatrix.inverse();

    var impulse = this.impulse;
    var angImpulseA = this.angImpulseA;
    var angImpulseB = this.angImpulseB;

    b.applyImpulse(impulse);
    b.applyAngularImpulse(angImpulseB);
    impulse.invert();
    a.applyImpulse(impulse);
    a.applyAngularImpulse(angImpulseA);

    impulse.clear();
    angImpulseA.clear();
    angImpulseB.clear();
};

/**
 * Apply impulses to resolve the constraint.
 *
 * @method resolve
 */
Point2Point.prototype.resolve = function resolve() {
    var a = this.a;
    var b = this.b;

    var rA = this.rA;
    var rB = this.rB;

    var v1 = Vec3.add(a.velocity, Vec3.cross(a.angularVelocity, rA, WxR_REGISTER), VB1_REGISTER);
    var v2 = Vec3.add(b.velocity, Vec3.cross(b.angularVelocity, rB, WxR_REGISTER), VB2_REGISTER);

    var impulse = v1.subtract(v2).subtract(this.error).applyMatrix(this.effMassMatrix);
    var angImpulseB = Vec3.cross(rB, impulse, VEC1_REGISTER);
    var angImpulseA = Vec3.cross(rA, impulse, VEC2_REGISTER).invert();

    b.applyImpulse(impulse);
    b.applyAngularImpulse(angImpulseB);
    impulse.invert();
    a.applyImpulse(impulse);
    a.applyAngularImpulse(angImpulseA);
    impulse.invert();

    this.impulse.add(impulse);
    this.angImpulseA.add(angImpulseA);
    this.angImpulseB.add(angImpulseB);
};

module.exports = Point2Point;

},{"./Constraint":108,"famous-math":82}],114:[function(require,module,exports){
'use strict';

/**
 * Axis-aligned bounding box. Used in collision broadphases.
 *
 * @class AABB
 */
function AABB(body) {
    this._body = body;
    this._ID = body._ID;
    this.position = null;
    this.vertices = {
        x: [],
        y: [],
        z: []
    };
    this.update();
}

var SPHERE = 1 << 2;
var WALL = 1 << 3;

var DOWN = 0;
var UP = 1;
var LEFT = 2;
var RIGHT = 3;
var FORWARD = 4;
var BACKWARD = 5;

/**
 * Update the bounds to reflect the current orientation and position of the parent Body.
 *
 * @method update
 */
AABB.prototype.update = function() {
    var body = this._body;
    var pos = this.position = body.position;

    var minX = Infinity, maxX = -Infinity;
    var minY = Infinity, maxY = -Infinity;
    var minZ = Infinity, maxZ = -Infinity;

    var type = body.type;
    if (type === SPHERE) {
        maxX = maxY = maxZ = body.radius;
        minX = minY = minZ = -body.radius;
    }
    else if (type === WALL) {
        var d = body.direction;
        maxX = maxY = maxZ = 1e6;
        minX = minY = minZ = -1e6;
        switch (d) {
            case DOWN:
                maxY = 25;
                minY = -1e3;
                break;
            case UP:
                maxY = 1e3;
                minY = -25;
                break;
            case LEFT:
                maxX = 25;
                minX = -1e3;
                break;
            case RIGHT:
                maxX = 1e3;
                minX = -25;
                break;
            case FORWARD:
                maxZ = 25;
                minZ = -1e3;
                break;
            case BACKWARD:
                maxZ = 1e3;
                minZ = -25;
                break;
            default:
                break;
       }
    }
    else if (body.vertices) {
        // ConvexBody
        var bodyVertices = body.vertices;
        for (var i = 0, len = bodyVertices.length; i < len; i++) {
            var vertex = bodyVertices[i];
            if (vertex.x < minX) minX = vertex.x;
            if (vertex.x > maxX) maxX = vertex.x;
            if (vertex.y < minY) minY = vertex.y;
            if (vertex.y > maxY) maxY = vertex.y;
            if (vertex.z < minZ) minZ = vertex.z;
            if (vertex.z > maxZ) maxZ = vertex.z;
        }
    } else {
        // Particle
        maxX = maxY = maxZ = 25;
        minX = minY = minZ = -25;
    }
    var vertices = this.vertices;
    vertices.x[0] = minX + pos.x;
    vertices.x[1] = maxX + pos.x;
    vertices.y[0] = minY + pos.y;
    vertices.y[1] = maxY + pos.y;
    vertices.z[0] = minZ + pos.z;
    vertices.z[1] = maxZ + pos.z;
};

/**
 * Check for overlap between two AABB's.
 *
 * @method checkOverlap
 * @param {AABB} aabb1
 * @param {AABB} aabb2
 */
AABB.checkOverlap = function(aabb1, aabb2) {
    var vertices1 = aabb1.vertices;
    var vertices2 = aabb2.vertices;

    var x10 = vertices1.x[0];
    var x11 = vertices1.x[1];
    var x20 = vertices2.x[0];
    var x21 = vertices2.x[1];
    if ((x20 <= x10 && x10 <= x21) || (x10 <= x20 && x20 <= x11)) {
        var y10 = vertices1.y[0];
        var y11 = vertices1.y[1];
        var y20 = vertices2.y[0];
        var y21 = vertices2.y[1];
        if ((y20 <= y10 && y10 <= y21) || (y10 <= y20 && y20 <= y11)) {
            var z10 = vertices1.z[0];
            var z11 = vertices1.z[1];
            var z20 = vertices2.z[0];
            var z21 = vertices2.z[1];
            if ((z20 <= z10 && z10 <= z21) || (z10 <= z20 && z20 <= z11)) {
                return true;
            }
        }
    }
    return false;
};

AABB.vertexThreshold = 100;

module.exports = AABB;

},{}],115:[function(require,module,exports){
'use strict';

var AABB = require('./AABB');

/**
 * O(n^2) comparisons with an AABB check for a midphase. Likely to be more performant
 * that the BruteForce when the bodies have many vertices. Only feasible for a small number of bodies.
 *
 * @class BruteForAABB
 * @param {Particles[]} targets
 * @param {Object} options
 */
function BruteForceAABB(targets) {
    this._volumes = [];
    this._entityRegistry = {};
    for (var i = 0; i < targets.length; i++) {
        this.add(targets[i]);
    }
}

/**
 * Start tracking a Particle.
 *
 * @method add
 * @param {Particle} body
 */
BruteForceAABB.prototype.add = function add(body) {
    var boundingVolume = new AABB(body);

    this._entityRegistry[body._ID] = body;
    this._volumes.push(boundingVolume);
};

/**
 * Return an array of possible collision pairs, culled by an AABB intersection test.
 *
 * @method update
 * @return {Particle[][]}
 */
BruteForceAABB.prototype.update = function update() {
    var _volumes = this._volumes;
    var _entityRegistry = this._entityRegistry;

    for (var k = 0, len = _volumes.length; k < len; k++) {
        _volumes[k].update();
    }

    var result = [];
    for (var i = 0, numTargets = _volumes.length; i < numTargets; i++) {
        for (var j = i + 1; j < numTargets; j++) {
            if (AABB.checkOverlap(_volumes[i], _volumes[j])) {
                result.push([_entityRegistry[i], _entityRegistry[j]]);
            }
        }
    }
    return result;
};

/**
 * The most simple yet computationally intensive broad-phase. Immediately passes its targets to the narrow-phase,
 * resulting in an O(n^2) process. Only feasible for a relatively small number of bodies.
 *
 * @class BruteForce
 * @param {Particle[]} targets
 */
function BruteForce(targets) {
    this.targets = targets;
}

/**
 * Start tracking a Particle.
 *
 * @method add
 * @param {Particle} body
 */
BruteForce.prototype.add = function add(body) {
    this.targets.push(body);
};

/**
 * Immediately returns an array of possible collisions.
 *
 * @method update
 * @return {Particle[][]}
 */
BruteForce.prototype.update = function update() {
    return [this.targets];
};

module.exports.BruteForceAABB = BruteForceAABB;
module.exports.BruteForce = BruteForce;

},{"./AABB":114}],116:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var ObjectManager = require('famous-utilities').ObjectManager;

ObjectManager.register('Manifold', Manifold);
ObjectManager.register('Contact', Contact);
var OMRequestManifold = ObjectManager.requestManifold;
var OMRequestContact = ObjectManager.requestContact;
var OMFreeManifold = ObjectManager.freeManifold;
var OMFreeContact = ObjectManager.freeContact;

/**
 * Helper function to clamp a value to a given range.
 *
 * @method clamp
 * @param {Number} value
 * @param {Number} lower
 * @param {Number} upper
 * @return {Number}
 * @private
 */
function clamp(value, lower, upper) {
    return value < lower ? lower : value > upper ? upper : value;
}

var VEC1_REGISTER = new Vec3();
var VEC2_REGISTER = new Vec3();
var VB1_REGISTER = new Vec3();
var VB2_REGISTER = new Vec3();
var WxR_REGISTER = new Vec3();
var R1_REGISTER = new Vec3();
var R2_REGISTER = new Vec3();
var NORMALIMPULSE_REGISTER = new Vec3();
var TANGENTIMPULSE1_REGISTER = new Vec3();
var TANGENTIMPULSE2_REGISTER = new Vec3();
var WA_REGISTER = new Vec3();
var WB_REGISTER = new Vec3();
var PENETRATING_REGISTER = new Vec3();
var DRIFTA_REGISTER = new Vec3();
var DRIFTB_REGISTER = new Vec3();

/**
 * Table maintaining and managing current contact manifolds.
 *
 * @class ContactManifoldTable
 */
function ContactManifoldTable() {
    this.manifolds = [];
    this.collisionMatrix = {};
    this._IDPool = [];
}

/**
 * Create a new contact manifold. Tracked by the collisionMatrix according to
 * its low-high ordered ID pair.
 *
 * @method addManifold
 * @param {Number} lowId
 * @param {Number} highID
 * @param {Particle} bodyA
 * @param {Particle} bodyB
 * @return {ContactManifold}
 */
ContactManifoldTable.prototype.addManifold = function addManifold(lowID, highID, bodyA, bodyB) {
    var collisionMatrix = this.collisionMatrix;
    collisionMatrix[lowID] = collisionMatrix[lowID] || {};

    var index = this._IDPool.length ? this._IDPool.pop() : this.manifolds.length;
    this.collisionMatrix[lowID][highID] = index;
    var manifold = OMRequestManifold().reset(lowID, highID, bodyA, bodyB);
    this.manifolds[index] = manifold;

    return manifold;
};

/**
 * Remove a manifold and free it for later reuse.
 *
 * @method removeManifold
 * @param {ContactManifold} manifold
 * @param {Number} index
 */
ContactManifoldTable.prototype.removeManifold = function removeManifold(manifold, index) {
    var collisionMatrix = this.collisionMatrix;

    this.manifolds[index] = null;
    collisionMatrix[manifold.lowID][manifold.highID] = null;
    this._IDPool.push(index);

    OMFreeManifold(manifold);
};

/**
 * Update each of the manifolds, removing those that no longer contain contact points.
 *
 * @method update
 * @param {Number} dt
 */
ContactManifoldTable.prototype.update = function update(dt) {
    var manifolds = this.manifolds;
    for (var i = 0, len = manifolds.length; i < len; i++) {
        var manifold = manifolds[i];
        if (!manifold) continue;
        var persists = manifold.update(dt);
        if (!persists) {
            this.removeManifold(manifold, i);
            manifold.bodyA.events.trigger('collision:end', manifold);
            manifold.bodyB.events.trigger('collision:end', manifold);
        }
    }
};

/**
 * Warm start all Contacts, and perform precalculations needed in the iterative solver.
 *
 * @method prepContacts
 * @param {Number} dt
 */
ContactManifoldTable.prototype.prepContacts = function prepContacts(dt) {
    var manifolds = this.manifolds;
    for (var i = 0, len = manifolds.length; i < len; i++) {
        var manifold = manifolds[i];
        if (!manifold) continue;
        var contacts = manifold.contacts;
        for (var j = 0, lenj = contacts.length; j < lenj; j++) {
            var contact = contacts[j];
            if (!contact) continue;
            contact.update(dt);
        }
    }
};

/**
 * Resolve all contact manifolds.
 *
 * @method resolveManifolds
 */
ContactManifoldTable.prototype.resolveManifolds = function resolveManifolds() {
    var manifolds = this.manifolds;
    for (var i = 0, len = manifolds.length; i < len; i++) {
        var manifold = manifolds[i];
        if (!manifold) continue;
        manifold.resolveContacts();
    }
};

/**
 * Create a new Contact, also creating a new Manifold if one does not already exist for that pair.
 *
 * @method registerContact
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {CollisionData} collisionData
 */
ContactManifoldTable.prototype.registerContact = function registerContact(bodyA, bodyB, collisionData) {
    var lowID;
    var highID;

    if (bodyA._ID < bodyB._ID) {
        lowID = bodyA._ID;
        highID = bodyB._ID;
    } else {
        lowID = bodyB._ID;
        highID = bodyA._ID;
    }

    var manifolds = this.manifolds;
    var collisionMatrix = this.collisionMatrix;
    var manifold;
    if (!collisionMatrix[lowID] || collisionMatrix[lowID][highID] == null) {
        manifold = this.addManifold(lowID, highID, bodyA, bodyB);
        manifold.addContact(bodyA, bodyB, collisionData);
        bodyA.events.trigger('collision:start', manifold);
        bodyB.events.trigger('collision:start', manifold);
    } else {
        manifold = manifolds[ collisionMatrix[lowID][highID] ];
        manifold.contains(collisionData);
        manifold.addContact(bodyA, bodyB, collisionData);
    }
};

var THRESHOLD = 10;

/**
 * Class to keep track of Contact points.
 * @class manifold
 * @param {Number} lowId
 * @param {Number} highId
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function Manifold(lowID, highID, bodyA, bodyB) {
    this.lowID = lowID;
    this.highID = highID;

    this.contacts = [];
    this.numContacts = 0;

    this.bodyA = bodyA;
    this.bodyB = bodyB;

    this.lru = 0;
}

/**
 * Used by ObjectManager to reset the object with different data.
 *
 * @method reset
 * @param {Object[]} args
 * @chainable
 */
Manifold.prototype.reset = function reset(lowID, highID, bodyA, bodyB) {
    this.lowID = lowID;
    this.highID = highID;

    this.contacts = [];
    this.numContacts = 0;

    this.bodyA = bodyA;
    this.bodyB = bodyB;

    this.lru = 0;

    return this;
};

/**
 * Create a new Contact point and add it to the Manifold.
 *
 * @method addContact
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {CollisionData} collisionData
 */
Manifold.prototype.addContact = function addContact(bodyA, bodyB, collisionData) {
    var index = this.lru;
    if (this.contacts[index]) this.removeContact(this.contacts[index], index);
    this.contacts[index] = OMRequestContact().reset(bodyA, bodyB, collisionData);
    this.lru = (this.lru + 1) % 4;
    this.numContacts++;
};

/**
 * Remove and free a Contact for later reuse.
 *
 * @method removeContact
 * @param {Contact} contact
 * @param {Number} index
 */
Manifold.prototype.removeContact = function removeContact(contact, index) {
    this.contacts[index] = null;
    this.numContacts--;

    ObjectManager.freeCollisionData(contact.data);
    contact.data = null;
    OMFreeContact(contact);
};

/**
 * Check if a Contact already exists for the collision data within a certain tolerance.
 * If found, remove the Contact.
 *
 * @method contains
 * @param {CollisionData} collisionData
 * @return {Boolean}
 */
Manifold.prototype.contains = function contains(collisionData) {
    var wA = collisionData.worldContactA;
    var wB = collisionData.worldContactB;

    var contacts = this.contacts;
    for (var i = 0, len = contacts.length; i < len; i++) {
        var contact = contacts[i];
        if (!contact) continue;
        var data = contact.data;
        var distA = Vec3.subtract(data.worldContactA, wA, DRIFTA_REGISTER).length();
        var distB = Vec3.subtract(data.worldContactB, wB, DRIFTB_REGISTER).length();

        if (distA < THRESHOLD || distB < THRESHOLD) {
            this.removeContact(contact, i);
            return true;
        }
    }

    return false;
};

/**
 * Remove Contacts the local points of which have drifted above a certain tolerance.
 * Return true or false to indicate that the Manifold still contains at least one Contact.
 *
 * @method update
 * @return {Boolean} whether or not the manifold persists
 */
Manifold.prototype.update = function update() {
    var contacts = this.contacts;
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;

    var posA = bodyA.position;
    var posB = bodyB.position;

    for (var i = 0, len = contacts.length; i < len; i++) {
        var contact = contacts[i];
        if (!contact) continue;
        var data = contact.data;
        var n = data.normal;
        var rA = data.localContactA;
        var rB = data.localContactB;

        var cached_wA = data.worldContactA;
        var cached_wB = data.worldContactB;

        var wA = Vec3.add(posA, rA, WA_REGISTER);
        var wB = Vec3.add(posB, rB, WB_REGISTER);

        var notPenetrating = Vec3.dot(Vec3.subtract(wB, wA, PENETRATING_REGISTER), n) > 0;

        var driftA = Vec3.subtract(cached_wA, wA, DRIFTA_REGISTER);
        var driftB = Vec3.subtract(cached_wB, wB, DRIFTB_REGISTER);


        if (driftA.length() >= THRESHOLD || driftB.length() >= THRESHOLD || notPenetrating) {
            this.removeContact(contact, i);
        }
    }

    if (this.numContacts) return true;
    else return false;
};

/**
 * Resolve all contacts.
 *
 * @method resolveContacts
 */
Manifold.prototype.resolveContacts = function resolveContacts() {
    var contacts = this.contacts;
    for (var i = 0, len = contacts.length; i < len; i++) {
        if (!contacts[i]) continue;
        contacts[i].resolve();
    }
};

/**
 * Class to maintain collision data between two bodies.
 * The end of the resolve chain, and where the actual impulses are applied.
 *
 * @class Contact
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {CollisionData} collisionData
 */
function Contact(bodyA, bodyB, collisionData) {
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.data = collisionData;

    this.normalImpulse = 0;
    this.tangentImpulse1 = 0;
    this.tangentImpulse2 = 0;

    this.impulse = new Vec3();
    this.angImpulseA = new Vec3();
    this.angImpulseB = new Vec3();

    if (collisionData) this.init();
}

/**
 * Used by ObjectManager to reset the object with different data.
 *
 * @method reset
 * @param {Object[]} args
 * @chainable
 */
Contact.prototype.reset = function reset(bodyA, bodyB, collisionData) {
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.data = collisionData;

    this.normalImpulse = 0;
    this.tangentImpulse1 = 0;
    this.tangentImpulse2 = 0;

    this.impulse.clear();
    this.angImpulseA.clear();
    this.angImpulseB.clear();

    this.init();

    return this;
};

/**
 * Initialization method called on instantiantion or reset of the Contact. Performs
 * precalculations that will not change over the life of the Contact.
 *
 * @method init
 */
Contact.prototype.init = function init() {
    var data = this.data;
    var n = data.normal;
    var t1 = new Vec3();
    if (n.x >= 0.57735) {
        t1.set(n.y, -n.x, 0);
    } else {
        t1.set(0, n.z, -n.y);
    }
    t1.normalize();
    var t2 = Vec3.cross(n, t1, new Vec3());

    this.tangent1 = t1;
    this.tangent2 = t2;

    var bodyA = this.bodyA;
    var bodyB = this.bodyB;

    var rBodyA = data.localContactA;
    var rBodyB = data.localContactB;

    var invEffectiveMass = bodyA.inverseMass + bodyB.inverseMass;

    var r1n = Vec3.cross(rBodyA, n, R1_REGISTER);
    var r2n = Vec3.cross(rBodyB, n, R2_REGISTER);
    this.effNormalMass = 1 / (invEffectiveMass +
        Vec3.dot(r1n, bodyA.inverseInertia.vectorMultiply(r1n, VEC1_REGISTER)) +
        Vec3.dot(r2n, bodyB.inverseInertia.vectorMultiply(r2n, VEC1_REGISTER)));

    var r1t1 = Vec3.cross(rBodyA, t1, R1_REGISTER);
    var r2t1 = Vec3.cross(rBodyB, t1, R2_REGISTER);
    this.effTangentialMass1 = 1 / (invEffectiveMass +
        Vec3.dot(r1t1, bodyA.inverseInertia.vectorMultiply(r1t1, VEC1_REGISTER)) +
         Vec3.dot(r2t1, bodyB.inverseInertia.vectorMultiply(r2t1, VEC1_REGISTER)));

    var r1t2 = Vec3.cross(rBodyA, t2, R1_REGISTER);
    var r2t2 = Vec3.cross(rBodyB, t2, R2_REGISTER);
    this.effTangentialMass2 = 1 / (invEffectiveMass +
        Vec3.dot(r1t2, bodyA.inverseInertia.vectorMultiply(r1t2, VEC1_REGISTER)) +
         Vec3.dot(r2t2, bodyB.inverseInertia.vectorMultiply(r2t2, VEC1_REGISTER)));

    this.restitution = Math.min(bodyA.restitution, bodyB.restitution);
    this.friction = bodyA.friction * bodyB.friction;
};

/**
 * Warm start the Contact, prepare for the iterative solver, and reset impulses.
 *
 * @method update
 * @param {Number} dt
 */
Contact.prototype.update = function update(dt) {
    var data = this.data;
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;

    var rBodyA = data.localContactA;
    var rBodyB = data.localContactB;

    var n = data.normal;

    var vb1 = Vec3.add(bodyA.velocity, Vec3.cross(bodyA.angularVelocity, rBodyA, WxR_REGISTER), VB1_REGISTER);
    var vb2 = Vec3.add(bodyB.velocity, Vec3.cross(bodyB.angularVelocity, rBodyB, WxR_REGISTER), VB2_REGISTER);
    var relativeVelocity = vb2.subtract(vb1);
    var contactSpeed = Vec3.dot(relativeVelocity, n);

    var beta = 0.15;
    var slop = 1.5;
    var velocityTolerance = 20.0;

    var restitution = Math.abs(contactSpeed) < velocityTolerance ? 0.0 : this.restitution;
    this.velocityBias = -beta * Math.max(data.penetration - slop, 0.0) / dt;
    this.velocityBias += restitution * contactSpeed;

    var impulse = this.impulse.scale(0.25);
    var angImpulseA = this.angImpulseA.scale(0.25);
    var angImpulseB = this.angImpulseB.scale(0.25);

    bodyB.applyImpulse(impulse);
    bodyB.applyAngularImpulse(angImpulseB);
    impulse.invert();
    bodyA.applyImpulse(impulse);
    bodyA.applyAngularImpulse(angImpulseA);

    this.normalImpulse = 0;
    this.tangentImpulse1 = 0;
    this.tangentImpulse2 = 0;

    impulse.clear();
    angImpulseA.clear();
    angImpulseB.clear();
};

/**
 * Apply impulses to resolve the contact and simulate friction.
 *
 * @method resolve
 */
Contact.prototype.resolve = function resolve() {
    var data = this.data;
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;

    var rBodyA = data.localContactA;
    var rBodyB = data.localContactB;

    var n = data.normal;
    var t1 = this.tangent1;
    var t2 = this.tangent2;

    var vb1 = Vec3.add(bodyA.velocity, Vec3.cross(bodyA.angularVelocity, rBodyA, WxR_REGISTER), VB1_REGISTER);
    var vb2 = Vec3.add(bodyB.velocity, Vec3.cross(bodyB.angularVelocity, rBodyB, WxR_REGISTER), VB2_REGISTER);
    var relativeVelocity = vb2.subtract(vb1);

    var normalLambda = -(Vec3.dot(relativeVelocity, n) + this.velocityBias) * this.effNormalMass;
    var newNormalImpulse = Math.max(this.normalImpulse + normalLambda, 0);
    normalLambda = newNormalImpulse - this.normalImpulse;

    var maxFriction = this.friction * newNormalImpulse;

    var tangentLambda1 = -Vec3.dot(relativeVelocity, t1) * this.effTangentialMass1;
    var newTangentImpulse1 = clamp(this.tangentImpulse1 + tangentLambda1, -maxFriction, maxFriction);
    tangentLambda1 = newTangentImpulse1 - this.tangentImpulse1;

    var tangentLambda2 = -Vec3.dot(relativeVelocity, t2) * this.effTangentialMass2;
    var newTangentImpulse2 = clamp(this.tangentImpulse2 + tangentLambda2, -maxFriction, maxFriction);
    tangentLambda2 = newTangentImpulse2 - this.tangentImpulse2;

    var impulse = Vec3.scale(n, normalLambda, NORMALIMPULSE_REGISTER);
    var tangentImpulse1 = Vec3.scale(t1, tangentLambda1, TANGENTIMPULSE1_REGISTER);
    var tangentImpulse2 = Vec3.scale(t2, tangentLambda2, TANGENTIMPULSE2_REGISTER);

    impulse.add(tangentImpulse1).add(tangentImpulse2);

    var angImpulseB = Vec3.cross(rBodyB, impulse, VEC1_REGISTER);
    var angImpulseA = Vec3.cross(rBodyA, impulse, VEC2_REGISTER).invert();

    bodyB.applyImpulse(impulse);
    bodyB.applyAngularImpulse(angImpulseB);
    impulse.invert();
    bodyA.applyImpulse(impulse);
    bodyA.applyAngularImpulse(angImpulseA);

    this.normalImpulse = newNormalImpulse;
    this.tangentImpulse1 = newTangentImpulse1;
    this.tangentImpulse2 = newTangentImpulse2;

    this.impulse.add(impulse);
    this.angImpulseA.add(angImpulseA);
    this.angImpulseB.add(angImpulseB);
};

module.exports = ContactManifoldTable;

},{"famous-math":82,"famous-utilities":95}],117:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var ObjectManager = require('famous-utilities').ObjectManager;

ObjectManager.register('GJK_EPASupportPoint', GJK_EPASupportPoint);
var OMRequestGJK_EPASupportPoint = ObjectManager.requestGJK_EPASupportPoint;
var OMRequestDynamicGeometry = ObjectManager.requestDynamicGeometry;
var OMFreeGJK_EPASupportPoint = ObjectManager.freeGJK_EPASupportPoint;
var OMFreeDynamicGeometry = ObjectManager.freeDynamicGeometry;
var OMFreeDynamicGeometryFeature = ObjectManager.freeDynamicGeometryFeature;

var P_REGISTER = new Vec3();
var V0_REGISTER = new Vec3();
var V1_REGISTER = new Vec3();
var V2_REGISTER = new Vec3();

var DIRECTION_REGISTER = new Vec3();
var INVDIRECTION_REGISTER = new Vec3();

/**
 * Support point to be added to the DynamicGeometry. The point in Minkowski space as well as the
 * original pair.
 *
 * @class GJK_EPASupportPoint
 * @param {Vec3} vertex
 * @param {Vec3} worldVertexA
 * @param {Vec3} worldVertexAB
 */
function GJK_EPASupportPoint(vertex, worldVertexA, worldVertexB) {
    this.vertex = vertex;
    this.worldVertexA = worldVertexA;
    this.worldVertexB = worldVertexB;
}

/**
 * Used by ObjectManager to reset the object with different data.
 *
 * @method reset
 * @param {Object[]} args
 * @chainable
 */
GJK_EPASupportPoint.prototype.reset = function reset(vertex, worldVertexA, worldVertexB) {
    this.vertex = vertex;
    this.worldVertexA = worldVertexA;
    this.worldVertexB = worldVertexB;

    return this;
};

/**
 * Free the DynamicGeomtetry and associate vertices and features for later reuse.
 *
 * @method freeGJK_EPADynamicGeometry
 * @param {DynamicGeometry} geometry
 */
function freeGJK_EPADynamicGeometry(geometry) {
    var vertices = geometry.vertices;
    var i;
    i = vertices.length;
    while (i--) {
        var v = vertices.pop();
        if (v !== null) OMFreeGJK_EPASupportPoint(v);
    }
    geometry.numVertices = 0;
    var features = geometry.features;
    i = features.length;
    while (i--) {
        var f = features.pop();
        if (f !== null) OMFreeDynamicGeometryFeature(f);
    }
    geometry.numFeatures = 0;
    OMFreeDynamicGeometry(geometry);
}

/**
 * Find the point in Minkowski space furthest in a given direction for two convex Bodies.
 *
 * @method minkowskiSupport
 * @param {Body} body1
 * @param {Body} body2
 * @param {Vec3} direction
 * @return {GJK_EPASupportPoint}
 */
function minkowskiSupport(body1, body2, direction) {
    var inverseDirection = Vec3.scale(direction, -1, INVDIRECTION_REGISTER);

    var furthest1 = body1.support(direction);
    var furthest2 = body2.support(inverseDirection);

    var w1 = Vec3.add(furthest1, body1.position, new Vec3());
    var w2 = Vec3.add(furthest2, body2.position, new Vec3());

    // The vertex in Minkowski space as well as the original pair in world space
    return OMRequestGJK_EPASupportPoint().reset(Vec3.subtract(w1, w2, new Vec3()), w1, w2);
}

/**
 * Gilbert-Johnson-Keerthi collision detection. Returns a DynamicGeometry simplex if the bodies are found
 * to have collided or false for no collsion.
 *
 * @method GJK
 * param {Body} body1
 * param {Body} body2
 * @return {DynamicGeometry | Boolean}
 */
function GJK(body1, body2) {
    var support = minkowskiSupport;
    // Use p2 - p1 to seed the initial choice of direction
    var direction = Vec3.subtract(body2.position, body1.position, DIRECTION_REGISTER).normalize();
    var simplex = OMRequestDynamicGeometry();
    simplex.addVertex(support(body1, body2, direction));
    direction.invert();

    var i = 0;
    var maxIterations = 1e3;
    while(i++ < maxIterations) {
        if (direction.x === 0 && direction.y === 0 && direction.z === 0) break;
        simplex.addVertex(support(body1, body2, direction));
        if (Vec3.dot(simplex.getLastVertex().vertex, direction) < 0) break;
        // If simplex contains origin, return for use in EPA
        if (simplex.simplexContainsOrigin(direction, OMFreeGJK_EPASupportPoint)) return simplex;
    }
    freeGJK_EPADynamicGeometry(simplex);
    return false;
}

/**
 * Expanding Polytope Algorithm--penetration depth, collision normal, and contact points.
 * Returns a CollisonData object.
 *
 * @method EPA
 * @param {Body} body1
 * @param {Body} body2
 * @param {DynamicGeometry} polytope
 * @return {CollisionData}
 */
function EPA(body1, body2, polytope) {
    var support = minkowskiSupport;
    var depthEstimate = Infinity;

    var i = 0;
    var maxIterations = 1e3;
    while(i++ < maxIterations) {
        var closest = polytope.getFeatureClosestToOrigin();
        if (closest === null) return null;
        var direction = closest.normal;
        var point = support(body1, body2, direction);
        depthEstimate = Math.min(depthEstimate, Vec3.dot(point.vertex, direction));
        if (depthEstimate - closest.distance <= 0.01) {
            var supportA = polytope.vertices[closest.vertexIndices[0]];
            var supportB = polytope.vertices[closest.vertexIndices[1]];
            var supportC = polytope.vertices[closest.vertexIndices[2]];

            var A = supportA.vertex;
            var B = supportB.vertex;
            var C = supportC.vertex;
            var P = Vec3.scale(direction, closest.distance, P_REGISTER);

            var V0 = Vec3.subtract(B, A, V0_REGISTER);
            var V1 = Vec3.subtract(C, A, V1_REGISTER);
            var V2 = Vec3.subtract(P, A, V2_REGISTER);

            var d00 = Vec3.dot(V0, V0);
            var d01 = Vec3.dot(V0, V1);
            var d11 = Vec3.dot(V1, V1);
            var d20 = Vec3.dot(V2, V0);
            var d21 = Vec3.dot(V2, V1);
            var denom = d00*d11 - d01*d01;

            var v = (d11*d20 - d01*d21) / denom;
            var w = (d00*d21 - d01*d20) / denom;
            var u = 1.0 - v - w;

            var body1Contact =      supportA.worldVertexA.scale(u)
                               .add(supportB.worldVertexA.scale(v))
                               .add(supportC.worldVertexA.scale(w));

            var body2Contact =      supportA.worldVertexB.scale(u)
                               .add(supportB.worldVertexB.scale(v))
                               .add(supportC.worldVertexB.scale(w));

            var localBody1Contact = Vec3.subtract(body1Contact, body1.position, new Vec3());
            var localBody2Contact = Vec3.subtract(body2Contact, body2.position, new Vec3());

            freeGJK_EPADynamicGeometry(polytope);
            OMFreeGJK_EPASupportPoint(point);

            return ObjectManager.requestCollisionData().reset(closest.distance, direction, body1Contact, body2Contact, localBody1Contact, localBody2Contact);
        } else {
            polytope.addVertex(point);
            polytope.reshape();
        }
    }
    throw new Error('EPA failed to terminate in allotted iterations.');
}

module.exports.GJK = GJK;
module.exports.EPA = EPA;

},{"famous-math":82,"famous-utilities":95}],118:[function(require,module,exports){
'use strict';

var AABB = require('./AABB');

/**
 * @const {String[]} AXES x, y, and z axes
 */
var AXES = ['x', 'y', 'z'];

/**
 * Persistant object maintaining sorted lists of AABB endpoints used in a sweep-and-prune broadphase.
 * Used to accelerate collision detection.
 * http://en.wikipedia.org/wiki/Sweep_and_prune
 *
 * @class SweepAndPrune
 * @param {Body[]} targets
 */
function SweepAndPrune(targets) {
    this._sweepVolumes = [];
    this._entityRegistry = {};
    this._boundingVolumeRegistry = {};
    this.endpoints = {x: [], y: [], z: []};

    this.overlaps = [];
    this.overlapsMatrix = {};
    this._IDPool = [];
    targets = targets || [];
    for (var i = 0; i < targets.length; i++) {
        this.add(targets[i]);
    }
}

/**
 * Start tracking a body in the broad-phase.
 *
 * @method add
 * @param {Body} body
 */
SweepAndPrune.prototype.add = function(body) {
    var boundingVolume = new AABB(body);
    var sweepVolume = new SweepVolume(boundingVolume);

    this._entityRegistry[body._ID] = body;
    this._boundingVolumeRegistry[body._ID] = boundingVolume;
    this._sweepVolumes.push(sweepVolume);
    for (var i = 0; i < 3; i++) {
        var axis = AXES[i];
        this.endpoints[axis].push(sweepVolume.points[axis][0]);
        this.endpoints[axis].push(sweepVolume.points[axis][1]);
    }
};

/**
 * Stop tracking a body in the broad-phase.
 *
 * @method add
 * @param {Body} body
 */
SweepAndPrune.prototype.remove = function remove(body) {
    this._entityRegistry[body._ID] = null;
    this._boundingVolumeRegistry[body._ID] = null;
    var i, len;
    var index;
    for (i = 0, len = this._sweepVolumes.length; i < len; i++) {
        if (this._sweepVolumes[i]._ID === body._ID) {
            index = i;
            break;
        }
    }
    this._sweepVolumes.splice(index, 1);
    var endpoints = this.endpoints;
    var point;

    var xs = [];
    for (i = 0, len = endpoints.x.length; i < len; i++) {
        point = endpoints.x[i];
        if (point._ID !== body._ID) xs.push(point);
    }
    var ys = [];
    for (i = 0, len = endpoints.y.length; i < len; i++) {
        point = endpoints.y[i];
        if (point._ID !== body._ID) ys.push(point);
    }
    var zs = [];
    for (i = 0, len = endpoints.z.length; i < len; i++) {
        point = endpoints.z[i];
        if (point._ID !== body._ID) zs.push(point);
    }
    endpoints.x = xs;
    endpoints.y = ys;
    endpoints.z = zs;
};

/**
 * Update the endpoints of the tracked AABB's and resort the endpoint lists accordingly. Uses an insertion sort,
 * where swaps during the sort are taken to signify a potential change in overlap status for the two
 * relevant AABB's. Returns pairs of overlapping AABB's.
 *
 * @param update
 * @return {Particle[][]}
 */
SweepAndPrune.prototype.update = function() {
    var _sweepVolumes = this._sweepVolumes;
    var _entityRegistry = this._entityRegistry;
    var _boundingVolumeRegistry = this._boundingVolumeRegistry;

    var i, j, k, len;

    for (j = 0, len = _sweepVolumes.length; j < len; j++) {
        _sweepVolumes[j].update();
    }

    var endpoints = this.endpoints;
    var overlaps = this.overlaps;
    var overlapsMatrix = this.overlapsMatrix;
    var _IDPool = this._IDPool;

    for (k = 0; k < 3; k++) {
        var axis = AXES[k];
        // Insertion sort:
        var endpointAxis = endpoints[axis];
        for (j = 1, len = endpointAxis.length; j < len; j++) {
            var current = endpointAxis[j];
            var val = current.value;
            var swap;
            var row;
            var index;
            var lowID;
            var highID;
            var cID;
            var sID;

            i = j - 1;
            while (i >= 0 && (swap = endpointAxis[i]).value > val) {
                // A swap occurence indicates that current and swap either just started or just stopped overlapping

                cID = current._ID;
                sID = swap._ID;

                if (cID < sID) {
                    lowID = cID;
                    highID = sID;
                } else {
                    lowID = sID;
                    highID = cID;
                }

                // If, for this axis, min point of current and max point of swap
                if (~current.side & swap.side) {
                    // Now overlapping on this axis -> possible overlap, do full AABB check
                    if (AABB.checkOverlap(_boundingVolumeRegistry[cID], _boundingVolumeRegistry[sID])) {
                        row = overlapsMatrix[lowID] = overlapsMatrix[lowID] || {};
                        index = row[highID] = _IDPool.length ? _IDPool.pop() : overlaps.length;
                        overlaps[index] = [_entityRegistry[lowID], _entityRegistry[highID]];
                    }
                // // Else if, for this axis, max point of current and min point of swap
                } else if (current.side & ~swap.side) {
                    // Now not overlapping on this axis -> definitely not overlapping
                    if ((row = overlapsMatrix[lowID]) && row[highID] != null) {
                        index = row[highID];
                        overlaps[index] = null;
                        row[highID] = null;
                        _IDPool.push(index);
                    }
                }
                // Else if max of both or min of both, still overlapping

                endpointAxis[i + 1] = swap;
                i--;
            }
            endpointAxis[i + 1] = current;
        }
    }

    return overlaps;
};

/**
 * Object used to associate an AABB with its endpoints in the sorted lists.
 *
 * @class SweepVolume
 * @constructor
 * @param {AABB} boundingVolume
 */
function SweepVolume(boundingVolume) {
    this._boundingVolume = boundingVolume;
    this._ID = boundingVolume._ID;
    this.points = {
        x: [{_ID: boundingVolume._ID, side: 0, value: null}, {_ID: boundingVolume._ID, side: 1, value: null}],
        y: [{_ID: boundingVolume._ID, side: 0, value: null}, {_ID: boundingVolume._ID, side: 1, value: null}],
        z: [{_ID: boundingVolume._ID, side: 0, value: null}, {_ID: boundingVolume._ID, side: 1, value: null}]
    };
    this.update();
}

/**
 * Update the endpoints to reflect the current location of the AABB.
 *
 * @method update
 */
SweepVolume.prototype.update = function() {
    var boundingVolume = this._boundingVolume;
    boundingVolume.update();

    var points = this.points;

    for (var i = 0; i < 3; i++) {
        var axis = AXES[i];
        points[axis][0].value = boundingVolume.vertices[axis][0];
        points[axis][1].value = boundingVolume.vertices[axis][1];
    }
};

module.exports = SweepAndPrune;

},{"./AABB":114}],119:[function(require,module,exports){
'use strict';

var Force = require('./Force');
var Vec3 = require('famous-math').Vec3;

var FORCE_REGISTER = new Vec3();

/**
 * Use drag to oppose momentum of a moving object
 *
 * @class Drag
 * @extends Force
 * @param {Object} options
 */
function Drag(targets, options) {
    Force.call(this, targets, options);
}

Drag.prototype = Object.create(Force.prototype);
Drag.prototype.constructor = Drag;

/**
 * Used to scale velocity in the computation of the drag force.
 *
 * @attribute QUADRATIC
 * @type Function
 * @param {Number} v
 * @return {Number} used to square the magnitude of the velocity
 */
Drag.QUADRATIC = function QUADRATIC(v) {
    return v*v;
};

/**
 * Used to scale velocity in the computation of the drag force.
 *
 * @attribute LINEAR
 * @type Function
 * @param {Number} v
 * @return {Number} strength 1, will not scale the velocity
 */
Drag.LINEAR = function LINEAR(v) {
    return v;
};

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Drag.prototype.init = function() {
    this.max = this.max || Infinity;
    this.strength = this.strength || 1;
    this.type = this.type || Drag.LINEAR;
};

/**
 * Apply the force.
 *
 * @method update
 */
Drag.prototype.update = function update() {
    var targets = this.targets;
    var type = this.type;

    var force = FORCE_REGISTER;

    var max = this.max;
    var strength = this.strength;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        var velocity = target.velocity;
        var v = velocity.length();
        var invV = v ? 1 / v : 0;
        var magnitude = -strength * type(v);
        Vec3.scale(velocity, (magnitude < -max ? -max : magnitude) * invV, force);
        target.applyForce(force);
    }
};

module.exports = Drag;

},{"./Force":120,"famous-math":82}],120:[function(require,module,exports){
'use strict';

var _ID = 0;
/**
 * Abstract force manager to apply forces to targets.
 *
 * @class Force
 * @virtual
 * @param {Particle[]} targets The targets of the force.
 * @param {Object} options The options hash.
 */
function Force(targets, options) {
    if (targets) {
        if (targets instanceof Array) this.targets = targets;
        else this.targets = [targets];
    }
    else this.targets = [];

    options = options || {};
    this.setOptions(options);

    this._ID = _ID++;
}

/**
 * Decorates the Force with the options object.
 *
 * @method setOptions
 * @param {Object} options The options hash.
 */
Force.prototype.setOptions = function setOptions(options) {
    for (var key in options) this[key] = options[key];
    this.init(options);
};

/**
 * Add a target or targets to the Force.
 *
 * @method addTarget
 * @param {Particle} target The body to begin targetting.
 */
Force.prototype.addTarget = function addTarget(target) {
    this.targets.push(target);
};

/**
 * Remove a target or targets from the Force.
 *
 * @method addTarget
 * @param {Particle} target The body to stop targetting.
 */
Force.prototype.removeTarget = function removeTarget(target) {
    var index = this.targets.indexOf(target);
    if (index < 0) return;
    this.targets.splice(index, 1);
};

/**
 * Method invoked upon instantiation and the setting of options.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Force.prototype.init = function init(options) {};

/**
 * Apply forces on each target.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Force.prototype.update = function update(time, dt) {};

module.exports = Force;

},{}],121:[function(require,module,exports){
'use strict';

var Force = require('./Force');
var Vec3 = require('famous-math').Vec3;

var FORCE_REGISTER = new Vec3();

/**
 * Force that pulls all objects in a direction with constant acceleration
 *
 * @class Gravity1D
 * @extends Force
 * @param {Object} options
 */
function Gravity1D(targets, options) {
    Force.call(this, targets, options);
}

Gravity1D.prototype = Object.create(Force.prototype);
Gravity1D.prototype.constructor = Gravity1D;

/**
 * @enum directions
 */
Gravity1D.DOWN     = 0;
Gravity1D.UP       = 1;
Gravity1D.LEFT     = 2;
Gravity1D.RIGHT    = 3;
Gravity1D.FORWARD  = 4;
Gravity1D.BACKWARD = 5;

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Gravity1D.prototype.init = function(options) {
    this.max = this.max || Infinity;
    if (options.acceleration) {
        this.strength = this.acceleration.length();
        this.direction = -1;
        return;
    }
    var acceleration = this.acceleration = new Vec3();
    var direction = this.direction = this.direction || Gravity1D.DOWN;
    var magnitude = this.strength = this.strength || 200;
    switch (direction) {
        case Gravity1D.DOWN:
            acceleration.set(0, magnitude, 0);
            break;
        case Gravity1D.UP:
            acceleration.set(0, -1 * magnitude, 0);
            break;
        case Gravity1D.LEFT:
            acceleration.set(-1 * magnitude, 0, 0);
            break;
        case Gravity1D.RIGHT:
            acceleration.set(magnitude, 0, 0);
            break;
        case Gravity1D.FORWARD:
            acceleration.set(0, 0, -1 * magnitude);
            break;
        case Gravity1D.BACKWARD:
            acceleration.set(0, 0, magnitude);
            break;
        default:
            break;
    }
};

/**
 * Apply the force.
 *
 * @method update
 */
Gravity1D.prototype.update = function() {
    var targets = this.targets;

    var force = FORCE_REGISTER;

    var max = this.max;
    var acceleration = this.acceleration;
    var a = acceleration.length();
    var invA = a ? 1 / a : 0;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        var magnitude = a * target.mass;
        Vec3.scale(acceleration, (magnitude > max ? max : magnitude) * invA, force);
        target.applyForce(force);
    }
};

module.exports = Gravity1D;

},{"./Force":120,"famous-math":82}],122:[function(require,module,exports){
'use strict';

var Force = require('./Force');
var Vec3 = require('famous-math').Vec3;

var FORCE_REGISTER = new Vec3();

/**
 * An inverse square force dependent on the masses of the source and targets.
 *
 * @class Gravity3D
 * @extends Force
 * @param {Object} options
 */
function Gravity3D(source, targets, options) {
    this.source = source || null;
    Force.call(this, targets, options);
}

Gravity3D.prototype = Object.create(Force.prototype);
Gravity3D.prototype.constructor = Gravity3D;

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 */
Gravity3D.prototype.init = function() {
    this.max = this.max || Infinity;
    this.strength = this.strength || 200;
};

/**
 * Apply the force.
 *
 * @method update
 */
Gravity3D.prototype.update = function() {
    var source = this.source;
    var targets = this.targets;

    var force = FORCE_REGISTER;

    var strength = this.strength;
    var max = this.max;
    var anchor = this.anchor || source.position;
    var sourceMass = this.anchor ? 1 : source.mass;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        Vec3.subtract(anchor, target.position, force);
        var dist = force.length();
        var invDistance = dist ? 1 / dist : 0;
        var magnitude = strength * sourceMass * target.mass * invDistance * invDistance;
        if (magnitude < 0) {
            magnitude = magnitude < -max ? -max : magnitude;
        } else {
            magnitude = magnitude > max ? max : magnitude;
        }
        force.scale(magnitude * invDistance);
        target.applyForce(force);
        if (source) source.applyForce(force.invert());
    }
};

module.exports = Gravity3D;

},{"./Force":120,"famous-math":82}],123:[function(require,module,exports){
'use strict';

var Force = require('./Force');
var Vec3 = require('famous-math').Vec3;

var TORQUE_REGISTER = new Vec3();

/**
 * A behavior that slows angular velocity by applying torque.
 *
 * @class RotationalDrag
 * @extends Force
 * @param {Object} options options to set on drag
 */
function RotationalDrag(targets, options) {
    Force.call(this, targets, options);
}

RotationalDrag.prototype = Object.create(Force.prototype);
RotationalDrag.prototype.constructor = RotationalDrag;

/**
 * Used to scale angular velocity in the computation of the drag torque.
 *
 * @attribute QUADRATIC
 * @type Function
 * @param {Vec3} omega
 * @return {Number}
 */
RotationalDrag.QUADRATIC = function QUADRATIC(omega) {
    return omega.length();
};

/**
 * Used to scale angular velocity in the computation of the drag torque.
 *
 * @attribute LINEAR
 * @type Function
 * @return {Number}
 */
RotationalDrag.LINEAR = function LINEAR() {
    return 1;
};

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 */
RotationalDrag.prototype.init = function init() {
    this.max = this.max || Infinity;
    this.strength = this.strength || 1;
    this.type = this.type || RotationalDrag.LINEAR;
};

/**
 * Adds a rotational drag force to a physics body's torque accumulator.
 *
 * @method update
 */
RotationalDrag.prototype.update = function update() {
    var targets = this.targets;
    var type = this.type;

    var torque = TORQUE_REGISTER;

    var max = this.max;
    var strength = this.strength;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        var omega = target.angularVelocity;
        var magnitude = -strength * type(omega);
        Vec3.scale(omega, magnitude < -max ? -max : magnitude, torque);
        target.applyTorque(torque);
    }
};

module.exports = RotationalDrag;

},{"./Force":120,"famous-math":82}],124:[function(require,module,exports){
'use strict';

var Force = require('./Force');
var Quaternion = require('famous-math').Quaternion;
var Vec3 = require('famous-math').Vec3;
var Mat33 = require('famous-math').Mat33;

var Q_REGISTER = new Quaternion();
var DAMPING_REGISTER = new Vec3();
var XYZ_REGISTER = new Vec3();
var MAT_REGISTER = new Mat33();

/** @const PI */
var PI = Math.PI;

/**
 * A spring-like behavior that attempts to enforce a specfic orientation by applying torque.
 *
 * @class RotationalSpring
 * @extends Force
 * @param {Object} options
 */
function RotationalSpring(source, targets, options) {
    this.source = source || null;
    Force.call(this, targets, options);
}

RotationalSpring.prototype = Object.create(Force.prototype);
RotationalSpring.prototype.constructor = RotationalSpring;

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
RotationalSpring.prototype.init = function init(options) {
    if (!this.source) this.anchor = this.anchor ? this.anchor.normalize() : new Quaternion(1,0,0,0);
    if (options.stiffness || options.damping) {
        this.stiffness = this.stiffness || 100;
        this.damping = this.damping || 0;
        this.period = null;
        this.dampingRatio = null;
    }
    else if (options.period || options.dampingRatio) {
        this.period = this.period || 1;
        this.dampingRatio = this.dampingRatio || 0;

        this.stiffness = 2 * PI / this.period;
        this.stiffness *= this.stiffness;
        this.damping = 4 * PI * this.dampingRatio / this.period;
    }
};

/**
 * Adds a torque force to a physics body's torque accumulator.
 *
 * @method update
 */
RotationalSpring.prototype.update = function update() {
    var source = this.source;
    var targets = this.targets;

    var deltaQ = Q_REGISTER;
    var dampingTorque = DAMPING_REGISTER;
    var XYZ = XYZ_REGISTER;
    var effInertia = MAT_REGISTER;

    var max = this.max;
    var stiffness = this.stiffness;
    var damping = this.damping;
    var anchor = this.anchor || source.orientation;
    var invSourceInertia = this.anchor ? null : source.inverseInertia;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        var q = target.orientation;
        Quaternion.conjugate(q, deltaQ);
        deltaQ.multiply(anchor);

        if (deltaQ.w >= 1) continue;
        var halftheta = Math.acos(deltaQ.w);
        var length = Math.sqrt(1 - deltaQ.w * deltaQ.w);

        var deltaOmega = XYZ.copy(deltaQ).scale(2 * halftheta / length);

        deltaOmega.scale(stiffness);

        if (invSourceInertia !== null) {
            Mat33.add(invSourceInertia, target.inverseInertia, effInertia).inverse();
        } else {
            Mat33.inverse(target.inverseInertia, effInertia);
        }

        if (damping !== 0) {
            if (source) {
                deltaOmega.add(Vec3.subtract(target.angularVelocity, source.angularVelocity, dampingTorque).scale(-damping));
            }
            else {
                deltaOmega.add(Vec3.scale(target.angularVelocity, -damping, dampingTorque));
            }
        }

        var torque = deltaOmega.applyMatrix(effInertia);
        var magnitude = torque.length();

        if (magnitude > max) torque.scale(max/magnitude);

        target.applyTorque(torque);
        if (source) source.applyTorque(torque.invert());
    }
};

module.exports = RotationalSpring;

},{"./Force":120,"famous-math":82}],125:[function(require,module,exports){
'use strict';

var Force = require('./Force');
var Vec3 = require('famous-math').Vec3;

var FORCE_REGISTER = new Vec3();
var DAMPING_REGISTER = new Vec3();

/**
 * A force that accelerates a Particle towards a specific anchor point. Can be anchored to
 * a Vec3 or another source Particle.
 *
 *  @class Spring
 *  @extends Force
 *  @param {Object} options options to set on drag
 */
function Spring(source, targets, options) {
    this.source = source || null;
    Force.call(this, targets, options);
}

Spring.prototype = Object.create(Force.prototype);
Spring.prototype.constructor = Spring;

/** @const */
var PI = Math.PI;

/**
 * A FENE (Finitely Extensible Nonlinear Elastic) spring force
 *      see: http://en.wikipedia.org/wiki/FENE
 * @attribute FENE
 * @type Function
 * @param {Number} dist current distance target is from source body
 * @param {Number} rMax maximum range of influence
 * @return {Number} unscaled force
 */
Spring.FENE = function(dist, rMax) {
    var rMaxSmall = rMax * 0.99;
    var r = Math.max(Math.min(dist, rMaxSmall), -rMaxSmall);
    return r / (1 - r * r/(rMax * rMax));
};

/**
 * A Hookean spring force, linear in the displacement
 *      see: http://en.wikipedia.org/wiki/Hooke's_law
 * @attribute HOOKE
 * @type Function
 * @param {Number} dist current distance target is from source body
 * @return {Number} unscaled force
 */
Spring.HOOKE = function(dist) {
    return dist;
};

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Spring.prototype.init = function(options) {
    this.max = this.max || Infinity;
    this.length = this.length || 0;
    this.type = this.type || Spring.HOOKE;
    this.maxLength = this.maxLength || Infinity;
    if (options.stiffness || options.damping) {
        this.stiffness = this.stiffness || 100;
        this.damping = this.damping || 0;
        this.period = null;
        this.dampingRatio = null;
    }
    else if (options.period || options.dampingRatio) {
        this.period = this.period || 1;
        this.dampingRatio = this.dampingRatio || 0;

        this.stiffness = 2 * PI / this.period;
        this.stiffness *= this.stiffness;
        this.damping = 4 * PI * this.dampingRatio / this.period;
    }
};

/**
 * Apply the force.
 *
 * @method update
 */
Spring.prototype.update = function() {
    var source = this.source;
    var targets = this.targets;

    var force = FORCE_REGISTER;
    var dampingForce = DAMPING_REGISTER;

    var max = this.max;
    var stiffness = this.stiffness;
    var damping = this.damping;
    var restLength = this.length;
    var maxLength = this.maxLength;
    var anchor = this.anchor || source.position;
    var invSourceMass = this.anchor ? 0 : source.inverseMass;
    var type = this.type;

    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        Vec3.subtract(anchor, target.position, force);
        var dist = force.length();
        var stretch = dist - restLength;

        if (Math.abs(stretch) < 1e-6) continue;

        var effMass = 1 / (target.inverseMass + invSourceMass);
        if (this.period !== null) {
            stiffness *= effMass;
            damping *= effMass;
        }

        force.scale(stiffness * type(stretch, maxLength) / stretch);

        if (damping !== 0) {
            if (source) {
                force.add(Vec3.subtract(target.velocity, source.velocity, dampingForce).scale(-damping));
            }
            else {
                force.add(Vec3.scale(target.velocity, -damping, dampingForce));
            }
        }

        var magnitude = force.length();
        var invMag = magnitude ? 1 / magnitude : 0;

        Vec3.scale(force, (magnitude > max ? max : magnitude) * invMag, force);

        target.applyForce(force);
        if (source) source.applyForce(force.invert());
    }
};

module.exports = Spring;

},{"./Force":120,"famous-math":82}],126:[function(require,module,exports){
'use strict';

module.exports = {
    Particle: require('./bodies/Particle'),
    ConvexBodyFactory: require('./bodies/ConvexBodyFactory'),
    Box: require('./bodies/Box'),
    Sphere: require('./bodies/Sphere'),
    Wall: require('./bodies/Wall'),

    Constraint: require('./constraints/Constraint'),
    Angle: require('./constraints/Angle'),
    Collision: require('./constraints/Collision'),
    Direction: require('./constraints/Direction'),
    Distance: require('./constraints/Distance'),
    Curve: require('./constraints/Curve'),
    Hinge: require('./constraints/Hinge'),
    Point2Point: require('./constraints/Point2Point'),

    Force: require('./forces/Force'),
    Drag: require('./forces/Drag'),
    RotationalDrag: require('./forces/RotationalDrag'),
    Gravity1D: require('./forces/Gravity1D'),
    Gravity3D: require('./forces/Gravity3D'),
    Spring: require('./forces/Spring'),
    RotationalSpring: require('./forces/RotationalSpring'),

    PhysicsEngine: require('./PhysicsEngine'),
    Geometry: require('./Geometry')
};

},{"./Geometry":99,"./PhysicsEngine":100,"./bodies/Box":101,"./bodies/ConvexBodyFactory":102,"./bodies/Particle":103,"./bodies/Sphere":104,"./bodies/Wall":105,"./constraints/Angle":106,"./constraints/Collision":107,"./constraints/Constraint":108,"./constraints/Curve":109,"./constraints/Direction":110,"./constraints/Distance":111,"./constraints/Hinge":112,"./constraints/Point2Point":113,"./forces/Drag":119,"./forces/Force":120,"./forces/Gravity1D":121,"./forces/Gravity3D":122,"./forces/RotationalDrag":123,"./forces/RotationalSpring":124,"./forces/Spring":125}],127:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],128:[function(require,module,exports){
arguments[4][71][0].apply(exports,arguments)
},{"./animationFrame":127,"dup":71}],129:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],130:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./Mat33":129,"dup":3}],131:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],132:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],133:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"./Mat33":129,"./Quaternion":130,"./Vec2":131,"./Vec3":132,"dup":6}],134:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],135:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],136:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./Curves":134,"dup":9}],137:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],138:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./Curves":134,"./Easing":135,"./Transitionable":136,"./after":137,"dup":11}],139:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],140:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],141:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./Curves":139,"dup":9}],142:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],143:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./Curves":139,"./Easing":140,"./Transitionable":141,"./after":142,"dup":11}],144:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17}],145:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"famous-transitions":143}],146:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],147:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],148:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],149:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],150:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],151:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./CallbackStore":144,"./Color":145,"./KeyCodes":146,"./MethodStore":147,"./ObjectManager":148,"./clone":149,"./flatClone":150,"./keyValueToArrays":152,"./loadURL":153,"./strip":154,"dup":24}],152:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],153:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],154:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],155:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./Position":163,"dup":28}],156:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],157:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],158:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31,"famous-utilities":151}],159:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32,"famous-math":133,"famous-utilities":151}],160:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./Position":163,"dup":33}],161:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34,"famous-transitions":138}],162:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./Position":163,"dup":35}],163:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"dup":36,"famous-transitions":138}],164:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"./Position":163,"dup":37}],165:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./Position":163,"dup":38}],166:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"famous-core":50,"famous-transitions":138}],167:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"dup":40,"famous-utilities":151}],168:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"./Align":155,"./Camera":156,"./EventEmitter":157,"./EventHandler":158,"./GestureHandler":159,"./MountPoint":160,"./Opacity":161,"./Origin":162,"./Position":163,"./Rotation":164,"./Scale":165,"./Size":166,"./UIEventHandler":167,"dup":41}],169:[function(require,module,exports){
'use strict';

var ElementCache = require('./ElementCache');

// an enumeration of potential vendor prefixes.
var VENDOR_PREFIXES = ['', '-ms-', '-webkit-', '-moz-', '-o-'];

/**
 * A private function for determining if a css property
 * has a vendor prefix.
 *
 * @param {String} property
 */
function vendorPrefix(property) {
    for (var i = 0; i < VENDOR_PREFIXES.length; i++) {
        var prefixed = VENDOR_PREFIXES[i] + property;
        if (document.documentElement.style[prefixed] === '') {
            return prefixed;
        }
    }
    return property;
}

// the prefixed transform property.
var TRANSFORM = vendorPrefix('transform');

/**
 * DOMRenderer is a class responsible for adding elements
 * to the DOM and writing to those elements.
 * there is a DOMRenderer per context, represented as an
 * element and a selector. It is instantiated in the 
 * context class.
 *
 * @class DOMRenderer
 * 
 * @param {HTMLElement} an element.
 * @param {String} the selector of the element.
 * @param {Compositor}
 */
function DOMRenderer (element, selector, compositor) {
    this._compositor = compositor; // a reference to the compositor

    this._target = null; // a register for holding the current
                         // element that the Renderer is operating
                         // upon

    this._parent = null; // a register for holding the parent
                         // of the target

    this._path = null; // a register for holding the path of the target
                       // this register must be set first, and then
                       // children, target, and parent are all looked
                       // up from that.

    this._children = []; // a register for holding the children of the
                         // current target.

    this._root = new ElementCache(element, selector); // the root
                                                      // of the dom tree that this
                                                      // renderer is responsible
                                                      // for

    this._selector = selector;
    
    this._elements = {};

    this._elements[selector] = this._root;

    this.perspectiveTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    this._VPtransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);

    this._eventListeners = {};
}

DOMRenderer.prototype.addEventListener = function addEventListener(path, type, properties, preventDefault) {
    if (!this._eventListeners[type]) {
        this._eventListeners[type] = {};
        this._root.element.addEventListener(type, this._triggerEvent.bind(this));
    }

    this._eventListeners[type][path] = {
        properties: properties,
        preventDefault: preventDefault
    };
};

function _mirror(item, target, reference) {
    var i, len;
    var key, keys;
    if (typeof item === 'string' || typeof item === 'number') target[item] = reference[item];
    else if (Array.isArray(item)) {
        for (i = 0, len = item.length; i < len; i++) {
            _mirror(item[i], target, reference);
        }
    }
    else {
        keys = Object.keys(item);
        for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            if (reference[key]) {
                target[key] = {};
                _mirror(item[key], target[key], reference[key])
            }
        }
    }
}

function _makeTarget (ev) {
    var target = ev.target;
    var result = {
        tagName: target.tagName,
        id: target.getAttribute('id'),
        classes: []
    };
    for (var i = 0, len = target.classList.length ; i < len ; i++)
        result.classes[i] = target.classList[i];
    return result;
}

function _stripEvent (ev, properties, path) {
    var result = {
        path: path,
        target: _makeTarget(ev),
        node: null
    };
    var i, len;
    for (i = 0, len = properties ? properties.length : 0; i < len; i++) {
        var prop = properties[i];
        _mirror(prop, result, ev);
    }
    result.timeStamp = ev.timeStamp;
    result.time = ev.timeStamp;
    switch (ev.type) {
        case 'mousedown':
        case 'mouseup':
        case 'click':
        case 'mousemove':
            result.x = ev.x;
            result.y = ev.y;
            result.timeStamp = ev.timeStamp;
            result.pageX = ev.pageX;
            result.pageY = ev.pageY;
            break;
        case 'wheel':
            result.deltaX = ev.deltaX;
            result.deltaY = ev.deltaY;
            break;
        case 'touchstart':
        case 'touchmove':
        case 'touchend':
           result.targetTouches = [];
           for (var i = 0 ; i < ev.targetTouches.length ; i++) {
               result.targetTouches.push({
                   pageX: ev.targetTouches[i].pageX,
                   pageY: ev.targetTouches[i].pageY,
                   identifier: ev.targetTouches[i].identifier
               });
           }
    }
    
    return result;
}

DOMRenderer.prototype._triggerEvent = function _triggerEvent(ev) {
    var evPath = ev.path ? ev.path : _getPath(ev);
    for (var i = 0; i < evPath.length; i++) {
        if (!evPath[i].dataset) continue;
        var path = evPath[i].dataset.faPath;
        if (this._eventListeners[ev.type][path]) {
            this._compositor.sendEvent(path, ev.type, _stripEvent(ev, this._eventListeners[ev.type][path].properties, path));
            ev.stopPropagation();
            if (this._eventListeners[ev.type][path].preventDefault) {
                ev.preventDefault();
            }
            break;
        }
    }
};

function _getPath (ev) {
    var path = [];
    var node = ev.target;
    while (node != document.body) {
        path.push(node);
        node = node.parentNode;
    }
    return path;
}

DOMRenderer.prototype.getSize = function getSize () {
    return [this._root.element.offsetWidth, this._root.element.offsetHeight];
};

DOMRenderer.prototype._getSize = DOMRenderer.prototype.getSize;

DOMRenderer.prototype.draw = function draw (renderState) {
    if (renderState.perspectiveDirty) {
        this.perspectiveDirty = true;

        this.perspectiveTransform[0] = renderState.perspectiveTransform[0];
        this.perspectiveTransform[1] = renderState.perspectiveTransform[1];
        this.perspectiveTransform[2] = renderState.perspectiveTransform[2];
        this.perspectiveTransform[3] = renderState.perspectiveTransform[3];

        this.perspectiveTransform[4] = renderState.perspectiveTransform[4];
        this.perspectiveTransform[5] = renderState.perspectiveTransform[5];
        this.perspectiveTransform[6] = renderState.perspectiveTransform[6];
        this.perspectiveTransform[7] = renderState.perspectiveTransform[7];

        this.perspectiveTransform[8] = renderState.perspectiveTransform[8];
        this.perspectiveTransform[9] = renderState.perspectiveTransform[9];
        this.perspectiveTransform[10] = renderState.perspectiveTransform[10];
        this.perspectiveTransform[11] = renderState.perspectiveTransform[11];

        this.perspectiveTransform[12] = renderState.perspectiveTransform[12];
        this.perspectiveTransform[13] = renderState.perspectiveTransform[13];
        this.perspectiveTransform[14] = renderState.perspectiveTransform[14];
        this.perspectiveTransform[15] = renderState.perspectiveTransform[15];
    }

    if (renderState.viewDirty || renderState.perspectiveDirty) {
        multiply(this._VPtransform, this.perspectiveTransform, renderState.viewTransform);
        this._root.element.style[TRANSFORM] = stringifyMatrix(this._VPtransform);
    }
};

DOMRenderer.prototype._assertPathLoaded = function _asserPathLoaded () {
    if (!this._path) throw new Error('path not loaded');
};

DOMRenderer.prototype._assertParentLoaded = function _assertParentLoaded () {
    if (!this._parent) throw new Error('parent not loaded');
};

DOMRenderer.prototype._assertChildrenLoaded = function _assertChildrenLoaded () {
    if (!this._children) throw new Error('children not loaded');
};

DOMRenderer.prototype.findParent = function findParent () {
    this._assertPathLoaded();

    var path = this._path;
    var parent;

    while (!parent && path.length) {
        path = path.substring(0, path.lastIndexOf('/'));
        parent = this._elements[path];
    }
    this._parent = parent;
    return parent;
};

DOMRenderer.prototype.findChildren = function findChildren (array) {
    this._assertPathLoaded();
    
    var path = this._path;
    var keys = Object.keys(this._elements);
    var i = 0;
    var len;
    array = array ? array : this._children;

    this._children.length = 0;

    while (i < keys.length) {
        if (keys[i].indexOf(path) === -1 || keys[i] === path) keys.splice(i, 1);
        else i++;
    }
    var currentPath;
    var j = 0;
    for (i = 0 ; i < keys.length ; i++) {
        currentPath = keys[i];
        for (j = 0 ; j < keys.length ; j++) {
            if (i !== j && keys[j].indexOf(currentPath) !== -1) {
                keys.splice(j, 1);
                i--;
            }
        }
    }
    for (i = 0, len = keys.length ; i < len ; i++)
        array[i] = this._elements[keys[i]];

    return array;
};

DOMRenderer.prototype.findTarget = function findTarget () {
    this._target = this._elements[this._path];
    return this._target;
};

DOMRenderer.prototype.loadPath = function loadPath (path) {
    this._path = path;
    return this._path;
};

DOMRenderer.prototype.insertEl = function insertEl (tagName) {
    if (!this._target ||
         this._target.element.tagName.toLowerCase() === tagName.toLowerCase()) {
        
        this.findParent();
        this.findChildren();
        
        this._assertParentLoaded();
        this._assertChildrenLoaded();

        if (this._target) this._parent.element.removeChild(this._target.element);
 
        this._target = new ElementCache(document.createElement(tagName), this._path);
        this._parent.element.appendChild(this._target.element);
        this._elements[this._path] = this._target;
        
        for (var i = 0, len = this._children.length ; i < len ; i++) {
            this._target.element.appendChild(this._children[i].element);
        }
    }
};

DOMRenderer.prototype._assertTargetLoaded = function _assertTargetLoaded () {
    if (!this._target) throw new Error('No target loaded');
};

DOMRenderer.prototype.setProperty = function setProperty (name, value) {
    this._assertTargetLoaded();
    this._target.element.style[name] = value;
};

DOMRenderer.prototype.setSize = function setSize (width, height) {
    this._assertTargetLoaded();
    this._target.element.style.width = (width === true) ? '' : width + 'px';
    this._target.element.style.height = (height === true) ? '' : height + 'px';
};

DOMRenderer.prototype.setAttribute = function setAttribute (name, value) {
    this._assertTargetLoaded();
    this._target.element.setAttribute(name, value);
};

DOMRenderer.prototype.setContent = function setContent (content) {
    this._assertTargetLoaded();
    this.findChildren(this._path);

    // Temporary solution
    for (var i = 0 ; i < this._children.length ; i++) {
        this._target.element.removeChild(this._children[i].element);
    }

    this._target.element.innerHTML = content;

    for (var i = 0 ; i < this._children.length ; i++)
        this._target.element.appendChild(this._children[i].element);
};

DOMRenderer.prototype.setMatrix = function setMatrix (transform) { 
    this._assertTargetLoaded();
    this.findParent();
    var worldTransform = this._target.worldTransform;
    var changed = false

    if (transform)
        for (var i = 0, len = 16 ; i < len ; i++) {
            changed = changed ? changed : worldTransform[i] === transform[i];
            worldTransform[i] = transform[i];
        }
    else changed = true;

    if (changed) {
        invert(this._target.invertedParent, this._parent.worldTransform);
        multiply(this._target.finalTransform, this._target.invertedParent, worldTransform);

        // TODO: this is a temporary fix for draw commands
        // coming in out of order
        var children = this.findChildren([]);
        var previousPath = this._path;
        var previousTarget = this._target;
        for (i = 0, len = children.length ; i < len ; i++) {
            this._target = children[i];
            this._path = this._target.path;
            this.setMatrix();
        }
        this._path = previousPath;
        this._target = previousTarget;
    }

    this._target.element.style[TRANSFORM] = stringifyMatrix(this._target.finalTransform);
};

DOMRenderer.prototype.addClass = function addClass (domClass) {
    this._assertTargetLoaded();
    this._target.element.classList.add(domClass);
};

DOMRenderer.prototype.removeClass = function removeClass (domClass) {
    this._assertTargetLoaded();
    this._target.element.classList.remove(domClass);
};

function stringifyMatrix(m) {
    var r = 'matrix3d(';

    r += (m[0] < 0.000001 && m[0] > -0.000001) ? '0,' : m[0] + ',';
    r += (m[1] < 0.000001 && m[1] > -0.000001) ? '0,' : m[1] + ',';
    r += (m[2] < 0.000001 && m[2] > -0.000001) ? '0,' : m[2] + ',';
    r += (m[3] < 0.000001 && m[3] > -0.000001) ? '0,' : m[3] + ',';
    r += (m[4] < 0.000001 && m[4] > -0.000001) ? '0,' : m[4] + ',';
    r += (m[5] < 0.000001 && m[5] > -0.000001) ? '0,' : m[5] + ',';
    r += (m[6] < 0.000001 && m[6] > -0.000001) ? '0,' : m[6] + ',';
    r += (m[7] < 0.000001 && m[7] > -0.000001) ? '0,' : m[7] + ',';
    r += (m[8] < 0.000001 && m[8] > -0.000001) ? '0,' : m[8] + ',';
    r += (m[9] < 0.000001 && m[9] > -0.000001) ? '0,' : m[9] + ',';
    r += (m[10] < 0.000001 && m[10] > -0.000001) ? '0,' : m[10] + ',';
    r += (m[11] < 0.000001 && m[11] > -0.000001) ? '0,' : m[11] + ',';
    r += (m[12] < 0.000001 && m[12] > -0.000001) ? '0,' : m[12] + ',';
    r += (m[13] < 0.000001 && m[13] > -0.000001) ? '0,' : m[13] + ',';
    r += (m[14] < 0.000001 && m[14] > -0.000001) ? '0,' : m[14] + ',';

    r += m[15] + ')';
    return r;
}

function invert (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
}

function multiply (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3],
        b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7],
        b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11],
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    var changed = false;
    var out0, out1, out2, out3;

    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 == out[0] ||
                        out1 == out[1] ||
                        out2 == out[2] ||
                        out3 == out[3];

    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = out3;

    b0 = b4; b1 = b5; b2 = b6; b3 = b7;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 == out[4] ||
                        out1 == out[5] ||
                        out2 == out[6] ||
                        out3 == out[7];

    out[4] = out0;
    out[5] = out1;
    out[6] = out2;
    out[7] = out3;

    b0 = b8; b1 = b9; b2 = b10; b3 = b11;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 == out[8] ||
                        out1 == out[9] ||
                        out2 == out[10] ||
                        out3 == out[11];

    out[8] = out0;
    out[9] = out1;
    out[10] = out2;
    out[11] = out3;

    b0 = b12; b1 = b13; b2 = b14; b3 = b15;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 == out[12] ||
                        out1 == out[13] ||
                        out2 == out[14] ||
                        out3 == out[15];

    out[12] = out0;
    out[13] = out1;
    out[14] = out2;
    out[15] = out3;

    return out;
}

module.exports = DOMRenderer;


},{"./ElementCache":170}],170:[function(require,module,exports){
'use strict';

var ident = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
];

function ElementCache (element, path) {
    this.element = element;
    this.path = path;
    this.worldTransform = new Float32Array(ident);
    this.invertedParent = new Float32Array(ident);
    this.finalTransform = new Float32Array(ident);
    this.postRenderSize = new Float32Array(2);
};

module.exports = ElementCache;


},{}],171:[function(require,module,exports){
'use strict';

module.exports = {
    DOMRenderer: require('./DOMRenderer')
};

},{"./DOMRenderer":169}],172:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],173:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],174:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./Curves":172,"dup":9}],175:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],176:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./Curves":172,"./Easing":173,"./Transitionable":174,"./after":175,"dup":11}],177:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17}],178:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"famous-transitions":176}],179:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],180:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],181:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],182:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],183:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],184:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./CallbackStore":177,"./Color":178,"./KeyCodes":179,"./MethodStore":180,"./ObjectManager":181,"./clone":182,"./flatClone":183,"./keyValueToArrays":185,"./loadURL":186,"./strip":187,"dup":24}],185:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],186:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],187:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],188:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],189:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],190:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./Curves":188,"dup":9}],191:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],192:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./Curves":188,"./Easing":189,"./Transitionable":190,"./after":191,"dup":11}],193:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17}],194:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"famous-transitions":192}],195:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],196:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],197:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],198:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],199:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],200:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./CallbackStore":193,"./Color":194,"./KeyCodes":195,"./MethodStore":196,"./ObjectManager":197,"./clone":198,"./flatClone":199,"./keyValueToArrays":201,"./loadURL":202,"./strip":203,"dup":24}],201:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],202:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],203:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],204:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],205:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./Mat33":204,"dup":3}],206:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],207:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],208:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"./Mat33":204,"./Quaternion":205,"./Vec2":206,"./Vec3":207,"dup":6}],209:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],210:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],211:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./Curves":209,"dup":9}],212:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],213:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./Curves":209,"./Easing":210,"./Transitionable":211,"./after":212,"dup":11}],214:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17}],215:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"famous-transitions":213}],216:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],217:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],218:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],219:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],220:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],221:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./CallbackStore":214,"./Color":215,"./KeyCodes":216,"./MethodStore":217,"./ObjectManager":218,"./clone":219,"./flatClone":220,"./keyValueToArrays":222,"./loadURL":223,"./strip":224,"dup":24}],222:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],223:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],224:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],225:[function(require,module,exports){
'use strict';

var Geometry = require('./Geometry');

/**
 * DynamicGeometry is a component that defines the data that should
 *   be drawn to the webGL canvas. Manages vertex data and attributes.
 *
 * @class DynamicGeometry
 * @constructor
 * 
 * @param {Object} options instantiation options
 */
function DynamicGeometry(options) {
    Geometry.call(this, options);

    this.spec.dynamic = true;
}

/**
 * Returns the number of attribute values used to draw the DynamicGeometry.
 *
 * @class DynamicGeometry
 * @constructor
 * 
 * @return {Object} flattened length of the vertex positions attribute
 * in the geometry.
 */
DynamicGeometry.prototype.getLength = function getLength() {
    return this.getVertexPositions().length;
};

/**
 * Gets the buffer object based on buffer name. Throws error
 * if bufferName is not provided.
 *
 * @method getVertexBuffer
 *
 * @param {String} bufferName Name of vertexBuffer to be retrieved.
 * @return {Object} value of buffer with corresponding bufferName.
 */
DynamicGeometry.prototype.getVertexBuffer = function getVertexBuffer(bufferName) {
    if (! bufferName) throw 'getVertexBuffer requires a name';

    var idx = this.spec.bufferNames.indexOf(bufferName);
    if (idx === -1) throw 'buffer does not exist';
    else {
        return this.spec.bufferValues[idx];
    }
};

/**
 * Sets a vertex buffer with given name to input value. Registers a new 
 * buffer if one does not exist with given name.
 * 
 * @method setVertexBuffer
 * @param {String} bufferName Name of vertexBuffer to be set.
 * @param {Array} value Input data to fill target buffer.
 * @param {Number} size Vector size of input buffer data.
 * @return {Object} current geometry.
 */
DynamicGeometry.prototype.setVertexBuffer = function setVertexBuffer(bufferName, value, size) {
    var idx = this.spec.bufferNames.indexOf(bufferName);

    if (idx === -1) {
        idx = this.spec.bufferNames.push(bufferName) - 1;
    }

    this.spec.bufferValues[idx] = value || [];
    this.spec.bufferSpacings[idx] = size || this.DEFAULT_BUFFER_SIZE;

    if (this.spec.invalidations.indexOf(idx) === -1) {
        this.spec.invalidations.push(idx);
    }

    return this;
};

/**
 * Copies and sets all buffers from another geometry instance.
 *
 * @method fromGeometry
 *
 * @param {Object} geometry Geometry instance to copy buffers from.
 * @return {Object} current geometry.
 */
DynamicGeometry.prototype.fromGeometry = function fromGeometry(geometry) {
    var len = geometry.spec.bufferNames.length;
    for (var i = 0; i < len; i++) {
        this.setVertexBuffer(
            geometry.spec.bufferNames[i],
            geometry.spec.bufferValues[i],
            geometry.spec.bufferSpacings[i]
        );
    }
    return this;
};

/**
 *  Set the positions of the vertices in this geometry.
 * 
 *  @method setVertexPositions
 *  @param {Array} value New value for vertex position buffer
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setVertexPositions = function (value) {
    return this.setVertexBuffer('pos', value, 3);
};

/**
 *  Set the normals on this geometry.
 * 
 *  @method setNormals
 *  @param {Array} value Value to set normal buffer to.
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setNormals = function (value) {
    return this.setVertexBuffer('normals', value, 3);
};

/**
 *  Set the texture coordinates on this geometry.
 * 
 *  @method setTextureCoords
 *  @param {Array} value New value for texture coordinates buffer.
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setTextureCoords = function (value) {
    return this.setVertexBuffer('texCoord', value, 2);
};

/**
 *  Set the texture coordinates on this geometry.
 *  @method setTextureCoords
 *  @param {Array} value New value for index buffer
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setIndices = function (value) {
    return this.setVertexBuffer('indices', value, 1);
};

/**
 *  Set the WebGL drawing primitive for this geometry.
 *  @method setDrawType
 *  @param {String} type New drawing primitive for geometry
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setDrawType = function (value) {
    this.spec.type = value.toUpperCase();
    return this;
};

/**
 * Returns the 'pos' vertex buffer of the geometry.
 * @method getVertexPositions
 * @return {Array} Vertex buffer.
 */
DynamicGeometry.prototype.getVertexPositions = function () {
    return this.getVertexBuffer('pos');
};

/**
 * Returns the 'normal' vertex buffer of the geometry.
 * @method getNormals
 * @return {Array} Vertex Buffer.
 */
DynamicGeometry.prototype.getNormals = function () {
    return this.getVertexBuffer('normals');
};

/**
 * Returns the 'textureCoord' vertex buffer of the geometry.
 * @method getTextureCoords
 * @return {Array} Vertex Buffer.
 */
DynamicGeometry.prototype.getTextureCoords = function () {
    return this.getVertexBuffer('texCoord');
};

module.exports = DynamicGeometry;

},{"./Geometry":226}],226:[function(require,module,exports){
'use strict';

var GeometryIds = 0;

// WebGL drawing primitives map. This is generated in geometry to 
// avoid chrome deoptimizations in WebGLRenderer draw function.
// TODO: return draw type data retreival to WebGLRenderer.

var DRAW_TYPES = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
};

/**
 * Geometry is a component that defines the data that should
 * be drawn to the webGL canvas. Manages vertex data and attributes.
 *
 * @class Geometry
 * @constructor
 * 
 * @param {Object} options Instantiation options.
 */
function Geometry(options) {
    this.id = GeometryIds++;
    this.options = options || {};
    this.DEFAULT_BUFFER_SIZE = 3;

    this.spec = {
        id: this.id,
        dynamic: false,
        type: DRAW_TYPES[(this.options.type ? this.options.type.toUpperCase() : 'TRIANGLES')],
        bufferNames: [],
        bufferValues: [],
        bufferSpacings: [],
        invalidations: []
    };

    if (this.options.buffers) {
        var len = this.options.buffers.length;
        for (var i = 0; i < len;) {
            this.spec.bufferNames.push(this.options.buffers[i].name);
            this.spec.bufferValues.push(this.options.buffers[i].data);
            this.spec.bufferSpacings.push(this.options.buffers[i].size || this.DEFAULT_BUFFER_SIZE);
            this.spec.invalidations.push(i++);
        }
    }
}

module.exports = Geometry;

},{}],227:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var Vec2 = require('famous-math').Vec2;

var outputs = [
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec2(),
    new Vec2()
];

/**
 * A helper object used to calculate buffers for complicated geometries.
 * Tailored for the WebGLRenderer, used by most primitives.
 *
 * @static
 * @class GeometryHelper
 */
var GeometryHelper = {};

/**
 * A function that iterates through vertical and horizontal slices
 * based on input detail, and generates vertices and indices for each
 * subdivision.
 *
 * @static
 * @method generateParametric
 *
 * @param {Number} detailX Amount of slices to iterate through.
 * @param {Number} detailY Amount of stacks to iterate through.
 * @param {Function} func Function used to generate vertex positions at each point.
 * 
 * @return {Object} Object containing generated vertices and indices.
 */
GeometryHelper.generateParametric = function generateParametric(detailX, detailY, func) {
    var vertices = [],
        i, theta, phi, result, j;

    // We must wrap around slightly more than once for uv coordinates to look correct.

    var Xrange = Math.PI + (Math.PI / (detailX - 1));
    var out = [];

    for (i = 0; i < detailX + 1; i++) {
        theta = i * Xrange / detailX;
        for (j = 0; j < detailY; j++) {
            phi = j * 2.0 * Xrange / detailY;
            func(theta, phi, out);
            vertices.push(out[0], out[1], out[2]);
        }
    }

    var indices = [],
        v = 0,
        next;
    for (i = 0; i < detailX; i++) {
        for (j = 0; j < detailY; j++) {
            next = (j + 1) % detailY;
            indices.push(v + j, v + j + detailY, v + next);
            indices.push(v + next, v + j + detailY, v + next + detailY);
        }
        v += detailY;
    }

    return {
        vertices: vertices,
        indices: indices
    };
}

/**
 * Calculates normals belonging to each face of a geometry.  
 * Assumes clockwise declaration of vertices.
 *
 * @static
 * @method computeNormals
 *
 * @param {Array} vertices Vertices of all points on the geometry.
 * @param {Array} indices Indices declaring faces of geometry.
 * @param {Array} out Array to be filled and returned.
 * 
 * @return {Array} Calculated face normals.
 */
GeometryHelper.computeNormals = function computeNormals(vertices, indices, out) {
    var normals = out || [];
    var vertexThree;
    var vertexTwo;
    var vertexOne;
    var indexOne;
    var indexTwo;
    var indexThree;
    var start;
    var end;
    var normal;
    var j;
    var len = indices.length / 3;

    for (var i = 0; i < len; i++) {
        j = i * 3;
        indexTwo = indices[j + 0] * 3;
        indexOne = indices[j + 1] * 3;
        indexThree = indices[j + 2] * 3;

        outputs[0].set(vertices[indexOne], vertices[indexOne + 1], vertices[indexOne + 2]);
        outputs[1].set(vertices[indexTwo], vertices[indexTwo + 1], vertices[indexTwo + 2]);
        outputs[2].set(vertices[indexThree], vertices[indexThree + 1], vertices[indexThree + 2]);

        normal = outputs[2].subtract(outputs[0]).cross(outputs[1].subtract(outputs[0]));
        normal = normal.normalize().toArray();

        normals[indexOne + 0] = normal[0];
        normals[indexOne + 1] = normal[1];
        normals[indexOne + 2] = normal[2];

        normals[indexTwo + 0] = normal[0];
        normals[indexTwo + 1] = normal[1];
        normals[indexTwo + 2] = normal[2];

        normals[indexThree + 0] = normal[0];
        normals[indexThree + 1] = normal[1];
        normals[indexThree + 2] = normal[2];
    }

    return normals;
};

/**
 * Divides all inserted triangles into four sub-triangles. Alters the
 * passed in arrays.
 *
 * @static
 * @method subdivide
 *
 * @param {Array} indices Indices declaring faces of geometry
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} texutureCoords Texture coordinates of all points on the geometry
 * 
 */
GeometryHelper.subdivide = function subdivide(indices, vertices, textureCoords) {
    var triangleIndex = indices.length / 3,
        abc,
        face,
        i, j, k, pos, tex;

    while (triangleIndex--) {
        face = indices.slice(triangleIndex * 3, triangleIndex * 3 + 3);

        pos = face.map(function(vertIndex) {
            return new Vec3(vertices[vertIndex * 3], vertices[vertIndex * 3 + 1], vertices[vertIndex * 3 + 2]);
        });
        vertices.push.apply(vertices, Vec3.scale(Vec3.add(pos[0], pos[1], outputs[0]), 0.5, outputs[1]).toArray());
        vertices.push.apply(vertices, Vec3.scale(Vec3.add(pos[1], pos[2], outputs[0]), 0.5, outputs[1]).toArray());
        vertices.push.apply(vertices, Vec3.scale(Vec3.add(pos[0], pos[2], outputs[0]), 0.5, outputs[1]).toArray());

        if (textureCoords) {
            tex = face.map(function(vertIndex) {
                return new Vec2(textureCoords[vertIndex * 2], textureCoords[vertIndex * 2 + 1]);
            });
            textureCoords.push.apply(textureCoords, Vec2.scale(Vec2.add(tex[0], tex[1], outputs[3]), 0.5, outputs[4]).toArray());
            textureCoords.push.apply(textureCoords, Vec2.scale(Vec2.add(tex[1], tex[2], outputs[3]), 0.5, outputs[4]).toArray());
            textureCoords.push.apply(textureCoords, Vec2.scale(Vec2.add(tex[0], tex[2], outputs[3]), 0.5, outputs[4]).toArray());
        }

        i = vertices.length - 3, j = i + 1, k = i + 2;
        indices.push(i, j, k);
        indices.push(face[0], i, k);
        indices.push(i, face[1], j);
        indices[triangleIndex] = k;
        indices[triangleIndex + 1] = j;
        indices[triangleIndex + 2] = face[2];
    }
};

/**
 * Creates duplicate of vertices that are shared between faces.
 * Alters the input vertex and index arrays.
 *
 * @static
 * @method getUniqueFaces
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} indices Indices declaring faces of geometry
 * 
 */
GeometryHelper.getUniqueFaces = function getUniqueFaces(vertices, indices) {
    var triangleIndex = indices.length / 3,
        registered = [],
        index;

    while (triangleIndex--) {
        for (var i = 0; i < 3; i++) {

            index = indices[triangleIndex * 3 + i];

            if (registered[index]) {
                vertices.push(vertices[index * 3], vertices[index * 3 + 1], vertices[index * 3 + 2]);
                indices[triangleIndex * 3 + i] = vertices.length / 3 - 1;
            } else {
                registered[index] = true;
            }
        }
    }
};

/**
 * Divides all inserted triangles into four sub-triangles while maintaining
 * a radius of one. Alters the passed in arrays.
 *
 * @static
 * @method subdivide
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} indices Indices declaring faces of geometry
 * 
 */
GeometryHelper.subdivideSpheroid = function subdivideSpheroid(vertices, indices) {
    var triangleIndex = indices.length / 3,
        abc,
        face,
        i, j, k;

    while (triangleIndex--) {
        face = indices.slice(triangleIndex * 3, triangleIndex * 3 + 3);
        abc = face.map(function(vertIndex) {
            return new Vec3(vertices[vertIndex * 3], vertices[vertIndex * 3 + 1], vertices[vertIndex * 3 + 2]);
        });

        vertices.push.apply(vertices, Vec3.normalize(Vec3.add(abc[0], abc[1], outputs[0]), outputs[1]).toArray());
        vertices.push.apply(vertices, Vec3.normalize(Vec3.add(abc[1], abc[2], outputs[0]), outputs[1]).toArray());
        vertices.push.apply(vertices, Vec3.normalize(Vec3.add(abc[0], abc[2], outputs[0]), outputs[1]).toArray());

        i = vertices.length / 3 - 3, j = i + 1, k = i + 2;

        indices.push(i, j, k);
        indices.push(face[0], i, k);
        indices.push(i, face[1], j);
        indices[triangleIndex * 3] = k;
        indices[triangleIndex * 3 + 1] = j;
        indices[triangleIndex * 3 + 2] = face[2];
    }
};

/**
 * Divides all inserted triangles into four sub-triangles while maintaining
 * a radius of one. Alters the passed in arrays.
 *
 * @static
 * @method getSpheroidNormals
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} out Optional array to be filled with resulting normals.
 * 
 * @return {Array} new list of calculated normals.
 */
GeometryHelper.getSpheroidNormals = function getSpheroidNormals(vertices, out) {
    var out = out || [];
    var length = vertices.length / 3;
    var normalized;

    for(var i = 0; i < length; i++) {
        normalized = new Vec3(
            vertices[i * 3 + 0],
            vertices[i * 3 + 1],
            vertices[i * 3 + 2]
        ).normalize().toArray();

        out[i * 3 + 0] = normalized[0];
        out[i * 3 + 1] = normalized[1];
        out[i * 3 + 2] = normalized[2];
    }

    return out;
};

/**
 * Calculates texture coordinates for spheroid primitives based on
 * input vertices.
 *
 * @static
 * @method getSpheroidUV
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} out Optional array to be filled with resulting texture coordinates.
 * 
 * @return {Array} new list of calculated texture coordinates
 */
GeometryHelper.getSpheroidUV = function getSpheroidUV(vertices, out) {
    var out = out || [];
    var length = vertices.length / 3;
    var vertex;

    var uv = [];

    for(var i = 0; i < length; i++) {
        vertex = outputs[0].set(
            vertices[i * 3],
            vertices[i * 3 + 1],
            vertices[i * 3 + 2]
        )
        .normalize()
        .toArray();

        uv[0] = this.getAzimuth(vertex) * 0.5 / Math.PI + 0.5;
        uv[1] = this.getAltitude(vertex) / Math.PI + 0.5;

        out.push.apply(out, uv);
    }

    return out;
};

/**
 * Iterates through and normalizes a list of vertices.
 *
 * @static
 * @method normalizeAll
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} out Optional array to be filled with resulting normalized vectors.
 * 
 * @return {Array} new list of normalized vertices
 */
GeometryHelper.normalizeAll = function normalizeAll(vertices, out) {
    var out = out || [];
    var vertex;
    var len = vertices.length / 3;

    for (var i = 0; i < len; i++) {
        Array.prototype.push.apply(out, new Vec3(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]).normalize().toArray());
    }

    return out;
};

/**
 * Normalizes a set of vertices to model space.
 *
 * @static
 * @method normalizeVertices
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} out Optional array to be filled with model space position vectors.
 * 
 * @return {Array} Output vertices.
 */
GeometryHelper.normalizeVertices = function normalizeVertices(vertices, out) {
    var out = out || [];
    var len = vertices.length / 3;
    var vectors = [];
    var minX;
    var maxX;
    var minY;
    var maxY;
    var minZ;
    var maxZ;
    var v;

    for (var i = 0; i < len; i++) {
        v = vectors[i] = new Vec3(
            vertices[i * 3],
            vertices[i * 3 + 1],
            vertices[i * 3 + 2]
        );

        if (minX == null || v.x < minX) minX = v.x;
        if (maxX == null || v.x > maxX) maxX = v.x;

        if (minY == null || v.y < minY) minY = v.y;
        if (maxY == null || v.y > maxY) maxY = v.y;

        if (minZ == null || v.z < minZ) minZ = v.z;
        if (maxZ == null || v.z > maxZ) maxZ = v.z;
    };

    var translation = new Vec3(
        getTranslationFactor(maxX, minX),
        getTranslationFactor(maxY, minY),
        getTranslationFactor(maxZ, minZ)
    );

    var scale = Math.min(
        getScaleFactor(maxX + translation.x, minX + translation.x),
        getScaleFactor(maxY + translation.y, minY + translation.y),
        getScaleFactor(maxZ + translation.z, minZ + translation.z)
    );

    for (var i = 0; i < vectors.length; i++) {
        out.push.apply(out, vectors[i].add(translation).scale(scale).toArray());
    }

    return out;
};

/**
 * Determines translation amount for a given axis to normalize model coordinates.
 *
 * @method getTranslationFactor
 * @private
 *
 * @param {Number} max Maximum position value of given axis on the model.
 * @param {Number} min Minimum position value of given axis on the model.
 *
 * @return {Number} Number by which the given axis should be translated for all vertices.
 */
function getTranslationFactor(max, min) {
    return -(min + (max - min) / 2);
}

/**
 * Determines scale amount for a given axis to normalize model coordinates.
 *
 * @method getScaleFactor
 * @private
 *
 * @param {Number} max Maximum scale value of given axis on the model.
 * @param {Number} min Minimum scale value of given axis on the model.
 *
 * @return {Number} Number by which the given axis should be scaled for all vertices.
 */
function getScaleFactor(max, min) {
    return 1 / ((max - min) / 2);
}

/**
 * Finds the azimuth, or angle above the XY plane, of a given vector.
 *
 * @static
 * @method getAzimuth
 *
 * @param {Array} v Vertex to retreive azimuth from.
 * 
 * @return {Number} Azimuth value in radians. 
 */
GeometryHelper.getAzimuth = function azimuth(v) {
    return Math.atan2(v[2], -v[0]);
};

/**
 * Finds the altitude, or angle above the XZ plane, of a given vector.
 *
 * @static
 * @method getAltitude
 *
 * @param {Array} v Vertex to retreive altitude from.
 * 
 * @return {Number} Altitude value in radians. 
 */
GeometryHelper.getAltitude = function altitude(v) {
    return Math.atan2(-v[1], Math.sqrt((v[0] * v[0]) + (v[2] * v[2])));
};

/**
 * Converts a list of indices from 'triangle' to 'line' format.
 *
 * @static
 * @method trianglesToLines
 *
 * @param {Array} indices Indices of all faces on the geometry
 * 
 * @return {Array} new list of line-formatted indices
 */
GeometryHelper.trianglesToLines = function triangleToLines(indices, out) {
    var out = [];
    var face;
    var j;
    var i;

    for (i = 0; i < indices.length; i++) {
        out.push(indices[i][0], indices[i][1]);
        out.push(indices[i][1], indices[i][2]);
        out.push(indices[i][2], indices[i][0]);
    }

    return out;
};

module.exports = GeometryHelper;

},{"famous-math":208}],228:[function(require,module,exports){
var loadURL        = require('famous-utilities').loadURL;
var GeometryHelper = require('./GeometryHelper');

/*
 * A singleton object that takes that makes requests
 * for OBJ files and returns the formatted data as
 * an argument to a callback function.
 *
 * @static
 * @class OBJLoader
 */

var OBJLoader = {
    cached: {},
    requests: {}
};

/*
 * Takes a path to desired obj file and makes an XMLHttp request
 * if the resource is not cached. Sets up the 'onresponse' function
 * as a callback for formatting and callback invocation.
 *
 * @method load
 *
 * @param {String} url URL of desired obj
 * @param {Function} cb Function to be fired upon successful formatting of obj
 * @param {Object} options Options hash to that can affect the output of the OBJ
 * vertices.
 */
OBJLoader.load = function load(url, cb, options) {
    if (! this.cached[url]) {
        if(! this.requests[url]) {
            this.requests[url] = [cb];
            loadURL(
                url,
                this._onsuccess.bind(
                    this,
                    url,
                    options
                )
            );
        } else {
            this.requests[url].push(cb);
        }
    } else {
        cb(this.cached[url]);
    }
};

/*
 * Fired on response from server for OBJ asset.  Formats the
 * returned string and stores the buffer data in cache.
 * Invokes all queued callbacks before clearing them.
 *
 * @method _onsuccess
 * @private
 *
 * @param {String} URL of requested obj
 * @param {Boolean} value determining whether or not to manually calculate normals
 * @param {String} content of the server response
 */
OBJLoader._onsuccess = function _onsuccess(url, options, text) {
    var buffers = format.call(this, text, options || {});
    this.cached[url] = buffers;

    for (var i = 0; i < this.requests[url].length; i++) {
        this.requests[url][i](buffers);
    }

    this.requests[url] = null;
};

/*
 * Takes raw string format of obj and converts it to a javascript
 * object representing the buffers needed to draw the geometry.
 *
 * @method format
 * @private
 *
 * @param {String} raw obj data in text format
 * @param {Boolean} value determining whether or not to manually calculate normals
 *
 * @return {Object} vertex buffer data
 */
function format(text, options) {
    var text = sanitize(text);

    var lines = text.split('\n');

    var faceTexCoords = [];
    var faceVertices = [];
    var faceNormals = [];

    var normals = [];
    var texCoords = [];
    var vertices = [];

    var i1, i2, i3, i4;
    var split;
    var line;

    var length = lines.length;

    for (var i = 0; i < length; i++) {
        line = lines[i];
        split = lines[i].split(' ');

        // Handle vertex positions

        if (line.indexOf('v ') !== -1) {
            vertices.push([
                parseFloat(split[1]),
                parseFloat(split[2]),
                parseFloat(split[3])
            ]);
        }

        // Handle texture coordinates

        else if(line.indexOf('vt ') !== -1) {
            texCoords.push([
                parseFloat(split[1]),
                parseFloat(split[2])
            ]);
        }

        // Handle vertex normals

        else if (line.indexOf('vn ') !== -1) {
            normals.push([
                parseFloat(split[1]),
                parseFloat(split[2]),
                parseFloat(split[3])
            ]);
        }

        // Handle face

        else if (line.indexOf('f ') !== -1) {

            // Vertex, Normal

            if (split[1].indexOf('//') !== -1) {
                i1 = split[1].split('//');
                i2 = split[2].split('//');
                i3 = split[3].split('//');

                faceVertices.push([
                    parseFloat(i1[0]) - 1,
                    parseFloat(i2[0]) - 1,
                    parseFloat(i3[0]) - 1
                ]);
                faceNormals.push([
                    parseFloat(i1[1]) - 1,
                    parseFloat(i2[1]) - 1,
                    parseFloat(i3[1]) - 1
                ]);

                // Handle quad

                if (split[4]) {
                    i4 = split[4].split('//');
                    faceVertices.push([
                        parseFloat(i1[0]) - 1,
                        parseFloat(i3[0]) - 1,
                        parseFloat(i4[0]) - 1
                    ]);
                    faceNormals.push([
                        parseFloat(i1[2]) - 1,
                        parseFloat(i3[2]) - 1,
                        parseFloat(i4[2]) - 1
                    ]);
                }
            }

            // Vertex, TexCoord, Normal

            else if (split[1].indexOf('/') !== -1) {
                i1 = split[1].split('/');
                i2 = split[2].split('/');
                i3 = split[3].split('/');

                faceVertices.push([
                    parseFloat(i1[0]) - 1,
                    parseFloat(i2[0]) - 1,
                    parseFloat(i3[0]) - 1
                ]);
                faceTexCoords.push([
                    parseFloat(i1[1]) - 1,
                    parseFloat(i2[1]) - 1,
                    parseFloat(i3[1]) - 1
                ]);
                faceNormals.push([
                    parseFloat(i1[2]) - 1,
                    parseFloat(i2[2]) - 1,
                    parseFloat(i3[2]) - 1
                ]);

                // Handle Quad

                if (split[4]) {
                    i4 = split[4].split('/');

                    faceVertices.push([
                        parseFloat(i1[0]) - 1,
                        parseFloat(i3[0]) - 1,
                        parseFloat(i4[0]) - 1
                    ]);
                    faceTexCoords.push([
                        parseFloat(i1[1]) - 1,
                        parseFloat(i3[1]) - 1,
                        parseFloat(i4[1]) - 1
                    ]);
                    faceNormals.push([
                        parseFloat(i1[2]) - 1,
                        parseFloat(i3[2]) - 1,
                        parseFloat(i4[2]) - 1
                    ]);
                }
            }

            // Vertex

            else {
                faceVertices.push([
                    parseFloat(split[1]) - 1,
                    parseFloat(split[2]) - 1,
                    parseFloat(split[3]) - 1
                ]);
                faceTexCoords.push([
                    parseFloat(split[1]) - 1,
                    parseFloat(split[2]) - 1,
                    parseFloat(split[3]) - 1
                ]);
                faceNormals.push([
                    parseFloat(split[1]) - 1,
                    parseFloat(split[2]) - 1,
                    parseFloat(split[3]) - 1
                ]);

                // Handle Quad

                if (split[4]) {
                    faceVertices.push([
                        parseFloat(split[1]) - 1,
                        parseFloat(split[3]) - 1,
                        parseFloat(split[4]) - 1
                    ]);
                    faceTexCoords.push([
                        parseFloat(split[1]) - 1,
                        parseFloat(split[3]) - 1,
                        parseFloat(split[4]) - 1
                    ]);
                    faceNormals.push([
                        parseFloat(split[1]) - 1,
                        parseFloat(split[3]) - 1,
                        parseFloat(split[4]) - 1
                    ]);
                }
            }
        }
    }

    var cached = cacheVertices(
        vertices,
        normals,
        texCoords,
        faceVertices,
        faceNormals,
        faceTexCoords
    );


    cached.vertices = flatten(cached.vertices);
    cached.normals = flatten(cached.normals);
    cached.texCoords = flatten(cached.texCoords);
    cached.indices = flatten(cached.indices);

    if (options.normalize) {
        cached.vertices = GeometryHelper.normalizeVertices(
            cached.vertices
        );
    }

    if (options.computeNormals) {
        cached.normals = GeometryHelper.computeNormals(
            cached.vertices,
            cached.indices
        );
    }

    return {
        vertices: cached.vertices,
        normals: cached.normals,
        textureCoords: cached.texCoords,
        indices: cached.indices
    };
};

/*
 * Replaces all double spaces with single spaces and removes
 * all trailing spaces from lines of a given string.
 *
 * @method sanitize
 * @private
 *
 * @param {String} text String to be sanitized.
 *
 * @return {String} sanitized string.
 */
function sanitize(text) {
    return text.replace(/ +(?= )/g,'').replace(/\s+$/g, '');
}

/*
 * Takes a given pool of attributes and face definitions
 * and removes all duplicate vertices.
 *
 * @method cacheVertices
 * @private
 *
 * @param {Array} v Pool of vertices used in face declarations.
 * @param {Array} n Pool of normals used in face declarations.
 * @param {Array} t Pool of textureCoords used in face declarations.
 * @param {Array} fv Vertex positions at each face in the OBJ.
 * @param {Array} fn Normals at each face in the OBJ.
 * @param {Array} ft Texture coordinates at each face in the OBJ.
 *
 * @return {Object} Object containing the vertices, textureCoordinates and
 * normals of the OBJ.
 */
function cacheVertices(v, n, t, fv, fn, ft) {
    var outNormals = [];
    var outPos = [];
    var outTexCoord = [];
    var outIndices = [];

    var vertexCache = {};

    var positionIndex;
    var normalIndex;
    var texCoordIndex;

    var currentIndex = 0;
    var fvLength = fv.length;
    var fnLength = fn.length;
    var ftLength = ft.length;
    var faceLength;
    var index;

    for (var i = 0; i < fvLength; i++) {
        outIndices[i] = [];
        faceLength = fv[i].length;

        for (var j = 0; j < faceLength; j++) {
            if (ftLength) texCoordIndex = ft[i][j];
            if (fnLength) normalIndex   = fn[i][j];
                          positionIndex = fv[i][j];

            index = vertexCache[positionIndex + ',' + normalIndex + ',' + texCoordIndex];

            if(index === undefined) {
                index = currentIndex++;

                              outPos.push(v[positionIndex]);
                if (fnLength) outNormals.push(n[normalIndex]);
                if (ftLength) outTexCoord.push(t[texCoordIndex]);

                vertexCache[positionIndex + ',' + normalIndex + ',' + texCoordIndex] = index;
            }

            outIndices[i].push(index);
        }
    }

    return {
        vertices: outPos,
        normals: outNormals,
        texCoords: outTexCoord,
        indices: outIndices
    }
}

/*
 * Flattens an array of arrays. Not recursive. Assumes
 * all children are arrays.
 *
 * @method flatten
 * @private
 *
 * @param {Array} arr Input array to be flattened.
 *
 * @return {Array} Flattened version of input array.
 */
function flatten(arr) {
    var len = arr.length;
    var out = [];

    for (var i = 0; i < len; i++) {
        out.push.apply(out, arr[i]);
    }

    return out;
}

module.exports = OBJLoader;

},{"./GeometryHelper":227,"famous-utilities":221}],229:[function(require,module,exports){
'use strict';

module.exports = {
    Box: require('./primitives/Box'),
    Circle: require('./primitives/Circle'),
    Cylinder: require('./primitives/Cylinder'),
    GeodesicSphere: require('./primitives/GeodesicSphere'),
    Icosahedron: require('./primitives/Icosahedron'),
    ParametricCone: require('./primitives/ParametricCone'),
    Plane: require('./primitives/Plane'),
    Sphere: require('./primitives/Sphere'),
    Tetrahedron: require('./primitives/Tetrahedron'),
    Torus: require('./primitives/Torus'),
    Triangle: require('./primitives/Triangle'),
    GeometryHelper: require('./GeometryHelper'),
    DynamicGeometry: require('./DynamicGeometry'),
    Geometry: require('./Geometry'),
    OBJLoader: require('./OBJLoader'),
};
},{"./DynamicGeometry":225,"./Geometry":226,"./GeometryHelper":227,"./OBJLoader":228,"./primitives/Box":230,"./primitives/Circle":231,"./primitives/Cylinder":232,"./primitives/GeodesicSphere":233,"./primitives/Icosahedron":234,"./primitives/ParametricCone":235,"./primitives/Plane":236,"./primitives/Sphere":237,"./primitives/Tetrahedron":238,"./primitives/Torus":239,"./primitives/Triangle":240}],230:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');

function pickOctant(i) {
    return [(i & 1) * 2 - 1, (i & 2) - 1, (i & 4) / 2 - 1];
}

var boxData = [
    [0, 4, 2, 6, -1, 0, 0], 
    [1, 3, 5, 7, +1, 0, 0],
    [0, 1, 4, 5, 0, -1, 0],
    [2, 6, 3, 7, 0, +1, 0],
    [0, 2, 1, 3, 0, 0, -1],
    [4, 5, 6, 7, 0, 0, +1]
];

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class BoxGeometry
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function BoxGeometry(options) {
    var options = options || {};

    var vertices      = [];
    var textureCoords = [];
    var normals       = [];
    var indices       = [];

    var data;
    var d;
    var v;
    var i;
    var j;

    for (i = 0; i < boxData.length; i++) {
        data = boxData[i], v = i * 4;
        for (j = 0; j < 4; j++) {
            d = data[j];
            var octant = pickOctant(d);
            vertices.push(octant[0], octant[1], octant[2]);
            textureCoords.push(j & 1, (j & 2) / 2);
            normals.push(data[4], data[5], data[6]);
        }
        indices.push(v, v + 1, v + 2);
        indices.push(v + 2, v + 1, v + 3);
    }

    return new Geometry({
        buffers: [
            { name: 'pos', data: vertices },
            { name: 'texCoord', data: textureCoords, size: 2 },
            { name: 'normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
};

module.exports = BoxGeometry;

},{"../Geometry":226}],231:[function(require,module,exports){
'use strict';

var Geometry       = require('../Geometry');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Circle
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Circle (options) {
    var options  = options || {};
    var detail   = options.detail || 30;
    var buffers  = getBuffers(detail);

    return new Geometry({
        type: 'TRIANGLE_FAN',
        buffers: [
            { name: 'pos', data: buffers.vertices },
            { name: 'texCoord', data: buffers.textureCoords, size: 2 },
            { name: 'normals', data: buffers.normals }
        ]
    });
}
    
/**
 * Calculates and returns all vertex positions, texture
 * coordinates and normals of the circle primitive.
 *
 * @method getBuffers
 *
 * @param {Number} detail Amount of detail that determines how many
 * vertices are created and where they are placed
 * 
 * @return {Object} constructed geometry
 */
function getBuffers(detail) {
    var theta = 0;
    var x;
    var y;
    var index = detail + 1;
    var nextTheta;
    var vertices      = [0, 0, 0];
    var normals       = [0, 0, 1];
    var textureCoords = [0.5, 0.5];

    while (index--) {
        theta = index / detail * Math.PI * 2;

        x = Math.cos(theta), y = Math.sin(theta);
        vertices.unshift(x, y, 0);
        normals.unshift(0, 0, 1);
        textureCoords.unshift(0.5 + x * 0.5, 0.5 + -y * 0.5);
    }

    return {
        vertices: vertices,
        normals: normals,
        textureCoords: textureCoords
    };
}

module.exports = Circle;

},{"../Geometry":226}],232:[function(require,module,exports){
'use strict';

var Geometry       = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This class creates a new geometry instance and sets
 * its vertex positions, texture coordinates, normals,
 * and indices to based on the primitive.
 *
 * @class Cylinder
 * @constructor
 * 
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 *
 * @return {Object} constructed geometry
 */
function Cylinder (options) {
    var options  = options || {};
    var radius   = options.radius || 1;
    var detail   = options.detail || 15;
    var buffers;

    buffers = GeometryHelper.generateParametric(
        1,
        detail,
        Cylinder.generator.bind(null, radius)
    );

    return new Geometry({
        buffers: [
            { name: 'pos', data: buffers.vertices },
            { name: 'texCoord', data: GeometryHelper.getSpheroidUV(buffers.vertices), size: 2 },
            { name: 'normals', data: GeometryHelper.computeNormals(buffers.vertices, buffers.indices) },
            { name: 'indices', data: buffers.indices, size: 1 }
        ]
    });
}

/**
 * Function used in iterative construction of parametric primitive.
 *
 * @static
 * @method generator
 * @param {Number} r Cylinder radius.
 * @param {Number} u Longitudal progress from 0 to PI.
 * @param {Number} v Latitudal progress from 0 to PI.
 *
 * @return {Array} x, y and z coordinate of geometry.
 */
Cylinder.generator = function generator(r, u, v, pos) {
    pos[0] = r * Math.cos(v);
    pos[1] = r * (-1 + u / Math.PI * 2);
    pos[2] = r * Math.sin(v);
}

module.exports = Cylinder;

},{"../Geometry":226,"../GeometryHelper":227}],233:[function(require,module,exports){
'use strict';

var Geometry       = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class GeodesicSphere
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function GeodesicSphere (options) {
    var t = (1 + Math.sqrt(5)) * 0.5;

    var vertices = [
        - 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
         0, - 1, -t,    0,  1, -t,    0, - 1,   t,    0,  1,   t,
         t,  0,   1,    t,  0, -1,   - t,  0,   1,   - t,  0, -1
    ];
    var indices = [
        0,  5, 11,    0,  1,  5,    0,  7,  1,    0, 10,  7,    0, 11, 10,
        1,  9,  5,    5,  4, 11,    11, 2, 10,   10,  6,  7,    7,  8,  1,
        3,  4,  9,    3,  2,  4,    3,  6,  2,    3,  8,  6,    3,  9,  8,
        4,  5,  9,    2, 11,  4,    6, 10,  2,    8,  7,  6,    9,  1,  8
    ];

    vertices = GeometryHelper.normalizeAll(vertices);

    var options = options || {};
    var detail  = options.detail || 3;

    while(--detail) GeometryHelper.subdivideSpheroid(vertices, indices);
    GeometryHelper.getUniqueFaces(vertices, indices);

    var normals       = GeometryHelper.computeNormals(vertices, indices);
    var textureCoords = GeometryHelper.getSpheroidUV(vertices);

    return new Geometry({
        buffers: [
            { name: 'pos', data: vertices },
            { name: 'texCoord', data: textureCoords, size: 2 },
            { name: 'normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
}

module.exports = GeodesicSphere;

},{"../Geometry":226,"../GeometryHelper":227}],234:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Icosahedron
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Icosahedron() {
    var t = ( 1 + Math.sqrt( 5 ) ) / 2;

    var geometry;
    var detail;
    var vertices = [
        - 1,   t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
          0, - 1, -t,    0,  1, -t,     0, - 1,  t,    0,   1,  t,
          t,   0,  1,    t,  0, -1,   - t,   0,  1,  - t,   0, -1
    ];
    var indices = [
        0,  5, 11,    0,  1,  5,    0,  7,  1,    0, 10,  7,    0, 11, 10,
        1,  9,  5,    5,  4, 11,    11, 2, 10,   10,  6,  7,    7,  8,  1,
        3,  4,  9,    3,  2,  4,    3,  6,  2,    3,  8,  6,    3,  9,  8,
        4,  5,  9,    2, 11,  4,    6, 10,  2,    8,  7,  6,    9,  1,  8
    ];

    GeometryHelper.getUniqueFaces(vertices, indices);

    var normals       = GeometryHelper.computeNormals(vertices, indices);
    var textureCoords = GeometryHelper.getSpheroidUV(vertices);

    vertices      = GeometryHelper.normalizeAll(vertices);

    return new Geometry({
        buffers: [
            { name: 'pos', data: vertices },
            { name: 'texCoord', data: textureCoords, size: 2 },
            { name: 'normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
}

module.exports = Icosahedron;

},{"../Geometry":226,"../GeometryHelper":227}],235:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class ParametricCone
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function ParametricCone (options) {
    var options  = options || {};
    var detail   = options.detail || 15;
    var radius   = options.radius || 1 / Math.PI;

    var buffers = GeometryHelper.generateParametric(
        detail,
        detail,
        ParametricCone.generator.bind(null, radius)
    );

    return new Geometry({
        buffers: [
            { name: 'pos', data: buffers.vertices },
            { name: 'texCoord', data: GeometryHelper.getSpheroidUV(buffers.vertices), size: 2 },
            { name: 'normals', data: GeometryHelper.computeNormals(buffers.vertices, buffers.indices) },
            { name: 'indices', data: buffers.indices, size: 1 }
        ]
    });
}

/**
 * function used in iterative construction of parametric primitive.
 *
 * @static
 * @method generator
 * @param {Number} r Cone Radius.
 * @param {Number} u Longitudal progress from 0 to PI.
 * @param {Number} v Latitudal progress from 0 to PI.
 * @return {Array} x, y and z coordinate of geometry.
 */

ParametricCone.generator = function generator(r, u, v, pos) {
    pos[0] = r * u * Math.sin(v);
    pos[1] = -r * u * Math.cos(v);
    pos[2] = -u;
}

module.exports = ParametricCone;

},{"../Geometry":226,"../GeometryHelper":227}],236:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Plane
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Plane(options) {
    var options = options || {};
    var detailX = options.detailX || options.detail || 1;
    var detailY = options.detailY || options.detail || 1;

    var vertices      = [];
    var textureCoords = [];
    var normals       = [];
    var indices       = [];

    for (var y = 0; y <= detailY; y++) {
        var t = y / detailY;
        for (var x = 0; x <= detailX; x++) {
            var s = x / detailX;
            vertices.push(2. * (s - .5), 2 * (t - .5), 0);
            textureCoords.push(s, 1 - t);
            normals.push(0, 0, 1);
            if (x < detailX && y < detailY) {
                var i = x + y * (detailX + 1);
                indices.push(i, i + 1, i + detailX + 1);
                indices.push(i + detailX + 1, i + 1, i + detailX + 2);
            }
        }
    }
    
    return new Geometry({
        buffers: [
            { name: 'pos', data: vertices },
            { name: 'texCoord', data: textureCoords, size: 2 },
            { name: 'normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
};

module.exports = Plane;

},{"../Geometry":226}],237:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class ParametricSphere
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function ParametricSphere (options) {
    options = options || {};
    var detail = options.detail || 10;
    var detailX = options.detailX || detail;    
    var detailY = options.detailY || detail;

    var buffers = GeometryHelper.generateParametric(
          detailX,
          detailY,
          ParametricSphere.generator
    );

    GeometryHelper.getUniqueFaces(buffers.vertices, buffers.indices);

    return new Geometry({
        buffers: [
            { name: 'pos', data: buffers.vertices },
            { name: 'texCoord', data: GeometryHelper.getSpheroidUV(buffers.vertices), size: 2 },
            { name: 'normals', data: GeometryHelper.getSpheroidNormals(buffers.vertices) },
            { name: 'indices', data: buffers.indices, size: 1 }
        ]
    });
}

/**
 * Function used in iterative construction of parametric primitive.
 *
 * @static
 * @method generator
 * @param {Number} u Longitudal progress from 0 to PI.
 * @param {Number} v Latitudal progress from 0 to PI.
 * @return {Array} x, y and z coordinates of geometry
 */
ParametricSphere.generator = function generator(u, v, pos) {
    var x = Math.sin(u) * Math.cos(v);
    var y = Math.cos(u);
    var z = -Math.sin(u) * Math.sin(v);

    pos[0] = x;
    pos[1] = y;
    pos[2] = z;
};

module.exports = ParametricSphere;

},{"../Geometry":226,"../GeometryHelper":227}],238:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function generates custom buffers and passes them to
 * a new static geometry, which is returned to the user.
 *
 * @class Tetrahedron
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Tetrahedron(options) {
    var textureCoords = [];
    var normals = [];
    var geometry;
    var detail;
    var i;
    var t = Math.sqrt(3);
    
    var vertices = [
        // Back 
         1, -1, -1 / t,
        -1, -1, -1 / t,
         0,  1,  0,
        
        // Right
         0,  1,  0,
         0, -1, t - 1 / t,
         1, -1, -1 / t,

        // Left
         0,  1,  0,
        -1, -1, -1 / t,
         0, -1,  t - 1 / t,

        // Bottom
         0, -1,  t - 1 / t,
        -1, -1, -1 / t,
         1, -1, -1 / t,
    ];

    var indices = [
        0, 1, 2,
        3, 4, 5,
        6, 7, 8,
        9, 10, 11,
    ];

    for (i = 0; i < 4; i++) {
        textureCoords.push(
            0.0, 0.0,
            0.5, 1.0,
            1.0, 0.0
        );
    }

    options       = options || {};

    while(--detail) GeometryHelper.subdivide(indices, vertices, textureCoords);
    normals       = GeometryHelper.computeNormals(vertices, indices);

    return new Geometry({
        buffers: [
            { name: 'pos', data: vertices },
            { name: 'texCoord', data: textureCoords, size: 2 },
            { name: 'normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
}

module.exports = Tetrahedron;

},{"../Geometry":226,"../GeometryHelper":227}],239:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Torus
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */

function Torus(options) {
    var options  = options || {};
    var detail   = options.detail || 30;
    var holeRadius = options.holeRadius || 0.80;
    var tubeRadius = options.tubeRadius || 0.20;

    var buffers = GeometryHelper.generateParametric(
        detail,
        detail,
        Torus.generator.bind(null, holeRadius, tubeRadius)
    );

    return new Geometry({
        buffers: [
            { name: 'pos', data: buffers.vertices },
            { name: 'texCoord', data: GeometryHelper.getSpheroidUV(buffers.vertices), size: 2 },
            { name: 'normals', data: GeometryHelper.computeNormals(buffers.vertices, buffers.indices) },
            { name: 'indices', data: buffers.indices, size: 1 }
        ]
    });
}

/**
 * function used in iterative construction of parametric primitive.
 *
 * @static
 * @method generator
 * @param {Number} c Radius of inner hole.
 * @param {Number} a Radius of tube.
 * @param {Number} u Longitudal progress from 0 to PI.
 * @param {Number} v Latitudal progress from 0 to PI.
 * @return {Array} x, y and z coordinate of the vertex.
 */
Torus.generator = function generator(c, a, u, v, pos) {
    pos[0] = (c + a * Math.cos(2 * v)) * Math.sin(2 * u);
    pos[1] = -(c + a * Math.cos(2 * v)) * Math.cos(2 * u);
    pos[2] = a * Math.sin(2 * v);
}

module.exports = Torus;

},{"../Geometry":226,"../GeometryHelper":227}],240:[function(require,module,exports){
'use strict';

var Geometry       = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Triangle
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Triangle (options) {
    var options  = options || {};
    var detail   = options.detail || 1;
    var normals  = [];
    var textureCoords = [
        0.0, 0.0,
        0.5, 1.0,
        1.0, 0.0
    ];
    var indices  = [
        0, 1, 2
    ];
    var vertices = [
        -1,  1, 0,
         0, -1, 0,
         1,  1, 0
    ];

    while(--detail) GeometryHelper.subdivide(indices, vertices, textureCoords);
    normals       = GeometryHelper.computeNormals(vertices, indices);

    return new Geometry({
        buffers: [
            { name: 'pos', data: vertices },
            { name: 'texCoord', data: textureCoords, size: 2 },
            { name: 'normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
}

module.exports = Triangle;

},{"../Geometry":226,"../GeometryHelper":227}],241:[function(require,module,exports){
module.exports = noop

function noop() {
  throw new Error(
      'You should bundle your code ' +
      'using `glslify` as a transform.'
  )
}

},{}],242:[function(require,module,exports){
module.exports = programify

function programify(vertex, fragment, uniforms, attributes) {
  return {
    vertex: vertex, 
    fragment: fragment,
    uniforms: uniforms, 
    attributes: attributes
  };
}

},{}],243:[function(require,module,exports){
"use strict";
var glslify = require("glslify");
var shaders = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nmat3 a_x_getNormalMatrix(in mat4 t) {\n  mat3 matNorm;\n  mat4 a = t;\n  float a00 = a[0][0], a01 = a[0][1], a02 = a[0][2], a03 = a[0][3], a10 = a[1][0], a11 = a[1][1], a12 = a[1][2], a13 = a[1][3], a20 = a[2][0], a21 = a[2][1], a22 = a[2][2], a23 = a[2][3], a30 = a[3][0], a31 = a[3][1], a32 = a[3][2], a33 = a[3][3], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  det = 1.0 / det;\n  matNorm[0][0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  matNorm[0][1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  matNorm[0][2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  matNorm[1][0] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  matNorm[1][1] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  matNorm[1][2] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  matNorm[2][0] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  matNorm[2][1] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  matNorm[2][2] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return matNorm;\n}\nfloat b_x_inverse(float m) {\n  return 1.0 / m;\n}\nmat2 b_x_inverse(mat2 m) {\n  return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / (m[0][0] * m[1][1] - m[0][1] * m[1][0]);\n}\nmat3 b_x_inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11), b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10), b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\nmat4 b_x_inverse(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3], a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3], a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3], a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  return mat4(a11 * b11 - a12 * b10 + a13 * b09, a02 * b10 - a01 * b11 - a03 * b09, a31 * b05 - a32 * b04 + a33 * b03, a22 * b04 - a21 * b05 - a23 * b03, a12 * b08 - a10 * b11 - a13 * b07, a00 * b11 - a02 * b08 + a03 * b07, a32 * b02 - a30 * b05 - a33 * b01, a20 * b05 - a22 * b02 + a23 * b01, a10 * b10 - a11 * b08 + a13 * b06, a01 * b08 - a00 * b10 - a03 * b06, a30 * b04 - a31 * b02 + a33 * b00, a21 * b02 - a20 * b04 - a23 * b00, a11 * b07 - a10 * b09 - a12 * b06, a00 * b09 - a01 * b07 + a02 * b06, a31 * b01 - a30 * b03 - a32 * b00, a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\nfloat c_x_transpose(float m) {\n  return m;\n}\nmat2 c_x_transpose(mat2 m) {\n  return mat2(m[0][0], m[1][0], m[0][1], m[1][1]);\n}\nmat3 c_x_transpose(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0], m[0][1], m[1][1], m[2][1], m[0][2], m[1][2], m[2][2]);\n}\nmat4 c_x_transpose(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0], m[0][1], m[1][1], m[2][1], m[3][1], m[0][2], m[1][2], m[2][2], m[3][2], m[0][3], m[1][3], m[2][3], m[3][3]);\n}\nvec4 applyTransform(vec4 pos) {\n  mat4 MVMatrix = view * transform;\n  pos.x += 1.0;\n  pos.y -= 1.0;\n  pos.xyz *= size * 0.5;\n  pos.y *= -1.0;\n  v_Position = (MVMatrix * pos).xyz;\n  MVMatrix[0][1] *= -1.0;\n  MVMatrix[1][1] *= -1.0;\n  MVMatrix[2][1] *= -1.0;\n  MVMatrix[3][1] *= -1.0;\n  mat4 MVPMatrix = perspective * MVMatrix;\n  pos = MVPMatrix * pos;\n  pos.x /= (resolution.x * 0.5);\n  pos.y /= (resolution.y * 0.5);\n  pos.x -= 1.0;\n  pos.y += 1.0;\n  pos.z *= -0.00001;\n  return pos;\n}\n#vert_definitions\n\nvec3 calculateOffset(vec3 ID) {\n  \n  #vert_applications\n  return vec3(0.0);\n}\nvoid main() {\n  gl_PointSize = 10.0;\n  vec3 invertedNormals = normals;\n  invertedNormals.y *= -1.0;\n  v_Normal = c_x_transpose(mat3(b_x_inverse(transform))) * invertedNormals;\n  v_TextureCoordinate = texCoord;\n  vec3 offsetPos = pos + calculateOffset(positionOffset);\n  gl_Position = applyTransform(vec4(offsetPos, 1.0));\n}", "\n#define GLSLIFY 1\n\n#float_definitions\n\nfloat a_x_applyMaterial(float ID) {\n  \n  #float_applications\n  return 1.;\n}\n#vec_definitions\n\nvec3 a_x_applyMaterial(vec3 ID) {\n  \n  #vec_applications\n  return vec3(.5);\n}\nvec3 b_x_applyLight(in vec3 material) {\n  int numLights = int(u_NumLights);\n  float lambertianTerm;\n  vec3 finalColor = vec3(0.0);\n  vec3 normal = normalize(v_Normal);\n  vec3 ambientLight = u_AmbientLight * material;\n  vec3 eyeVector = vec3(-v_Position);\n  vec3 diffuse, specular, lightDirection;\n  for(int i = 0; i < 4; i++) {\n    if(i >= numLights)\n      break;\n    diffuse = vec3(0.0, 0.0, 0.0);\n    specular = vec3(0.0, 0.0, 0.0);\n    lightDirection = normalize(u_LightPosition[i].xyz - v_Position);\n    lambertianTerm = dot(lightDirection, normal);\n    if(lambertianTerm > 0.0 && glossiness > 0.0) {\n      diffuse = material * lambertianTerm;\n      vec3 E = normalize(eyeVector);\n      vec3 R = reflect(lightDirection, normal);\n      float specularWeight = pow(max(dot(R, E), 0.0), glossiness);\n      specular = u_LightColor[i].rgb * specularWeight;\n      finalColor += diffuse + specular;\n    } else {\n      lambertianTerm = max(lambertianTerm, 0.0);\n      finalColor += u_LightColor[i].rgb * material * lambertianTerm;\n    }\n  }\n  return ambientLight + finalColor;\n}\nvoid main() {\n  vec3 material = baseColor.r >= 0.0 ? baseColor : a_x_applyMaterial(baseColor);\n  bool lightsEnabled = (u_FlatShading == 0.0) && (u_NumLights > 0.0 || length(u_AmbientLight) > 0.0);\n  vec3 color = lightsEnabled ? b_x_applyLight(material) : material;\n  gl_FragColor = vec4(color, opacity);\n  if(int(baseColor.r) == -1)\n    gl_FragColor = texture2D(image, v_TextureCoordinate);\n  \n}", [], []);
module.exports = shaders;
},{"glslify":241,"glslify/simple-adapter.js":242}],244:[function(require,module,exports){
'use strict';

/**
 * Buffer is a private class that wraps the vertex data that defines
 * the the points of the triangles that webgl draws. Each buffer 
 * maps to one attribute of a mesh.
 * 
 * @class Buffer
 * @constructor
 * 
 * @param {Number} target The bind target of the buffer to update: ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER
 * @param {Object} type Array type to be used in calls to gl.bufferData.
 * @param {WebGLContext} gl The WebGL context that the buffer is hosted by.
 * 
 */
function Buffer(target, type, gl) {
    this.buffer = null;
    this.target = target;
    this.type = type;
    this.data = [];
    this.gl = gl;
}

/**
 * Creates a WebGL buffer if one does not yet exist and binds the buffer to
 * to the context.  Runs bufferData with appropriate data.
 * 
 * @method subData
 * 
 */
Buffer.prototype.subData = function subData() {
    var gl = this.gl;
    var data = [];

    // to prevent against maximum call-stack issue.
    for (var i = 0, chunk = 10000; i < this.data.length; i += chunk)
        data = Array.prototype.concat.apply(data, this.data.slice(i, i + chunk));

    this.buffer = this.buffer || gl.createBuffer();
    gl.bindBuffer(this.target, this.buffer);
    gl.bufferData(this.target, new this.type(data), gl.STATIC_DRAW);
};

module.exports = Buffer;

},{}],245:[function(require,module,exports){
'use strict';

var INDICES = 'indices';

var Buffer = require('./Buffer');

/**
 * BufferRegistry is a class that manages allocation of buffers to
 * input geometries.
 * 
 * @class BufferRegistry
 * @constructor
 * 
 * @param {WebGLContext} context WebGL drawing context to be passed to buffers.
 */
function BufferRegistry(context) {
    this.gl = context;

    this.registry = {};
    this._dynamicBuffers = [];
    this._staticBuffers = [];
    
    this._arrayBufferMax = 30000;
    this._elementBufferMax = 30000;
}

/**
 * Binds and fills all the vertex data into webgl buffers.  Will reuse buffers if
 * possible.  Populates registry with the name of the buffer, the WebGL buffer
 * object, spacing of the attribute, the attribute's offset within the buffer, 
 * and finally the length of the buffer.  This information is later accessed by
 * the root to draw the buffers.
 *
 * @method allocate
 *
 * @param {Number} geometryId Id of the geometry instance that holds the buffers.
 * @param {String} name Key of the input buffer in the geometry.
 * @param {Array} value Flat array containing input data for buffer.
 * @param {Number} spacing The spacing, or itemSize, of the input buffer.
 * @param {Boolean} dynamic Boolean denoting whether a geometry is dynamic or static.
 */
BufferRegistry.prototype.allocate = function allocate(geometryId, name, value, spacing, dynamic) {
    var vertexBuffers = this.registry[geometryId] || (this.registry[geometryId] = { keys: [], values: [], spacing: [], offset: [], length: [] });

    var j = vertexBuffers.keys.indexOf(name);
    var isIndex = name === INDICES;
    var bufferFound = false;
    var newOffset;
    var offset = 0;
    var length;
    var buffer;
    var k;

    if (j === -1) {
        j = vertexBuffers.keys.length;
        length = isIndex ? value.length : Math.floor(value.length / spacing);

        if (dynamic) {

            // Use a previously created buffer if available.

            for (k = 0; k < this._staticBuffers.length; k++) {
                
                if (isIndex === this._staticBuffers[k].isIndex) {
                    newOffset = this._staticBuffers[k].offset + value.length;
                    if ((!isIndex && newOffset < this._arrayBufferMax) || (isIndex && newOffset < this._elementBufferMax)) {
                        buffer = this._staticBuffers[k].buffer;
                        offset = this._staticBuffers[k].offset;
                        this._staticBuffers[k].offset += value.length;
                        bufferFound = true;
                        break;
                    }
                }
            }

            // Create a new static buffer in none were found.

            if (!bufferFound) {
                buffer = new Buffer(
                    isIndex ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER,
                    isIndex ? Uint16Array : Float32Array,
                    this.gl
                );

                this._staticBuffers.push({ buffer: buffer, offset: value.length, isIndex: isIndex });
            }
        }
        else {

            // For dynamic geometries, always create new buffer.

            buffer = new Buffer(
                isIndex ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER,
                isIndex ? Uint16Array : Float32Array,
                this.gl
            );

            this._dynamicBuffers.push({ buffer: buffer, offset: value.length });
        }

        // Update the registry for the spec with buffer information.

        vertexBuffers.keys.push(name);
        vertexBuffers.values.push(buffer);
        vertexBuffers.spacing.push(spacing);
        vertexBuffers.offset.push(offset);
        vertexBuffers.length.push(length);
    }
    
    var len = value.length;
    for (var k = 0; k < len; k++) {
        vertexBuffers.values[j].data[offset + k] = value[k];
    }
    vertexBuffers.values[j].subData();
};

module.exports = BufferRegistry;

},{"./Buffer":244}],246:[function(require,module,exports){
'use strict';

// Generates a checkerboard pattern to be used as a placeholder texture
// while an image loads over the network.

module.exports = (function() {
    var context = document.createElement('canvas').getContext('2d');
    context.canvas.width = context.canvas.height = 128;
    for (var y = 0; y < context.canvas.height; y += 16) {
        for (var x = 0; x < context.canvas.width; x += 16) {
            context.fillStyle = (x ^ y) & 16 ? '#FFF' : '#DDD';
            context.fillRect(x, y, 16, 16);
        }
    }
    
    return context.canvas;
})();

},{}],247:[function(require,module,exports){
'use strict';

var Utility = require('famous-utilities');

var vertexWrapper = require('famous-webgl-shaders').vertex;
var fragmentWrapper = require('famous-webgl-shaders').fragment;

var VERTEX_SHADER = 35633;
var FRAGMENT_SHADER = 35632;

var identityMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

var TYPES = {
    undefined: 'float ',
    1: 'float ',
    2: 'vec2 ',
    3: 'vec3 ',
    4: 'vec4 ',
    16: 'mat4 '
};

var inputTypes = {
    baseColor: 'vec3',
    normal: 'vec3',
    glossiness: 'float',
    metalness: 'float',
    positionOffset: 'vert'
};

var masks =  {
    vert: 1,
    vec3: 2,
    float: 4
};

var uniformNames = [
    'perspective',
    'view',
    'resolution',
    'transform',
    'size',
    'time',
    'opacity',
    'metalness',
    'glossiness',
    'baseColor',
    'normal',
    'positionOffset',
    'u_LightPosition',
    'u_LightColor',
    'u_AmbientLight',
    'u_FlatShading',
    'u_NumLights'
];

var uniformValues = [
    identityMatrix,
    identityMatrix,
    [0, 0, 0],
    identityMatrix,
    [1, 1, 1],
    0,
    1,
    0,
    0,
    [1, 1, 1],
    [1, 1, 1],
    [0, 0, 0],
    identityMatrix,
    identityMatrix,
    [0, 0, 0],
    0,
    0
];

var attributeNames = ['pos', 'texCoord', 'normals'];
var attributeValues = [3, 2, 3, 1];

var varyingNames = ['v_TextureCoordinate', 'v_Normal', 'v_Position'];
var varyingValues = [2, 3, 3];

var header = 'precision mediump float;\n';

/**
 * A class that handles interactions with the WebGL shader program
 * used by a specific context.  It manages creation of the shader program
 * and the attached vertex and fragment shaders.  It is also in charge of
 * passing all uniforms to the WebGLContext.
 *
 * @class Program
 * @constructor
 *
 * @param {WebGL_Context} gl Context to be used to create the shader program.
 */

function Program(gl) {
    this.gl = gl;
    this.textureSlots = 1;

    this.registeredMaterials = {};
    this.flaggedUniforms = [];
    this.cachedUniforms  = {};

    this.definitionVec = [];
    this.definitionFloat = [];
    this.applicationVec = [];
    this.applicationFloat = [];
    this.applicationVert = [];
    this.definitionVert = [];

    this.resetProgram();
}

/**
 * Determines whether a material has already been registered to
 * the shader program.
 *
 * @method registerMaterial
 *
 * @param {String} name Name of target input of material.
 * @param {Object} material Compiled material object being verified.
 *
 * @return {Object} Current program.
 */

Program.prototype.registerMaterial = function registerMaterial(name, material) {
    var compiled = material;
    var type = inputTypes[name];
    var mask = masks[type];

    if ((this.registeredMaterials[material._id] & mask) === mask) return;

    for (var k in compiled.uniforms) {
        if (uniformNames.indexOf(k) === -1) {
            uniformNames.push(k);
            uniformValues.push(compiled.uniforms[k]);
        }
    }

    for (var k in compiled.varyings) {
        if (varyingNames.indexOf(k) === -1) {
            varyingNames.push(k);
            varyingValues.push(compiled.varyings[k].length);
        }
    }

    for (var k in compiled.attributes) {
        if (attributeNames.indexOf(k) === -1) {
            attributeNames.push(k);
            attributeValues.push(compiled.attributes[k].length);
        }
    }

    this.registeredMaterials[material._id] |= mask;

    if (type == 'float') {
        this.definitionFloat.push(material.defines);
        this.definitionFloat.push('float fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationFloat.push('if (int(abs(ID)) == ' + material._id + ') return fa_' + material._id  + '();');
    }

    if (type == 'vec3') {
        this.definitionVec.push(material.defines);
        this.definitionVec.push('vec3 fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationVec.push('if (int(abs(ID.x)) == ' + material._id + ') return fa_' + material._id + '();');
    }

    if (type == 'vert') {
        this.definitionVert.push(material.defines);
        this.definitionVert.push('vec3 fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationVert.push('if (int(abs(ID.x)) == ' + material._id + ') return fa_' + material._id + '();');
    }

    return this.resetProgram();
};

/**
 * Clears all cached uniforms and attribute locations.  Assembles
 * new fragment and vertex shaders and based on material from
 * currently registered materials.  Attaches said shaders to new
 * shader program and upon success links program to the WebGL
 * context.
 *
 * @method resetProgram
 *
 * @return {Program} Current program.
 */
Program.prototype.resetProgram = function resetProgram() {
    var vsChunkDefines = [];
    var vsChunkApplies = [];
    var fsChunkDefines = [];
    var fsChunkApplies = [];

    var vertexHeader = [header];
    var fragmentHeader = [header];

    var fragmentSource;
    var vertexSource;
    var material;
    var program;
    var chunk;
    var name;
    var value;
    var i;

    this.uniformLocations   = [];
    this.attributeLocations = {};

    this.attributeNames = Utility.clone(attributeNames);
    this.attributeValues = Utility.clone(attributeValues);

    this.varyingNames = Utility.clone(varyingNames);
    this.varyingValues = Utility.clone(varyingValues);

    this.uniformNames = Utility.clone(uniformNames);
    this.uniformValues = Utility.clone(uniformValues);

    this.flaggedUniforms = [];
    this.cachedUniforms = {};

    fragmentHeader.push('uniform sampler2D image;\n');

    if (this.applicationVert.length > 1) {
        vertexHeader.push('uniform sampler2D image;\n');
    }

    for(i = 0; i < this.uniformNames.length; i++) {
        name = this.uniformNames[i], value = this.uniformValues[i];
        vertexHeader.push('uniform ' + TYPES[value.length] + name + ';\n');
        fragmentHeader.push('uniform ' + TYPES[value.length] + name + ';\n');
    }

    for(i = 0; i < this.attributeNames.length; i++) {
        name = this.attributeNames[i], value = this.attributeValues[i];
        vertexHeader.push('attribute ' + TYPES[value] + name + ';\n');
    }

    for(i = 0; i < this.varyingNames.length; i++) {
        name = this.varyingNames[i], value = this.varyingValues[i];
        vertexHeader.push('varying ' + TYPES[value]  + name + ';\n');
        fragmentHeader.push('varying ' + TYPES[value] + name + ';\n');
    }

    vertexSource = vertexHeader.join('') + vertexWrapper
        .replace('#vert_definitions', this.definitionVert.join('\n'))
        .replace('#vert_applications', this.applicationVert.join('\n'));

    fragmentSource = fragmentHeader.join('') + fragmentWrapper
        .replace('#vec_definitions', this.definitionVec.join('\n'))
        .replace('#vec_applications', this.applicationVec.join('\n'))
        .replace('#float_definitions', this.definitionFloat.join('\n'))
        .replace('#float_applications', this.applicationFloat.join('\n'));

    program = this.gl.createProgram();

    this.gl.attachShader(
        program,
        this.compileShader(this.gl.createShader(VERTEX_SHADER), vertexSource)
    );

    this.gl.attachShader(
        program,
        this.compileShader(this.gl.createShader(FRAGMENT_SHADER), fragmentSource)
    );

    this.gl.linkProgram(program);

    if (! this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
        console.error('link error: ' + this.gl.getProgramInfoLog(program));
        this.program = null;
    }
    else {
        this.program = program;
        this.gl.useProgram(this.program);
    }

    this.setUniforms(this.uniformNames, this.uniformValues);

    return this;
};

/**
 * Compares the value of the input uniform value against
 * the cached value stored on the Program class.  Updates and
 * creates new entries in the cache when necessary.
 *
 * @method uniformIsCached
 *
 * @param {String} targetName Key of uniform spec being evaluated.
 * @param {Number|Array} value Value of uniform spec being evaluated.
 * @return {Boolean} Value indicating whether the uniform being set
 * is cached.
 */
Program.prototype.uniformIsCached = function (targetName, value) {
    if(this.cachedUniforms[targetName] == null) {
        if (value.length) {
            this.cachedUniforms[targetName] = new Float32Array(value);
        }
        else {
            this.cachedUniforms[targetName] = value;
        }
        return false;
    }
    else if (value.length) {
        var i = value.length;
        while (i--) {
            if(value[i] !== this.cachedUniforms[targetName][i]) {
                i = value.length;
                while(i--) this.cachedUniforms[targetName][i] = value[i];
                return false;
            }
        }
    }

    else if (this.cachedUniforms[targetName] !== value) {
        this.cachedUniforms[targetName] = value;
        return false;
    }

    return true;
};

/**
 * Handles all passing of uniforms to WebGL drawing context.  This
 * function will find the uniform location and then, based on
 * a type inferred from the javascript value of the uniform, it will call
 * the appropriate function to pass the uniform to WebGL.  Finally,
 * setUniforms will iterate through the passed in shaderChunks (if any)
 * and set the appropriate uniforms to specify which chunks to use.
 *
 * @method setUniforms
 *
 * @param {Array} uniformNames Array containing the keys of all uniforms to be set.
 * @param {Array} uniformValue Array containing the values of all uniforms to be set.
 *
 * @return {Program} Current program.
 */
Program.prototype.setUniforms = function (uniformNames, uniformValue) {
    var gl = this.gl;
    var location;
    var value;
    var name;
    var flag;
    var len;
    var i;

    if (!this.program) return;

    len = uniformNames.length;
    for (i = 0; i < len; i++) {
        name = uniformNames[i];
        value = uniformValue[i];

        // Retreive the cached location of the uniform,
        // requesting a new location from the WebGL context
        // if it does not yet exist.

        location = this.uniformLocations[name] || gl.getUniformLocation(this.program, name);
        if (!location) continue;

        this.uniformLocations[name] = location;

        // Check if the value is already set for the
        // given uniform.

        if (this.uniformIsCached(name, value)) continue;

        // Determine the correct function and pass the uniform
        // value to WebGL.

        if (Array.isArray(value) || value instanceof Float32Array) {
            switch (value.length) {
                case 4:  gl.uniform4fv(location, value); break;
                case 3:  gl.uniform3fv(location, value); break;
                case 2:  gl.uniform2fv(location, value); break;
                case 16: gl.uniformMatrix4fv(location, false, value); break;
                case 1:  gl.uniform1fv(location, value); break;
                case 9:  gl.uniformMatrix3fv(location, false, value); break;
                default: throw 'cant load uniform "' + name + '" with value:' + JSON.stringify(value);
            }
        }
        else if (! isNaN(parseFloat(value)) && isFinite(value)) {
            gl.uniform1f(location, value);
        }
        else {
            throw 'set uniform "' + name + '" to invalid type :' + value;
        }
    }
    return this;
};

/**
 * Adds shader source to shader and compiles the input shader.  Checks
 * compile status and logs error if necessary.
 *
 * @method compileShader
 *
 * @param {Object} shader Program to be compiled.
 * @param {String} source Source to be used in the shader.
 *
 * @return {Object} Compiled shader.
 */
Program.prototype.compileShader = function compileShader(shader, source) {
    var i = 1;

    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        console.error('compile error: ' + this.gl.getShaderInfoLog(shader));
        console.error('1: ' + source.replace(/\n/g, function () { return '\n' + (i+=1) + ': '; }));
    }

    return shader;
};

module.exports = Program;

},{"famous-utilities":200,"famous-webgl-shaders":243}],248:[function(require,module,exports){
'use strict';

/**
 * Texture is a private class that stores image data
 * to be accessed from a shader or used as a render target.
 *
 * @class Texture
 * @constructor
 */
function Texture(gl, options) {
    options = options || {};
    this.id = gl.createTexture();
    this.width = options.width || 0;
    this.height = options.height || 0;
    this.format = options.format || gl.RGBA;
    this.type = options.type || gl.UNSIGNED_BYTE;
    this.gl = gl;

    this.bind();

    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl[options.magFilter] || gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[options.minFilter] || gl.NEAREST);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl[options.wrapS] || gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl[options.wrapS] || gl.CLAMP_TO_EDGE);

    gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.width, this.height, 0, this.format, this.type, null);

    if (options.mipmap !== false && isPowerOfTwo(this.width, this.height)) {
        gl.generateMipmap(gl.TEXTURE_2D);
    }

    this.unbind();
}

/**
 * Binds this texture as the selected target.
 *
 * @method bind
 * @chainable
 *
 * @param {Number} unit The texture slot in which to upload the data.
 *
 * @return {Object} Current texture instance.
 */
Texture.prototype.bind = function bind(unit) {
    this.gl.activeTexture(this.gl.TEXTURE0 + (unit || 0));
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.id);
    return this;
};

/**
 * Erases the texture data in the given texture slot.
 *
 * @method unbind
 * @chainable
 *
 * @param {Number} unit The texture slot in which to clean the data.
 * 
 * @return {Object} Current texture instance.
 */
Texture.prototype.unbind = function unbind(unit) {
    this.gl.activeTexture(this.gl.TEXTURE0 + (unit || 0));
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    return this;
};

/**
 * Replaces the image data in the texture with the given image.
 *
 * @method setImage
 * @chainable
 *
 * @param {Image} img The image object to upload pixel data from.
 *
 * @return {Object} Current texture instance.
 */
Texture.prototype.setImage = function setImage(img) {
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.id);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.format, this.format, this.type, img);
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    return this;
};

/**
 * Replaces the image data in the texture with an array of arbitrary data.
 *
 * @method setArray
 * @chainable
 *
 * @param {Array} input Array to be set as data to texture. 
 *
 * @return {Object} Current texture instance.
 */
Texture.prototype.setArray = function setArray(input) {
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.id);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.format, 1, 1, 0, this.format, this.type, new Uint8Array(input));
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    return this;
};

/**
 * Dumps the rgb-pixel contents of a texture into an array for debugging purposes
 *
 * @method readBack
 * @chainable
 *
 * @param {Number} x-offset between texture coordinates and snapshot
 * @param {Number} y-offset between texture coordinates and snapshot
 * @param {Number} x-depth of the snapshot
 * @param {Number} y-depth of the snapshot
 * 
 * @return {Array} An array of the pixels contained in the snapshot.
 */
Texture.prototype.readBack = function readBack(x, y, width, height) {
    var gl = this.gl;
    var pixels;
    x = x || 0;
    y = y || 0;
    width = width || this.width;
    height = height || this.height;
    var fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.id, 0);
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE) {
        pixels = new Uint8Array(width * height * 4);
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    }
    return pixels;
};

/*
 * Determines whether both input values are power-of-two numbers.
 *
 * @method isPowerOfTwo
 * @private
 *
 * @param {Number} width Number representing texture width.
 * @param {Number} height Number representing texture height.
 *
 * @return {Boolean} Boolean denoting whether the input dimensions
 * are both power-of-two values.
 */
function isPowerOfTwo(width, height) {
    return (width & width - 1) === 0 
        && (height & height - 1) === 0;
};

module.exports = Texture;

},{}],249:[function(require,module,exports){
'use strict';

var Texture = require('./Texture');
var Program = require('./Program');
var Buffer = require('./Buffer');
var BufferRegistry = require('./BufferRegistry');
var checkers = require('./Checkerboard');
var Plane = require('famous-webgl-geometries').Plane;
var sorter = require('./radixSort');

var identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

/**
 * WebGLRenderer is a private class that manages all interactions with the WebGL
 * API.  Each frame it receives commands from the compositor and updates its registries
 * accordingly.  Subsequently, the draw function is called and the WebGLRenderer
 * issues draw calls for all meshes in its registry.
 *
 * @class WebGLRenderer
 * @constructor
 *
 * @param {DOMElement} canvas The dom element that GL will paint itself onto.
 *
 */
function WebGLRenderer(canvas) {
    this.canvas = canvas;

    var gl = this.gl = this.getWebGLContext(this.canvas);

    gl.polygonOffset(0.1, 0.1);
    gl.enable(gl.POLYGON_OFFSET_FILL);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.depthFunc(gl.LEQUAL);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.enable(gl.CULL_FACE);

    this.meshRegistry = {};
    this.meshRegistryKeys = [];

    this.cutoutRegistry = {};
    this.cutoutRegistryKeys = [];
    this.cutoutGeometry;

    /**
     * Lights
     */

    this.numLights = 0;
    this.ambientLightColor = [0, 0, 0];
    this.lightRegistry = {};
    this.lightRegistryKeys = [];
    this.lightPositions = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    this.lightColors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

    this.textureRegistry = [];
    this.texCache = {};
    this.bufferRegistry = new BufferRegistry(gl);
    this.program = new Program(gl);

    this.state = {
        boundArrayBuffer: null,
        boundElementBuffer: null,
        lastDrawn: null,
        enabledAttributes: {},
        enabledAttributesKeys: []
    };

    this.resolutionName = ['resolution'];
    this.resolutionValues = [];

    this.cachedSize = [];

    this.projectionTransform = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}

/**
 * Attempts to retreive the WebGLRenderer context using several
 * accessors.  For browser compatability.  Throws on error.
 *
 * @method getWebGLContext
 *
 * @param {Object} canvas Canvas element from which the context is retreived.
 *
 * @return {Object} WebGLContext of canvas element.
 */
WebGLRenderer.prototype.getWebGLContext = function getWebGLContext(canvas) {
    var names = ['webgl', 'experimental-webgl', 'webkit-3d', 'moz-webgl'];
    var context = null;
    for (var i = 0; i < names.length; i++) {
        try {
            context = canvas.getContext(names[i]);
        }
        catch (error) {
            var msg = 'Error creating WebGL context: ' + error.toString();
            console.error(msg);
        }
        if (context) {
            break;
        }
    }
    return context ? context : false;
};

/**
 * Adds a new base spec to the light registry at a given path.
 *
 * @method createLight
 *
 * @param {String} Path used as id of new light in lightRegistry.
 *
 * @return {Object} Newly created light spec.
 */
WebGLRenderer.prototype.createLight = function createLight(path) {
    this.numLights++;
    this.lightRegistryKeys.push(path);
    return this.lightRegistry[path] = {
        color: [0, 0, 0],
        position: [0, 0, 0]
    };
};

/**
 * Adds a new base spec to the mesh registry at a given path.
 *
 * @method createMesh
 *
 * @param {String} Path used as id of new mesh in meshRegistry.
 *
 * @return {Object} Newly created mesh spec.
 */
WebGLRenderer.prototype.createMesh = function createMesh(path) {
    this.meshRegistryKeys.push(path);
    return this.meshRegistry[path] = {
        uniformKeys: ['opacity', 'transform', 'size', 'baseColor', 'positionOffset', 'u_FlatShading'],
        uniformValues: [1, identity, [0, 0, 0], [0.5, 0.5, 0.5], [0, 0, 0], 0],
        buffers: {},
        geometry: null,
        drawType: null,
        texture: null
    };
};


/**
 * Creates or retreives cutout
 *
 * @method getOrSetCutout
 *
 * @param {String} Path used as id of new mesh in meshRegistry.
 *
 * @return {Object} Newly created cutout spec.
 */

WebGLRenderer.prototype.getOrSetCutout = function getOrSetCutout(path) {
    var geometry;

    if (this.cutoutRegistry[path]) {
        return this.cutoutRegistry[path];
    }
    else {
        if (!this.cutoutGeometry) {
            geometry = this.cutoutGeometry = Plane();

            this.bufferRegistry.allocate(geometry.id, 'pos', geometry.spec.bufferValues[0], 3);
            this.bufferRegistry.allocate(geometry.id, 'texCoord', geometry.spec.bufferValues[1], 2);
            this.bufferRegistry.allocate(geometry.id, 'normals', geometry.spec.bufferValues[2], 3);
            this.bufferRegistry.allocate(geometry.id, 'indices', geometry.spec.bufferValues[3], 1);
        }

        this.cutoutRegistryKeys.push(path);

        return this.cutoutRegistry[path] = {
            uniformKeys: ['transform', 'size', 'origin', 'baseColor', 'opacity'],
            uniformValues: [identity, [0, 0, 0], [0, 0, 0], [0, 0, 0], 0],
            geometry: this.cutoutGeometry.id,
            drawType: 4
        };
    }

};

/**
 * Creates or retreives cutout
 *
 * @method setCutoutUniform
 *
 * @param {String} Path used as id of cutout in cutout registry.
 * @param {String} uniformLocation identifier used to upload value
 * @param {Array} value of uniform data 
 *
 */

WebGLRenderer.prototype.setCutoutUniform = function setCutoutUniform(path, uniformName, uniformValue) {
    var cutout = this.getOrSetCutout(path);

    var index = cutout.uniformKeys.indexOf(uniformName);

    cutout.uniformValues[index] = uniformValue;
};


/**
 * Edits the options field on a mesh
 *
 * @method setMeshOptions
 *
 * @param {String} Path used as id of cutout in cutout registry.
 * @param {Object} map of draw options for mesh
 *
**/
WebGLRenderer.prototype.setMeshOptions = function(path, options) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    mesh.options = options;
    return this;
};


/**
 * Changes the color of the fixed intensity lighting in the scene
 *
 * @method setAmbientLightColor
 *
 * @param {String} path used as id of light
 * @param {Number} red channel
 * @param {Number} green channel
 * @param {Number} blue channel
 *
**/
WebGLRenderer.prototype.setAmbientLightColor = function setAmbientLightColor(path, r, g, b) {
    this.ambientLightColor[0] = r;
    this.ambientLightColor[1] = g;
    this.ambientLightColor[2] = b;
    return this;
};


/**
 * Changes the location of the light in the scene
 *
 * @method setLightPosition
 *
 * @param {String} path used as id of light
 * @param {Number} x position
 * @param {Number} y position
 * @param {Number} z position
 *
**/
WebGLRenderer.prototype.setLightPosition = function setLightPosition(path, x, y, z) {
    var light = this.lightRegistry[path] || this.createLight(path);

    light.position[0] = x;
    light.position[1] = y;
    light.position[2] = z;
    return this;
};


/**
 * Changes the color of a dynamic intensity lighting in the scene
 *
 * @method setLightColor
 *
 * @param {String} path used as id of light in light Registry.
 * @param {Number} red channel
 * @param {Number} green channel
 * @param {Number} blue channel
 *
**/
WebGLRenderer.prototype.setLightColor = function setLightColor(path, r, g, b) {
    var light = this.lightRegistry[path] || this.createLight(path);

    light.color[0] = r;
    light.color[1] = g;
    light.color[2] = b;
    return this;
};
/**
 * Compiles material spec into program shader
 *
 * @method handleMateriaInput
 *
 * @param {String} Path used as id of cutout in cutout registry.
 * @param {String} which rendering input the material is bound to
 * @param {Object} material spec
 *
**/
WebGLRenderer.prototype.handleMaterialInput = function handleMaterialInput(path, name, material) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    mesh.uniformValues[name === 'baseColor' ? 3 : 4][0] = - material._id;
    if (material.texture) mesh.texture = handleTexture.call(this, material.texture);
    this.program.registerMaterial(name, material);
    return this.updateSize();
};

/**
 * Changes the geometry data of a mesh
 *
 * @method setGeometry
 *
 * @param {String} Path used as id of cutout in cutout registry.
 * @param {Object} Geometry object containing vertex data to be drawn
 * @param {Number} primitive identifier
 * @param {Boolean} will the geometry data change?
 *
**/

WebGLRenderer.prototype.setGeometry = function setGeometry(path, geometry, drawType, dynamic) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    mesh.geometry = geometry;
    mesh.drawType = drawType;
    mesh.dynamic = dynamic;

    return this;
};

/**
 * Uploads a new value for the uniform data when the mesh is being drawn
 *
 * @method setMeshUniform
 *
 * @param {String} Path used as id of mesh in mesh registry
 * @param {String} uniformLocation identifier used to upload value
 * @param {Array} value of uniform data 
 *
**/
WebGLRenderer.prototype.setMeshUniform = function setMeshUniform(path, uniformName, uniformValue) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    var index = mesh.uniformKeys.indexOf(uniformName);

    if (index === -1) {
        mesh.uniformKeys.push(uniformName);
        mesh.uniformValues.push(uniformValue);
    }
    else {
        mesh.uniformValues[index] = uniformValue;
    }
}

/**
 * Triggers the 'draw' phase of the WebGLRenderer.  Iterates through registries
 * to set uniforms, set attributes and issue draw commands for renderables.
 *
 * @method bufferData
 *
 * @param {String} Path used as id of mesh in mesh registry
 * @param {Number} Id of geometry in geometry registry
 * @param {String} Attribute location name
 * @param {Array} Vertex data 
 * @param {Number} The dimensions of the vertex
 */


WebGLRenderer.prototype.bufferData = function bufferData(path, geometryId, bufferName, bufferValue, bufferSpacing) {
    this.bufferRegistry.allocate(geometryId, bufferName, bufferValue, bufferSpacing);

    return this;
};

/**
 * Triggers the 'draw' phase of the WebGLRenderer.  Iterates through registries
 * to set uniforms, set attributes and issue draw commands for renderables.
 *
 * @method draw
 *
 * @param {Object} renderState Parameters provided by the compositor, that
 * affect the rendering of all renderables.
 */
WebGLRenderer.prototype.draw = function draw(renderState) {
    var mesh;
    var buffers;
    var size;
    var light;
    var stride;
    var cutout;

    /**
     * Update lights
     */
    for(var i = 0; i < this.lightRegistryKeys.length; i++) {
        light = this.lightRegistry[this.lightRegistryKeys[i]];
        stride = i * 4;
        // Build the light positions' 4x4 matrix
        this.lightPositions[0 + stride] = light.position[0];
        this.lightPositions[1 + stride] = light.position[1];
        this.lightPositions[2 + stride] = light.position[2];
        // Build the light colors' 4x4 matrix
        this.lightColors[0 + stride] = light.color[0];
        this.lightColors[1 + stride] = light.color[1];
        this.lightColors[2 + stride] = light.color[2];
    }
    this.program.setUniforms(['u_NumLights'], [this.numLights]);
    this.program.setUniforms(['u_AmbientLight'], [this.ambientLightColor]);
    this.program.setUniforms(['u_LightPosition'], [this.lightPositions]);
    this.program.setUniforms(['u_LightColor'], [this.lightColors]);

    this.projectionTransform[11] = renderState.perspectiveTransform[11];

    this.program.setUniforms(['perspective', 'time', 'view'], [this.projectionTransform, Date.now()  % 100000 / 1000, renderState.viewTransform]);
    var keys = this.meshRegistryKeys;
    var registry = this.meshRegistry;

    this.meshRegistryKeys = sorter(keys, registry);

    for (var i = 0, len = this.cutoutRegistryKeys.length; i < len; i++) {
        cutout = this.cutoutRegistry[this.cutoutRegistryKeys[i]];
        buffers = this.bufferRegistry.registry[cutout.geometry];

        this.gl.enable(this.gl.BLEND);
        this.program.setUniforms(cutout.uniformKeys, cutout.uniformValues);
        this.drawBuffers(buffers, cutout.drawType, cutout.geometry);
        this.gl.disable(this.gl.BLEND);
    }

    for(var i = 0; i < this.meshRegistryKeys.length; i++) {
        mesh = this.meshRegistry[this.meshRegistryKeys[i]];
        buffers = this.bufferRegistry.registry[mesh.geometry];

        var gl = this.gl;
        if (mesh.uniformValues[0] < 1) {
            gl.depthMask(false);
            gl.enable(gl.BLEND);
        } else {
            gl.depthMask(true);
            gl.disable(gl.BLEND);
        }

        if (!buffers) continue;

        if (mesh.options) this.handleOptions(mesh.options);
        if (mesh.texture) mesh.texture.bind();

        this.program.setUniforms(mesh.uniformKeys, mesh.uniformValues);
        this.drawBuffers(buffers, mesh.drawType, mesh.geometry);

        if (mesh.texture) mesh.texture.unbind();
        if (mesh.options) this.resetOptions(mesh.options);
    }
};


/**
 * Loads the buffers and issues the draw command for a geometry.
 *
 * @method drawBuffers
 *
 * @param {Object} vertexBuffers All buffers used to draw the geometry.
 * @param {Number} mode Enumerator defining what primitive to draw
 * @param {Number} id ID of geometry being drawn.
 */
WebGLRenderer.prototype.drawBuffers = function drawBuffers(vertexBuffers, mode, id) {
    var gl = this.gl;
    var length = 0;
    var attribute;
    var location;
    var spacing;
    var offset;
    var buffer;
    var iter;
    var j;

    iter = vertexBuffers.keys.length;
    for (var i = 0; i < iter; i++) {
        attribute = vertexBuffers.keys[i];

        // Do not set vertexAttribPointer if index buffer.

        if (attribute === 'indices') {
            j = i; continue;
        }

        // Retreive the attribute location and make sure it is enabled.

        location = this.program.attributeLocations[attribute];

        if (location === -1) continue;
        if (location === undefined) {
            location = gl.getAttribLocation(this.program.program, attribute);
            this.program.attributeLocations[attribute] = location;
            if (location === -1) continue;
        }

        if (!this.state.enabledAttributes[attribute]) {
            gl.enableVertexAttribArray(location);
            this.state.enabledAttributes[attribute] = true;
            this.state.enabledAttributesKeys.push(attribute);
        }

        // Retreive buffer information used to set attribute pointer.

        buffer = vertexBuffers.values[i];
        spacing = vertexBuffers.spacing[i];
        offset = vertexBuffers.offset[i];
        length = vertexBuffers.length[i];

        // Skip bindBuffer if buffer is currently bound.

        if (this.state.boundArrayBuffer !== buffer) {
            gl.bindBuffer(buffer.target, buffer.buffer);
            this.state.boundArrayBuffer = buffer;
        }

        if (this.state.lastDrawn !== id) {
            gl.vertexAttribPointer(location, spacing, gl.FLOAT, gl.FALSE, 0, 4 * offset);
        }
    }

    // Disable any attributes that not currently being used.

    for(var i = 0, len = this.state.enabledAttributesKeys.length; i < len; i++) {
        var key = this.state.enabledAttributes[this.state.enabledAttributesKeys[i]];
        if (this.state.enabledAttributes[key] && vertexBuffers.keys.indexOf(key) === -1) {
            gl.disableVertexAttribArray(this.program.attributeLocations[key]);
            this.state.enabledAttributes[key] = false;
        }
    }

    if (length) {

        // If index buffer, use drawElements.

        if (j !== undefined) {
            buffer = vertexBuffers.values[j];
            offset = vertexBuffers.offset[j];
            spacing = vertexBuffers.spacing[j];
            length = vertexBuffers.length[j];

            // Skip bindBuffer if buffer is currently bound.

            if (this.state.boundElementBuffer !== buffer) {
                gl.bindBuffer(buffer.target, buffer.buffer);
                this.state.boundElementBuffer = buffer;
            }

            gl.drawElements(mode, length, gl.UNSIGNED_SHORT, 2 * offset);
        }
        else {
            gl.drawArrays(mode, 0, length);
        }
    }

    this.state.lastDrawn = id;
};

/**
 * Wraps draw methods in bound frame buffer
 *
 * @method renderOffscreen
 *
 * @param {Function} callback The render function to be called after setup and before cleanup.
 * @param {Array} size Size of framebuffer being drawn to.
 * @param {Object} texture Location where the render data is stored.
 */
function renderOffscreen(callback, size, texture) {
    var gl = this.gl;

    var framebuffer  = this.framebuffer ? this.framebuffer : this.framebuffer = gl.createFramebuffer();
    var renderbuffer = this.renderbuffer ? this.renderbuffer : this.renderbuffer = gl.createRenderbuffer();

    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);

    if (size[0] != renderbuffer.width || size[1] != renderbuffer.height) {
        renderbuffer.width = size[0];
        renderbuffer.height = size[1];
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, size[0], size[1]);
    }

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture.id, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

    if (this.debug) checkFrameBufferStatus(gl);

    callback.call(this);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
};

/**
 * Diagnoses the failed intialization of an FBO.
 *
 * @method checkFrameBufferStatus
 *
 * @param {Object} the WebGLContext that owns this FBO.
 */
function checkFrameBufferStatus(gl) {
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

    switch (status) {
        case gl.FRAMEBUFFER_COMPLETE:
            break;
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT"); break;
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"); break;
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS"); break;
        case gl.FRAMEBUFFER_UNSUPPORTED:
            throw("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED"); break;
        default:
            throw("Incomplete framebuffer: " + status);
    }
};

/**
 * Updates the width and height of parent canvas, sets the viewport size on
 * the WebGL context and updates the resolution uniform for the shader program.
 * Size is retreived from the container object of the renderer.
 *
 * @method updateSize
 * 
 * @param {Array} width, height and depth of canvas
 * 
 */
WebGLRenderer.prototype.updateSize = function updateSize(size) {
    if (size) {
        this.cachedSize[0] = size[0];
        this.cachedSize[1] = size[1];
        this.cachedSize[2] = (size[0] > size[1]) ? size[0] : size[1];
    }

    this.gl.viewport(0, 0, this.cachedSize[0], this.cachedSize[1]);

    this.resolutionValues[0] = this.cachedSize;
    this.program.setUniforms(this.resolutionName, this.resolutionValues);

    return this;
};

/**
 * Updates the state of the WebGL drawing context based on custom parameters
 * defined on a mesh.
 *
 * @method handleOptions
 *
 * @param {Object} options Draw state options to be set to the context.
 */
WebGLRenderer.prototype.handleOptions = function handleOptions(options) {
    var gl = this.gl;
    if (!options) return;
    if (options.blending) gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
};

/**
 * Resets the state of the WebGL drawing context to default values.
 *
 * @method resetOptions
 *
 * @param {Object} options Draw state options to be set to the context.
 */
WebGLRenderer.prototype.resetOptions = function resetOptions(options) {
    var gl = this.gl;
    if (!options) return;
    if (options.blending) gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
};

/**
 * Loads an image from a string or Image object and executes a callback function.
 *
 * @method loadImage
 * @private
 *
 * @param {Object | String} img The input image data to load as an asset.
 * @param {Function} callback The callback function to be fired when
 * the image has finished loading.
 *
 * @return {Object} Image object being loaded.
 */
function loadImage (img, callback) {
    var obj = (typeof img === 'string' ? new Image() : img) || {};
    obj.crossOrigin = 'anonymous';
    if (! obj.src) obj.src = img;
    if (! obj.complete) obj.onload = function () { callback(obj); };
    else callback(obj);
    return obj;
}

/**
 * Handles loading of texture objects.
 *
 * @method handleTexture
 * @private
 *
 * @param {Object} input The input texture object collected from mesh.
 *
 * @return {Object} Texture instance linked to input data.
 */
function handleTexture(input) {
    var source = input.data;
    var textureId = input.id;
    var options = input.options;
    var texture = this.textureRegistry[textureId];

    if (!texture) {
        if (Array.isArray(source)) {
            texture = new Texture(this.gl, options);
            texture.setArray(source);
        }

        else if (window && source instanceof window.HTMLVideoElement) {
            texture = new Texture(this.gl, options);
            texture.src = texture;
            texture.setImage(checkers);
            source.addEventListener('loadeddata', function() {
                texture.setImage(source);
                setInterval(function () { texture.setImage(source); }, 16);
            });
        }

        else if ('string' === typeof source) {
            texture = new Texture(this.gl, options);
            texture.setImage(checkers);
            loadImage(source, function (img) {
                texture.setImage(img);
            });
        }

        this.textureRegistry[textureId] = texture;
    }

    return texture;
}

module.exports = WebGLRenderer;

},{"./Buffer":244,"./BufferRegistry":245,"./Checkerboard":246,"./Program":247,"./Texture":248,"./radixSort":251,"famous-webgl-geometries":229}],250:[function(require,module,exports){
'use strict';

module.exports = {
    Buffer: require('./Buffer'),
    BufferRegistry: require('./BufferRegistry'),
    Checkerboard: require('./Checkerboard'),
    Program: require('./Program'),
    WebGLRenderer: require('./WebGLRenderer'),
    Texture: require('./Texture')
};

},{"./Buffer":244,"./BufferRegistry":245,"./Checkerboard":246,"./Program":247,"./Texture":248,"./WebGLRenderer":249}],251:[function(require,module,exports){
var radixBits = 11,
    maxRadix = 1 << (radixBits),
    radixMask = maxRadix - 1,
    buckets = new Array(maxRadix * Math.ceil(64 / radixBits)),
    msbMask = 1 << ((32 - 1) % radixBits),
    lastMask = (msbMask << 1) - 1,
    passCount = ((32 / radixBits) + 0.999999999999999) | 0,
    maxOffset = maxRadix * (passCount - 1),
    normalizer = Math.pow(20, 6);

var buffer = new ArrayBuffer(4);
var floatView = new Float32Array(buffer, 0, 1);
var intView = new Int32Array(buffer, 0, 1);

function comp(list, registry, i) {
    var key = list[i];
    return registry[key].uniformValues[1][14] + normalizer;
}

function mutator(list, registry, i, value) {
    var key = list[i];
    registry[key].uniformValues[1][14] = intToFloat(value) - normalizer;
    return key;
}


function floatToInt(k) {
    floatView[0] = k;
    return intView[0];
}

function intToFloat(k) {
    intView[0] = k;
    return floatView[0];
}

function sort(list, registry) {
    var pass = 0;
    var out = [];

    var i, j, k, n, div, offset, swap, id, sum, tsum, size;

    passCount = ((32 / radixBits) + 0.999999999999999) | 0;

    for (i = 0, n = maxRadix * passCount; i < n; i++) buckets[i] = 0;

    for (i = 0, n = list.length; i < n; i++) {
        div = floatToInt(comp(list, registry, i));
        div ^= div >> 31 | 0x80000000;
        for (j = 0, k = 0; j < maxOffset; j += maxRadix, k += radixBits) {
            buckets[j + (div >>> k & radixMask)]++;
        }
        buckets[j + (div >>> k & lastMask)]++;
    }

    for (j = 0; j <= maxOffset; j += maxRadix) {
        for (id = j, sum = 0; id < j + maxRadix; id++) {
            tsum = buckets[id] + sum;
            buckets[id] = sum - 1;
            sum = tsum;
        }
    }
    if (--passCount) {
        for (i = 0, n = list.length; i < n; i++) {
            div = floatToInt(comp(list, registry, i));
            out[++buckets[div & radixMask]] = mutator(list, registry, i, div ^= div >> 31 | 0x80000000);
        }
        swap = out, out = list, list = swap;
        while (++pass < passCount) {
            for (i = 0, n = list.length, offset = pass * maxRadix, size = pass * radixBits; i < n; i++) {
                div = floatToInt(comp(list, registry, i));
                out[++buckets[offset + (div >>> size & radixMask)]] = list[i];
            }
            swap = out, out = list, list = swap;
        }
    }

    for (i = 0, n = list.length, offset = pass * maxRadix, size = pass * radixBits; i < n; i++) {
        div = floatToInt(comp(list, registry, i));
        out[++buckets[offset + (div >>> size & lastMask)]] = mutator(list, registry, i, div ^ (~div >> 31 | 0x80000000));
    }

    return out;

}

module.exports = sort;

},{}],252:[function(require,module,exports){
'use strict';

var VirtualElement = require('famous-dom-renderers').VirtualElement;
var strip = require('famous-utilities').strip;
var flatClone = require('famous-utilities').flatClone;

var Context = require('./Context');

/**
 * Instantiates a new Compositor, used for routing commands received from the
 * WebWorker to the WebGL and DOM renderer.
 *
 * @class Compositor
 * @constructor
 */
function Compositor() {
    this._contexts = {};
    this._outCommands = [];
    this._inCommands = [];

    this.clearCommands();
}

/**
 * Schedules an event to be sent to the WebWorker the next time the out command
 * queue is being flushed.
 *
 * @method sendEvent
 * @private
 *
 * @param  {String} path    render path to the node the event should be
 *                          triggered on (*targeted event*)
 * @param  {String} ev      event type
 * @param  {Object} payload event object (serializable using structured
 *                          cloning algorithm)
 */
Compositor.prototype.sendEvent = function sendEvent(path, ev, payload) {
    this._outCommands.push('WITH', path, 'TRIGGER', ev, payload);
};

/**
 * Internal helper method used by `drawCommands`.
 *
 * @method handleWith
 * @private
 *
 * @param  {Array} commands     remaining message queue received from the
 *                              WebWorker, used to shift single messages from
 */
Compositor.prototype.handleWith = function handleWith (iterator, commands) {
    var path = commands[iterator];
    var pathArr = path.split('/');
    var context = this.getOrSetContext(pathArr.shift());
    return context.receive(pathArr, path, commands, iterator);
};

/**
 * Retrieves the top-level VirtualElement attached to the passed in document
 * selector.
 * If no such element exists, one will be instantiated, therefore representing
 * the equivalent of a Context in the Main Thread.
 *
 * @method getOrSetContext
 * @private
 *
 * @param  {String} selector            document query selector used for
 *                                      retrieving the DOM node the
 *                                      VirtualElement should be attached to
 * @return {Object} result
 * @return {VirtualElement} result.DOM  final VirtualElement
 */
Compositor.prototype.getOrSetContext = function getOrSetContext(selector) {
    if (this._contexts[selector]) return this._contexts[selector];
    else return (this._contexts[selector] = new Context(selector, this));
};

/**
 * Internal helper method used by `drawCommands`.
 *
 * @method giveSizeFor
 * @private
 *
 * @param  {Array} commands     remaining message queue received from the
 *                              WebWorker, used to shift single messages from
 */
Compositor.prototype.giveSizeFor = function giveSizeFor(iterator, commands) {
    var selector = commands[iterator];
    var size = this.getOrSetContext(selector).getRootSize();
    this.sendResize(selector, size);
    var _this = this;
    if (selector === 'body')
        window.addEventListener('resize', function() {
            if (!_this._sentResize) {
                _this.sendResize(selector, _this.getOrSetContext(selector).getRootSize());
            }
        });
};

/**
 * Internal helper method used for notifying the WebWorker about externally
 * resized contexts (e.g. by resizing the browser window).
 *
 * @method sendResize
 * @private
 *
 * @param  {String} selector    render path to the node (context) that should
 *                              be resized
 * @param  {Array} size         new context size
 */
Compositor.prototype.sendResize = function sendResize (selector, size) {
    this._outCommands.push('WITH', selector, 'TRIGGER', 'CONTEXT_RESIZE', size);
    this._sentResize = true;
};

Compositor.prototype._wrapProxyFunction = function _wrapProxyFunction(id) {
    var _this = this;
    return function() {
        var i;

        for (i = 0; i < arguments.length; i++) {
            if (typeof arguments[i] === 'object') {
                arguments[i] = strip(flatClone(arguments[i]));
            }
        }
        _this._outCommands.push('INVOKE', id, Array.prototype.slice.call(arguments));
    };
};

Compositor.prototype.invoke = function invoke (target, methodName, args, functionArgs) {
    var targetObject = window[target];

    for (var i = 0; i < args.length; i++) {
        if (functionArgs[i] != null) {
            args[i] = this._wrapProxyFunction(functionArgs[i]);
        }
    }

    targetObject[methodName].apply(targetObject, args);
};

/**
 * Processes the previously via `receiveCommands` updated incoming "in"
 * command queue.
 * Called by ThreadManager.
 *
 * @method drawCommands
 *
 * @return {Array} outCommands  set of commands to be sent back to the
 *                              WebWorker
 */
Compositor.prototype.drawCommands = function drawCommands() {
    var commands = this._inCommands;
    var localIterator = 0;
    var command = commands[localIterator];
    while (command) {
        switch (command) {
            case 'WITH':
                localIterator = this.handleWith(++localIterator, commands);
                break;

            case 'INVOKE':
                this.invoke(
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'NEED_SIZE_FOR':
                this.giveSizeFor(++localIterator, commands);
                break;
        }
        command = commands[++localIterator];
    }

    // TODO: Switch to associative arrays here...

    for (var key in this._contexts) {
        this._contexts[key].draw();
    }

    return this._outCommands;
};

/**
 * Used by ThreadManager to update the interal queue of incoming commands.
 * Receiving commands does not immediately start the rederning process.
 *
 * @param  {Array} commands     command queue to be processed by the
 *                              compositor's `drawCommands` method
 */
Compositor.prototype.receiveCommands = function receiveCommands(commands) {
    var len = commands.length;
    for (var i = 0; i < len; i++) {
        this._inCommands.push(commands[i]);
    }
};

/**
 * Flushes the queue of outgoing "out" commands.
 * Called by ThreadManager.
 *
 * @method clearCommands
 */
Compositor.prototype.clearCommands = function clearCommands() {
    this._inCommands.length = 0;
    this._outCommands.length = 0;
    this._sentResize = false;
};

module.exports = Compositor;

},{"./Context":253,"famous-dom-renderers":171,"famous-utilities":184}],253:[function(require,module,exports){
var WebGLRenderer = require('famous-webgl-renderers').WebGLRenderer;
var Camera = require('famous-components').Camera;
var DOMRenderer = require('famous-dom-renderers').DOMRenderer;

function Context(selector, compositor) {
    this._compositor = compositor;
    this._rootEl = document.querySelector(selector);
    if (this._rootEl === document.body) {
        window.addEventListener('resize', this.updateSize.bind(this));
    }

    var DOMLayerEl = document.createElement('div');
    DOMLayerEl.style.width = '100%';
    DOMLayerEl.style.height = '100%';
    DOMLayerEl.style.transformStyle = 'preserve-3d';
    DOMLayerEl.style.webkitTransformStyle = 'preserve-3d';
    this._rootEl.appendChild(DOMLayerEl);
    this.DOMRenderer = new DOMRenderer(DOMLayerEl, selector, compositor); 
 
    this.WebGLRenderer = null;
    this.canvas = null;

    this._renderState = {
        projectionType: Camera.ORTHOGRAPHIC_PROJECTION,
        perspectiveTransform: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        viewTransform: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        viewDirty: false,
        perspectiveDirty: false
    };

    this._size = [];
    this._children = {};
    this._elementHash = {};

    this._meshTransform = [];
    this._meshSize = [0, 0, 0];

    this.updateSize();
}

Context.prototype.updateSize = function () {
    var newSize = this.DOMRenderer._getSize();

    var width = newSize[0];
    var height = newSize[1];

    this._size[0] = width;
    this._size[1] = height;
    this._size[2] = (width > height) ? width : height;

    if (this.canvas) {
        this.canvas.width  = width;
        this.canvas.height = height;
    }

    if (this.WebGLRenderer) this.WebGLRenderer.updateSize(this._size);

    return this;
}

Context.prototype.draw = function draw() {
    this.DOMRenderer.draw(this._renderState);
    if (this.WebGLRenderer) this.WebGLRenderer.draw(this._renderState);

    if (this._renderState.perspectiveDirty) this._renderState.perspectiveDirty = false;
    if (this._renderState.viewDirty) this._renderState.viewDirty = false;
};

Context.prototype.getRootSize = function getRootSize() {
    return this.DOMRenderer.getSize();
};

Context.prototype.initWebGL = function initWebGL() {
    this.canvas = document.createElement('canvas');
    this.canvas.className = 'famous-webgl';
    this._rootEl.appendChild(this.canvas);
    this.WebGLRenderer = new WebGLRenderer(this.canvas);
    this.updateSize();
};

Context.prototype.receive = function receive(pathArr, path, commands, iterator) {
    var pointer;
    var parentEl;
    var element;
    var id;
    var localIterator = iterator;

    var command = commands[++localIterator];
    this.DOMRenderer.loadPath(path);
    this.DOMRenderer.findTarget();
    while (command) {

        switch (command) {
            case 'INIT_DOM':
                this.DOMRenderer.insertEl(commands[++localIterator]);
                break;

            case 'CHANGE_TRANSFORM':
                for (var i = 0 ; i < 16 ; i++) this._meshTransform[i] = commands[++localIterator];

                this.DOMRenderer.setMatrix(this._meshTransform);

                if (this.WebGLRenderer)
                    this.WebGLRenderer.setCutoutUniform(path, 'transform', this._meshTransform);
                
                break;

            case 'CHANGE_SIZE':
                var width = commands[++localIterator];
                var height = commands[++localIterator];

                this.DOMRenderer.setSize(width, height);
                if (this.WebGLRenderer) {
                    this._meshSize[0] = width;
                    this._meshSize[1] = height;
                    this.WebGLRenderer.setCutoutUniform(path, 'size', this._meshSize);
                }
                break;

            case 'CHANGE_PROPERTY':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.setProperty(commands[++localIterator], commands[++localIterator]);
                break;

            case 'CHANGE_CONTENT':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.setContent(commands[++localIterator]);
                break;

            case 'CHANGE_ATTRIBUTE':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.setAttribute(commands[++localIterator], commands[++localIterator]);
                break;

            case 'ADD_CLASS':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.addClass(commands[++localIterator]); 
                break;

            case 'REMOVE_CLASS':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.removeClass(commands[++localIterator]);
                break;

            case 'ADD_EVENT_LISTENER':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);

                var type = commands[++localIterator];
                var properties = commands[++localIterator];
                var preventDefault = commands[++localIterator];

                this.DOMRenderer.addEventListener(path, type, properties, preventDefault);
                break;

            case 'GL_SET_DRAW_OPTIONS': 
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setMeshOptions(path, commands[++localIterator]);
                break;

            case 'GL_AMBIENT_LIGHT':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setAmbientLightColor(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_LIGHT_POSITION':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setLightPosition(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_LIGHT_COLOR':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setLightColor(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'MATERIAL_INPUT':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.handleMaterialInput(
                    path,
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_SET_GEOMETRY':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setGeometry(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_UNIFORMS':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setMeshUniform(
                    path,
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_BUFFER_DATA':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.bufferData(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'PINHOLE_PROJECTION':
                this._renderState.projectionType = Camera.PINHOLE_PROJECTION;
                this._renderState.perspectiveTransform[11] = -1 / commands[++localIterator];

                this._renderState.perspectiveDirty = true;
                break;

            case 'ORTHOGRAPHIC_PROJECTION':
                this._renderState.projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
                this._renderState.perspectiveTransform[11] = 0;

                this._renderState.perspectiveDirty = true;
                break;

            case 'CHANGE_VIEW_TRANSFORM':
                this._renderState.viewTransform[0] = commands[++localIterator];
                this._renderState.viewTransform[1] = commands[++localIterator];
                this._renderState.viewTransform[2] = commands[++localIterator];
                this._renderState.viewTransform[3] = commands[++localIterator];

                this._renderState.viewTransform[4] = commands[++localIterator];
                this._renderState.viewTransform[5] = commands[++localIterator];
                this._renderState.viewTransform[6] = commands[++localIterator];
                this._renderState.viewTransform[7] = commands[++localIterator];

                this._renderState.viewTransform[8] = commands[++localIterator];
                this._renderState.viewTransform[9] = commands[++localIterator];
                this._renderState.viewTransform[10] = commands[++localIterator];
                this._renderState.viewTransform[11] = commands[++localIterator];

                this._renderState.viewTransform[12] = commands[++localIterator];
                this._renderState.viewTransform[13] = commands[++localIterator];
                this._renderState.viewTransform[14] = commands[++localIterator];
                this._renderState.viewTransform[15] = commands[++localIterator];

                this._renderState.viewDirty = true;
                break;

            case 'WITH': return localIterator - 1;
        }

        command = commands[++localIterator];
    }

    return localIterator;
};

module.exports = Context;

},{"famous-components":168,"famous-dom-renderers":171,"famous-webgl-renderers":250}],254:[function(require,module,exports){
'use strict';

/**
 * The ThreadManager is being updated by an Engine by consecutively calling its
 * `update` method. It can either manage a real Web-Worker or the global
 * Famous core singleton.
 *
 * @example
 * var compositor = new Compositor();
 * 
 * // Using a Web Worker
 * var worker = new Worker('worker.bundle.js');
 * var threadmanger = new ThreadManager(worker, compositor);
 * 
 * // Without using a Web Worker
 * var threadmanger = new ThreadManager(Famous, compositor);
 * 
 * @class  ThreadManager
 * @constructor
 * 
 * @param {Famous|Worker} thread        The thread being used to receive
 *                                      messages from and post messages to.
 *                                      Expected to expose a WebWorker-like
 *                                      API, which means providing a way to
 *                                      listen for updates by setting its
 *                                      `onmessage` property and sending
 *                                      updates using `postMessage`.
 * @param {Compositor} compositor       an instance of Compositor used to
 *                                      extract enqueued draw commands from to
 *                                      be sent to the thread
 */
function ThreadManager (thread, compositor) {
    this._thread = thread;
    this._compositor = compositor;

    var _this = this;
    this._thread.onmessage = function (ev) {
        _this._compositor.receiveCommands(ev.data ? ev.data : ev);
    };
    this._thread.onerror = function (error) {
        console.error(error);
    };
}

/**
 * Update method being invoked by the Engine on every `requestAnimationFrame`.
 * Used for updating the notion of time within the managed thread by sending
 * a FRAME command and sending messages to 
 * 
 * @method update
 * 
 * @param  {Number} time unix timestamp to be passed down to the worker as a
 *                       FRAME command
 */
ThreadManager.prototype.update = function update (time) {
    this._thread.postMessage(['FRAME', time]);
    var threadMessages = this._compositor.drawCommands();
    this._thread.postMessage(threadMessages);
    this._compositor.clearCommands();
};

module.exports = ThreadManager;

},{}],255:[function(require,module,exports){
'use strict';

module.exports = {
    Compositor: require('./Compositor'),
    ThreadManager: require('./ThreadManager')
};

},{"./Compositor":252,"./ThreadManager":254}],256:[function(require,module,exports){
'use strict';

var sessionHistorySupport = window.history && window.history.pushState && window.history.replaceState;

/**
 * A stateless shim for hash routing. Used by router.
 *   Supports hash bang routing and HTML5 pushState.
 *   Falls back to hash bang urls when pushState is not supported.
 *   Implements subset of W3C spec in respect to
 *   http://www.w3.org/TR/2011/WD-html5-20110113/history.html#history-0
 *
 * @History
 * @class
 * @constructor
 * @private
 *
 * @example
 * var history = History();
 * console.log(history.hashBangUrls);
 * history.pushState({}, document.title, '/route');
 *
 * @param {Object} options
 * @param {Boolean} options.hashBangUrls force history to use URLs
 *   in the form of /#!/route
 * @param {String} root
 */
function History(options) {
    if (!(this instanceof History)) return new History(options);

    options = options || {};
    this._root = options.root || '';
    this._sessionHistorySupport = sessionHistorySupport;
    this.hashBangUrls = options.hashBangUrls || !this._sessionHistorySupport;
    this._location = window.location;
}

/**
 * @property {Boolean} hashBangUrls
 * @readonly
 */
History.prototype.hashBangUrls = false;

/**
 * Register a function to be invoked on every state change.
 *
 * @method onStateChange
 * @chainable
 *
 * @param {Function} handler callback to invoke on state change
 *
 * @return {History} this
 */
History.prototype.onStateChange = function onStateChange(handler) {
    // prefer HTML5 history API over hashchange when possible
    if (this._sessionHistorySupport) {
        window.addEventListener('popstate', handler);
        window.addEventListener('pushstate', handler);
    }
    else if (this.hashBangUrls && 'onhashchange' in window) {
        window.addEventListener('hashchange', handler);
    }
    else {
        // only possible solution at this point is to use an ugly combination
        // of setInterval and window.location.pathname
    }
    return this;
};

/**
 * Deregister a state change handler that has been previously registered
 *   through onStateChange.
 *
 * @method offStateChange
 * @chainable
 *
 * @param {Function} handler handler previously registered through onStateChange
 *
 * @return {History} this
 */
History.prototype.offStateChange = function offStateChange(handler) {
    window.removeEventListener('popstate', handler);
    window.removeEventListener('pushstate', handler);
    window.removeEventListener('hashchange', handler);
    return this;
};

/**
 * Shim for window.history.pushState
 * 
 * @method pushState
 * @chainable
 *
 * @params {Object} data state object passed through session API if possible,
 *   not accessable later on, used to make arguments list complaint with W3C
 *   spec
 * @params {String=document.title} title new document title, not associated with
 *   new state
 * @params {String} url
 *
 * @return {History} this
 */
History.prototype.pushState = function pushState(data, title, url) {
    document.title = title || document.title;
    if (this.hashBangUrls) {
        if (this._sessionHistorySupport) {
            window.history.pushState(data, title, '#!' + url);
        }
        else {
            window.location.hash = url;
        }
    }
    else {
        window.history.pushState(data, title, url);
    }
    return this;
};

/**
 * Shim for window.history.replaceState
 * 
 * @method replaceState
 * @chainable
 *
 * @params {Object} data state object passed through session API if possible,
 *   not accessable later on, used to make arguments list complaint with W3C
 *   spec
 * @params {String=document.title} title new document title, not associated with
 *   new state
 * @params {String} url
 *
 * @return {History} this
 */
History.prototype.replaceState = function replaceState(data, title, url) {
    document.title = title || document.title;
    if (this.hashBangUrls) {
        if (this._sessionHistorySupport) {
            window.history.replaceState(data, title, '#!' + url);
        }
        else {
            url = ('' + window.location).split('#')[0] + '#!' + url;
            window.location.replace(url);
        }
    }
    else {
        window.history.replaceState(data, title, url);
    }
    return this;
};

/**
 * Return current normalized state (routed pathname).
 * Not compliant with [W3C spec 5.4 Session history and
 * navigation](http://www.w3.org/TR/2011/WD-html5-20110113/history.html)
 *
 * @method getState
 *
 * @return {String|null} state as normalized pathname
 */
History.prototype.getState = function getState() {
    if (!this._location.pathname.match('^' + this._root)) {
        return null;
    }
    if (this.hashBangUrls) {
        return this._location.hash.substring(2);
    }
    else {
        return decodeURI(this._location.pathname).substring(this._root.length);
    }
};

module.exports = History;

},{}],257:[function(require,module,exports){
'use strict';

var _History = require('./History');

/**
 * A simple router supporting HTML5 pushState and hashbang  routing ("#!/").
 * 
 * @example
 * var router = Router({
 *     '/example-route-0': function() {
 *         console.log('/example-route-0');
 *     },
 *     '/example-route-1': function() {
 *         console.log('/example-route-1');
 *     },
 *     '/example-route-2': function() {
 *         console.log('/example-route-2');
 *     },
 *     '/example-route-3': function() {
 *         console.log('/example-route-3');
 *     }
 * });
 *
 * var currentState = 0;
 * var interval = setInterval(function() {
 *     if (currentState === 4) return clearTimeout(interval);
 *     router.navigate('/example-route-' + currentState, { invoke: true });
 *     currentState++;
 * }, 1000);
 * 
 * @class Router
 * @constructor
 *
 * @param {Object} routes
 * @param {Object} options
 * @param {Boolean} options.silent
 * @param {Boolean} options.hashBangUrls
 * @param {Object} options.proxy
 * @param {String} options.root
 * @param {Boolean} options.validate check for unknown routes
 */
function Router(routes, options) {
    if (!(this instanceof Router)) return new Router(routes, options);
    
    routes = routes || {};
    options = options || {};

    this._root = options.root || '';

    this._routes = [];
    this.proxy = options.proxy || {};
    if (options.validate) this.validate = true;

    // Avoids cylic routing by storing the last routed state
    // Seems like W3C spec doesn't mention if pushState event should be
    // dispatched on page load.
    this._lastState = null;

    _addInitialRoutes.call(this, routes);

    this._history = _History({
        hashBangUrls: options.hashBangUrls,
        root: this._root
    }).onStateChange(_onStateChange.bind(this));

    if (!options.silent) this.start();
}

/**
 * Starts the router by invoking the route handler bound to the current
 *   pathname. Will be called by constructor, unless silent option is
 *   in use.
 *
 * @method start
 * @chainable
 *
 * @return {Router} this
 */
Router.prototype.start = function start() {
    this.invoke();
    return this;
};

/**
 * Navigates to the given route. If no route is give, navigate to the current
 *   pathname (used during initialization).
 *
 * @method navigate
 * @chainable
 *
 * @param {String} [state=current pathname]
 * @param {Object} options
 * @param {Boolean} options.replace
 * @param {Boolean} options.invoke
 *
 * @return {Router} this
 */
Router.prototype.navigate = function navigate(state, options) {
    options = options || {};
    state = state || this._history.getState();
    if (this._lastState === state) return this;

    var method = options.replace ? 'replaceState' : 'pushState';
    this._history[method](null, null, state);

    if (options.invoke) this.invoke();
    return this;
};

/**
 * Dynamically adds a route to the register.
 *
 * @method addRoute
 * @chainable
 *
 * @param {String|RegExp} route
 * @param {Function} handler
 *
 * @return {Router} this
 */
Router.prototype.addRoute = function addRoute(route, handler) {
    if (typeof route === 'string') route = _createRegExpRoute(route);
    this._routes.push({ regExp: route, handler: handler });
    return this;
};

/**
 * Invokes the handler bound to the given state.
 *
 * @method invoke
 * @chainable
 *
 * @param {String} [state=current pathname] route
 *
 * @return {Router} this
 */
Router.prototype.invoke = function invoke(state) {
    if (this._lastState === state) return this;
    state = state || this._history.getState();
    if (state === null) return;
    var unknown = this._routes.every(function (route) {
        var result = _checkRoute.call(this, route, state);
        if (result) {
            if (typeof route.handler === 'string' && this.proxy[route.handler]) {
                this.proxy[route.handler].apply(null, result);
            }
            else {
                route.handler.apply(null, result);
            }
        }
        return !result;
    }.bind(this));
    if (unknown && this.validate) throw new Error('Unknown route');
    return this;
};

function _checkRoute(route, state) {
    var result = state.match(route.regExp);
    if (!result) return false;

    // no support for nested capturing groups
    result = result.slice(1);
    return result;
}

function _createRegExpRoute(route) {
    // TODO could be extended to splats etc.
    route = route.replace(/\:\w+/, function (param) {
        param = param.substring(1);
        return '(' + param + ')';
    });
    return new RegExp('^' + route + '$');
}

function _onStateChange() {
    /* jshint validthis: true */
    this.invoke();
}

function _addInitialRoutes(routes, scope) {
    /* jshint validthis: true */
    scope = scope || '';
    if (Array.isArray(routes)) {
        // composing nested sets of regular expressions of regular expressions
        // including lookarounds might lead to unexpected behavior. For now,
        // those can't be traversed.
        routes.forEach(function(routeSpec) {
            this.addRoute(routeSpec.route, routeSpec.handler);
        }.bind(this));
    } else {
        for (var route in routes) {
            var handler = routes[route];
            if (handler instanceof Function || typeof handler === 'string') {
                this.addRoute(scope + route, routes[route]);
            }
            else {
                _addInitialRoutes.call(this, routes[route], scope + route);
            }
        }
    }
}

module.exports = Router;

},{"./History":256}],258:[function(require,module,exports){
'use strict';

module.exports = {
    History: require('./History'),
    Router: require('./Router')
};

},{"./History":256,"./Router":257}],259:[function(require,module,exports){
module.exports = function (css, customDocument) {
  var doc = customDocument || document;
  if (doc.createStyleSheet) {
    var sheet = doc.createStyleSheet()
    sheet.cssText = css;
    return sheet.ownerNode;
  } else {
    var head = doc.getElementsByTagName('head')[0],
        style = doc.createElement('style');

    style.type = 'text/css';

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(doc.createTextNode(css));
    }

    head.appendChild(style);
    return style;
  }
};

module.exports.byUrl = function(url) {
  if (document.createStyleSheet) {
    return document.createStyleSheet(url).ownerNode;
  } else {
    var head = document.getElementsByTagName('head')[0],
        link = document.createElement('link');

    link.rel = 'stylesheet';
    link.href = url;

    head.appendChild(link);
    return link;
  }
};

},{}],260:[function(require,module,exports){
var css = "html {\n    width: 100%;\n    height: 100%;\n    margin: 0px;\n    padding: 0px;\n    overflow: hidden;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n}\n\nbody {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    margin: 0px;\n    padding: 0px;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n    -webkit-font-smoothing: antialiased;\n    -webkit-tap-highlight-color: transparent;\n    -webkit-perspective: 0;\n    perspective: none;\n    overflow: hidden;\n}\n\n.famous-container, .famous-group {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    bottom: 0px;\n    right: 0px;\n    overflow: visible;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n    -webkit-backface-visibility: visible;\n    backface-visibility: visible;\n    pointer-events: none;\n}\n\n.famous-group {\n    width: 0px;\n    height: 0px;\n    margin: 0px;\n    padding: 0px;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n}\n\n.fa-surface {\n    position: absolute;\n    -webkit-transform-origin: 0% 0%;\n    transform-origin: 0% 0%;\n    -webkit-backface-visibility: visible;\n    backface-visibility: visible;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d; /* performance */\n    -webkit-tap-highlight-color: transparent;\n    pointer-events: auto;\n    z-index: 1; /* HACK to account for browser issues with eventing on the same z-plane*/\n}\n\n.fa-content {\n    position: absolute;\n}\n\n.famous-container-group {\n    position: relative;\n    width: 100%;\n    height: 100%;\n}\n\n.fa-container {\n    position: absolute;\n    -webkit-transform-origin: center center;\n    transform-origin: center center;\n    overflow: hidden;\n}\n\ncanvas.famous-webgl {\n    pointer-events: none;\n    position: absolute;\n    z-index: 1;\n    top: 0px;\n    left: 0px;\n}"; (require("/Users/morgantheplant/Desktop/easing/node_modules/famous/node_modules/famous-stylesheets/node_modules/cssify"))(css); module.exports = css;
},{"/Users/morgantheplant/Desktop/easing/node_modules/famous/node_modules/famous-stylesheets/node_modules/cssify":259}],261:[function(require,module,exports){
'use strict';

require('./famous.css');

},{"./famous.css":260}],262:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],263:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],264:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./Curves":262,"dup":9}],265:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],266:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./Curves":262,"./Easing":263,"./Transitionable":264,"./after":265,"dup":11}],267:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],268:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],269:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./Curves":267,"dup":9}],270:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],271:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./Curves":267,"./Easing":268,"./Transitionable":269,"./after":270,"dup":11}],272:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17}],273:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"famous-transitions":271}],274:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],275:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],276:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],277:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],278:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],279:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./CallbackStore":272,"./Color":273,"./KeyCodes":274,"./MethodStore":275,"./ObjectManager":276,"./clone":277,"./flatClone":278,"./keyValueToArrays":280,"./loadURL":281,"./strip":282,"dup":24}],280:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],281:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],282:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],283:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],284:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./Mat33":283,"dup":3}],285:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],286:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],287:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"./Mat33":283,"./Quaternion":284,"./Vec2":285,"./Vec3":286,"dup":6}],288:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],289:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],290:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./Curves":288,"dup":9}],291:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],292:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./Curves":288,"./Easing":289,"./Transitionable":290,"./after":291,"dup":11}],293:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17}],294:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"famous-transitions":292}],295:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],296:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],297:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],298:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],299:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],300:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./CallbackStore":293,"./Color":294,"./KeyCodes":295,"./MethodStore":296,"./ObjectManager":297,"./clone":298,"./flatClone":299,"./keyValueToArrays":301,"./loadURL":302,"./strip":303,"dup":24}],301:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],302:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],303:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],304:[function(require,module,exports){
arguments[4][225][0].apply(exports,arguments)
},{"./Geometry":305,"dup":225}],305:[function(require,module,exports){
arguments[4][226][0].apply(exports,arguments)
},{"dup":226}],306:[function(require,module,exports){
arguments[4][227][0].apply(exports,arguments)
},{"dup":227,"famous-math":287}],307:[function(require,module,exports){
arguments[4][228][0].apply(exports,arguments)
},{"./GeometryHelper":306,"dup":228,"famous-utilities":300}],308:[function(require,module,exports){
arguments[4][229][0].apply(exports,arguments)
},{"./DynamicGeometry":304,"./Geometry":305,"./GeometryHelper":306,"./OBJLoader":307,"./primitives/Box":309,"./primitives/Circle":310,"./primitives/Cylinder":311,"./primitives/GeodesicSphere":312,"./primitives/Icosahedron":313,"./primitives/ParametricCone":314,"./primitives/Plane":315,"./primitives/Sphere":316,"./primitives/Tetrahedron":317,"./primitives/Torus":318,"./primitives/Triangle":319,"dup":229}],309:[function(require,module,exports){
arguments[4][230][0].apply(exports,arguments)
},{"../Geometry":305,"dup":230}],310:[function(require,module,exports){
arguments[4][231][0].apply(exports,arguments)
},{"../Geometry":305,"dup":231}],311:[function(require,module,exports){
arguments[4][232][0].apply(exports,arguments)
},{"../Geometry":305,"../GeometryHelper":306,"dup":232}],312:[function(require,module,exports){
arguments[4][233][0].apply(exports,arguments)
},{"../Geometry":305,"../GeometryHelper":306,"dup":233}],313:[function(require,module,exports){
arguments[4][234][0].apply(exports,arguments)
},{"../Geometry":305,"../GeometryHelper":306,"dup":234}],314:[function(require,module,exports){
arguments[4][235][0].apply(exports,arguments)
},{"../Geometry":305,"../GeometryHelper":306,"dup":235}],315:[function(require,module,exports){
arguments[4][236][0].apply(exports,arguments)
},{"../Geometry":305,"dup":236}],316:[function(require,module,exports){
arguments[4][237][0].apply(exports,arguments)
},{"../Geometry":305,"../GeometryHelper":306,"dup":237}],317:[function(require,module,exports){
arguments[4][238][0].apply(exports,arguments)
},{"../Geometry":305,"../GeometryHelper":306,"dup":238}],318:[function(require,module,exports){
arguments[4][239][0].apply(exports,arguments)
},{"../Geometry":305,"../GeometryHelper":306,"dup":239}],319:[function(require,module,exports){
arguments[4][240][0].apply(exports,arguments)
},{"../Geometry":305,"../GeometryHelper":306,"dup":240}],320:[function(require,module,exports){
'use strict';

var TextureRegistry = require('./TextureRegistry');

/** 
 * A list of glsl expressions which can interface with javascript data and
 * connected to each other to build custom shaders. 
 *
 */
var expressions = {};

var snippets = {

    /* Abs - The abs function returns the absolute value of x, i.e. x when x is positive or zero and -x for negative x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.
     */ 

    abs: {glsl: 'abs(%1);'},
    /* Sign - The sign function returns 1.0 when x is positive, 0.0 when x is zero and -1.0 when x is negative. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise. */


    sign: {glsl: 'sign(%1);'},

    /* Floor - The floor function returns the largest integer number that is smaller or equal to x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise. */

    floor: {glsl: 'floor(%1);'},

    /* Ceiling - The ceiling function returns the smallest number that is larger or equal to x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise. */

    ceiling: {glsl: 'ceil(%1);'},

    /* The mod expression returns the remained of the division operation of the two inputs. */
    mod: {glsl: 'mod(%1, %2);'},

    /* Min - The min function returns the smaller of the two arguments. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    min: {glsl: 'min(%1, %2);'},

    /* Max - The max function returns the larger of the two arguments. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */ 

    max: {glsl: 'max(%1, %2);'},
    /* Clamp - The clamp function returns x if it is larger than minVal and smaller than maxVal. In case x is smaller than minVal, minVal is returned. If x is larger than maxVal, maxVal is returned. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    clamp: {glsl: 'clamp(%1, %2, %3);'},

    /* Mix - The mix function returns the linear blend of x and y, i.e. the product of x and (1 - a) plus the product of y and a. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    mix: {glsl: 'mix(%1, %2, %3);'},

    /* Step - The step function returns 0.0 if x is smaller then edge and otherwise 1.0. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    step: {glsl: 'step(%1, %2, %3);'},
    
    /* Smoothstep - The smoothstep function returns 0.0 if x is smaller then edge0 and 1.0 if x is larger than edge1. Otherwise the return value is interpolated between 0.0 and 1.0 using Hermite polynomirals. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */ 

    smoothstep: {glsl: 'smoothstep(%1);'},


    /* fragCoord - The fragCoord function returns the fragment's position in screenspace. */

    fragCoord: {glsl: 'gl_FragColor.xy;'},

    /* Sin - The sin function returns the sine of an angle in radians. The input parameter can be a floating scalar or a float vector. In case of a float vector the sine is calculated separately for every component. */


    sin: {glsl: 'sin(%1);'},

    /* Cos - The cos function returns the cosine of an angle in radians. The input parameter can be a floating scalar or a float vector. */

    cos: {glsl: 'cos(%1);'},

    /* Pow - The power function returns x raised to the power of y. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */ 

    pow: {glsl: 'pow(%1, %2);'},

    /* Sqrt - The sqrt function returns the square root of x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise. */ 

    /* fragCoord - The time function returns the elapsed time in the unix epoch in milliseconds.*/

    time: {glsl: 'time;'},

    /* The Add function takes two inputs, adds them together and outputs the result. This addition operation is performed on a per channel basis, meaning that the inputs' R channels get added, G channels get added, B channels get added, etc. Both inputs must have the same number of channels unless one of them is a single Constant value. Constants can be added to a vector with any number of inputs. */
    add: {glsl: '%1 + %2;'},

    /* The Add function takes two inputs, adds them together and outputs the result. This addition operation is performed on a per channel basis, meaning that the inputs' R channels get added, G channels get added, B channels get added, etc. Both inputs must have the same number of channels unless one of them is a single Constant value. Constants can be added to a vector with any number of inputs. */
    multiply: {glsl: '%1 * %2;'},


    /* The normal function returns the 3-dimensional surface normal, which is a vector that is perpendicular to the tangent plane at that point.*/
    normal: {glsl:'(v_Normal + 1.0) * 0.5;'},

    /* The uv function returns the 2-dimensional vector that maps the object's 3-dimensional vertices to a 2D plane. */
    uv: {glsl:'vec3(v_TextureCoordinate, 1);'},

    /* The mesh position function returns the transformed fragment's position in world-space.  */
    meshPosition: {glsl:'(v_Position + 1.0) * 0.5;'},


    /* The image function fetches the model's */
    image: {glsl:'texture2D(image, v_TextureCoordinate).rgb;'},


    /* The constant function returns a static value which is defined at compile-time that cannot be changed dynamically.*/
    constant: {glsl: '%1;'},
    
    /* The Parameter expression has values that can be modified (dynamically during runtime in some cases) in a MaterialInstance of the base material containing the parameter. These expressions should be given unique names, via the Parameter Name property, to be used when identifying the specific parameter in the MaterialInstance. If two parameters of the same type have the same name in the same material, they will be assumed to be the same parameter. Changing the value of the parameter in the MaterialInstance would change the value of both the parameter expressions in the material. A default value for the parameter will also be set in the base material. This will be the value of the parameter in the MaterialInstance unless it is overridden and modified there. */

    parameter: {uniforms: {parameter: 1}, glsl: 'parameter;'}
};

expressions.registerExpression = function registerExpression(name, schema) {
    this[name] = function (inputs, options) {
        return new Material(name, schema, inputs, options);
    };
};

for (var name in snippets) {
    expressions.registerExpression(name, snippets[name]);
}

/**
 * Material is a public class that composes a material-graph out of expressions
 *
 *
 * @class Material
 * @constructor
 *
 * @param {Object} definiton of nascent expression with shader code, inputs and uniforms
 * @param {Array} list of Material expressions, images, or constant
 * @param {Object} map of uniform data of float, vec2, vec3, vec4
 */

function Material(name, chunk, inputs, options) {
    options = options || {};

    this.name = name;
    this.chunk = chunk;
    this.inputs = inputs ? (Array.isArray(inputs) ? inputs : [inputs]): [];
    this.uniforms = options.uniforms || {};
    this.varyings = options.varyings;
    this.attributes = options.attributes;
    if (options.texture) {
        this.texture = options.texture.__isATexture__ ? options.texture : TextureRegistry.register(null, options.texture);
    }

    this._id = Material.id++;

    this.invalidations = [];
}

Material.id = 1;

/**
 * Iterates over material graph
 *
 * @method traverse
 * @chainable
 *
 * @param {Function} invoked upon every expression in the graph
 */

Material.prototype.traverse = function traverse(callback) {
    var len = this.inputs && this.inputs.length, idx = -1;

    while (++idx < len) traverse.call(this.inputs[idx], callback, idx);

    callback(this);

    return this;
};

Material.prototype.setUniform = function setUniform(name, value) {
    this.uniforms[name] = value;

    this.invalidations.push(name);
};

/**
 * Converts material graph into chunk
 *
 * @method _compile
 * @protected
 *
 */

Material.prototype._compile = function _compile() {
    var glsl = '';
    var uniforms = {};
    var varyings = {};
    var attributes = {};
    var defines = [];
    var texture;

    this.traverse(function (node, depth) {
        if (! node.chunk) return;
        glsl += 'vec3 ' + makeLabel(node) + '=' + processGLSL(node.chunk.glsl, node.inputs) + '\n ';
        if (node.uniforms) extend(uniforms, node.uniforms);
        if (node.varyings) extend(varyings, node.varyings);
        if (node.attributes) extend(attributes, node.attributes);
        if (node.chunk.defines) defines.push(node.chunk.defines);
        if (node.texture) texture = node.texture;
    });

    return {
        _id: this._id,
        glsl: glsl + 'return ' + makeLabel(this) + ';',
        defines: defines.join('\n'),
        uniforms: uniforms,
        varyings: varyings,
        attributes: attributes,
        texture: texture
    };
};

function extend (a, b) { for (var k in b) a[k] = b[k]; }

function processGLSL(str, inputs) {
    return str.replace(/%\d/g, function (s) {
        return makeLabel(inputs[s[1]-1]);
    });
}
function makeLabel (n) {
    if (Array.isArray(n)) return arrayToVec(n);
    if (typeof n == 'object') return 'fa_' + (n._id);
    else return JSON.stringify(n);
}

function arrayToVec(array) {
    var len = array.length;
    return 'vec' + len + '(' + array.join(',')  + ')';
}

module.exports = expressions;
expressions.Material = Material;
expressions.Texture = function (source) {
    if (typeof window === 'undefined') return console.error('Texture constructor cannot be run inside of a worker');
    return expressions.image([], { texture: source });
};

},{"./TextureRegistry":321}],321:[function(require,module,exports){
'use strict';

/*
 * A singleton object that holds texture instances in a registry which
 * can be accessed by key.  Allows for texture sharing and easy referencing.
 *
 * @static
 * @class TextureRegistry
 */
var TextureRegistry = {
	registry: {},
	textureIds: 1
};

/*
 * Registers a new Texture object with a unique id and input parameters to be
 * handled by the WebGLRenderer.  If no accessor is input the texture will be 
 * created but not store in the registry.
 *
 * @method register
 *
 * @param {String} accessor Key used to later access the texture object.
 * @param {Object | Array | String} data Data to be used in the WebGLRenderer to
 * generate texture data.
 * @param {Object} options Optional parameters to affect the rendering of the
 * WebGL texture.
 *
 * @return {Object} Newly generated texture object.
 */
TextureRegistry.register = function register(accessor, data, options) {
	if (accessor) return (this.registry[accessor] = { id: this.textureIds++, __isATexture__: true, data: data, options: options });
	else return { id: this.textureIds++, data: data, __isATexture__: true, options: options };
};

/*
 * Retreives the texture object from registry.  Throws if no texture is
 * found at given key.
 *
 * @method get
 *
 * @param {String} accessor Key of a desired texture in the registry.
 *
 * @return {Object} Desired texture object.
 */
TextureRegistry.get = function get(accessor) {
	if (!this.registry[accessor]) {
		throw 'Texture "' + accessor + '" not found!';
	}
	else {
		return this.registry[accessor];
	}
}

module.exports = TextureRegistry;

},{}],322:[function(require,module,exports){
'use strict';

module.exports = {
    Material: require('./Material'),
    TextureRegistry: require('./TextureRegistry')
};
},{"./Material":320,"./TextureRegistry":321}],323:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],324:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./Mat33":323,"dup":3}],325:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],326:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],327:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"./Mat33":323,"./Quaternion":324,"./Vec2":325,"./Vec3":326,"dup":6}],328:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],329:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],330:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./Curves":328,"dup":9}],331:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],332:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"./Curves":328,"./Easing":329,"./Transitionable":330,"./after":331,"dup":11}],333:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17}],334:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"famous-transitions":332}],335:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],336:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],337:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],338:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],339:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],340:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./CallbackStore":333,"./Color":334,"./KeyCodes":335,"./MethodStore":336,"./ObjectManager":337,"./clone":338,"./flatClone":339,"./keyValueToArrays":341,"./loadURL":342,"./strip":343,"dup":24}],341:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],342:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],343:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],344:[function(require,module,exports){
arguments[4][225][0].apply(exports,arguments)
},{"./Geometry":345,"dup":225}],345:[function(require,module,exports){
arguments[4][226][0].apply(exports,arguments)
},{"dup":226}],346:[function(require,module,exports){
arguments[4][227][0].apply(exports,arguments)
},{"dup":227,"famous-math":327}],347:[function(require,module,exports){
arguments[4][228][0].apply(exports,arguments)
},{"./GeometryHelper":346,"dup":228,"famous-utilities":340}],348:[function(require,module,exports){
arguments[4][229][0].apply(exports,arguments)
},{"./DynamicGeometry":344,"./Geometry":345,"./GeometryHelper":346,"./OBJLoader":347,"./primitives/Box":349,"./primitives/Circle":350,"./primitives/Cylinder":351,"./primitives/GeodesicSphere":352,"./primitives/Icosahedron":353,"./primitives/ParametricCone":354,"./primitives/Plane":355,"./primitives/Sphere":356,"./primitives/Tetrahedron":357,"./primitives/Torus":358,"./primitives/Triangle":359,"dup":229}],349:[function(require,module,exports){
arguments[4][230][0].apply(exports,arguments)
},{"../Geometry":345,"dup":230}],350:[function(require,module,exports){
arguments[4][231][0].apply(exports,arguments)
},{"../Geometry":345,"dup":231}],351:[function(require,module,exports){
arguments[4][232][0].apply(exports,arguments)
},{"../Geometry":345,"../GeometryHelper":346,"dup":232}],352:[function(require,module,exports){
arguments[4][233][0].apply(exports,arguments)
},{"../Geometry":345,"../GeometryHelper":346,"dup":233}],353:[function(require,module,exports){
arguments[4][234][0].apply(exports,arguments)
},{"../Geometry":345,"../GeometryHelper":346,"dup":234}],354:[function(require,module,exports){
arguments[4][235][0].apply(exports,arguments)
},{"../Geometry":345,"../GeometryHelper":346,"dup":235}],355:[function(require,module,exports){
arguments[4][236][0].apply(exports,arguments)
},{"../Geometry":345,"dup":236}],356:[function(require,module,exports){
arguments[4][237][0].apply(exports,arguments)
},{"../Geometry":345,"../GeometryHelper":346,"dup":237}],357:[function(require,module,exports){
arguments[4][238][0].apply(exports,arguments)
},{"../Geometry":345,"../GeometryHelper":346,"dup":238}],358:[function(require,module,exports){
arguments[4][239][0].apply(exports,arguments)
},{"../Geometry":345,"../GeometryHelper":346,"dup":239}],359:[function(require,module,exports){
arguments[4][240][0].apply(exports,arguments)
},{"../Geometry":345,"../GeometryHelper":346,"dup":240}],360:[function(require,module,exports){
'use strict';
var Geometry = require('famous-webgl-geometries');

/**
 * The Mesh class is responsible for providing the API for how
 * a RenderNode will interact with the WebGL API by adding
 * a set of commands to the renderer.
 *
 * @class Mesh
 * @constructor
 * @renderable
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved
 * @param {object} Options Optional params for configuring Mesh
 */
function Mesh (node, options) {
    this._node = node;
    this._changeQueue = [];
    this._initialized = false;
    this._requestingUpdate = false;
    this._inDraw = false;
    this.value = {
        drawOptions: {},
        color: null,
        expressions: {},
        geometry: null,
        flatShading: false
    }

    if (options) this.setDrawOptions(options);
    this._id = node.addComponent(this);
}

/**
 * Pass custom options to Mesh, such as a 3 element map
 * which displaces the position of each vertex in world space.
 *
 * @method setDrawOptions
 * @chainable
 *
 * @param {Object} Options
 * @chainable
 */
Mesh.prototype.setDrawOptions = function setOptions (options) {
    if (this.value.drawOptions.blendMode) {
        this.value.drawOptions.blendMode = options.blendMode;
        this._changeQueue.push('GL_SET_DRAW_OPTIONS');
        this._changeQueue.push(options);
    }
    return this;
};

/**
 * Get the mesh's custom options.
 *
 * @method getDrawOptions
 * @returns {Object} Options
 */
Mesh.prototype.getDrawOptions = function getDrawOptions () {
    return this.value.drawOptions;
};

/**
 * Set the geometry of a mesh.
 *
 * @method setGeometry
 * @chainable
 *
 * @param {Geometry} geometry instance to be associated with the mesh
 * @param {Object} Options Various configurations for geometries.
 * @chainable
 */
Mesh.prototype.setGeometry = function setGeometry (geometry, options) {
    if (typeof geometry === 'string') {
        if (!Geometry[geometry]) throw 'Invalid geometry: "' + geometry + '".';
        else geometry = new Geometry[geometry](options);
    }

    if (this.value.geometry !== geometry || this._inDraw) {
        if (this._initialized) {
            this._changeQueue.push('GL_SET_GEOMETRY');
            this._changeQueue.push(geometry.id);
            this._changeQueue.push(geometry.spec.type);
            this._changeQueue.push(geometry.spec.dynamic);
        }
        if (!this._requestingUpdate) this._requestUpdate();
        this.value.geometry = geometry;
    }

    return this;
};

/**
 * Get the geometry of a mesh.
 *
 * @method getGeometry
 * @returns {Geometry} geometry Geometry of mesh
 */
Mesh.prototype.getGeometry = function getGeometry () {
    return this.value.geometry;
};

/**
* Changes the color of Mesh, passing either a material expression or
* color using the 'Color' utility component.
*
* @method setBaseColor
* @param {Object|Color} Material, image, vec3, or Color instance
* @chainable
*/
Mesh.prototype.setBaseColor = function setBaseColor (color) {
    var uniformValue;

    if (color._compile) {
        this.value.expressions.baseColor = color;
        uniformValue = color._compile(); 
    } else if (color.getNormalizedRGB) {
        this.value.expressions.baseColor = null;
        this.value.color = color;
        uniformValue = color.getNormalizedRGB();
    }

    if (this._initialized) {
        // If a material expression
        if (color._compile) {
            this._changeQueue.push('MATERIAL_INPUT');
        }

        // If a color component
        else if (color.getNormalizedRGB) {
            this._changeQueue.push('GL_UNIFORMS');
        }
        this._changeQueue.push('baseColor');
        this._changeQueue.push(uniformValue);
    }

    if (!this._requestingUpdate) this._requestUpdate();

    return this;
};

/**
 * Returns either the material expression or the color instance of Mesh.
 *
 * @method getBaseColor
 * @returns {MaterialExpress|Color}
 */
Mesh.prototype.getBaseColor = function getBaseColor () {
    return this.value.expressions.baseColor || this.value.color;
};

/**
 * Change whether the Mesh is affected by light. Default is true.
 *
 * @method setFlatShading
 * @param {boolean} Boolean
 * @chainable
 */
Mesh.prototype.setFlatShading = function setFlatShading (bool) {
    if (this._inDraw || this.value.flatShading !== bool) {
        if (this._initialized) {
            this._changeQueue.push('GL_UNIFORMS');
            this._changeQueue.push('u_flatShading');
            this._changeQueue.push(this.value.flatShading ? 1 : 0);        
        }
        this.value.flatShading = bool;
        if (!this._requestingUpdate) this._requestUpdate();
    }

    return this;
};

/**
 * Returns a boolean for whether Mesh is affected by light.
 *
 * @method getFlatShading
 * @returns {Boolean} Boolean
 */
Mesh.prototype.getFlatShading = function getFlatShading () {
    return this.value.flatShading;
};


/**
 * Defines a 3-element map which is used to provide significant physical
 * detail to the surface by perturbing the facing direction of each individual
 * pixel.
 *
 * @method normal
 * @chainable
 *
 * @param {Object|Array} Material, Image or vec3
 * @return {Element} current Mesh
 */
Mesh.prototype.setNormals = function setNormals (materialExpression) {
    if (materialExpression._compile) {
        this.value.expressions.normals = materialExpression;
        materialExpression = materialExpression._compile();
    }

    if (this._initialized) {
        this._changeQueue.push(typeof materialExpression === 'number' ? 'UNIFORM_INPUT' : 'MATERIAL_INPUT');
        this._changeQueue.push('normal');
        this._changeQueue.push(materialExpression);
    }

    if (!this._requestingUpdate) this._requestUpdate();

    return this;
};

/**
 * Returns the Normals expression of Mesh
 *
 * @method getNormals
 * @returns The normals expression for Mesh
 */
Mesh.prototype.getNormals = function getNormals (materialExpression) {
    return this.value.expressions.normals;
};

/**
 * Defines the glossiness of the mesh from either a material expression or a
 * scalar value
 *
 * @method setGlossiness
 * @param {MaterialExpression|Number}
 * @param {Object} Optional tweening parameter
 * @param {Function} Callback
 * @chainable
 */
Mesh.prototype.setGlossiness = function setGlossiness (materialExpression, transition, cb) {
    var glossiness;

    if (materialExpression._compile) {
        this.value.expressions.glossiness = materialExpression;
        glossiness = materialExpression._compile();
    }
    else {
        this.value.expressions.glossiness = null;
        this.value.glossiness = materialExpression;
        glossiness = this.value.glossiness;
    }

    if (this._initialized) {
        this._changeQueue.push(materialExpression._compile ? 'GL_UNIFORMS' : 'MATERIAL_INPUT');
        this._changeQueue.push('glossiness');
        this._changeQueue.push(glossiness);
    }

    if (!this._requestingUpdate) this._requestUpdate();

    return this;
};

/**
 * Returns material expression or scalar value for glossiness.
 *
 * @method getGlossiness
 * @returns {MaterialExpress|Number}
 */
Mesh.prototype.getGlossiness = function getGlossiness () {
    return this.value.expressions.glossiness || this.value.glossiness;
};

/**
 * Defines 3 element map which displaces the position of each vertex in world
 * space.
 *
 * @method setPositionOffset
 * @chainable
 *
 * @param {MaterialExpression|Array}
 * @param {Object} Optional tweening parameter
 * @param {Function} Callback
 * @chainable
 */
Mesh.prototype.setPositionOffset = function positionOffset (materialExpression, transition, cb) {
    var uniformValue;

    if (materialExpression._compile) {
        this.value.expressions.positionOffset = materialExpression;
        uniformValue = materialExpression._compile();
    }
    else {
        this.value.expressions.positionOffset = null;
        this.value.positionOffset = materialExpression;
        uniformValue = this.value.positionOffset;
    }

    if (this._initialized) {
        this._changeQueue.push(materialExpression._compile ? 'MATERIAL_INPUT' : 'GL_UNIFORMS');
        this._changeQueue.push('positionOffset');
        this._changeQueue.push(uniformValue);
    }

    if (!this._requestingUpdate) this._requestUpdate();

    return this;
};

/**
 * Returns position offset.
 *
 * @method getPositionOffset
 * @returns {MaterialExpress|Number}
 */
Mesh.prototype.getPositionOffset = function getPositionOffset (materialExpression) {
    return this.value.expressions.positionOffset || this.value.positionOffset;
};

/**
 * Get the mesh's custom options.
 *
 * @method getDrawOptions
 * @returns {Object} Options
 */
Mesh.prototype.getMaterialExpressions = function getMaterialExpressions () {
    return this.value.expressions;
};

Mesh.prototype.getValue = function getValue () {
    return this.value;
};

Mesh.prototype._pushInvalidations = function pushInvalidations (expressionName) {
    var uniformKey;
    var expression = this.value.expressions[expressionName];
    if (expression) {
        var i = expression.invalidations.length;
        while (i--) {
            uniformKey = expression.invalidations.pop();
            this._node.sendDrawCommand('GL_UNIFORMS');
            this._node.sendDrawCommand(uniformKey);
            this._node.sendDrawCommand(expression.uniforms[uniformKey]);
        }
    }
};

/**
* Sends draw commands to the renderer
*
* @private
* @method onUpdate
*/
Mesh.prototype.onUpdate = function onUpdate () {
    var node = this._node;
    var queue = this._changeQueue;

    if (node) {
        node.sendDrawCommand('WITH');
        node.sendDrawCommand(node.getLocation());

        if (this.value.geometry) {
        i = this.value.geometry.spec.invalidations.length;
            while (i--) {
                var bufferIndex = this.value.geometry.spec.invalidations.pop();
                node.sendDrawCommand('GL_BUFFER_DATA');
                node.sendDrawCommand(this.value.geometry.id);
                node.sendDrawCommand(this.value.geometry.spec.bufferNames[i]);
                node.sendDrawCommand(this.value.geometry.spec.bufferValues[i]);
                node.sendDrawCommand(this.value.geometry.spec.bufferSpacings[i]);
            }
        }

        // If any invalidations exist, push them into the queue
        if (this.value.color && this.value.color.isActive()) {
            this._node.sendDrawCommand('GL_UNIFORMS');
            this._node.sendDrawCommand('baseColor');
            this._node.sendDrawCommand(this.value.color.getNormalizedRGB());
            this._node.requestUpdateOnNextTick(this._id);
        } else {
            this._requestingUpdate = false;
        }

        // If any invalidations exist, push them into the queue
        this._pushInvalidations('baseColor');
        this._pushInvalidations('positionOffset');

        for (var i = 0; i < queue.length; i++) {
            node.sendDrawCommand(queue[i]);
        }

        queue.length = 0;
    }

};

Mesh.prototype.onMount = function onMount (node, id) {
    this._node = node;
    this._id = id;

    this.draw();
};

Mesh.prototype.onDismount = function onDismount () {
    this._initialized = false;
    this.onHide();
};

Mesh.prototype.onShow = function onShow () {
    //TODO
};

Mesh.prototype.onHide = function onHide () {
    //TODO
};

/**
 * Receives transform change updates from the scene graph.
 *
 * @private
 */
Mesh.prototype.onTransformChange = function onTransformChange (transform) {
    if (this._initialized) {
        this._changeQueue.push('GL_UNIFORMS');
        this._changeQueue.push('transform');
        this._changeQueue.push(transform);        
    }

    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Receives size change updates from the scene graph.
 *
 * @private
 */
Mesh.prototype.onSizeChange = function onSizeChange (size) {
    if (this._initialized) {
        this._changeQueue.push('GL_UNIFORMS');
        this._changeQueue.push('size');
        this._changeQueue.push(size);
    }

    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Receives opacity change updates from the scene graph.
 *
 * @private
 */
Mesh.prototype.onOpacityChange = function onOpacityChange (opacity) {
    if (this._initialized) {
        this._changeQueue.push('GL_UNIFORMS');
        this._changeQueue.push('opacity');
        this._changeQueue.push(opacity);
    }
    
    if (!this._requestingUpdate) this._requestUpdate();
};

Mesh.prototype.onAddUIEvent = function onAddUIEvent (UIEvent, methods, properties) {
    //TODO
};

Mesh.prototype._requestUpdate = function _requestUpdate () {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
};

Mesh.prototype.init = function init () {
    this._initialized = true;
    this.onTransformChange(this._node.getTransform());
    this.onSizeChange(this._node.getSize());
    this.onOpacityChange(this._node.getOpacity());
    if (!this._requestingUpdate) this._requestUpdate();
};

Mesh.prototype.draw = function draw () {
    var key;
    var i;
    var len;

    this._inDraw = true;

    this.init();

    var value = this.getValue();
    if (value.geometry != null) this.setGeometry(value.geometry);
    if (value.color != null) this.setBaseColor(value.color);
    if (value.drawOptions != null) this.setDrawOptions(value.drawOptions);
    if (value.flatShading != null) this.setFlatShading(value.flatShading);
    if (value.normals != null) this.setNormals(value.normals);
    if (value.glossiness != null) this.setGlossiness(value.glossiness);
    if (value.positionOffset != null) this.setPositionOffset(value.positionOffset);

    this._inDraw = false;
};

module.exports = Mesh;

},{"famous-webgl-geometries":348}],361:[function(require,module,exports){
'use strict';

module.exports = {
    Mesh: require('./Mesh'),
    PointLight: require('./lights/PointLight'),
    AmbientLight: require('./lights/AmbientLight'),
};

},{"./Mesh":360,"./lights/AmbientLight":362,"./lights/PointLight":364}],362:[function(require,module,exports){
'use strict';

var Light = require('./Light');


/**
 * AmbientLight extends the functionality of Light. It sets the ambience in
 * the scene. Ambience is a light source that emits light in the entire
 * scene, evenly.
 *
 * @class AmbientLight
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved
 * from the corresponding Render Node
 */
function AmbientLight(node) {
    Light.call(this, node);
    this.commands.color = 'GL_AMBIENT_LIGHT';
};

/**
* Returns the definition of the Class: 'AmbientLight'
*
* @method toString
* @return {string} definition
*/
AmbientLight.toString = function toString() {
    return 'AmbientLight';
};

/**
 * Extends Light constructor
 */
AmbientLight.prototype = Object.create(Light.prototype);

/**
 * Sets AmbientLight as the constructor
 */
AmbientLight.prototype.constructor = AmbientLight;

module.exports = AmbientLight;

},{"./Light":363}],363:[function(require,module,exports){
'use strict';

/**
 * The blueprint for all light components for inheriting common functionality.
 *
 * @class Light
 * @constructor
 * @component
 * @param {Node} node The controlling node
 * from the corresponding Render Node
 */
function Light(node) {
    this._node = node;
    this._id = node.addComponent(this);
    this._requestingUpdate = false;
    this.queue = [];
    this._color;
    this.commands = { color: 'GL_LIGHT_COLOR' };
};

/**
* Returns the definition of the Class: 'Light'
*
* @method toString
* @return {String} definition
*/
Light.toString = function toString() {
    return 'Light';
};

/**
* Changes the color of the light, using the 'Color' utility component.
*
* @method setColor
* @param {Color} Color instance
* @chainable
*/
Light.prototype.setColor = function setColor(color) {
    if (!color.getNormalizedRGB) return false;
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._color = color;
    this.queue.push(this.commands.color);
    var rgb = this._color.getNormalizedRGB();
    this.queue.push(rgb[0]);
    this.queue.push(rgb[1]);
    this.queue.push(rgb[2]);
    return this;
};

/**
* Returns the current color.

* @method getColor
* @returns {Color} Color.
*/
Light.prototype.getColor = function getColor(option) {
    return this._color;
};

/**
* Sends draw commands to the renderer
*
* @private
* @method onUpdate
*/
Light.prototype.onUpdate = function clean() {
    var path = this._node.getLocation();

    this._node
        .sendDrawCommand('WITH')
        .sendDrawCommand(path);

    var i = this.queue.length;
    while (i--) {
        this._node.sendDrawCommand(this.queue.shift());
    }

    if (this._color && this._color.isActive()) {
        this._node.sendDrawCommand(this.commands.color);
        var rgb = this._color.getNormalizedRGB();
        this._node.sendDrawCommand(rgb[0]);
        this._node.sendDrawCommand(rgb[1]);
        this._node.sendDrawCommand(rgb[2]);
        this._node.requestUpdateOnNextTick(this._id);
    } else {
        this._requestingUpdate = false;
    }
};

module.exports = Light;

},{}],364:[function(require,module,exports){
'use strict';

var Light = require('./Light');

/**
 * PointLight extends the functionality of Light. PointLight is a light source
 * that emits light in all directions from a point in space.
 *
 * @class PointLight
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved
 * from the corresponding Render Node
 */
function PointLight(node) {
    Light.call(this, node);
    this.commands.position = 'GL_LIGHT_POSITION';
    this.onTransformChange(node.getTransform());
};

/**
* Returns the definition of the Class: 'PointLight'
*
* @method toString
* @return {string} definition
*/
PointLight.toString = function toString() {
    return 'PointLight';
};

/**
 * Extends Light constructor
 */
PointLight.prototype = Object.create(Light.prototype);

/**
 * Sets PointLight as the constructor
 */
PointLight.prototype.constructor = PointLight;

/**
 * Receives transform change updates from the scene graph.
 *
 * @private
 */
PointLight.prototype.onTransformChange = function onTransformChange (transform) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this.queue.push(this.commands.position);
    this.queue.push(transform[12]);
    this.queue.push(transform[13]);
    this.queue.push(transform[14]);
};

module.exports = PointLight;

},{"./Light":363}],365:[function(require,module,exports){
arguments[4][241][0].apply(exports,arguments)
},{"dup":241}],366:[function(require,module,exports){
arguments[4][242][0].apply(exports,arguments)
},{"dup":242}],367:[function(require,module,exports){
arguments[4][243][0].apply(exports,arguments)
},{"dup":243,"glslify":365,"glslify/simple-adapter.js":366}],368:[function(require,module,exports){
'use strict';

var FamousPlatform = require('famous');
var Compositor = FamousPlatform.renderers.Compositor;
var ThreadManager = FamousPlatform.renderers.ThreadManager;
var Engine = FamousPlatform.engine;
var root = FamousPlatform.core.root;
var HTMLElement = FamousPlatform.domRenderables.HTMLElement;
var Famous = FamousPlatform.core.Famous;
var DOMElement = FamousPlatform.domRenderables.DOMElement;
var Size = FamousPlatform.components.Size;
var Rotation = FamousPlatform.components.Rotation;
var Align = FamousPlatform.components.Align;
var MountPoint = FamousPlatform.components.MountPoint;
var Origin = FamousPlatform.components.Origin;
var Position = FamousPlatform.components.Position;
var Clock = FamousPlatform.core.Clock;
var Easing = FamousPlatform.transitions.Curves;
var Mesh = FamousPlatform.webglRenderables.Mesh;
var Sphere = FamousPlatform.webglGeometries.Sphere;
var Color = FamousPlatform.utilities.Color;
var PointLight = FamousPlatform.webglRenderables.PointLight;
var AmbientLight = FamousPlatform.webglRenderables.AmbientLight;

//var App = require('./App.js')
// Boilerplate
var compositor = new Compositor();
var threadmanger = new ThreadManager(Famous, compositor);
var engine = new Engine();
engine.update(threadmanger);

var padding = 0;
var width = 400 - padding * 2;
var height = 150 - padding * 2;

var table = document.getElementById('easing-curve-table');
var rows = table.rows;
for (var i = 0; i < rows.length; i++) {
    var row = rows[i];
    var tds = row.querySelectorAll('td');
    if (tds.length > 0) {

        var name = tds[0].innerText || tds[0].textContent;
        var curve = Easing[name];
        // Draw the curve on the canvas.
        var canvas = document.getElementById(name + '-graph');
        canvas.width = width;
        canvas.height = height;
        var ctx = canvas.getContext('2d');
        var maxX = 100;
        var bounds = findBounds(curve, maxX);
        var minY = bounds.min;
        var maxY = bounds.max;
        var scale = maxY - minY;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        for (var t = 0; t < maxX; t++) {
            var v = curve(t / maxX);
            var x = t * (width / maxX) + padding;
            var y = height - (v - minY) / scale * height + padding;
            ctx.lineTo(~ ~x, ~ ~y);
        }
        ctx.stroke();

        // Display a demo in the container
        //var container = document.getElementById(name + '-container');
        var faContext = Famous.createContext('#' + name + '-container');
        var node = faContext.addChild();
        var size = new Size(node).setMode(1, 1).setAbsolute(40, 40);
        var align = new Align(node);
        var origin = new Origin(node).set(0.5, 0.5);
        var el = new DOMElement(node, {
            properties: {
                'background-color': '#8cd0d3'
            }
        });
        // var mesh = new Mesh(node)
        // mesh.setGeometry(new Sphere({ detail: 100 }))
        // var color = new Color().set('rgb', 32, 128, 230)
        // mesh.setBaseColor(color)

        makeAnim(align, curve);
    }
}
function makeAnim(alg, curve) {
    var goRight = function goRight() {
        alg.set(.75, 0, 0, { duration: 2000, curve: curve }, goLeft);
    };
    var goLeft = function goLeft() {
        alg.set(0, 0, 0, { duration: 2000, curve: curve }, goRight);
    };
    goRight();
}

function findBounds(fn, divisions) {
    var min = 0;
    var max = 0;
    for (var i = 0; i < divisions; i++) {
        var n = fn(i / divisions);
        if (max < n) max = n;
        if (min > n) min = n;
    }
    return { min: min, max: max };
}

},{"famous":1}]},{},[368])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtbWF0aC9zcmMvTWF0MzMuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLW1hdGgvc3JjL1F1YXRlcm5pb24uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLW1hdGgvc3JjL1ZlYzIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLW1hdGgvc3JjL1ZlYzMuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLW1hdGgvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy10cmFuc2l0aW9ucy9zcmMvQ3VydmVzLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy10cmFuc2l0aW9ucy9zcmMvRWFzaW5nLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy10cmFuc2l0aW9ucy9zcmMvVHJhbnNpdGlvbmFibGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXRyYW5zaXRpb25zL3NyYy9hZnRlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtdHJhbnNpdGlvbnMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy11dGlsaXRpZXMvc3JjL0NhbGxiYWNrU3RvcmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXV0aWxpdGllcy9zcmMvQ29sb3IuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXV0aWxpdGllcy9zcmMvS2V5Q29kZXMuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXV0aWxpdGllcy9zcmMvTWV0aG9kU3RvcmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXV0aWxpdGllcy9zcmMvT2JqZWN0TWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtdXRpbGl0aWVzL3NyYy9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtdXRpbGl0aWVzL3NyYy9mbGF0Q2xvbmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXV0aWxpdGllcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXV0aWxpdGllcy9zcmMva2V5VmFsdWVUb0FycmF5cy5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtdXRpbGl0aWVzL3NyYy9sb2FkVVJMLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy11dGlsaXRpZXMvc3JjL3N0cmlwLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvc3JjL0FsaWduLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvc3JjL0NhbWVyYS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL3NyYy9FdmVudEVtaXR0ZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvRXZlbnRIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvc3JjL0dlc3R1cmVIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvc3JjL01vdW50UG9pbnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvT3BhY2l0eS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL3NyYy9PcmlnaW4uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvUG9zaXRpb24uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvU2NhbGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvU2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL3NyYy9VSUV2ZW50SGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb3JlL3NyYy9DbG9jay5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb3JlL3NyYy9Db250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvcmUvc3JjL0Rpc3BhdGNoZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29yZS9zcmMvRXZlbnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29yZS9zcmMvRmFtb3VzLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvcmUvc3JjL05vZGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29yZS9zcmMvU2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb3JlL3NyYy9UcmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29yZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtZG9tLXJlbmRlcmFibGVzL3NyYy9ET01FbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWRvbS1yZW5kZXJhYmxlcy9zcmMvSFRNTEVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtZG9tLXJlbmRlcmFibGVzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2ZhbW91cy1wb2x5ZmlsbHMvc3JjL2FuaW1hdGlvbkZyYW1lLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWVuZ2luZS9ub2RlX21vZHVsZXMvZmFtb3VzLXBvbHlmaWxscy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtZW5naW5lL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9HZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9QaHlzaWNzRW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2JvZGllcy9Cb3guanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvYm9kaWVzL0NvbnZleEJvZHlGYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2JvZGllcy9QYXJ0aWNsZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9ib2RpZXMvU3BoZXJlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2JvZGllcy9XYWxsLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2NvbnN0cmFpbnRzL0FuZ2xlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2NvbnN0cmFpbnRzL0NvbGxpc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9Db25zdHJhaW50LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2NvbnN0cmFpbnRzL0N1cnZlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2NvbnN0cmFpbnRzL0RpcmVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9EaXN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9IaW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9Qb2ludDJQb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9jb2xsaXNpb24vQUFCQi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9jb2xsaXNpb24vQnJ1dGVGb3JjZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9jb2xsaXNpb24vQ29udGFjdE1hbmlmb2xkLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2NvbnN0cmFpbnRzL2NvbGxpc2lvbi9Db252ZXhDb2xsaXNpb25EZXRlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvY29uc3RyYWludHMvY29sbGlzaW9uL1N3ZWVwQW5kUHJ1bmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvZm9yY2VzL0RyYWcuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvZm9yY2VzL0ZvcmNlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2ZvcmNlcy9HcmF2aXR5MUQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvZm9yY2VzL0dyYXZpdHkzRC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9mb3JjZXMvUm90YXRpb25hbERyYWcuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvZm9yY2VzL1JvdGF0aW9uYWxTcHJpbmcuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvZm9yY2VzL1NwcmluZy5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1kb20tcmVuZGVyZXJzL3NyYy9ET01SZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1kb20tcmVuZGVyZXJzL3NyYy9FbGVtZW50Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtZG9tLXJlbmRlcmVycy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtZ2VvbWV0cmllcy9zcmMvRHluYW1pY0dlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMvc3JjL0dlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMvc3JjL0dlb21ldHJ5SGVscGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMvc3JjL09CSkxvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzL3NyYy9wcmltaXRpdmVzL0JveC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzL3NyYy9wcmltaXRpdmVzL0NpcmNsZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzL3NyYy9wcmltaXRpdmVzL0N5bGluZGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMvc3JjL3ByaW1pdGl2ZXMvR2VvZGVzaWNTcGhlcmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtZ2VvbWV0cmllcy9zcmMvcHJpbWl0aXZlcy9JY29zYWhlZHJvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzL3NyYy9wcmltaXRpdmVzL1BhcmFtZXRyaWNDb25lLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMvc3JjL3ByaW1pdGl2ZXMvUGxhbmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtZ2VvbWV0cmllcy9zcmMvcHJpbWl0aXZlcy9TcGhlcmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtZ2VvbWV0cmllcy9zcmMvcHJpbWl0aXZlcy9UZXRyYWhlZHJvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzL3NyYy9wcmltaXRpdmVzL1RvcnVzLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMvc3JjL3ByaW1pdGl2ZXMvVHJpYW5nbGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtc2hhZGVycy9ub2RlX21vZHVsZXMvZ2xzbGlmeS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXNoYWRlcnMvbm9kZV9tb2R1bGVzL2dsc2xpZnkvc2ltcGxlLWFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtc2hhZGVycy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL3NyYy9CdWZmZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL3NyYy9CdWZmZXJSZWdpc3RyeS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvc3JjL0NoZWNrZXJib2FyZC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvc3JjL1Byb2dyYW0uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL3NyYy9UZXh0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9zcmMvV2ViR0xSZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9zcmMvcmFkaXhTb3J0LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9zcmMvQ29tcG9zaXRvci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvc3JjL0NvbnRleHQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL3NyYy9UaHJlYWRNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcm91dGVyL3NyYy9IaXN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJvdXRlci9zcmMvUm91dGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJvdXRlci9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtc3R5bGVzaGVldHMvbm9kZV9tb2R1bGVzL2Nzc2lmeS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXN0eWxlc2hlZXRzL3NyYy9mYW1vdXMuY3NzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXN0eWxlc2hlZXRzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1tYXRlcmlhbHMvc3JjL01hdGVyaWFsLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLW1hdGVyaWFscy9zcmMvVGV4dHVyZVJlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLW1hdGVyaWFscy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyYWJsZXMvc3JjL01lc2guanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyYWJsZXMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmFibGVzL3NyYy9saWdodHMvQW1iaWVudExpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmFibGVzL3NyYy9saWdodHMvTGlnaHQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyYWJsZXMvc3JjL2xpZ2h0cy9Qb2ludExpZ2h0LmpzIiwiL1VzZXJzL21vcmdhbnRoZXBsYW50L0Rlc2t0b3AvZWFzaW5nL3NyYy9tYWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3poQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2p3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekRBLFlBQVksQ0FBQzs7QUFFYixJQUFJLGNBQWMsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDdkMsSUFBSSxVQUFVLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUM7QUFDckQsSUFBSSxhQUFhLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUM7QUFDM0QsSUFBSSxNQUFNLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQztBQUNuQyxJQUFJLElBQUksR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztBQUNwQyxJQUFJLFdBQVcsR0FBRyxjQUFjLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQztBQUM1RCxJQUFJLE1BQU0sR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztBQUN4QyxJQUFJLFVBQVUsR0FBRyxjQUFjLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQztBQUMxRCxJQUFJLElBQUksR0FBRyxjQUFjLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztBQUMxQyxJQUFJLFFBQVEsR0FBRyxjQUFjLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQztBQUNsRCxJQUFJLEtBQUssR0FBRyxjQUFjLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQztBQUM1QyxJQUFJLFVBQVUsR0FBRyxjQUFjLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztBQUN0RCxJQUFJLE1BQU0sR0FBRyxjQUFjLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQztBQUM5QyxJQUFJLFFBQVEsR0FBRyxjQUFjLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQztBQUNsRCxJQUFJLEtBQUssR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQTtBQUNyQyxJQUFJLE1BQU0sR0FBRyxjQUFjLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQztBQUMvQyxJQUFJLElBQUksR0FBRyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDO0FBQ2hELElBQUksTUFBTSxHQUFHLGNBQWMsQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDO0FBQ25ELElBQUksS0FBSyxHQUFHLGNBQWMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO0FBQzNDLElBQUksVUFBVSxHQUFHLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUM7QUFDNUQsSUFBSSxZQUFZLEdBQUcsY0FBYyxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQzs7OztBQUloRSxJQUFJLFVBQVUsR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDO0FBQ2xDLElBQUksWUFBWSxHQUFHLElBQUksYUFBYSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztBQUN6RCxJQUFJLE1BQU0sR0FBRyxJQUFJLE1BQU0sRUFBRSxDQUFDO0FBQzFCLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7O0FBRzVCLElBQUksT0FBTyxHQUFHLENBQUMsQ0FBQztBQUNoQixJQUFJLEtBQUssR0FBRyxHQUFHLEdBQUcsT0FBTyxHQUFHLENBQUMsQ0FBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsT0FBTyxHQUFHLENBQUMsQ0FBQzs7QUFFL0IsSUFBSSxLQUFLLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBQzFELElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUM7QUFDdEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDbEMsUUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xCLFFBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNyQyxRQUFJLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFOztBQUdoQixZQUFJLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUE7QUFDakQsWUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUV6QixZQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQztBQUN0RCxjQUFNLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNyQixjQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztBQUN2QixZQUFJLEdBQUcsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2xDLFlBQUksSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUNmLFlBQUksTUFBTSxHQUFHLFVBQVUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDckMsWUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQztBQUN0QixZQUFJLElBQUksR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDO0FBQ3RCLFlBQUksS0FBSyxHQUFJLElBQUksR0FBRyxJQUFJLEFBQUMsQ0FBQztBQUMxQixXQUFHLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQztBQUN6QixXQUFHLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztBQUNsQixXQUFHLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUN0QixXQUFHLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDaEIsYUFBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMzQixnQkFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUN4QixnQkFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUEsQUFBQyxHQUFHLE9BQU8sQ0FBQztBQUNyQyxnQkFBSSxDQUFDLEdBQUcsTUFBTSxHQUFHLEFBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFBLEdBQUksS0FBSyxHQUFJLE1BQU0sR0FBRyxPQUFPLENBQUM7QUFDekQsZUFBRyxDQUFDLE1BQU0sQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN4QjtBQUNELFdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQzs7OztBQUliLFlBQUksU0FBUyxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxHQUFDLElBQUksR0FBRyxZQUFZLENBQUMsQ0FBQTtBQUM3RCxZQUFJLElBQUksR0FBRyxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUE7QUFDL0IsWUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsRUFBRSxFQUFDLEVBQUUsQ0FBQyxDQUFBO0FBQ3pELFlBQUksS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQzNCLFlBQUksTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUMsR0FBRyxDQUFDLENBQUE7QUFDMUMsWUFBSSxFQUFFLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxFQUFDO0FBQzNCLHNCQUFVLEVBQUM7QUFDVCxrQ0FBa0IsRUFBRSxTQUFTO2FBQzlCO1NBQ0YsQ0FBQyxDQUFBOzs7Ozs7QUFNRixnQkFBUSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztLQUMxQjtDQUNKO0FBQ0QsU0FBUyxRQUFRLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRTtBQUMxQixRQUFJLE9BQU8sR0FBRyxTQUFWLE9BQU8sR0FBYztBQUNwQixXQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDbkUsQ0FBQTtBQUNDLFFBQUksTUFBTSxHQUFHLFNBQVQsTUFBTSxHQUFjO0FBQUUsV0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBQyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0tBQUUsQ0FBQTtBQUN2RixXQUFPLEVBQUUsQ0FBQztDQUNiOztBQUVELFNBQVMsVUFBVSxDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUU7QUFDL0IsUUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ1osUUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ1osU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNoQyxZQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDO0FBQzFCLFlBQUksR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ3JCLFlBQUksR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0tBQ3hCO0FBQ0QsV0FBTyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO0NBQ2pDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbXBvbmVudHM6IHJlcXVpcmUoJ2ZhbW91cy1jb21wb25lbnRzJyksXG4gICAgY29yZTogcmVxdWlyZSgnZmFtb3VzLWNvcmUnKSxcbiAgICBlbmdpbmU6IHJlcXVpcmUoJ2ZhbW91cy1lbmdpbmUnKSxcbiAgICBkb21SZW5kZXJhYmxlczogcmVxdWlyZSgnZmFtb3VzLWRvbS1yZW5kZXJhYmxlcycpLFxuICAgIG1hdGg6IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJyksXG4gICAgcGh5c2ljczogcmVxdWlyZSgnZmFtb3VzLXBoeXNpY3MnKSxcbiAgICByZW5kZXJlcnM6IHJlcXVpcmUoJ2ZhbW91cy1yZW5kZXJlcnMnKSxcbiAgICBzdHlsZXNoZWV0czogcmVxdWlyZSgnZmFtb3VzLXN0eWxlc2hlZXRzJyksXG4gICAgcm91dGVyOiByZXF1aXJlKCdmYW1vdXMtcm91dGVyJyksXG4gICAgdHJhbnNpdGlvbnM6IHJlcXVpcmUoJ2ZhbW91cy10cmFuc2l0aW9ucycpLFxuICAgIHV0aWxpdGllczogcmVxdWlyZSgnZmFtb3VzLXV0aWxpdGllcycpLFxuICAgIHdlYmdsUmVuZGVyYWJsZXM6IHJlcXVpcmUoJ2ZhbW91cy13ZWJnbC1yZW5kZXJhYmxlcycpLFxuICAgIHdlYmdsR2VvbWV0cmllczogcmVxdWlyZSgnZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMnKSxcbiAgICB3ZWJnbE1hdGVyaWFsczogcmVxdWlyZSgnZmFtb3VzLXdlYmdsLW1hdGVyaWFscycpLFxuICAgIHdlYmdsU2hhZGVyczogcmVxdWlyZSgnZmFtb3VzLXdlYmdsLXNoYWRlcnMnKSxcbiAgICBwb2x5ZmlsbHM6IHJlcXVpcmUoJ2ZhbW91cy1wb2x5ZmlsbHMnKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIDN4MyBudW1lcmljYWwgbWF0cml4LCByZXByZXNlbnRlZCBhcyBhbiBhcnJheS5cbiAqXG4gKiBAY2xhc3MgTWF0MzNcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7TnVtYmVyW119IHZhbHVlc1xuICovXG5mdW5jdGlvbiBNYXQzMyh2YWx1ZXMpIHtcbiAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcyB8fCBbMSwwLDAsMCwxLDAsMCwwLDFdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSB2YWx1ZXMgaW4gdGhlIE1hdDMzIGFzIGFuIGFycmF5LlxuICpcbiAqIEBtZXRob2QgZ2V0XG4gKiBAcmV0dXJuIHtOdW1iZXJbXX0gbWF0cml4IHZhbHVlcyBhcyBhcnJheSBvZiByb3dzLlxuICovXG5NYXQzMy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZXMgb2YgdGhlIGN1cnJlbnQgTWF0MzMuXG4gKlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7TnVtYmVyW119IHZhbHVlcyBBcnJheSBvZiBuaW5lIG51bWJlcnMgdG8gc2V0IGluIHRoZSBNYXQzMy5cbiAqIEBjaGFpbmFibGVcbiAqL1xuTWF0MzMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCh2YWx1ZXMpIHtcbiAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIG9mIHRoZSBpbnB1dCBNYXQzMy5cbiAqXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7TWF0MzN9IG1hdHJpeCBUaGUgTWF0MzMgdG8gY29weS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuTWF0MzMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5KG1hdHJpeCkge1xuICAgIHZhciBBID0gdGhpcy52YWx1ZXM7XG4gICAgdmFyIEIgPSBtYXRyaXgudmFsdWVzO1xuXG4gICAgQVswXSA9IEJbMF07XG4gICAgQVsxXSA9IEJbMV07XG4gICAgQVsyXSA9IEJbMl07XG4gICAgQVszXSA9IEJbM107XG4gICAgQVs0XSA9IEJbNF07XG4gICAgQVs1XSA9IEJbNV07XG4gICAgQVs2XSA9IEJbNl07XG4gICAgQVs3XSA9IEJbN107XG4gICAgQVs4XSA9IEJbOF07XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVGFrZSB0aGlzIE1hdDMzIGFzIEEsIGlucHV0IHZlY3RvciBWIGFzIGEgY29sdW1uIHZlY3RvciwgYW5kIHJldHVybiBNYXQzMyBwcm9kdWN0IChBKShWKS5cbiAqXG4gKiBAbWV0aG9kIHZlY3Rvck11bHRpcGx5XG4gKiBAcGFyYW0ge1ZlYzN9IHYgVmVjdG9yIHRvIHJvdGF0ZS5cbiAqIEBwYXJhbSB7VmVjM30gb3V0cHV0IFZlYzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBpbnB1dCB2ZWN0b3IgYWZ0ZXIgbXVsdGlwbGljYXRpb24uXG4gKi9cbk1hdDMzLnByb3RvdHlwZS52ZWN0b3JNdWx0aXBseSA9IGZ1bmN0aW9uIHZlY3Rvck11bHRpcGx5KHYsIG91dHB1dCkge1xuICAgIHZhciBNID0gdGhpcy52YWx1ZXM7XG4gICAgdmFyIHYwID0gdi54O1xuICAgIHZhciB2MSA9IHYueTtcbiAgICB2YXIgdjIgPSB2Lno7XG5cbiAgICBvdXRwdXQueCA9IE1bMF0qdjAgKyBNWzFdKnYxICsgTVsyXSp2MjtcbiAgICBvdXRwdXQueSA9IE1bM10qdjAgKyBNWzRdKnYxICsgTVs1XSp2MjtcbiAgICBvdXRwdXQueiA9IE1bNl0qdjAgKyBNWzddKnYxICsgTVs4XSp2MjtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHRoZSBwcm92aWRlZCBNYXQzMyB3aXRoIHRoZSBjdXJyZW50IE1hdDMzLiAgUmVzdWx0IGlzICh0aGlzKSAqIChtYXRyaXgpLlxuICpcbiAqIEBtZXRob2QgbXVsdGlwbHlcbiAqIEBwYXJhbSB7TWF0MzN9IG1hdHJpeCBJbnB1dCBNYXQzMyB0byBtdWx0aXBseSBvbiB0aGUgcmlnaHQuXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1hdDMzLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG1hdHJpeCkge1xuICAgIHZhciBBID0gdGhpcy52YWx1ZXM7XG4gICAgdmFyIEIgPSBtYXRyaXgudmFsdWVzO1xuXG4gICAgdmFyIEEwID0gQVswXTtcbiAgICB2YXIgQTEgPSBBWzFdO1xuICAgIHZhciBBMiA9IEFbMl07XG4gICAgdmFyIEEzID0gQVszXTtcbiAgICB2YXIgQTQgPSBBWzRdO1xuICAgIHZhciBBNSA9IEFbNV07XG4gICAgdmFyIEE2ID0gQVs2XTtcbiAgICB2YXIgQTcgPSBBWzddO1xuICAgIHZhciBBOCA9IEFbOF07XG5cbiAgICB2YXIgQjAgPSBCWzBdO1xuICAgIHZhciBCMSA9IEJbMV07XG4gICAgdmFyIEIyID0gQlsyXTtcbiAgICB2YXIgQjMgPSBCWzNdO1xuICAgIHZhciBCNCA9IEJbNF07XG4gICAgdmFyIEI1ID0gQls1XTtcbiAgICB2YXIgQjYgPSBCWzZdO1xuICAgIHZhciBCNyA9IEJbN107XG4gICAgdmFyIEI4ID0gQls4XTtcblxuICAgIEFbMF0gPSBBMCpCMCArIEExKkIzICsgQTIqQjY7XG4gICAgQVsxXSA9IEEwKkIxICsgQTEqQjQgKyBBMipCNztcbiAgICBBWzJdID0gQTAqQjIgKyBBMSpCNSArIEEyKkI4O1xuICAgIEFbM10gPSBBMypCMCArIEE0KkIzICsgQTUqQjY7XG4gICAgQVs0XSA9IEEzKkIxICsgQTQqQjQgKyBBNSpCNztcbiAgICBBWzVdID0gQTMqQjIgKyBBNCpCNSArIEE1KkI4O1xuICAgIEFbNl0gPSBBNipCMCArIEE3KkIzICsgQTgqQjY7XG4gICAgQVs3XSA9IEE2KkIxICsgQTcqQjQgKyBBOCpCNztcbiAgICBBWzhdID0gQTYqQjIgKyBBNypCNSArIEE4KkI4O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZXMgdGhlIE1hdDMzLlxuICpcbiAqIEBtZXRob2QgdHJhbnNwb3NlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1hdDMzLnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UoKSB7XG4gICAgdmFyIE0gPSB0aGlzLnZhbHVlcztcblxuICAgIHZhciBNMSA9IE1bMV07XG4gICAgdmFyIE0yID0gTVsyXTtcbiAgICB2YXIgTTMgPSBNWzNdO1xuICAgIHZhciBNNSA9IE1bNV07XG4gICAgdmFyIE02ID0gTVs2XTtcbiAgICB2YXIgTTcgPSBNWzddO1xuXG4gICAgTVsxXSA9IE0zO1xuICAgIE1bMl0gPSBNNjtcbiAgICBNWzNdID0gTTE7XG4gICAgTVs1XSA9IE03O1xuICAgIE1bNl0gPSBNMjtcbiAgICBNWzddID0gTTU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVGhlIGRldGVybWluYW50IG9mIHRoZSBNYXQzMy5cbiAqXG4gKiBAbWV0aG9kIGdldERldGVybWluYW50XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkZXRlcm1pbmFudC5cbiAqL1xuTWF0MzMucHJvdG90eXBlLmdldERldGVybWluYW50ID0gZnVuY3Rpb24gZ2V0RGV0ZXJtaW5hbnQoKSB7XG4gICAgdmFyIE0gPSB0aGlzLnZhbHVlcztcblxuICAgIHZhciBNMyA9IE1bM107XG4gICAgdmFyIE00ID0gTVs0XTtcbiAgICB2YXIgTTUgPSBNWzVdO1xuICAgIHZhciBNNiA9IE1bNl07XG4gICAgdmFyIE03ID0gTVs3XTtcbiAgICB2YXIgTTggPSBNWzhdO1xuXG4gICAgdmFyIGRldCA9IE1bMF0qKE00Kk04IC0gTTUqTTcpXG4gICAgICAgICAgICAtIE1bMV0qKE0zKk04IC0gTTUqTTYpXG4gICAgICAgICAgICArIE1bMl0qKE0zKk03IC0gTTQqTTYpO1xuXG4gICAgcmV0dXJuIGRldDtcbn07XG5cbi8qKlxuICogVGhlIGludmVyc2Ugb2YgdGhlIE1hdDMzLlxuICpcbiAqIEBtZXRob2QgaW52ZXJzZVxuICogQGNoYWluYWJsZVxuICovXG5NYXQzMy5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uIGludmVyc2UoKSB7XG4gICAgdmFyIE0gPSB0aGlzLnZhbHVlcztcblxuICAgIHZhciBNMCA9IE1bMF07XG4gICAgdmFyIE0xID0gTVsxXTtcbiAgICB2YXIgTTIgPSBNWzJdO1xuICAgIHZhciBNMyA9IE1bM107XG4gICAgdmFyIE00ID0gTVs0XTtcbiAgICB2YXIgTTUgPSBNWzVdO1xuICAgIHZhciBNNiA9IE1bNl07XG4gICAgdmFyIE03ID0gTVs3XTtcbiAgICB2YXIgTTggPSBNWzhdO1xuXG4gICAgdmFyIGRldCA9IE0wKihNNCpNOCAtIE01Kk03KVxuICAgICAgICAgICAgLSBNMSooTTMqTTggLSBNNSpNNilcbiAgICAgICAgICAgICsgTTIqKE0zKk03IC0gTTQqTTYpO1xuXG4gICAgaWYgKE1hdGguYWJzKGRldCkgPCAxZS00MCkgcmV0dXJuIG51bGw7XG5cbiAgICBkZXQgPSAxIC8gZGV0O1xuXG4gICAgTVswXSA9IChNNCpNOCAtIE01Kk03KSAqIGRldDtcbiAgICBNWzNdID0gKC1NMypNOCArIE01Kk02KSAqIGRldDtcbiAgICBNWzZdID0gKE0zKk03IC0gTTQqTTYpICogZGV0O1xuICAgIE1bMV0gPSAoLU0xKk04ICsgTTIqTTcpICogZGV0O1xuICAgIE1bNF0gPSAoTTAqTTggLSBNMipNNikgKiBkZXQ7XG4gICAgTVs3XSA9ICgtTTAqTTcgKyBNMSpNNikgKiBkZXQ7XG4gICAgTVsyXSA9IChNMSpNNSAtIE0yKk00KSAqIGRldDtcbiAgICBNWzVdID0gKC1NMCpNNSArIE0yKk0zKSAqIGRldDtcbiAgICBNWzhdID0gKE0wKk00IC0gTTEqTTMpICogZGV0O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb25lcyB0aGUgaW5wdXQgTWF0MzMuXG4gKlxuICogQG1ldGhvZCBjbG9uZVxuICogQHBhcmFtIHtNYXQzM30gbSBNYXQzMyB0byBjbG9uZS5cbiAqIEByZXR1cm4ge01hdDMzfSBOZXcgY29weSBvZiB0aGUgb3JpZ2luYWwgTWF0MzMuXG4gKi9cbk1hdDMzLmNsb25lID0gZnVuY3Rpb24gY2xvbmUobSkge1xuICAgIHJldHVybiBuZXcgTWF0MzMobS52YWx1ZXMuc2xpY2UoKSk7XG59O1xuXG4vKipcbiAqIFRoZSBpbnZlcnNlIG9mIHRoZSBNYXQzMy5cbiAqXG4gKiBAbWV0aG9kIGludmVyc2VcbiAqIEBwYXJhbSB7TWF0MzN9IG1hdHJpeCBNYXQzMyB0byBpbnZlcnQuXG4gKiBAcGFyYW0ge01hdDMzfSBvdXRwdXQgTWF0MzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge01hdDMzfSBUaGUgTWF0MzMgYWZ0ZXIgdGhlIGludmVydC5cbiAqL1xuTWF0MzMuaW52ZXJzZSA9IGZ1bmN0aW9uIGludmVyc2UobWF0cml4LCBvdXRwdXQpIHtcbiAgICB2YXIgTSA9IG1hdHJpeC52YWx1ZXM7XG4gICAgdmFyIHJlc3VsdCA9IG91dHB1dC52YWx1ZXM7XG5cbiAgICB2YXIgTTAgPSBNWzBdO1xuICAgIHZhciBNMSA9IE1bMV07XG4gICAgdmFyIE0yID0gTVsyXTtcbiAgICB2YXIgTTMgPSBNWzNdO1xuICAgIHZhciBNNCA9IE1bNF07XG4gICAgdmFyIE01ID0gTVs1XTtcbiAgICB2YXIgTTYgPSBNWzZdO1xuICAgIHZhciBNNyA9IE1bN107XG4gICAgdmFyIE04ID0gTVs4XTtcblxuICAgIHZhciBkZXQgPSBNMCooTTQqTTggLSBNNSpNNylcbiAgICAgICAgICAgIC0gTTEqKE0zKk04IC0gTTUqTTYpXG4gICAgICAgICAgICArIE0yKihNMypNNyAtIE00Kk02KTtcblxuICAgIGlmIChNYXRoLmFicyhkZXQpIDwgMWUtNDApIHJldHVybiBudWxsO1xuXG4gICAgZGV0ID0gMSAvIGRldDtcblxuICAgIHJlc3VsdFswXSA9IChNNCpNOCAtIE01Kk03KSAqIGRldDtcbiAgICByZXN1bHRbM10gPSAoLU0zKk04ICsgTTUqTTYpICogZGV0O1xuICAgIHJlc3VsdFs2XSA9IChNMypNNyAtIE00Kk02KSAqIGRldDtcbiAgICByZXN1bHRbMV0gPSAoLU0xKk04ICsgTTIqTTcpICogZGV0O1xuICAgIHJlc3VsdFs0XSA9IChNMCpNOCAtIE0yKk02KSAqIGRldDtcbiAgICByZXN1bHRbN10gPSAoLU0wKk03ICsgTTEqTTYpICogZGV0O1xuICAgIHJlc3VsdFsyXSA9IChNMSpNNSAtIE0yKk00KSAqIGRldDtcbiAgICByZXN1bHRbNV0gPSAoLU0wKk01ICsgTTIqTTMpICogZGV0O1xuICAgIHJlc3VsdFs4XSA9IChNMCpNNCAtIE0xKk0zKSAqIGRldDtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZXMgdGhlIE1hdDMzLlxuICpcbiAqIEBtZXRob2QgdHJhbnNwb3NlXG4gKiBAcGFyYW0ge01hdDMzfSBtYXRyaXggTWF0MzMgdG8gdHJhbnNwb3NlLlxuICogQHBhcmFtIHtNYXQzM30gb3V0cHV0IE1hdDMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtNYXQzM30gVGhlIE1hdDMzIGFmdGVyIHRoZSB0cmFuc3Bvc2UuXG4gKi9cbk1hdDMzLnRyYW5zcG9zZSA9IGZ1bmN0aW9uIHRyYW5zcG9zZShtYXRyaXgsIG91dHB1dCkge1xuICAgIHZhciBNID0gbWF0cml4LnZhbHVlcztcbiAgICB2YXIgcmVzdWx0ID0gb3V0cHV0LnZhbHVlcztcblxuICAgIHZhciBNMCA9IE1bMF07XG4gICAgdmFyIE0xID0gTVsxXTtcbiAgICB2YXIgTTIgPSBNWzJdO1xuICAgIHZhciBNMyA9IE1bM107XG4gICAgdmFyIE00ID0gTVs0XTtcbiAgICB2YXIgTTUgPSBNWzVdO1xuICAgIHZhciBNNiA9IE1bNl07XG4gICAgdmFyIE03ID0gTVs3XTtcbiAgICB2YXIgTTggPSBNWzhdO1xuXG4gICAgcmVzdWx0WzBdID0gTTA7XG4gICAgcmVzdWx0WzFdID0gTTM7XG4gICAgcmVzdWx0WzJdID0gTTY7XG4gICAgcmVzdWx0WzNdID0gTTE7XG4gICAgcmVzdWx0WzRdID0gTTQ7XG4gICAgcmVzdWx0WzVdID0gTTc7XG4gICAgcmVzdWx0WzZdID0gTTI7XG4gICAgcmVzdWx0WzddID0gTTU7XG4gICAgcmVzdWx0WzhdID0gTTg7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIHByb3ZpZGVkIE1hdDMzJ3MuXG4gKlxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7TWF0MzN9IG1hdHJpeDEgVGhlIGxlZnQgTWF0MzMuXG4gKiBAcGFyYW0ge01hdDMzfSBtYXRyaXgyIFRoZSByaWdodCBNYXQzMy5cbiAqIEBwYXJhbSB7TWF0MzN9IG91dHB1dCBNYXQzMyBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7TWF0MzN9IFRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uLlxuICovXG5NYXQzMy5hZGQgPSBmdW5jdGlvbiBhZGQobWF0cml4MSwgbWF0cml4Miwgb3V0cHV0KSB7XG4gICAgdmFyIEEgPSBtYXRyaXgxLnZhbHVlcztcbiAgICB2YXIgQiA9IG1hdHJpeDIudmFsdWVzO1xuICAgIHZhciByZXN1bHQgPSBvdXRwdXQudmFsdWVzO1xuXG4gICAgdmFyIEEwID0gQVswXTtcbiAgICB2YXIgQTEgPSBBWzFdO1xuICAgIHZhciBBMiA9IEFbMl07XG4gICAgdmFyIEEzID0gQVszXTtcbiAgICB2YXIgQTQgPSBBWzRdO1xuICAgIHZhciBBNSA9IEFbNV07XG4gICAgdmFyIEE2ID0gQVs2XTtcbiAgICB2YXIgQTcgPSBBWzddO1xuICAgIHZhciBBOCA9IEFbOF07XG5cbiAgICB2YXIgQjAgPSBCWzBdO1xuICAgIHZhciBCMSA9IEJbMV07XG4gICAgdmFyIEIyID0gQlsyXTtcbiAgICB2YXIgQjMgPSBCWzNdO1xuICAgIHZhciBCNCA9IEJbNF07XG4gICAgdmFyIEI1ID0gQls1XTtcbiAgICB2YXIgQjYgPSBCWzZdO1xuICAgIHZhciBCNyA9IEJbN107XG4gICAgdmFyIEI4ID0gQls4XTtcblxuICAgIHJlc3VsdFswXSA9IEEwICsgQjA7XG4gICAgcmVzdWx0WzFdID0gQTEgKyBCMTtcbiAgICByZXN1bHRbMl0gPSBBMiArIEIyO1xuICAgIHJlc3VsdFszXSA9IEEzICsgQjM7XG4gICAgcmVzdWx0WzRdID0gQTQgKyBCNDtcbiAgICByZXN1bHRbNV0gPSBBNSArIEI1O1xuICAgIHJlc3VsdFs2XSA9IEE2ICsgQjY7XG4gICAgcmVzdWx0WzddID0gQTcgKyBCNztcbiAgICByZXN1bHRbOF0gPSBBOCArIEI4O1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3QgdGhlIHByb3ZpZGVkIE1hdDMzJ3MuXG4gKlxuICogQG1ldGhvZCBzdWJ0cmFjdFxuICogQHBhcmFtIHtNYXQzM30gbWF0cml4MSBUaGUgbGVmdCBNYXQzMy5cbiAqIEBwYXJhbSB7TWF0MzN9IG1hdHJpeDIgVGhlIHJpZ2h0IE1hdDMzLlxuICogQHBhcmFtIHtNYXQzM30gb3V0cHV0IE1hdDMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtNYXQzM30gVGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24uXG4gKi9cbk1hdDMzLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3QobWF0cml4MSwgbWF0cml4Miwgb3V0cHV0KSB7XG4gICAgdmFyIEEgPSBtYXRyaXgxLnZhbHVlcztcbiAgICB2YXIgQiA9IG1hdHJpeDIudmFsdWVzO1xuICAgIHZhciByZXN1bHQgPSBvdXRwdXQudmFsdWVzO1xuXG4gICAgdmFyIEEwID0gQVswXTtcbiAgICB2YXIgQTEgPSBBWzFdO1xuICAgIHZhciBBMiA9IEFbMl07XG4gICAgdmFyIEEzID0gQVszXTtcbiAgICB2YXIgQTQgPSBBWzRdO1xuICAgIHZhciBBNSA9IEFbNV07XG4gICAgdmFyIEE2ID0gQVs2XTtcbiAgICB2YXIgQTcgPSBBWzddO1xuICAgIHZhciBBOCA9IEFbOF07XG5cbiAgICB2YXIgQjAgPSBCWzBdO1xuICAgIHZhciBCMSA9IEJbMV07XG4gICAgdmFyIEIyID0gQlsyXTtcbiAgICB2YXIgQjMgPSBCWzNdO1xuICAgIHZhciBCNCA9IEJbNF07XG4gICAgdmFyIEI1ID0gQls1XTtcbiAgICB2YXIgQjYgPSBCWzZdO1xuICAgIHZhciBCNyA9IEJbN107XG4gICAgdmFyIEI4ID0gQls4XTtcblxuICAgIHJlc3VsdFswXSA9IEEwIC0gQjA7XG4gICAgcmVzdWx0WzFdID0gQTEgLSBCMTtcbiAgICByZXN1bHRbMl0gPSBBMiAtIEIyO1xuICAgIHJlc3VsdFszXSA9IEEzIC0gQjM7XG4gICAgcmVzdWx0WzRdID0gQTQgLSBCNDtcbiAgICByZXN1bHRbNV0gPSBBNSAtIEI1O1xuICAgIHJlc3VsdFs2XSA9IEE2IC0gQjY7XG4gICAgcmVzdWx0WzddID0gQTcgLSBCNztcbiAgICByZXN1bHRbOF0gPSBBOCAtIEI4O1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG4vKipcbiAqIE11bHRpcGx5IHRoZSBwcm92aWRlZCBNYXQzMyBNMiB3aXRoIHRoaXMgTWF0MzMuICBSZXN1bHQgaXMgKHRoaXMpICogKE0yKS5cbiAqXG4gKiBAbWV0aG9kIG11bHRpcGx5XG4gKiBAcGFyYW0ge01hdDMzfSBtYXRyaXgxIFRoZSBsZWZ0IE1hdDMzLlxuICogQHBhcmFtIHtNYXQzM30gbWF0cml4MiBUaGUgcmlnaHQgTWF0MzMuXG4gKiBAcGFyYW0ge01hdDMzfSBvdXRwdXQgTWF0MzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge01hdDMzfSB0aGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi5cbiAqL1xuTWF0MzMubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtYXRyaXgxLCBtYXRyaXgyLCBvdXRwdXQpIHtcbiAgICB2YXIgQSA9IG1hdHJpeDEudmFsdWVzO1xuICAgIHZhciBCID0gbWF0cml4Mi52YWx1ZXM7XG4gICAgdmFyIHJlc3VsdCA9IG91dHB1dC52YWx1ZXM7XG5cbiAgICB2YXIgQTAgPSBBWzBdO1xuICAgIHZhciBBMSA9IEFbMV07XG4gICAgdmFyIEEyID0gQVsyXTtcbiAgICB2YXIgQTMgPSBBWzNdO1xuICAgIHZhciBBNCA9IEFbNF07XG4gICAgdmFyIEE1ID0gQVs1XTtcbiAgICB2YXIgQTYgPSBBWzZdO1xuICAgIHZhciBBNyA9IEFbN107XG4gICAgdmFyIEE4ID0gQVs4XTtcblxuICAgIHZhciBCMCA9IEJbMF07XG4gICAgdmFyIEIxID0gQlsxXTtcbiAgICB2YXIgQjIgPSBCWzJdO1xuICAgIHZhciBCMyA9IEJbM107XG4gICAgdmFyIEI0ID0gQls0XTtcbiAgICB2YXIgQjUgPSBCWzVdO1xuICAgIHZhciBCNiA9IEJbNl07XG4gICAgdmFyIEI3ID0gQls3XTtcbiAgICB2YXIgQjggPSBCWzhdO1xuXG4gICAgcmVzdWx0WzBdID0gQTAqQjAgKyBBMSpCMyArIEEyKkI2O1xuICAgIHJlc3VsdFsxXSA9IEEwKkIxICsgQTEqQjQgKyBBMipCNztcbiAgICByZXN1bHRbMl0gPSBBMCpCMiArIEExKkI1ICsgQTIqQjg7XG4gICAgcmVzdWx0WzNdID0gQTMqQjAgKyBBNCpCMyArIEE1KkI2O1xuICAgIHJlc3VsdFs0XSA9IEEzKkIxICsgQTQqQjQgKyBBNSpCNztcbiAgICByZXN1bHRbNV0gPSBBMypCMiArIEE0KkI1ICsgQTUqQjg7XG4gICAgcmVzdWx0WzZdID0gQTYqQjAgKyBBNypCMyArIEE4KkI2O1xuICAgIHJlc3VsdFs3XSA9IEE2KkIxICsgQTcqQjQgKyBBOCpCNztcbiAgICByZXN1bHRbOF0gPSBBNipCMiArIEE3KkI1ICsgQTgqQjg7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXQzMztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE1hdHJpeCA9IHJlcXVpcmUoJy4vTWF0MzMnKTtcblxudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIGFzaW4gPSBNYXRoLmFzaW47XG52YXIgYWNvcyA9IE1hdGguYWNvcztcbnZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG52YXIgc3FydCA9IE1hdGguc3FydDtcblxuLyoqXG4gKiBBIHZlY3Rvci1saWtlIG9iamVjdCB1c2VkIHRvIHJlcHJlc2VudCByb3RhdGlvbnMuIElmIHRoZXRhIGlzIHRoZSBhbmdsZSBvZlxuICogcm90YXRpb24sIGFuZCAoeCcsIHknLCB6JykgaXMgYSBub3JtYWxpemVkIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGF4aXMgb2ZcbiAqIHJvdGF0aW9uLCB0aGVuIHcgPSBjb3ModGhldGEvMiksIHggPSBzaW4odGhldGEvMikqeCcsIHkgPSBzaW4odGhldGEvMikqeScsXG4gKiBhbmQgeiA9IHNpbih0aGV0YS8yKSp6Jy5cbiAqXG4gKiBAY2xhc3MgUXVhdGVybmlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIHcgY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IHogVGhlIHogY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBRdWF0ZXJuaW9uKHcsIHgsIHksIHopIHtcbiAgICB0aGlzLncgPSB3IHx8IDE7XG4gICAgdGhpcy54ID0geCB8fCAwO1xuICAgIHRoaXMueSA9IHkgfHwgMDtcbiAgICB0aGlzLnogPSB6IHx8IDA7XG59XG5cbi8qKlxuICogTXVsdGlwbHkgdGhlIGN1cnJlbnQgUXVhdGVybmlvbiBieSBpbnB1dCBRdWF0ZXJuaW9uIHEuXG4gKiBMZWZ0LWhhbmRlZCBtdWx0aXBsaWNhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIG11bHRpcGx5XG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgVGhlIFF1YXRlcm5pb24gdG8gbXVsdGlwbHkgYnkgb24gdGhlIHJpZ2h0LlxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KHEpIHtcbiAgICB2YXIgeDEgPSB0aGlzLng7XG4gICAgdmFyIHkxID0gdGhpcy55O1xuICAgIHZhciB6MSA9IHRoaXMuejtcbiAgICB2YXIgdzEgPSB0aGlzLnc7XG4gICAgdmFyIHgyID0gcS54O1xuICAgIHZhciB5MiA9IHEueTtcbiAgICB2YXIgejIgPSBxLno7XG4gICAgdmFyIHcyID0gcS53IHx8IDA7XG5cbiAgICB0aGlzLncgPSB3MSAqIHcyIC0geDEgKiB4MiAtIHkxICogeTIgLSB6MSAqIHoyO1xuICAgIHRoaXMueCA9IHgxICogdzIgKyB4MiAqIHcxICsgeTIgKiB6MSAtIHkxICogejI7XG4gICAgdGhpcy55ID0geTEgKiB3MiArIHkyICogdzEgKyB4MSAqIHoyIC0geDIgKiB6MTtcbiAgICB0aGlzLnogPSB6MSAqIHcyICsgejIgKiB3MSArIHgyICogeTEgLSB4MSAqIHkyO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgY3VycmVudCBRdWF0ZXJuaW9uIGJ5IGlucHV0IFF1YXRlcm5pb24gcSBvbiB0aGUgbGVmdCwgaS5lLiBxICogdGhpcy5cbiAqIExlZnQtaGFuZGVkIG11bHRpcGxpY2F0aW9uLlxuICpcbiAqIEBtZXRob2QgbGVmdE11bHRpcGx5XG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgVGhlIFF1YXRlcm5pb24gdG8gbXVsdGlwbHkgYnkgb24gdGhlIGxlZnQuXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLmxlZnRNdWx0aXBseSA9IGZ1bmN0aW9uIGxlZnRNdWx0aXBseShxKSB7XG4gICAgdmFyIHgxID0gcS54O1xuICAgIHZhciB5MSA9IHEueTtcbiAgICB2YXIgejEgPSBxLno7XG4gICAgdmFyIHcxID0gcS53IHx8IDA7XG4gICAgdmFyIHgyID0gdGhpcy54O1xuICAgIHZhciB5MiA9IHRoaXMueTtcbiAgICB2YXIgejIgPSB0aGlzLno7XG4gICAgdmFyIHcyID0gdGhpcy53O1xuXG4gICAgdGhpcy53ID0gdzEqdzIgLSB4MSp4MiAtIHkxKnkyIC0gejEqejI7XG4gICAgdGhpcy54ID0geDEqdzIgKyB4Mip3MSArIHkyKnoxIC0geTEqejI7XG4gICAgdGhpcy55ID0geTEqdzIgKyB5Mip3MSArIHgxKnoyIC0geDIqejE7XG4gICAgdGhpcy56ID0gejEqdzIgKyB6Mip3MSArIHgyKnkxIC0geDEqeTI7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGx5IHRoZSBjdXJyZW50IFF1YXRlcm5pb24gdG8gaW5wdXQgVmVjMyB2LCBhY2NvcmRpbmcgdG9cbiAqIHYnID0gfnEgKiB2ICogcS5cbiAqXG4gKiBAbWV0aG9kIHJvdGF0ZVZlY3RvclxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSByZWZlcmVuY2UgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gb3V0cHV0IFZlYzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSByb3RhdGVkIHZlcnNpb24gb2YgdGhlIFZlYzMuXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnJvdGF0ZVZlY3RvciA9IGZ1bmN0aW9uIHJvdGF0ZVZlY3Rvcih2LCBvdXRwdXQpIHtcbiAgICB2YXIgY3cgPSB0aGlzLnc7XG4gICAgdmFyIGN4ID0gLXRoaXMueDtcbiAgICB2YXIgY3kgPSAtdGhpcy55O1xuICAgIHZhciBjeiA9IC10aGlzLno7XG5cbiAgICB2YXIgdnggPSB2Lng7XG4gICAgdmFyIHZ5ID0gdi55O1xuICAgIHZhciB2eiA9IHYuejtcblxuICAgIHZhciB0dyA9IC1jeCAqIHZ4IC0gY3kgKiB2eSAtIGN6ICogdno7XG4gICAgdmFyIHR4ID0gdnggKiBjdyArIHZ5ICogY3ogLSBjeSAqIHZ6O1xuICAgIHZhciB0eSA9IHZ5ICogY3cgKyBjeCAqIHZ6IC0gdnggKiBjejtcbiAgICB2YXIgdHogPSB2eiAqIGN3ICsgdnggKiBjeSAtIGN4ICogdnk7XG5cbiAgICB2YXIgdyA9IGN3O1xuICAgIHZhciB4ID0gLWN4O1xuICAgIHZhciB5ID0gLWN5O1xuICAgIHZhciB6ID0gLWN6O1xuXG4gICAgb3V0cHV0LnggPSB0eCAqIHcgKyB4ICogdHcgKyB5ICogdHogLSB0eSAqIHo7XG4gICAgb3V0cHV0LnkgPSB0eSAqIHcgKyB5ICogdHcgKyB0eCAqIHogLSB4ICogdHo7XG4gICAgb3V0cHV0LnogPSB0eiAqIHcgKyB6ICogdHcgKyB4ICogdHkgLSB0eCAqIHk7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0IHRoZSBjdXJyZW50IFF1YXRlcm5pb24uXG4gKlxuICogQG1ldGhvZCBpbnZlcnRcbiAqIEBjaGFpbmFibGVcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgIHRoaXMudyA9IC10aGlzLnc7XG4gICAgdGhpcy54ID0gLXRoaXMueDtcbiAgICB0aGlzLnkgPSAtdGhpcy55O1xuICAgIHRoaXMueiA9IC10aGlzLno7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbmp1Z2F0ZSB0aGUgY3VycmVudCBRdWF0ZXJuaW9uLlxuICpcbiAqIEBtZXRob2QgY29uanVnYXRlXG4gKiBAY2hhaW5hYmxlXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSgpIHtcbiAgICB0aGlzLnggPSAtdGhpcy54O1xuICAgIHRoaXMueSA9IC10aGlzLnk7XG4gICAgdGhpcy56ID0gLXRoaXMuejtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbGVuZ3RoIChub3JtKSBvZiB0aGUgY3VycmVudCBRdWF0ZXJuaW9uLlxuICpcbiAqIEBtZXRob2QgbGVuZ3RoXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICB2YXIgdyA9IHRoaXMudztcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcbiAgICByZXR1cm4gc3FydCh3ICogdyArIHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG59O1xuXG4vKipcbiAqIEFsdGVyIHRoZSBjdXJyZW50IFF1YXRlcm5pb24gdG8gYmUgb2YgdW5pdCBsZW5ndGg7XG4gKlxuICogQG1ldGhvZCBub3JtYWxpemVcbiAqIEBjaGFpbmFibGVcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuICAgIHZhciBsZW5ndGggPSBzcXJ0KHcgKiB3ICsgeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgbGVuZ3RoID0gMSAvIGxlbmd0aDtcbiAgICB0aGlzLncgKj0gbGVuZ3RoO1xuICAgIHRoaXMueCAqPSBsZW5ndGg7XG4gICAgdGhpcy55ICo9IGxlbmd0aDtcbiAgICB0aGlzLnogKj0gbGVuZ3RoO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHcsIHgsIHksIHogY29tcG9uZW50cyBvZiB0aGUgY3VycmVudCBRdWF0ZXJuaW9uLlxuICpcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgdyBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geiBUaGUgeiBjb21wb25lbnQuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCh3LCB4ICx5LCB6KSB7XG4gICAgaWYgKHcgIT0gbnVsbCkgdGhpcy53ID0gdztcbiAgICBpZiAoeCAhPSBudWxsKSB0aGlzLnggPSB4O1xuICAgIGlmICh5ICE9IG51bGwpIHRoaXMueSA9IHk7XG4gICAgaWYgKHogIT0gbnVsbCkgdGhpcy56ID0gejtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29weSBpbnB1dCBRdWF0ZXJuaW9uIHEgb250byB0aGUgY3VycmVudCBRdWF0ZXJuaW9uLlxuICpcbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIFRoZSByZWZlcmVuY2UgUXVhdGVybmlvbi5cbiAqIEBjaGFpbmFibGVcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkocSkge1xuICAgIHRoaXMudyA9IHEudztcbiAgICB0aGlzLnggPSBxLng7XG4gICAgdGhpcy55ID0gcS55O1xuICAgIHRoaXMueiA9IHEuejtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIGN1cnJlbnQgUXVhdGVybmlvbi5cbiAqXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAY2hhaW5hYmxlXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy53ID0gMTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy56ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVGhlIGRvdCBwcm9kdWN0LiBDYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNvc2luZSBvZiB0aGUgYW5nbGUgYmV0d2VlblxuICogdGhlIHR3byByb3RhdGlvbnMsIGFzc3VtaW5nIGJvdGggUXVhdGVybmlvbnMgYXJlIG9mIHVuaXQgbGVuZ3RoLlxuICpcbiAqIEBtZXRob2QgZG90XG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgVGhlIG90aGVyIFF1YXRlcm5pb24uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uIGRvdChxKSB7XG4gICAgcmV0dXJuIHRoaXMudyAqIHEudyArIHRoaXMueCAqIHEueCArIHRoaXMueSAqIHEueSArIHRoaXMueiAqIHEuejtcbn07XG5cbi8qKlxuICogU3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uLlxuICpcbiAqIEBtZXRob2Qgc2xlcnBcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSBUaGUgZmluYWwgb3JpZW50YXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gdCBUaGUgdHdlZW4gcGFyYW1ldGVyLlxuICogQHBhcmFtIHtWZWMzfSBvdXRwdXQgVmVjMyBpbiB3aGljaCB0byBwdXQgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1F1YXRlcm5pb259XG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnNsZXJwID0gZnVuY3Rpb24gc2xlcnAocSwgdCwgb3V0cHV0KSB7XG4gICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICB2YXIgcXcgPSBxLnc7XG4gICAgdmFyIHF4ID0gcS54O1xuICAgIHZhciBxeSA9IHEueTtcbiAgICB2YXIgcXogPSBxLno7XG5cbiAgICB2YXIgb21lZ2E7XG4gICAgdmFyIGNvc29tZWdhO1xuICAgIHZhciBzaW5vbWVnYTtcbiAgICB2YXIgc2NhbGVGcm9tO1xuICAgIHZhciBzY2FsZVRvO1xuXG4gICAgY29zb21lZ2EgPSB3ICogcXcgKyB4ICogcXggKyB5ICogcXkgKyB6ICogcXo7XG4gICAgaWYgKCgxLjAgLSBjb3NvbWVnYSkgPiAxZS01KSB7XG4gICAgICAgIG9tZWdhID0gYWNvcyhjb3NvbWVnYSk7XG4gICAgICAgIHNpbm9tZWdhID0gc2luKG9tZWdhKTtcbiAgICAgICAgc2NhbGVGcm9tID0gc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tZWdhO1xuICAgICAgICBzY2FsZVRvID0gc2luKHQgKiBvbWVnYSkgLyBzaW5vbWVnYTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNjYWxlRnJvbSA9IDEuMCAtIHQ7XG4gICAgICAgIHNjYWxlVG8gPSB0O1xuICAgIH1cblxuICAgIG91dHB1dC53ID0gdyAqIHNjYWxlRnJvbSArIHF3ICogc2NhbGVUbztcbiAgICBvdXRwdXQueCA9IHggKiBzY2FsZUZyb20gKyBxeCAqIHNjYWxlVG87XG4gICAgb3V0cHV0LnkgPSB5ICogc2NhbGVGcm9tICsgcXkgKiBzY2FsZVRvO1xuICAgIG91dHB1dC56ID0geiAqIHNjYWxlRnJvbSArIHF6ICogc2NhbGVUbztcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgTWF0MzMgbWF0cml4IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGN1cnJlbnQgUXVhdGVybmlvbi5cbiAqXG4gKiBAbWV0aG9kIHRvTWF0cml4XG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm19XG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnRvTWF0cml4ID0gZnVuY3Rpb24gdG9NYXRyaXgob3V0cHV0KSB7XG4gICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICB2YXIgeHggPSB4Kng7XG4gICAgdmFyIHl5ID0geSp5O1xuICAgIHZhciB6eiA9IHoqejtcbiAgICB2YXIgeHkgPSB4Knk7XG4gICAgdmFyIHh6ID0geCp6O1xuICAgIHZhciB5eiA9IHkqejtcblxuICAgIHJldHVybiBvdXRwdXQuc2V0KFtcbiAgICAgICAgMSAtIDIgKiAoeXkgKyB6eiksIDIgKiAoeHkgLSB3KnopLCAyICogKHh6ICsgdyp5KSxcbiAgICAgICAgMiAqICh4eSArIHcqeiksIDEgLSAyICogKHh4ICsgenopLCAyICogKHl6IC0gdyp4KSxcbiAgICAgICAgMiAqICh4eiAtIHcqeSksIDIgKiAoeXogKyB3KngpLCAxIC0gMiAqICh4eCArIHl5KVxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBUaGUgcm90YXRpb24gYW5nbGVzIGFib3V0IHRoZSB4LCB5LCBhbmQgeiBheGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gKiBjdXJyZW50IFF1YXRlcm5pb24sIHdoZW4gYXBwbGllZCBpbiB0aGUgWllYIG9yZGVyLlxuICpcbiAqIEBtZXRob2QgdG9FdWxlclxuICogQHBhcmFtIHtWZWMzfSBvdXRwdXQgVmVjMyBpbiB3aGljaCB0byBwdXQgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblxuUXVhdGVybmlvbi5wcm90b3R5cGUudG9FdWxlciA9IGZ1bmN0aW9uIHRvRXVsZXIob3V0cHV0KSB7XG4gICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICB2YXIgeHggPSB4ICogeDtcbiAgICB2YXIgeXkgPSB5ICogeTtcbiAgICB2YXIgenogPSB6ICogejtcbiAgICB2YXIgd3cgPSB3ICogdztcblxuICAgIHZhciB0eSA9IDIgKiAoeCAqIHogKyB5ICogdyk7XG4gICAgdHkgPSB0eSA8IC0xID8gLTEgOiB0eSA+IDEgPyAxIDogdHk7XG5cbiAgICBvdXRwdXQueCA9IGF0YW4yKDIgKiAoeCAqIHcgLSB5ICogeiksIDEgLSAyICogKHh4ICsgeXkpKTtcbiAgICBvdXRwdXQueSA9IGFzaW4odHkpO1xuICAgIG91dHB1dC56ID0gYXRhbjIoMiAqICh6ICogdyAtIHggKiB5KSwgMSAtIDIgKiAoeXkgKyB6eikpO1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogVGhlIFF1YXRlcm5pb24gY29ycmVzcG9uZGluZyB0byB0aGUgRXVsZXIgYW5nbGVzIHgsIHksIGFuZCB6LFxuICogYXBwbGllZCBpbiB0aGUgWllYIG9yZGVyLlxuICpcbiAqIEBtZXRob2QgZnJvbUV1bGVyXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gYWJvdXQgdGhlIHggYXhpcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBhbmdsZSBvZiByb3RhdGlvbiBhYm91dCB0aGUgeSBheGlzLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGFib3V0IHRoZSB6IGF4aXMuXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IG91dHB1dCBRdWF0ZXJuaW9uIGluIHdoaWNoIHRvIHB1dCB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7UXVhdGVybmlvbn0gVGhlIGVxdWl2YWxlbnQgUXVhdGVybmlvbi5cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuZnJvbUV1bGVyID0gZnVuY3Rpb24gZnJvbUV1bGVyKHgsIHksIHopIHtcbiAgICB2YXIgaHggPSB4ICogMC41O1xuICAgIHZhciBoeSA9IHkgKiAwLjU7XG4gICAgdmFyIGh6ID0geiAqIDAuNTtcblxuICAgIHZhciBzeCA9IHNpbihoeCk7XG4gICAgdmFyIHN5ID0gc2luKGh5KTtcbiAgICB2YXIgc3ogPSBzaW4oaHopO1xuICAgIHZhciBjeCA9IGNvcyhoeCk7XG4gICAgdmFyIGN5ID0gY29zKGh5KTtcbiAgICB2YXIgY3ogPSBjb3MoaHopO1xuXG4gICAgdGhpcy53ID0gY3ggKiBjeSAqIGN6IC0gc3ggKiBzeSAqIHN6O1xuICAgIHRoaXMueCA9IHN4ICogY3kgKiBjeiArIGN4ICogc3kgKiBzejtcbiAgICB0aGlzLnkgPSBjeCAqIHN5ICogY3ogLSBzeCAqIGN5ICogc3o7XG4gICAgdGhpcy56ID0gY3ggKiBjeSAqIHN6ICsgc3ggKiBzeSAqIGN6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFsdGVyIHRoZSBjdXJyZW50IFF1YXRlcm5pb24gdG8gcmVmbGVjdCBhIHJvdGF0aW9uIG9mIGlucHV0IGFuZ2xlIGFib3V0XG4gKiBpbnB1dCBheGlzIHYuXG4gKlxuICogQG1ldGhvZCBtYWtlRnJvbUFuZ2xlQW5kQXhpc1xuICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIFRoZSBhbmdsZSBvZiByb3RhdGlvbi5cbiAqIEBwYXJhbSB7VmVjM30gdiBUaGUgYXhpcyBvZiByb3RhdGlvbi5cbiAqIEBjaGFpbmFibGVcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuZnJvbUFuZ2xlQXhpcyA9IGZ1bmN0aW9uIGZyb21BbmdsZUF4aXMoYW5nbGUsIHgsIHksIHopIHtcbiAgICB2YXIgbGVuID0gc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgdGhpcy53ID0gMTtcbiAgICAgICAgdGhpcy54ID0gdGhpcy55ID0gdGhpcy56ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHZhciBoYWxmVGhldGEgPSBhbmdsZSAqIDAuNTtcbiAgICAgICAgdmFyIHMgPSBzaW4oaGFsZlRoZXRhKTtcbiAgICAgICAgdGhpcy53ID0gY29zKGhhbGZUaGV0YSk7XG4gICAgICAgIHRoaXMueCA9IHMgKiB4ICogbGVuO1xuICAgICAgICB0aGlzLnkgPSBzICogeSAqIGxlbjtcbiAgICAgICAgdGhpcy56ID0gcyAqIHogKiBsZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgaW5wdXQgUXVhdGVybmlvbnMuXG4gKiBMZWZ0LWhhbmRlZCBjb29yZGluYXRlIHN5c3RlbSBtdWx0aXBsaWNhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIG11bHRpcGx5XG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHExIFRoZSBsZWZ0IFF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHEyIFRoZSByaWdodCBRdWF0ZXJuaW9uLlxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBvdXRwdXQgUXVhdGVybmlvbiBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7UXVhdGVybmlvbn0gVGhlIHByb2R1Y3Qgb2YgbXVsdGlwbGljYXRpb24uXG4gKi9cblF1YXRlcm5pb24ubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShxMSwgcTIsIG91dHB1dCkge1xuICAgIHZhciB3MSA9IHExLncgfHwgMDtcbiAgICB2YXIgeDEgPSBxMS54O1xuICAgIHZhciB5MSA9IHExLnk7XG4gICAgdmFyIHoxID0gcTEuejtcblxuICAgIHZhciB3MiA9IHEyLncgfHwgMDtcbiAgICB2YXIgeDIgPSBxMi54O1xuICAgIHZhciB5MiA9IHEyLnk7XG4gICAgdmFyIHoyID0gcTIuejtcblxuICAgIG91dHB1dC53ID0gdzEgKiB3MiAtIHgxICogeDIgLSB5MSAqIHkyIC0gejEgKiB6MjtcbiAgICBvdXRwdXQueCA9IHgxICogdzIgKyB4MiAqIHcxICsgeTIgKiB6MSAtIHkxICogejI7XG4gICAgb3V0cHV0LnkgPSB5MSAqIHcyICsgeTIgKiB3MSArIHgxICogejIgLSB4MiAqIHoxO1xuICAgIG91dHB1dC56ID0gejEgKiB3MiArIHoyICogdzEgKyB4MiAqIHkxIC0geDEgKiB5MjtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGlucHV0IHF1YXRlcm5pb24uXG4gKlxuICogQG1ldGhvZCBub3JtYWxpemVcbiAqIEByZXR1cm4ge1F1YXRlcm5pb259IFRoZSBub3JtYWxpemVkIHF1YXRlcm5pb24uXG4gKi9cblF1YXRlcm5pb24ubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKHEsIG91dHB1dCkge1xuICAgIHZhciB3ID0gcS53O1xuICAgIHZhciB4ID0gcS54O1xuICAgIHZhciB5ID0gcS55O1xuICAgIHZhciB6ID0gcS56O1xuICAgIHZhciBsZW5ndGggPSBzcXJ0KHcgKiB3ICsgeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgbGVuZ3RoID0gMSAvIGxlbmd0aDtcbiAgICBvdXRwdXQudyAqPSBsZW5ndGg7XG4gICAgb3V0cHV0LnggKj0gbGVuZ3RoO1xuICAgIG91dHB1dC55ICo9IGxlbmd0aDtcbiAgICBvdXRwdXQueiAqPSBsZW5ndGg7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogVGhlIGNvbmp1Z2F0ZSBvZiB0aGUgaW5wdXQgUXVhdGVybmlvbi5cbiAqXG4gKiBAbWV0aG9kIGNvbmp1Z2F0ZVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIFRoZSByZWZlcmVuY2UgUXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gb3V0cHV0IFF1YXRlcm5pb24gaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1F1YXRlcm5pb259IFRoZSBjb25qdWdhdGUgUXVhdGVybmlvbi5cbiAqL1xuUXVhdGVybmlvbi5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUocSwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LncgPSBxLnc7XG4gICAgb3V0cHV0LnggPSAtcS54O1xuICAgIG91dHB1dC55ID0gLXEueTtcbiAgICBvdXRwdXQueiA9IC1xLno7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogQ2xvbmUgdGhlIGlucHV0IFF1YXRlcm5pb24uXG4gKlxuICogQG1ldGhvZCBjbG9uZVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIHRoZSByZWZlcmVuY2UgUXVhdGVybmlvbi5cbiAqIEByZXR1cm4ge1F1YXRlcm5pb259IFRoZSBjbG9uZWQgUXVhdGVybmlvbi5cbiAqL1xuUXVhdGVybmlvbi5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKHEpIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24ocS53LCBxLngsIHEueSwgcS56KTtcbn07XG5cbi8qKlxuICogVGhlIGRvdCBwcm9kdWN0IG9mIHRoZSB0d28gaW5wdXQgUXVhdGVybmlvbnMuXG4gKlxuICogQG1ldGhvZCBkb3RQcm9kdWN0XG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHExIFRoZSBsZWZ0IFF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHEyIFRoZSByaWdodCBRdWF0ZXJuaW9uLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgZG90IHByb2R1Y3Qgb2YgdGhlIHR3byBRdWF0ZXJuaW9ucy5cbiAqL1xuUXVhdGVybmlvbi5kb3QgPSBmdW5jdGlvbiBkb3QocTEsIHEyKSB7XG4gICAgcmV0dXJuIHExLncgKiBxMi53ICsgcTEueCAqIHEyLnggKyBxMS55ICogcTIueSArIHExLnogKiBxMi56O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWF0ZXJuaW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2luID0gTWF0aC5zaW47XG52YXIgY29zID0gTWF0aC5jb3M7XG52YXIgc3FydCA9IE1hdGguc3FydDtcblxuLyoqXG4gKiBBIHR3by1kaW1lbnNpb25hbCB2ZWN0b3IuXG4gKlxuICogQGNsYXNzIFZlYzJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudC5cbiAqL1xudmFyIFZlYzIgPSBmdW5jdGlvbih4LCB5KXtcbiAgICBpZiAoeCBpbnN0YW5jZW9mIEFycmF5IHx8IHggaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgdGhpcy54ID0geFswXSB8fCAwO1xuICAgICAgICB0aGlzLnkgPSB4WzFdIHx8IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgICAgIHRoaXMueSA9IHkgfHwgMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiB0aGUgY3VycmVudCBWZWMyLlxuICpcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb21wb25lbnQuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCh4LCB5KSB7XG4gICAgaWYgKHggIT0gbnVsbCkgdGhpcy54ID0geDtcbiAgICBpZiAoeSAhPSBudWxsKSB0aGlzLnkgPSB5O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGlucHV0IHYgdG8gdGhlIGN1cnJlbnQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtWZWMyfSB2IFRoZSBWZWMyIHRvIGFkZC5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHYpIHtcbiAgICB0aGlzLnggKz0gdi54O1xuICAgIHRoaXMueSArPSB2Lnk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0IHRoZSBpbnB1dCB2IGZyb20gdGhlIGN1cnJlbnQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIHN1YnRyYWN0XG4gKiBAcGFyYW0ge1ZlYzJ9IHYgVGhlIFZlYzIgdG8gc3VidHJhY3QuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qodikge1xuICAgIHRoaXMueCAtPSB2Lng7XG4gICAgdGhpcy55IC09IHYueTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2NhbGUgdGhlIGN1cnJlbnQgVmVjMiBieSBhIHNjYWxhciBvciBWZWMyLlxuICpcbiAqIEBtZXRob2Qgc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfFZlYzJ9IHMgVGhlIE51bWJlciBvciB2ZWMyIGJ5IHdoaWNoIHRvIHNjYWxlLlxuICogQGNoYWluYWJsZVxuICovXG5WZWMyLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHMpIHtcbiAgICBpZiAocyBpbnN0YW5jZW9mIFZlYzIpIHtcbiAgICAgICAgdGhpcy54ICo9IHMueDtcbiAgICAgICAgdGhpcy55ICo9IHMueTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnggKj0gcztcbiAgICAgICAgdGhpcy55ICo9IHM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgdGhlIFZlYzIgY291bnRlci1jbG9ja3dpc2UgYnkgdGhldGEgYWJvdXQgdGhlIHotYXhpcy5cbiAqXG4gKiBAbWV0aG9kIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRoZXRhIEFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMi5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24odGhldGEpIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcblxuICAgIHZhciBjb3NUaGV0YSA9IGNvcyh0aGV0YSk7XG4gICAgdmFyIHNpblRoZXRhID0gc2luKHRoZXRhKTtcblxuICAgIHRoaXMueCA9IHggKiBjb3NUaGV0YSAtIHkgKiBzaW5UaGV0YTtcbiAgICB0aGlzLnkgPSB4ICogc2luVGhldGEgKyB5ICogY29zVGhldGE7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVGhlIGRvdCBwcm9kdWN0IG9mIG9mIHRoZSBjdXJyZW50IFZlYzIgd2l0aCB0aGUgaW5wdXQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIGRvdFxuICogQHBhcmFtIHtOdW1iZXJ9IHYgVGhlIG90aGVyIFZlYzIuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xufTtcblxuLyoqXG4gKiBUaGUgY3Jvc3MgcHJvZHVjdCBvZiBvZiB0aGUgY3VycmVudCBWZWMyIHdpdGggdGhlIGlucHV0IFZlYzIuXG4gKlxuICogQG1ldGhvZCBjcm9zc1xuICogQHBhcmFtIHtOdW1iZXJ9IHYgVGhlIG90aGVyIFZlYzIuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XG59O1xuXG4vKipcbiAqIFByZXNlcnZlIHRoZSBtYWduaXR1ZGUgYnV0IGludmVydCB0aGUgb3JpZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIGludmVydFxuICogQGNoYWluYWJsZVxuICovXG5WZWMyLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgdGhpcy54ICo9IC0xO1xuICAgIHRoaXMueSAqPSAtMTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbHkgYSBmdW5jdGlvbiBjb21wb25lbnQtd2lzZSB0byB0aGUgY3VycmVudCBWZWMyLlxuICpcbiAqIEBtZXRob2QgbWFwXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBhcHBseS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMi5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwKGZuKSB7XG4gICAgdGhpcy54ID0gZm4odGhpcy54KTtcbiAgICB0aGlzLnkgPSBmbih0aGlzLnkpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGUgbWFnbml0dWRlIG9mIHRoZSBjdXJyZW50IFZlYzIuXG4gKlxuICogQG1ldGhvZCBsZW5ndGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVmVjMi5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuXG4gICAgcmV0dXJuIHNxcnQoeCAqIHggKyB5ICogeSk7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIGlucHV0IG9udG8gdGhlIGN1cnJlbnQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7VmVjMn0gdiBWZWMyIHRvIGNvcHkuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5KHYpIHtcbiAgICB0aGlzLnggPSB2Lng7XG4gICAgdGhpcy55ID0gdi55O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgY3VycmVudCBWZWMyLlxuICpcbiAqIEBtZXRob2QgY2xlYXJcbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG1hZ25pdHVkZSBvZiB0aGUgY3VycmVudCBWZWMyIGlzIGV4YWN0bHkgMC5cbiAqXG4gKiBAbWV0aG9kIGlzWmVyb1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuVmVjMi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xuICAgIGlmICh0aGlzLnggIT09IDAgfHwgdGhpcy55ICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgZWxzZSByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogVGhlIGFycmF5IGZvcm0gb2YgdGhlIGN1cnJlbnQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIHRvQXJyYXlcbiAqIEByZXR1cm4ge051bWJlcltdfVxuICovXG5WZWMyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55XTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBpbnB1dCBWZWMyLlxuICpcbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAcGFyYW0ge1ZlYzJ9IHYgVGhlIHJlZmVyZW5jZSBWZWMyLlxuICogQHBhcmFtIHtWZWMyfSBvdXRwdXQgVmVjMiBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjMn0gVGhlIG5vcm1hbGl6ZSBWZWMyLlxuICovXG5WZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSh2LCBvdXRwdXQpIHtcbiAgICB2YXIgeCA9IHYueDtcbiAgICB2YXIgeSA9IHYueTtcblxuICAgIHZhciBsZW5ndGggPSBzcXJ0KHggKiB4ICsgeSAqIHkpIHx8IDE7XG4gICAgbGVuZ3RoID0gMSAvIGxlbmd0aDtcbiAgICBvdXRwdXQueCA9IHYueCAqIGxlbmd0aDtcbiAgICBvdXRwdXQueSA9IHYueSAqIGxlbmd0aDtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIENsb25lIHRoZSBpbnB1dCBWZWMyLlxuICpcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEBwYXJhbSB7VmVjMn0gdiBUaGUgVmVjMiB0byBjbG9uZS5cbiAqIEByZXR1cm4ge1ZlYzJ9IFRoZSBjbG9uZWQgVmVjMi5cbiAqL1xuVmVjMi5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKHYpIHtcbiAgICByZXR1cm4gbmV3IFZlYzIodi54LCB2LnkpO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGlucHV0IFZlYzIncy5cbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtWZWMyfSB2MSBUaGUgbGVmdCBWZWMyLlxuICogQHBhcmFtIHtWZWMyfSB2MiBUaGUgcmlnaHQgVmVjMi5cbiAqIEBwYXJhbSB7VmVjMn0gb3V0cHV0IFZlYzIgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzJ9IFRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uLlxuICovXG5WZWMyLmFkZCA9IGZ1bmN0aW9uIGFkZCh2MSwgdjIsIG91dHB1dCkge1xuICAgIG91dHB1dC54ID0gdjEueCArIHYyLng7XG4gICAgb3V0cHV0LnkgPSB2MS55ICsgdjIueTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0IHRoZSBzZWNvbmQgVmVjMiBmcm9tIHRoZSBmaXJzdC5cbiAqXG4gKiBAbWV0aG9kIHN1YnRyYWN0XG4gKiBAcGFyYW0ge1ZlYzJ9IHYxIFRoZSBsZWZ0IFZlYzIuXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyIFRoZSByaWdodCBWZWMyLlxuICogQHBhcmFtIHtWZWMyfSBvdXRwdXQgVmVjMiBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjMn0gVGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24uXG4gKi9cblZlYzIuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdCh2MSwgdjIsIG91dHB1dCkge1xuICAgIG91dHB1dC54ID0gdjEueCAtIHYyLng7XG4gICAgb3V0cHV0LnkgPSB2MS55IC0gdjIueTtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBTY2FsZSB0aGUgaW5wdXQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIHNjYWxlXG4gKiBAcGFyYW0ge1ZlYzJ9IHYgVGhlIHJlZmVyZW5jZSBWZWMyLlxuICogQHBhcmFtIHtOdW1iZXJ9IHMgTnVtYmVyIHRvIHNjYWxlIGJ5LlxuICogQHBhcmFtIHtWZWMyfSBvdXRwdXQgVmVjMiBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjMn0gVGhlIHJlc3VsdCBvZiB0aGUgc2NhbGluZy5cbiAqL1xuVmVjMi5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHYsIHMsIG91dHB1dCkge1xuICAgIG91dHB1dC54ID0gdi54ICogcztcbiAgICBvdXRwdXQueSA9IHYueSAqIHM7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogVGhlIGRvdCBwcm9kdWN0IG9mIHRoZSBpbnB1dCBWZWMyJ3MuXG4gKlxuICogQG1ldGhvZCBkb3RcbiAqIEBwYXJhbSB7VmVjMn0gdjEgVGhlIGxlZnQgVmVjMi5cbiAqIEBwYXJhbSB7VmVjMn0gdjIgVGhlIHJpZ2h0IFZlYzIuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkb3QgcHJvZHVjdC5cbiAqL1xuVmVjMi5kb3QgPSBmdW5jdGlvbiBkb3QodjEsIHYyKSB7XG4gICAgcmV0dXJuIHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnk7XG59O1xuXG4vKipcbiAqIFRoZSBjcm9zcyBwcm9kdWN0IG9mIHRoZSBpbnB1dCBWZWMyJ3MuXG4gKlxuICogQG1ldGhvZCBjcm9zc1xuICogQHBhcmFtIHtOdW1iZXJ9IHYgVGhlIGxlZnQgVmVjMi5cbiAqIEBwYXJhbSB7TnVtYmVyfSB2IFRoZSByaWdodCBWZWMyLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgei1jb21wb25lbnQgb2YgdGhlIGNyb3NzIHByb2R1Y3QuXG4gKi9cblZlYzIuY3Jvc3MgPSBmdW5jdGlvbih2MSx2Mikge1xuICAgIHJldHVybiB2MS54ICogdjIueSAtIHYxLnkgKiB2Mi54O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2luID0gTWF0aC5zaW47XG52YXIgY29zID0gTWF0aC5jb3M7XG52YXIgc3FydCA9IE1hdGguc3FydDtcblxuLyoqXG4gKiBBIHRocmVlLWRpbWVuc2lvbmFsIHZlY3Rvci5cbiAqXG4gKiBAY2xhc3MgVmVjM1xuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IHogVGhlIHogY29tcG9uZW50LlxuICovXG52YXIgVmVjMyA9IGZ1bmN0aW9uKHggLHksIHope1xuICAgIHRoaXMueCA9IHggfHwgMDtcbiAgICB0aGlzLnkgPSB5IHx8IDA7XG4gICAgdGhpcy56ID0geiB8fCAwO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IHogVGhlIHogY29tcG9uZW50LlxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoeCwgeSwgeikge1xuICAgIGlmICh4ICE9IG51bGwpIHRoaXMueCA9IHg7XG4gICAgaWYgKHkgIT0gbnVsbCkgdGhpcy55ID0geTtcbiAgICBpZiAoeiAhPSBudWxsKSB0aGlzLnogPSB6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgaW5wdXQgdiB0byB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIFZlYzMgdG8gYWRkLlxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQodikge1xuICAgIHRoaXMueCArPSB2Lng7XG4gICAgdGhpcy55ICs9IHYueTtcbiAgICB0aGlzLnogKz0gdi56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0IHRoZSBpbnB1dCB2IGZyb20gdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIHN1YnRyYWN0XG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIFZlYzMgdG8gc3VidHJhY3QuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzMucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qodikge1xuICAgIHRoaXMueCAtPSB2Lng7XG4gICAgdGhpcy55IC09IHYueTtcbiAgICB0aGlzLnogLT0gdi56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSB0aGUgY3VycmVudCBWZWMzIGJ5IHRoZXRhIGNsb2Nrd2lzZSBhYm91dCB0aGUgeCBheGlzLlxuICpcbiAqIEBtZXRob2Qgcm90YXRlWFxuICogQHBhcmFtIHtOdW1iZXJ9IHRoZXRhIEFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUucm90YXRlWCA9IGZ1bmN0aW9uIHJvdGF0ZVgodGhldGEpIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHZhciBjb3NUaGV0YSA9IGNvcyh0aGV0YSk7XG4gICAgdmFyIHNpblRoZXRhID0gc2luKHRoZXRhKTtcblxuICAgIHRoaXMueSA9IHkgKiBjb3NUaGV0YSAtIHogKiBzaW5UaGV0YTtcbiAgICB0aGlzLnogPSB5ICogc2luVGhldGEgKyB6ICogY29zVGhldGE7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUm90YXRlIHRoZSBjdXJyZW50IFZlYzMgYnkgdGhldGEgY2xvY2t3aXNlIGFib3V0IHRoZSB5IGF4aXMuXG4gKlxuICogQG1ldGhvZCByb3RhdGVZXG4gKiBAcGFyYW0ge051bWJlcn0gdGhldGEgQW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlLlxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5yb3RhdGVZID0gZnVuY3Rpb24gcm90YXRlWSh0aGV0YSkge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgdmFyIGNvc1RoZXRhID0gY29zKHRoZXRhKTtcbiAgICB2YXIgc2luVGhldGEgPSBzaW4odGhldGEpO1xuXG4gICAgdGhpcy54ID0geiAqIHNpblRoZXRhICsgeCAqIGNvc1RoZXRhO1xuICAgIHRoaXMueiA9IHogKiBjb3NUaGV0YSAtIHggKiBzaW5UaGV0YTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgdGhlIGN1cnJlbnQgVmVjMyBieSB0aGV0YSBjbG9ja3dpc2UgYWJvdXQgdGhlIHogYXhpcy5cbiAqXG4gKiBAbWV0aG9kIHJvdGF0ZVpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aGV0YSBBbmdsZSBieSB3aGljaCB0byByb3RhdGUuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzMucHJvdG90eXBlLnJvdGF0ZVogPSBmdW5jdGlvbiByb3RhdGVaKHRoZXRhKSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICB2YXIgY29zVGhldGEgPSBjb3ModGhldGEpO1xuICAgIHZhciBzaW5UaGV0YSA9IHNpbih0aGV0YSk7XG5cbiAgICB0aGlzLnggPSB4ICogY29zVGhldGEgLSB5ICogc2luVGhldGE7XG4gICAgdGhpcy55ID0geCAqIHNpblRoZXRhICsgeSAqIGNvc1RoZXRhO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgY3VycmVudCBWZWMzIHdpdGggaW5wdXQgVmVjMyB2LlxuICpcbiAqIEBtZXRob2QgZG90XG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIG90aGVyIFZlYzMuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblZlYzMucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uIGRvdCh2KSB7XG4gICAgcmV0dXJuIHRoaXMueCp2LnggKyB0aGlzLnkqdi55ICsgdGhpcy56KnYuejtcbn07XG5cbi8qKlxuICogVGhlIGRvdCBwcm9kdWN0IG9mIHRoZSBjdXJyZW50IFZlYzMgd2l0aCBpbnB1dCBWZWMzIHYuXG4gKiBTdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgY3Jvc3NcbiAqIEBwYXJhbSB7VmVjM30gdiBUaGUgb3RoZXIgVmVjMy5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuY3Jvc3MgPSBmdW5jdGlvbiBjcm9zcyh2KSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICB2YXIgdnggPSB2Lng7XG4gICAgdmFyIHZ5ID0gdi55O1xuICAgIHZhciB2eiA9IHYuejtcblxuICAgIHRoaXMueCA9IHkgKiB2eiAtIHogKiB2eTtcbiAgICB0aGlzLnkgPSB6ICogdnggLSB4ICogdno7XG4gICAgdGhpcy56ID0geCAqIHZ5IC0geSAqIHZ4O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTY2FsZSB0aGUgY3VycmVudCBWZWMzIGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBtZXRob2Qgc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBzIFRoZSBOdW1iZXIgYnkgd2hpY2ggdG8gc2NhbGUuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzMucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gc2NhbGUocykge1xuICAgIHRoaXMueCAqPSBzO1xuICAgIHRoaXMueSAqPSBzO1xuICAgIHRoaXMueiAqPSBzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFByZXNlcnZlIHRoZSBtYWduaXR1ZGUgYnV0IGludmVydCB0aGUgb3JpZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIGludmVydFxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgdGhpcy54ID0gLXRoaXMueDtcbiAgICB0aGlzLnkgPSAtdGhpcy55O1xuICAgIHRoaXMueiA9IC10aGlzLno7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbHkgYSBmdW5jdGlvbiBjb21wb25lbnQtd2lzZSB0byB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgbWFwXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBhcHBseS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwKGZuKSB7XG4gICAgdGhpcy54ID0gZm4odGhpcy54KTtcbiAgICB0aGlzLnkgPSBmbih0aGlzLnkpO1xuICAgIHRoaXMueiA9IGZuKHRoaXMueik7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVGhlIG1hZ25pdHVkZSBvZiB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgbGVuZ3RoXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblZlYzMucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHJldHVybiBzcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG59O1xuXG4vKipcbiAqIFRoZSBtYWduaXR1ZGUgc3F1YXJlZCBvZiB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgbGVuZ3RoXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblZlYzMucHJvdG90eXBlLmxlbmd0aFNxID0gZnVuY3Rpb24gbGVuZ3RoU3EoKSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSBpbnB1dCBvbnRvIHRoZSBjdXJyZW50IFZlYzMuXG4gKlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge1ZlYzN9IHYgVmVjMyB0byBjb3B5LlxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSh2KSB7XG4gICAgdGhpcy54ID0gdi54O1xuICAgIHRoaXMueSA9IHYueTtcbiAgICB0aGlzLnogPSB2Lno7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBjdXJyZW50IFZlYzMuXG4gKlxuICogQG1ldGhvZCBjbGVhclxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLnogPSAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGN1cnJlbnQgVmVjMyBpcyBleGFjdGx5IDAuXG4gKlxuICogQG1ldGhvZCBpc1plcm9cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblZlYzMucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcbiAgICByZXR1cm4gdGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMCAmJiB0aGlzLnogPT09IDA7XG59O1xuXG4vKipcbiAqIFRoZSBhcnJheSBmb3JtIG9mIHRoZSBjdXJyZW50IFZlYzMuXG4gKlxuICogQG1ldGhvZCB0b0FycmF5XG4gKiBAcmV0dXJuIHtOdW1iZXJbXX1cbiAqL1xuVmVjMy5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueSwgdGhpcy56XTtcbn07XG5cbi8qKlxuICogUHJlc2VydmUgdGhlIG9yaWVudGF0aW9uIGJ1dCBjaGFuZ2UgdGhlIGxlbmd0aCBvZiB0aGUgY3VycmVudCBWZWMzIHRvIDEuXG4gKlxuICogQG1ldGhvZCBub3JtYWxpemVcbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgdmFyIGxlbiA9IHNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSB8fCAxO1xuICAgIGxlbiA9IDEgLyBsZW47XG5cbiAgICB0aGlzLnggKj0gbGVuO1xuICAgIHRoaXMueSAqPSBsZW47XG4gICAgdGhpcy56ICo9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbHkgdGhlIHJvdGF0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGlucHV0ICh1bml0KSBRdWF0ZXJuaW9uXG4gKiB0byB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgYXBwbHlSb3RhdGlvblxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIFVuaXQgUXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uIHRvIGFwcGx5LlxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5hcHBseVJvdGF0aW9uID0gZnVuY3Rpb24gYXBwbHlSb3RhdGlvbihxKSB7XG4gICAgdmFyIGN3ID0gcS53O1xuICAgIHZhciBjeCA9IC1xLng7XG4gICAgdmFyIGN5ID0gLXEueTtcbiAgICB2YXIgY3ogPSAtcS56O1xuXG4gICAgdmFyIHZ4ID0gdGhpcy54O1xuICAgIHZhciB2eSA9IHRoaXMueTtcbiAgICB2YXIgdnogPSB0aGlzLno7XG5cbiAgICB2YXIgdHcgPSAtY3ggKiB2eCAtIGN5ICogdnkgLSBjeiAqIHZ6O1xuICAgIHZhciB0eCA9IHZ4ICogY3cgKyB2eSAqIGN6IC0gY3kgKiB2ejtcbiAgICB2YXIgdHkgPSB2eSAqIGN3ICsgY3ggKiB2eiAtIHZ4ICogY3o7XG4gICAgdmFyIHR6ID0gdnogKiBjdyArIHZ4ICogY3kgLSBjeCAqIHZ5O1xuXG4gICAgdmFyIHcgPSBjdztcbiAgICB2YXIgeCA9IC1jeDtcbiAgICB2YXIgeSA9IC1jeTtcbiAgICB2YXIgeiA9IC1jejtcblxuICAgIHRoaXMueCA9IHR4ICogdyArIHggKiB0dyArIHkgKiB0eiAtIHR5ICogejtcbiAgICB0aGlzLnkgPSB0eSAqIHcgKyB5ICogdHcgKyB0eCAqIHogLSB4ICogdHo7XG4gICAgdGhpcy56ID0gdHogKiB3ICsgeiAqIHR3ICsgeCAqIHR5IC0gdHggKiB5O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBseSB0aGUgaW5wdXQgTWF0MzMgdGhlIHRoZSBjdXJyZW50IFZlYzMuXG4gKlxuICogQG1ldGhvZCBhcHBseU1hdHJpeFxuICogQHBhcmFtIHtNYXQzM30gbWF0cml4IE1hdDMzIHRvIGFwcGx5LlxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5hcHBseU1hdHJpeCA9IGZ1bmN0aW9uIGFwcGx5TWF0cml4KG1hdHJpeCkge1xuICAgIHZhciBNID0gbWF0cml4LmdldCgpO1xuXG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICB0aGlzLnggPSBNWzBdKnggKyBNWzFdKnkgKyBNWzJdKno7XG4gICAgdGhpcy55ID0gTVszXSp4ICsgTVs0XSp5ICsgTVs1XSp6O1xuICAgIHRoaXMueiA9IE1bNl0qeCArIE1bN10qeSArIE1bOF0qejtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBpbnB1dCBWZWMzLlxuICpcbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIHJlZmVyZW5jZSBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSBvdXRwdXQgVmVjMyBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjM30gVGhlIG5vcm1hbGl6ZSBWZWMzLlxuICovXG5WZWMzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSh2LCBvdXRwdXQpIHtcbiAgICB2YXIgeCA9IHYueDtcbiAgICB2YXIgeSA9IHYueTtcbiAgICB2YXIgeiA9IHYuejtcblxuICAgIHZhciBsZW5ndGggPSBzcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeikgfHwgMTtcbiAgICBsZW5ndGggPSAxIC8gbGVuZ3RoO1xuXG4gICAgb3V0cHV0LnggPSB4ICogbGVuZ3RoO1xuICAgIG91dHB1dC55ID0geSAqIGxlbmd0aDtcbiAgICBvdXRwdXQueiA9IHogKiBsZW5ndGg7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogQXBwbHkgYSByb3RhdGlvbiB0byB0aGUgaW5wdXQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIGFwcGx5Um90YXRpb25cbiAqIEBwYXJhbSB7VmVjM30gdiBUaGUgcmVmZXJlbmNlIFZlYzMuXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgVW5pdCBRdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0ge1ZlYzN9IG91dHB1dCBWZWMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgcm90YXRlZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dCBWZWMzLlxuICovXG5WZWMzLmFwcGx5Um90YXRpb24gPSBmdW5jdGlvbiBhcHBseVJvdGF0aW9uKHYsIHEsIG91dHB1dCkge1xuICAgIHZhciBjdyA9IHEudztcbiAgICB2YXIgY3ggPSAtcS54O1xuICAgIHZhciBjeSA9IC1xLnk7XG4gICAgdmFyIGN6ID0gLXEuejtcblxuICAgIHZhciB2eCA9IHYueDtcbiAgICB2YXIgdnkgPSB2Lnk7XG4gICAgdmFyIHZ6ID0gdi56O1xuXG4gICAgdmFyIHR3ID0gLWN4ICogdnggLSBjeSAqIHZ5IC0gY3ogKiB2ejtcbiAgICB2YXIgdHggPSB2eCAqIGN3ICsgdnkgKiBjeiAtIGN5ICogdno7XG4gICAgdmFyIHR5ID0gdnkgKiBjdyArIGN4ICogdnogLSB2eCAqIGN6O1xuICAgIHZhciB0eiA9IHZ6ICogY3cgKyB2eCAqIGN5IC0gY3ggKiB2eTtcblxuICAgIHZhciB3ID0gY3c7XG4gICAgdmFyIHggPSAtY3g7XG4gICAgdmFyIHkgPSAtY3k7XG4gICAgdmFyIHogPSAtY3o7XG5cbiAgICBvdXRwdXQueCA9IHR4ICogdyArIHggKiB0dyArIHkgKiB0eiAtIHR5ICogejtcbiAgICBvdXRwdXQueSA9IHR5ICogdyArIHkgKiB0dyArIHR4ICogeiAtIHggKiB0ejtcbiAgICBvdXRwdXQueiA9IHR6ICogdyArIHogKiB0dyArIHggKiB0eSAtIHR4ICogeTtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBDbG9uZSB0aGUgaW5wdXQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIFZlYzMgdG8gY2xvbmUuXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgY2xvbmVkIFZlYzMuXG4gKi9cblZlYzMuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSh2KSB7XG4gICAgcmV0dXJuIG5ldyBWZWMzKHYueCwgdi55LCB2LnopO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGlucHV0IFZlYzMncy5cbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtWZWMzfSB2MSBUaGUgbGVmdCBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSB2MiBUaGUgcmlnaHQgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gb3V0cHV0IFZlYzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uLlxuICovXG5WZWMzLmFkZCA9IGZ1bmN0aW9uIGFkZCh2MSwgdjIsIG91dHB1dCkge1xuICAgIG91dHB1dC54ID0gdjEueCArIHYyLng7XG4gICAgb3V0cHV0LnkgPSB2MS55ICsgdjIueTtcbiAgICBvdXRwdXQueiA9IHYxLnogKyB2Mi56O1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0IHRoZSBzZWNvbmQgVmVjMyBmcm9tIHRoZSBmaXJzdC5cbiAqXG4gKiBAbWV0aG9kIHN1YnRyYWN0XG4gKiBAcGFyYW0ge1ZlYzN9IHYxIFRoZSBsZWZ0IFZlYzMuXG4gKiBAcGFyYW0ge1ZlYzN9IHYyIFRoZSByaWdodCBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSBvdXRwdXQgVmVjMyBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjM30gVGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24uXG4gKi9cblZlYzMuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdCh2MSwgdjIsIG91dHB1dCkge1xuICAgIG91dHB1dC54ID0gdjEueCAtIHYyLng7XG4gICAgb3V0cHV0LnkgPSB2MS55IC0gdjIueTtcbiAgICBvdXRwdXQueiA9IHYxLnogLSB2Mi56O1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlIHRoZSBpbnB1dCBWZWMzLlxuICpcbiAqIEBtZXRob2Qgc2NhbGVcbiAqIEBwYXJhbSB7VmVjM30gdiBUaGUgcmVmZXJlbmNlIFZlYzMuXG4gKiBAcGFyYW0ge051bWJlcn0gcyBOdW1iZXIgdG8gc2NhbGUgYnkuXG4gKiBAcGFyYW0ge1ZlYzN9IG91dHB1dCBWZWMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgcmVzdWx0IG9mIHRoZSBzY2FsaW5nLlxuICovXG5WZWMzLnNjYWxlID0gZnVuY3Rpb24gc2NhbGUodiwgcywgb3V0cHV0KSB7XG4gICAgb3V0cHV0LnggPSB2LnggKiBzO1xuICAgIG91dHB1dC55ID0gdi55ICogcztcbiAgICBvdXRwdXQueiA9IHYueiAqIHM7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogVGhlIGRvdCBwcm9kdWN0IG9mIHRoZSBpbnB1dCBWZWMzJ3MuXG4gKlxuICogQG1ldGhvZCBkb3RQcm9kdWN0XG4gKiBAcGFyYW0ge1ZlYzN9IHYxIFRoZSBsZWZ0IFZlYzMuXG4gKiBAcGFyYW0ge1ZlYzN9IHYyIFRoZSByaWdodCBWZWMzLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgZG90IHByb2R1Y3QuXG4gKi9cblZlYzMuZG90ID0gZnVuY3Rpb24gZG90KHYxLCB2Mikge1xuICAgIHJldHVybiB2MS54ICogdjIueCArIHYxLnkgKiB2Mi55ICsgdjEueiAqIHYyLno7XG59O1xuXG4vKipcbiAqIFRoZSAocmlnaHQtaGFuZGVkKSBjcm9zcyBwcm9kdWN0IG9mIHRoZSBpbnB1dCBWZWMzJ3MuXG4gKiB2MSB4IHYyLlxuICpcbiAqIEBtZXRob2QgY3Jvc3NQcm9kdWN0XG4gKiBAcGFyYW0ge1ZlYzN9IHYxIFRoZSBsZWZ0IFZlYzMuXG4gKiBAcGFyYW0ge1ZlYzN9IHYyIFRoZSByaWdodCBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSBvdXRwdXQgVmVjMyBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjM31cbiAqL1xuVmVjMy5jcm9zcyA9IGZ1bmN0aW9uIGNyb3NzKHYxLCB2Miwgb3V0cHV0KSB7XG4gICAgdmFyIHgxID0gdjEueDtcbiAgICB2YXIgeTEgPSB2MS55O1xuICAgIHZhciB6MSA9IHYxLno7XG4gICAgdmFyIHgyID0gdjIueDtcbiAgICB2YXIgeTIgPSB2Mi55O1xuICAgIHZhciB6MiA9IHYyLno7XG5cbiAgICBvdXRwdXQueCA9IHkxICogejIgLSB6MSAqIHkyO1xuICAgIG91dHB1dC55ID0gejEgKiB4MiAtIHgxICogejI7XG4gICAgb3V0cHV0LnogPSB4MSAqIHkyIC0geTEgKiB4MjtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBUaGUgcHJvamVjdGlvbiBvZiB2MSBvbnRvIHYyLlxuICpcbiAqIEBtZXRob2QgcHJvamVjdFxuICogQHBhcmFtIHtWZWMzfSB2MSBUaGUgbGVmdCBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSB2MiBUaGUgcmlnaHQgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gb3V0cHV0IFZlYzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblZlYzMucHJvamVjdCA9IGZ1bmN0aW9uIHByb2plY3QodjEsIHYyLCBvdXRwdXQpIHtcbiAgICB2YXIgeDEgPSB2MS54O1xuICAgIHZhciB5MSA9IHYxLnk7XG4gICAgdmFyIHoxID0gdjEuejtcbiAgICB2YXIgeDIgPSB2Mi54O1xuICAgIHZhciB5MiA9IHYyLnk7XG4gICAgdmFyIHoyID0gdjIuejtcblxuICAgIHZhciBzY2FsZSA9IHgxICogeDIgKyB5MSAqIHkyICsgejEgKiB6MjtcbiAgICBzY2FsZSAvPSB4MiAqIHgyICsgeTIgKiB5MiArIHoyICogejI7XG5cbiAgICBvdXRwdXQueCA9IHgyICogc2NhbGU7XG4gICAgb3V0cHV0LnkgPSB5MiAqIHNjYWxlO1xuICAgIG91dHB1dC56ID0gejIgKiBzY2FsZTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlYzM7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBNYXQzMzogcmVxdWlyZSgnLi9NYXQzMycpLFxuICAgIFF1YXRlcm5pb246IHJlcXVpcmUoJy4vUXVhdGVybmlvbicpLFxuICAgIFZlYzI6IHJlcXVpcmUoJy4vVmVjMicpLFxuICAgIFZlYzM6IHJlcXVpcmUoJy4vVmVjMycpXG59O1xuXG4iLCIvKmpzaGludCAtVzAwOCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDdXJ2ZXMgPSB7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGxpbmVhclxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgbGluZWFyOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZWFzZUluXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBlYXNlSW46IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGVhc2VPdXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGVhc2VPdXQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqKDItdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBlYXNlSW5PdXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGVhc2VJbk91dDogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAodCA8PSAwLjUpIHJldHVybiAyKnQqdDtcbiAgICAgICAgZWxzZSByZXR1cm4gLTIqdCp0ICsgNCp0IC0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGVhc2VPdXRCb3VuY2VcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGVhc2VPdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqKDMgLSAyKnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgc3ByaW5nXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBzcHJpbmc6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICgxIC0gdCkgKiBNYXRoLnNpbig2ICogTWF0aC5QSSAqIHQpICsgdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluUXVhZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5RdWFkOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRRdWFkXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRRdWFkOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAtKHQtPTEpKnQrMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0UXVhZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRRdWFkOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41KnQqdDtcbiAgICAgICAgcmV0dXJuIC0uNSooKC0tdCkqKHQtMikgLSAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluQ3ViaWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluQ3ViaWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdCp0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0Q3ViaWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dEN1YmljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAoKC0tdCkqdCp0ICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dEN1YmljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dEN1YmljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41KnQqdCp0O1xuICAgICAgICByZXR1cm4gLjUqKCh0LT0yKSp0KnQgKyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluUXVhcnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluUXVhcnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdCp0KnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRRdWFydFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0oKC0tdCkqdCp0KnQgLSAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0UXVhcnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqdCp0KnQqdDtcbiAgICAgICAgcmV0dXJuIC0uNSAqICgodC09MikqdCp0KnQgLSAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluUXVpbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluUXVpbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdCp0KnQqdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dFF1aW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRRdWludDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gKCgtLXQpKnQqdCp0KnQgKyAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0UXVpbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqdCp0KnQqdCp0O1xuICAgICAgICByZXR1cm4gLjUqKCh0LT0yKSp0KnQqdCp0ICsgMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpblNpbmVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluU2luZTogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLTEuMCpNYXRoLmNvcyh0ICogKE1hdGguUEkvMikpICsgMS4wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0U2luZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0U2luZTogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zaW4odCAqIChNYXRoLlBJLzIpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0U2luZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRTaW5lOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAtLjUqKE1hdGguY29zKE1hdGguUEkqdCkgLSAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluRXhwb1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5FeHBvOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAodD09PTApID8gMC4wIDogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dEV4cG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dEV4cG86IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICh0PT09MS4wKSA/IDEuMCA6ICgtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0RXhwb1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRFeHBvOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0PT09MCkgcmV0dXJuIDAuMDtcbiAgICAgICAgaWYgKHQ9PT0xLjApIHJldHVybiAxLjA7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcbiAgICAgICAgcmV0dXJuIC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbkNpcmNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluQ2lyYzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLShNYXRoLnNxcnQoMSAtIHQqdCkgLSAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dENpcmNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dENpcmM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgxIC0gKC0tdCkqdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dENpcmNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAtLjUgKiAoTWF0aC5zcXJ0KDEgLSB0KnQpIC0gMSk7XG4gICAgICAgIHJldHVybiAuNSAqIChNYXRoLnNxcnQoMSAtICh0LT0yKSp0KSArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5FbGFzdGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbkVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHM9MS43MDE1ODt2YXIgcD0wO3ZhciBhPTEuMDtcbiAgICAgICAgaWYgKHQ9PT0wKSByZXR1cm4gMC4wOyAgaWYgKHQ9PT0xKSByZXR1cm4gMS4wOyAgaWYgKCFwKSBwPS4zO1xuICAgICAgICBzID0gcC8oMipNYXRoLlBJKSAqIE1hdGguYXNpbigxLjAvYSk7XG4gICAgICAgIHJldHVybiAtKGEqTWF0aC5wb3coMiwxMCoodC09MSkpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvIHApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dEVsYXN0aWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHM9MS43MDE1ODt2YXIgcD0wO3ZhciBhPTEuMDtcbiAgICAgICAgaWYgKHQ9PT0wKSByZXR1cm4gMC4wOyAgaWYgKHQ9PT0xKSByZXR1cm4gMS4wOyAgaWYgKCFwKSBwPS4zO1xuICAgICAgICBzID0gcC8oMipNYXRoLlBJKSAqIE1hdGguYXNpbigxLjAvYSk7XG4gICAgICAgIHJldHVybiBhKk1hdGgucG93KDIsLTEwKnQpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvcCkgKyAxLjA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dEVsYXN0aWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcz0xLjcwMTU4O3ZhciBwPTA7dmFyIGE9MS4wO1xuICAgICAgICBpZiAodD09PTApIHJldHVybiAwLjA7ICBpZiAoKHQvPS41KT09PTIpIHJldHVybiAxLjA7ICBpZiAoIXApIHA9KC4zKjEuNSk7XG4gICAgICAgIHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luKDEuMC9hKTtcbiAgICAgICAgaWYgKHQgPCAxKSByZXR1cm4gLS41KihhKk1hdGgucG93KDIsMTAqKHQtPTEpKSAqIE1hdGguc2luKCh0LXMpKigyKk1hdGguUEkpL3ApKTtcbiAgICAgICAgcmV0dXJuIGEqTWF0aC5wb3coMiwtMTAqKHQtPTEpKSAqIE1hdGguc2luKCh0LXMpKigyKk1hdGguUEkpL3ApKi41ICsgMS4wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5CYWNrXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbkJhY2s6IGZ1bmN0aW9uKHQsIHMpIHtcbiAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiB0KnQqKChzKzEpKnQgLSBzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dEJhY2tcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dEJhY2s6IGZ1bmN0aW9uKHQsIHMpIHtcbiAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiAoKC0tdCkqdCooKHMrMSkqdCArIHMpICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dEJhY2tcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0QmFjazogZnVuY3Rpb24odCwgcykge1xuICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMS43MDE1ODtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqKHQqdCooKChzKj0oMS41MjUpKSsxKSp0IC0gcykpO1xuICAgICAgICByZXR1cm4gLjUqKCh0LT0yKSp0KigoKHMqPSgxLjUyNSkpKzEpKnQgKyBzKSArIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5Cb3VuY2VcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluQm91bmNlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAxLjAgLSBDdXJ2ZXMub3V0Qm91bmNlKDEuMC10KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dEJvdW5jZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0IDwgKDEvMi43NSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoNy41NjI1KnQqdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodCA8ICgyLzIuNzUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDcuNTYyNSoodC09KDEuNS8yLjc1KSkqdCArIC43NSk7XG4gICAgICAgIH0gZWxzZSBpZiAodCA8ICgyLjUvMi43NSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoNy41NjI1Kih0LT0oMi4yNS8yLjc1KSkqdCArIC45Mzc1KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoNy41NjI1Kih0LT0oMi42MjUvMi43NSkpKnQgKyAuOTg0Mzc1KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRCb3VuY2VcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0IDwgLjUpIHJldHVybiBDdXJ2ZXMuaW5Cb3VuY2UodCoyKSAqIC41O1xuICAgICAgICByZXR1cm4gQ3VydmVzLm91dEJvdW5jZSh0KjItMS4wKSAqIC41ICsgLjU7XG4gICAgfSxcblxuICAgIGZsYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1cnZlcztcbiIsIi8qanNoaW50IC1XMDA4ICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9kZWZhdWx0Q3VydmVzID0ge1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBsaW5lYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGxpbmVhcjogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGVhc2VJblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZWFzZUluOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBlYXNlT3V0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBlYXNlT3V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KigyLXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZWFzZUluT3V0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBlYXNlSW5PdXQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQgPD0gMC41KSByZXR1cm4gMip0KnQ7XG4gICAgICAgIGVsc2UgcmV0dXJuIC0yKnQqdCArIDQqdCAtIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBlYXNlT3V0Qm91bmNlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KigzIC0gMip0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNwcmluZ1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgc3ByaW5nOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAoMSAtIHQpICogTWF0aC5zaW4oNiAqIE1hdGguUEkgKiB0KSArIHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpblF1YWRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluUXVhZDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0UXVhZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0UXVhZDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLSh0LT0xKSp0KzE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dFF1YWRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0UXVhZDogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSp0KnQ7XG4gICAgICAgIHJldHVybiAtLjUqKCgtLXQpKih0LTIpIC0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbkN1YmljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbkN1YmljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KnQqdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dEN1YmljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRDdWJpYzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gKCgtLXQpKnQqdCArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRDdWJpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRDdWJpYzogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSp0KnQqdDtcbiAgICAgICAgcmV0dXJuIC41KigodC09MikqdCp0ICsgMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpblF1YXJ0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpblF1YXJ0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KnQqdCp0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0UXVhcnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAtKCgtLXQpKnQqdCp0IC0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dFF1YXJ0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41KnQqdCp0KnQ7XG4gICAgICAgIHJldHVybiAtLjUgKiAoKHQtPTIpKnQqdCp0IC0gMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpblF1aW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpblF1aW50OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KnQqdCp0KnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRRdWludFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICgoLS10KSp0KnQqdCp0ICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dFF1aW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dFF1aW50OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41KnQqdCp0KnQqdDtcbiAgICAgICAgcmV0dXJuIC41KigodC09MikqdCp0KnQqdCArIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5TaW5lXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpblNpbmU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0xLjAqTWF0aC5jb3ModCAqIChNYXRoLlBJLzIpKSArIDEuMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dFNpbmVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKHQgKiAoTWF0aC5QSS8yKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dFNpbmVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0U2luZTogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLS41KihNYXRoLmNvcyhNYXRoLlBJKnQpIC0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbkV4cG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluRXhwbzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gKHQ9PT0wKSA/IDAuMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRFeHBvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRFeHBvOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAodD09PTEuMCkgPyAxLjAgOiAoLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dEV4cG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0RXhwbzogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAodD09PTApIHJldHVybiAwLjA7XG4gICAgICAgIGlmICh0PT09MS4wKSByZXR1cm4gMS4wO1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG4gICAgICAgIHJldHVybiAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5DaXJjXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbkNpcmM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0oTWF0aC5zcXJ0KDEgLSB0KnQpIC0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRDaXJjXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRDaXJjOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLXQpKnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRDaXJjXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dENpcmM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLS41ICogKE1hdGguc3FydCgxIC0gdCp0KSAtIDEpO1xuICAgICAgICByZXR1cm4gLjUgKiAoTWF0aC5zcXJ0KDEgLSAodC09MikqdCkgKyAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluRWxhc3RpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5FbGFzdGljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzPTEuNzAxNTg7dmFyIHA9MDt2YXIgYT0xLjA7XG4gICAgICAgIGlmICh0PT09MCkgcmV0dXJuIDAuMDsgIGlmICh0PT09MSkgcmV0dXJuIDEuMDsgIGlmICghcCkgcD0uMztcbiAgICAgICAgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4oMS4wL2EpO1xuICAgICAgICByZXR1cm4gLShhKk1hdGgucG93KDIsMTAqKHQtPTEpKSAqIE1hdGguc2luKCh0LXMpKigyKk1hdGguUEkpLyBwKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRFbGFzdGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzPTEuNzAxNTg7dmFyIHA9MDt2YXIgYT0xLjA7XG4gICAgICAgIGlmICh0PT09MCkgcmV0dXJuIDAuMDsgIGlmICh0PT09MSkgcmV0dXJuIDEuMDsgIGlmICghcCkgcD0uMztcbiAgICAgICAgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4oMS4wL2EpO1xuICAgICAgICByZXR1cm4gYSpNYXRoLnBvdygyLC0xMCp0KSAqIE1hdGguc2luKCh0LXMpKigyKk1hdGguUEkpL3ApICsgMS4wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRFbGFzdGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHM9MS43MDE1ODt2YXIgcD0wO3ZhciBhPTEuMDtcbiAgICAgICAgaWYgKHQ9PT0wKSByZXR1cm4gMC4wOyAgaWYgKCh0Lz0uNSk9PT0yKSByZXR1cm4gMS4wOyAgaWYgKCFwKSBwPSguMyoxLjUpO1xuICAgICAgICBzID0gcC8oMipNYXRoLlBJKSAqIE1hdGguYXNpbigxLjAvYSk7XG4gICAgICAgIGlmICh0IDwgMSkgcmV0dXJuIC0uNSooYSpNYXRoLnBvdygyLDEwKih0LT0xKSkgKiBNYXRoLnNpbigodC1zKSooMipNYXRoLlBJKS9wKSk7XG4gICAgICAgIHJldHVybiBhKk1hdGgucG93KDIsLTEwKih0LT0xKSkgKiBNYXRoLnNpbigodC1zKSooMipNYXRoLlBJKS9wKSouNSArIDEuMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluQmFja1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5CYWNrOiBmdW5jdGlvbih0LCBzKSB7XG4gICAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHMgPSAxLjcwMTU4O1xuICAgICAgICByZXR1cm4gdCp0KigocysxKSp0IC0gcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRCYWNrXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRCYWNrOiBmdW5jdGlvbih0LCBzKSB7XG4gICAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHMgPSAxLjcwMTU4O1xuICAgICAgICByZXR1cm4gKCgtLXQpKnQqKChzKzEpKnQgKyBzKSArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRCYWNrXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dEJhY2s6IGZ1bmN0aW9uKHQsIHMpIHtcbiAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDEuNzAxNTg7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41Kih0KnQqKCgocyo9KDEuNTI1KSkrMSkqdCAtIHMpKTtcbiAgICAgICAgcmV0dXJuIC41KigodC09MikqdCooKChzKj0oMS41MjUpKSsxKSp0ICsgcykgKyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluQm91bmNlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbkJvdW5jZTogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gMS4wIC0gX2RlZmF1bHRDdXJ2ZXMub3V0Qm91bmNlKDEuMC10KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dEJvdW5jZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0IDwgKDEvMi43NSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoNy41NjI1KnQqdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodCA8ICgyLzIuNzUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDcuNTYyNSoodC09KDEuNS8yLjc1KSkqdCArIC43NSk7XG4gICAgICAgIH0gZWxzZSBpZiAodCA8ICgyLjUvMi43NSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoNy41NjI1Kih0LT0oMi4yNS8yLjc1KSkqdCArIC45Mzc1KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoNy41NjI1Kih0LT0oMi42MjUvMi43NSkpKnQgKyAuOTg0Mzc1KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRCb3VuY2VcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0IDwgLjUpIHJldHVybiBfZGVmYXVsdEN1cnZlcy5pbkJvdW5jZSh0KjIpICogLjU7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdEN1cnZlcy5vdXRCb3VuY2UodCoyLTEuMCkgKiAuNSArIC41O1xuICAgIH1cbn07XG5cbnZhciBfY3VydmVzID0gT2JqZWN0LmNyZWF0ZShfZGVmYXVsdEN1cnZlcyk7XG5cbi8qXG4gKiBBIGxpYnJhcnkgb2YgY3VydmVzIHdoaWNoIG1hcCBhbiBhbmltYXRpb24gZXhwbGljaXRseSBhcyBhIGZ1bmN0aW9uIG9mIHRpbWUuXG4gKiAgICBUaGUgZm9sbG93aW5nIGVhc2luZyBjdXJ2ZXMgYXJlIGF2YWlsYWJsZSBieSBkZWZhdWx0IGFuZCBjYW4gbm90IGJlXG4gKiAgICB1bnJlZ2lzdGVyZWQgb3Igb3ZlcndyaXR0ZW46XG4gKlxuICogICAgbGluZWFyLFxuICogICAgZWFzZUluLCBlYXNlT3V0LCBlYXNlSW5PdXQsXG4gKiAgICBlYXNlT3V0Qm91bmNlLFxuICogICAgc3ByaW5nLFxuICogICAgaW5RdWFkLCBvdXRRdWFkLCBpbk91dFF1YWQsXG4gKiAgICBpbkN1YmljLCBvdXRDdWJpYywgaW5PdXRDdWJpYyxcbiAqICAgIGluUXVhcnQsIG91dFF1YXJ0LCBpbk91dFF1YXJ0LFxuICogICAgaW5RdWludCwgb3V0UXVpbnQsIGluT3V0UXVpbnQsXG4gKiAgICBpblNpbmUsIG91dFNpbmUsIGluT3V0U2luZSxcbiAqICAgIGluRXhwbywgb3V0RXhwbywgaW5PdXRFeHBvLFxuICogICAgaW5DaXJjLCBvdXRDaXJjLCBpbk91dENpcmMsXG4gKiAgICBpbkVsYXN0aWMsIG91dEVsYXN0aWMsIGluT3V0RWxhc3RpYyxcbiAqICAgIGluQmFjaywgb3V0QmFjaywgaW5PdXRCYWNrLFxuICogICAgaW5Cb3VuY2UsIG91dEJvdW5jZSwgaW5PdXRCb3VuY2VcbiAqXG4gKiBAY2xhc3MgRWFzaW5nXG4gKiBAZGVwcmVjYXRlZCBVc2UgY3VydmVzIGluc3RlYWRcbiAqL1xudmFyIEVhc2luZyA9IHtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBnaXZlbiBjdXJ2ZSB0byBiZSBhdmFpbGFibGUgaW4gc3Vic2VxdWVudCB0cmFuc2l0aW9ucyBieVxuICAgICAqICAgIGFkZGluZyBpdCB0byB0aGUgaW50ZXJhbCBkaWN0aW9uYXJ5IG9mIHJlZ2lzdGVyZWQgY3VydmVzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZWdpc3RlckN1cnZlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGFuIGVycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBvdmVyd3JpdGUgZGVmYXVsdFxuICAgICAqICAgIGN1cnZlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGFuIGVycm9yIGlmIGN1cnZlIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHVuaXF1ZSBuYW1lIGZvciBsYXRlciBhY2Nlc3NcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXJ2ZSBmdW5jdGlvbiBvZiBvbmUgbnVtZXJpYyB2YXJpYWJsZSBtYXBwaW5nIFswLDFdXG4gICAgICogICAgdG8gcmFuZ2UgaW5zaWRlIFswLDFdXG4gICAgICogQHJldHVybiB7RWFzaW5nfSB0aGlzXG4gICAgICovXG4gICAgcmVnaXN0ZXJDdXJ2ZTogZnVuY3Rpb24obmFtZSwgY3VydmUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdFYXNpbmcgaXMgZGVwcmVjYXRlZCEgVXNlIHRyYW5zaXRpb25zLkN1cnZlcyBpbnN0ZWFkIScpO1xuICAgICAgICBpZiAoX2RlZmF1bHRDdXJ2ZXNbbmFtZV0pIHRocm93IG5ldyBFcnJvcignRGVmYXVsdCBjdXJ2ZXMgY2FuIG5vdCBiZSBvdmVyd3JpdHRlbicpO1xuICAgICAgICBpZiAoX2N1cnZlc1tuYW1lXSkgdGhyb3cgbmV3IEVycm9yKCdDdXJ2ZSBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQnKTtcbiAgICAgICAgX2N1cnZlc1tuYW1lXSA9IGN1cnZlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlcnMgdGhlIGN1cnZlIHJlZ2lzdGVyZWQgdW5kZXIgdGhlIGdpdmVuIG5hbWUgYnkgcmVtb3ZpbmcgaXQgZnJvbVxuICAgICAqICAgIHRoZSBpbnRlcm5hbCBkaWN0aW9uYXJ5IG9mIHJlZ2lzdGVyZWQgY3VydmVzLiBUaGlzIHdvbid0IGVmZmVjdFxuICAgICAqICAgIGN1cnJlbnRseSBhY3RpdmUgdHJhbnNpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVucmVnaXN0ZXJDdXJ2ZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc3RhdGljXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBjdXJ2ZSBkb2VzIG5vdCBleGlzdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIGN1cnZlXG4gICAgICogQHJldHVybiB7RWFzaW5nfSB0aGlzXG4gICAgICovXG4gICAgdW5yZWdpc3RlckN1cnZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRWFzaW5nIGlzIGRlcHJlY2F0ZWQhIFVzZSB0cmFuc2l0aW9ucy5DdXJ2ZXMgaW5zdGVhZCEnKTtcbiAgICAgICAgaWYgKF9kZWZhdWx0Q3VydmVzW25hbWVdKSB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgY3VydmVzIGNhbiBub3QgYmUgdW5yZWdpc3RlcmVkJyk7XG4gICAgICAgIGlmICghX2N1cnZlc1tuYW1lXSkgdGhyb3cgbmV3IEVycm9yKCdDdXJ2ZSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCcpO1xuICAgICAgICBkZWxldGUgX2N1cnZlc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVhc2luZyBjdXJ2ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRDdXJ2ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgY3VydmVcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gY3VydmUgZnVuY3Rpb24gb2Ygb25lIG51bWVyaWMgdmFyaWFibGUgbWFwcGluZyBbMCwxXVxuICAgICAqICAgIHRvIHJhbmdlIGluc2lkZSBbMCwxXVxuICAgICAqL1xuICAgIGdldEN1cnZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRWFzaW5nIGlzIGRlcHJlY2F0ZWQhIFVzZSB0cmFuc2l0aW9ucy5DdXJ2ZXMgaW5zdGVhZCEnKTtcbiAgICAgICAgcmV0dXJuIF9jdXJ2ZXNbbmFtZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbmFtZXMgb2YgYWxsIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBlYXNpbmcgY3VydmVzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRDdXJ2ZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0gYXJyYXkgb2YgcmVnaXN0ZXJlZCBlYXNpbmcgY3VydmVzXG4gICAgICovXG4gICAgZ2V0Q3VydmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdFYXNpbmcgaXMgZGVwcmVjYXRlZCEgVXNlIHRyYW5zaXRpb25zLkN1cnZlcyBpbnN0ZWFkIScpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoX2RlZmF1bHRDdXJ2ZXMpLmNvbmNhdChPYmplY3Qua2V5cyhfY3VydmVzKSk7XG4gICAgfSxcblxuICAgIGNyZWF0ZUJlemllckN1cnZlOiBmdW5jdGlvbih2MSwgdjIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdFYXNpbmcgaXMgZGVwcmVjYXRlZCEgVXNlIHRyYW5zaXRpb25zLkN1cnZlcyBpbnN0ZWFkIScpO1xuICAgICAgICB2MSA9IHYxIHx8IDA7IHYyID0gdjIgfHwgMDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB2MSp0ICsgKC0yKnYxIC0gdjIgKyAzKSp0KnQgKyAodjEgKyB2MiAtIDIpKnQqdCp0O1xuICAgICAgICB9O1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRWFzaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ3VydmVzID0gcmVxdWlyZSgnLi9DdXJ2ZXMnKTtcblxuLyoqXG4gKiBBIHN0YXRlIG1haW50YWluZXIgZm9yIGEgc21vb3RoIHRyYW5zaXRpb24gYmV0d2VlblxuICogICAgbnVtZXJpY2FsbHktc3BlY2lmaWVkIHN0YXRlcy4gRXhhbXBsZSBudW1lcmljIHN0YXRlcyBpbmNsdWRlIGZsb2F0cyBhbmRcbiAqICAgIGFycmF5cyBvZiBmbG9hdHMgb2JqZWN0cy5cbiAqXG4gKiBBbiBpbml0aWFsIHN0YXRlIGlzIHNldCB3aXRoIHRoZSBjb25zdHJ1Y3RvciBvciB1c2luZ1xuICogICAgIHtAbGluayBUcmFuc2l0aW9uYWJsZSNmcm9tfS4gU3Vic2VxdWVudCB0cmFuc2l0aW9ucyBjb25zaXN0IG9mIGFuXG4gKiAgICAgaW50ZXJtZWRpYXRlIHN0YXRlLCBlYXNpbmcgY3VydmUsIGR1cmF0aW9uIGFuZCBjYWxsYmFjay4gVGhlIGZpbmFsIHN0YXRlXG4gKiAgICAgb2YgZWFjaCB0cmFuc2l0aW9uIGlzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBzdWJzZXF1ZW50IG9uZS4gQ2FsbHMgdG9cbiAqICAgICB7QGxpbmsgVHJhbnNpdGlvbmFibGUjZ2V0fSBwcm92aWRlIHRoZSBpbnRlcnBvbGF0ZWQgc3RhdGUgYWxvbmcgdGhlIHdheS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gZXZlbnQgbG9vcCBoZXJlIC0gY2FsbHMgdG8ge0BsaW5rIFRyYW5zaXRpb25hYmxlI2dldH1cbiAqICAgIGFyZSB0aGUgb25seSB3YXkgdG8gZmluZCBzdGF0ZSBwcm9qZWN0ZWQgdG8gdGhlIGN1cnJlbnQgKG9yIHByb3ZpZGVkKVxuICogICAgdGltZSBhbmQgYXJlIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGNhbGxiYWNrcyBhbmQgbXV0YXRlIHRoZSBpbnRlcm5hbFxuICogICAgdHJhbnNpdGlvbiBxdWV1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHQgPSBuZXcgVHJhbnNpdGlvbmFibGUoWzAsIDBdKTtcbiAqIHRcbiAqICAgICAudG8oWzEwMCwgMF0sICdsaW5lYXInLCAxMDAwKVxuICogICAgIC5kZWxheSgxMDAwKVxuICogICAgIC50byhbMjAwLCAwXSwgJ291dEJvdW5jZScsIDEwMDApO1xuICpcbiAqIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAqIGRpdi5zdHlsZS5iYWNrZ3JvdW5kID0gJ2JsdWUnO1xuICogZGl2LnN0eWxlLndpZHRoID0gJzEwMHB4JztcbiAqIGRpdi5zdHlsZS5oZWlnaHQgPSAnMTAwcHgnO1xuICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICpcbiAqIGRpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICogICAgIHQuaXNQYXVzZWQoKSA/IHQucmVzdW1lKCkgOiB0LnBhdXNlKCk7XG4gKiB9KTtcbiAqXG4gKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCgpIHtcbiAqICAgICBkaXYuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoJyArIHQuZ2V0KClbMF0gKyAncHgpJyArICcgdHJhbnNsYXRlWSgnICsgdC5nZXQoKVsxXSArICdweCknO1xuICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAqIH0pO1xuICpcbiAqIEBjbGFzcyBUcmFuc2l0aW9uYWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcnxBcnJheS5OdW1iZXJ9IGluaXRpYWxTdGF0ZSAgICBpbml0aWFsIHN0YXRlIHRvIHRyYW5zaXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gLSBlcXVpdmFsZW50IHRvIGEgcHVyc3VhbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludm9jYXRpb24gb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBUcmFuc2l0aW9uYWJsZSNmcm9tfVxuICovXG5mdW5jdGlvbiBUcmFuc2l0aW9uYWJsZShpbml0aWFsU3RhdGUpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX211bHRpID0gbnVsbDtcbiAgICB0aGlzLl9lbmQgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0ZWRBdCA9IG51bGw7XG4gICAgdGhpcy5fcGF1c2VkQXQgPSBudWxsO1xuICAgIGlmIChpbml0aWFsU3RhdGUgIT0gbnVsbCkgdGhpcy5mcm9tKGluaXRpYWxTdGF0ZSk7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgQ2xvY2sgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgdGhlIGN1cnJlbnQgdGltZSBmb3IgdGhlIG9uZ29pbmdcbiAqIHRyYW5zaXRpb25zLlxuICpcbiAqIEB0eXBlIHtQZXJmb3JtYW5jZXxEYXRlfE9iamVjdH1cbiAqL1xuVHJhbnNpdGlvbmFibGUuQ2xvY2sgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnID8gcGVyZm9ybWFuY2UgOiBEYXRlO1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIHRyYW5zaXRpb24gdG8gYmUgcHVzaGVkIG9udG8gdGhlIGludGVybmFsIHF1ZXVlLlxuICpcbiAqIEBtZXRob2QgdG9cbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfSAgICBmaW5hbFN0YXRlICAgICAgICAgICAgICBmaW5hbCBzdGF0ZSB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdG9uIHRvXG4gKiBAcGFyYW0gIHtTdHJpbmd8RnVuY3Rpb259ICAgICAgICBbY3VydmU9Q3VydmVzLmxpbmVhcl0gICBlYXNpbmcgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMCwgMV1cbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICAgICAgICAgIFtkdXJhdGlvbj0xMDBdICAgICAgICAgIGR1cmF0aW9uIG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgICAgICAgICBbY2FsbGJhY2tdICAgICAgICAgICAgICBjYWxsYmFjayBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgY2FsbGVkIGFmdGVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdHJhbnNpdGlvbiBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVcbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSAgICAgICAgIHRoaXNcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gdG8oZmluYWxTdGF0ZSwgY3VydmUsIGR1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgIGN1cnZlID0gY3VydmUgIT0gbnVsbCAmJiBjdXJ2ZS5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nID8gQ3VydmVzW2N1cnZlXSA6IGN1cnZlO1xuICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fc3RhcnRlZEF0ID0gdGhpcy5jb25zdHJ1Y3Rvci5DbG9jay5ub3coKTtcbiAgICAgICAgdGhpcy5fcGF1c2VkQXQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9xdWV1ZS5wdXNoKFxuICAgICAgICBmaW5hbFN0YXRlLFxuICAgICAgICBjdXJ2ZSAhPSBudWxsID8gY3VydmUgOiBDdXJ2ZXMubGluZWFyLFxuICAgICAgICBkdXJhdGlvbiAhPSBudWxsID8gZHVyYXRpb24gOiAxMDAsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoZSB0cmFuc2l0aW9uIHF1ZXVlIHRvIGEgc3RhYmxlIGluaXRpYWwgc3RhdGUuXG4gKlxuICogQG1ldGhvZCBmcm9tXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfEFycmF5Lk51bWJlcn0gICAgaW5pdGlhbFN0YXRlICAgIGluaXRpYWwgc3RhdGUgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uIGZyb21cbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSAgICAgICAgIHRoaXNcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiBmcm9tKGluaXRpYWxTdGF0ZSkge1xuICAgIHRoaXMuX2VuZCA9IGluaXRpYWxTdGF0ZTtcbiAgICBpZiAoaW5pdGlhbFN0YXRlLmNvbnN0cnVjdG9yID09PSBBcnJheSAmJiB0aGlzLl9tdWx0aSAhPSBudWxsICYmIHRoaXMuX211bHRpLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICB0aGlzLl9tdWx0aS5sZW5ndGggPSBpbml0aWFsU3RhdGUubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX211bHRpID0gaW5pdGlhbFN0YXRlLmNvbnN0cnVjdG9yID09PSBBcnJheSA/IFtdIDogZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fc3RhcnRlZEF0ID0gdGhpcy5jb25zdHJ1Y3Rvci5DbG9jay5ub3coKTtcbiAgICB0aGlzLl9wYXVzZWRBdCA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlbGF5cyB0aGUgZXhlY3V0aW9uIG9mIHRoZSBzdWJzZXF1ZW50IHRyYW5zaXRpb24gZm9yIGEgY2VydGFpbiBwZXJpb2Qgb2ZcbiAqIHRpbWUuXG4gKlxuICogQG1ldGhvZCBkZWxheVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgIGR1cmF0aW9uICAgIGRlbGF5IHRpbWUgaW4gbXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259ICAgIFtjYWxsYmFja10gIFplcm8tYXJndW1lbnQgZnVuY3Rpb24gdG8gY2FsbCBvbiBvYnNlcnZlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvbiAodD0xKVxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiBkZWxheShkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgZW5kU3RhdGUgPSB0aGlzLl9xdWV1ZS5sZW5ndGggPiAwID8gdGhpcy5fcXVldWVbdGhpcy5fcXVldWUubGVuZ3RoIC0gNF0gOiB0aGlzLl9lbmQ7XG4gICAgcmV0dXJuIHRoaXMudG8oZW5kU3RhdGUsIEN1cnZlcy5mbGF0LCBkdXJhdGlvbiwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZXMgY3VycmVudCB0cmFuc2l0aW9uLlxuICpcbiAqIEBtZXRob2Qgb3ZlcnJpZGVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfSAgICBbZmluYWxTdGF0ZV0gICAgZmluYWwgc3RhdGUgdG8gdHJhbnNpdG9uIHRvXG4gKiBAcGFyYW0gIHtTdHJpbmd8RnVuY3Rpb259ICAgICAgICBbY3VydmVdICAgICAgICAgZWFzaW5nIGZ1bmN0aW9uIHVzZWQgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGluZyBbMCwgMV1cbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICAgICAgICAgIFtkdXJhdGlvbl0gICAgICBkdXJhdGlvbiBvZiB0cmFuc2l0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgICAgICAgICBbY2FsbGJhY2tdICAgICAgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWQgYWZ0ZXIgdGhlIHRyYW5zaXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBjb21wbGV0ZVxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUub3ZlcnJpZGUgPSBmdW5jdGlvbiBvdmVycmlkZShmaW5hbFN0YXRlLCBjdXJ2ZSwgZHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGZpbmFsU3RhdGUgIT0gbnVsbCkgdGhpcy5fcXVldWVbMF0gPSBmaW5hbFN0YXRlO1xuICAgICAgICBpZiAoY3VydmUgIT0gbnVsbCkgICAgICB0aGlzLl9xdWV1ZVsxXSA9IGN1cnZlLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgPyBDdXJ2ZXNbY3VydmVdIDogY3VydmU7XG4gICAgICAgIGlmIChkdXJhdGlvbiAhPSBudWxsKSAgIHRoaXMuX3F1ZXVlWzJdID0gZHVyYXRpb247XG4gICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSAgIHRoaXMuX3F1ZXVlWzNdID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLl9pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIF9pbnRlcnBvbGF0ZShmcm9tLCB0bywgcHJvZ3Jlc3MpIHtcbiAgICBpZiAodGhpcy5fbXVsdGkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0by5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbXVsdGlbaV0gPSBmcm9tW2ldICsgcHJvZ3Jlc3MgKiAodG9baV0gLSBmcm9tW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbXVsdGk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZyb20gKyBwcm9ncmVzcyAqICh0byAtIGZyb20pO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGludGVycG9sYXRlZCBzdGF0ZSBvZiBjdXJyZW50IGFjdGlvbiBhdCBwcm92aWRlZCB0aW1lLiBJZiB0aGUgbGFzdFxuICogICAgYWN0aW9uIGhhcyBjb21wbGV0ZWQsIGludm9rZSBpdHMgY2FsbGJhY2suXG4gKlxuICogQG1ldGhvZCBnZXRcbiAqXG4gKiBAcGFyYW0ge051bWJlcj19IHRpbWVzdGFtcCBFdmFsdWF0ZSB0aGUgY3VydmUgYXQgYSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhpc1xuICogICAgdGltZS4gSWYgb21pdHRlZCwgdXNlIGN1cnJlbnQgdGltZS4gKFVuaXggZXBvY2ggdGltZSlcbiAqIEByZXR1cm4ge051bWJlcnxBcnJheS5OdW1iZXJ9IGJlZ2lubmluZyBzdGF0ZVxuICogICAgaW50ZXJwb2xhdGVkIHRvIHRoaXMgcG9pbnQgaW4gdGltZS5cbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCh0KSB7XG4gICAgdCA9IHRoaXMuX3BhdXNlZEF0ID8gdGhpcy5fcGF1c2VkQXQgOiB0O1xuICAgIHQgPSB0ID8gdCA6IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCk7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2VuZDtcblxuICAgIHZhciBwcm9ncmVzcyA9ICh0IC0gdGhpcy5fc3RhcnRlZEF0KSAvIHRoaXMuX3F1ZXVlWzJdO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2ludGVycG9sYXRlKHRoaXMuX2VuZCwgdGhpcy5fcXVldWVbMF0sIHRoaXMuX3F1ZXVlWzFdKHByb2dyZXNzID4gMSA/IDEgOiBwcm9ncmVzcykpO1xuICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWRBdCA9IHRoaXMuX3N0YXJ0ZWRBdCArIHRoaXMuX3F1ZXVlWzJdO1xuICAgICAgICB0aGlzLl9lbmQgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9ncmVzcyA+IDEgPyB0aGlzLmdldCgpIDogc3RhdGU7XG59O1xuXG4vKipcbiAqIElzIHRoZXJlIGF0IGxlYXN0IG9uZSB0cmFuc2l0aW9uIHBlbmRpbmcgY29tcGxldGlvbj9cbiAqXG4gKiBAbWV0aG9kIGlzQWN0aXZlXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDA7XG59O1xuXG4vKipcbiAqIEhhbHQgdHJhbnNpdGlvbiBhdCBjdXJyZW50IHN0YXRlIGFuZCBlcmFzZSBhbGwgcGVuZGluZyBhY3Rpb25zLlxuICpcbiAqIEBtZXRob2QgaGFsdFxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSB0aGlzXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gaGFsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKHRoaXMuZ2V0KCkpO1xufTtcblxuLyoqXG4gKiBQYXVzZSB0cmFuc2l0aW9uLiBUaGlzIHdpbGwgbm90IGVyYXNlIGFueSBhY3Rpb25zLlxuICpcbiAqIEBtZXRob2QgcGF1c2VcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICB0aGlzLl9wYXVzZWRBdCA9IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEhhcyB0aGUgY3VycmVudCBhY3Rpb24gYmVlbiBwYXVzZWQ/XG4gKlxuICogQG1ldGhvZCBpc1BhdXNlZFxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlmIHRoZSBjdXJyZW50IGFjdGlvbiBoYXMgYmVlbiBwYXVzZWRcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gaXNQYXVzZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcGF1c2VkQXQ7XG59O1xuXG4vKipcbiAqIFJlc3VtZSB0cmFuc2l0aW9uLlxuICpcbiAqIEBtZXRob2QgcmVzdW1lXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9IHRoaXNcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICB2YXIgZGlmZiA9IHRoaXMuX3BhdXNlZEF0IC0gdGhpcy5fc3RhcnRlZEF0O1xuICAgIHRoaXMuX3N0YXJ0ZWRBdCA9IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCkgLSBkaWZmO1xuICAgIHRoaXMuX3BhdXNlZEF0ID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FuY2VsIGFsbCB0cmFuc2l0aW9ucyBhbmQgcmVzZXQgdG8gYSBzdGFibGUgc3RhdGVcbiAqXG4gKiBAbWV0aG9kIHJlc2V0XG4gKiBAY2hhaW5hYmxlXG4gKiBAZGVwcmVjYXRlZCBVc2UgYC5mcm9tYCBpbnN0ZWFkIVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfEFycmF5Lk51bWJlcnxPYmplY3QuPG51bWJlciwgbnVtYmVyPn0gc3RhcnRTdGF0ZVxuICogICAgc3RhYmxlIHN0YXRlIHRvIHNldCB0b1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihzdGFydCkge1xuICAgIHJldHVybiB0aGlzLmZyb20oc3RhcnQpO1xufTtcblxuLyoqXG4gKiBBZGQgdHJhbnNpdGlvbiB0byBlbmQgc3RhdGUgdG8gdGhlIHF1ZXVlIG9mIHBlbmRpbmcgdHJhbnNpdGlvbnMuIFNwZWNpYWxcbiAqICAgIFVzZTogY2FsbGluZyB3aXRob3V0IGEgdHJhbnNpdGlvbiByZXNldHMgdGhlIG9iamVjdCB0byB0aGF0IHN0YXRlIHdpdGhcbiAqICAgIG5vIHBlbmRpbmcgYWN0aW9uc1xuICpcbiAqIEBtZXRob2Qgc2V0XG4gKiBAY2hhaW5hYmxlXG4gKiBAZGVwcmVjYXRlZCBVc2UgYC50b2AgaW5zdGVhZCFcbiAqXG4gKiBAcGFyYW0ge051bWJlcnxGYW1vdXNNYXRyaXh8QXJyYXkuTnVtYmVyfE9iamVjdC48bnVtYmVyLCBudW1iZXI+fSBlbmRTdGF0ZVxuICogICAgZW5kIHN0YXRlIHRvIHdoaWNoIHdlIGludGVycG9sYXRlXG4gKiBAcGFyYW0ge3RyYW5zaXRpb249fSB0cmFuc2l0aW9uIG9iamVjdCBvZiB0eXBlIHtkdXJhdGlvbjogbnVtYmVyLCBjdXJ2ZTpcbiAqICAgIGZbMCwxXSAtPiBbMCwxXSBvciBuYW1lfS4gSWYgdHJhbnNpdGlvbiBpcyBvbWl0dGVkLCBjaGFuZ2Ugd2lsbCBiZVxuICogICAgaW5zdGFudGFuZW91cy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IGNhbGxiYWNrIFplcm8tYXJndW1lbnQgZnVuY3Rpb24gdG8gY2FsbCBvbiBvYnNlcnZlZFxuICogICAgY29tcGxldGlvbiAodD0xKVxuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oc3RhdGUsIHRyYW5zaXRpb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRyYW5zaXRpb24gPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZyb20oc3RhdGUpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50byhzdGF0ZSwgdHJhbnNpdGlvbi5jdXJ2ZSwgdHJhbnNpdGlvbi5kdXJhdGlvbiwgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNpdGlvbmFibGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmV0dXJuIHdyYXBwZXIgYXJvdW5kIGNhbGxiYWNrIGZ1bmN0aW9uLiBPbmNlIHRoZSB3cmFwcGVyIGlzIGNhbGxlZCBOXG4gKiAgIHRpbWVzLCBpbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLiBBcmd1bWVudHMgYW5kIHNjb3BlIHByZXNlcnZlZC5cbiAqXG4gKiBAbWV0aG9kIGFmdGVyXG4gKiBAZGVwcmVjYXRlZFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHdyYXBwZWQgY2FsbGJhY2sgZnVuY3Rpb25cbiAqXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gd3JhcHBlZCBjYWxsYmFjayB3aXRoIGNvdW5kb3duIGZlYXR1cmVcbiAqL1xudmFyIGFmdGVyID0gZnVuY3Rpb24gYWZ0ZXIoY291bnQsIGNhbGxiYWNrKSB7XG4gICAgY29uc29sZS53YXJuKCd0cmFuc2l0aW9ucy5hZnRlciBpcyBkZXByZWNhdGVkIScpO1xuICAgIHZhciBjb3VudGVyID0gY291bnQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIGlmIChjb3VudGVyID09PSAwKSBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFmdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhZnRlcjogcmVxdWlyZSgnLi9hZnRlcicpLFxuICAgIEVhc2luZzogcmVxdWlyZSgnLi9FYXNpbmcnKSxcbiAgICBDdXJ2ZXM6IHJlcXVpcmUoJy4vQ3VydmVzJyksXG4gICAgVHJhbnNpdGlvbmFibGU6IHJlcXVpcmUoJy4vVHJhbnNpdGlvbmFibGUnKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGxpZ2h0d2VpZ2h0LCBmZWF0dXJlbGVzcyBFdmVudEVtaXR0ZXIuXG4gKiBcbiAqIEBjbGFzcyBDYWxsYmFja1N0b3JlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ2FsbGJhY2tTdG9yZSAoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG59XG5cbi8qKlxuICogQWRkcyBhIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50ICg9IGtleSkuXG4gKlxuICogQG1ldGhvZCBvblxuICogQGNoYWluYWJsZVxuICogXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAga2V5XG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRvIGNhbGwgaWYgeW91IHdhbnQgdG8gcmVtb3ZlIHRoZSBjYWxsYmFja1xuICovXG5DYWxsYmFja1N0b3JlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uIChrZXksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNba2V5XSkgdGhpcy5fZXZlbnRzW2tleV0gPSBbXTtcbiAgICB2YXIgY2FsbGJhY2tMaXN0ID0gdGhpcy5fZXZlbnRzW2tleV07XG4gICAgY2FsbGJhY2tMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrTGlzdC5zcGxpY2UoY2FsbGJhY2tMaXN0LmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBtZXRob2Qgb2ZmXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgICAga2V5XG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtDYWxsYmFja1N0b3JlfSAgIHRoaXNcbiAqL1xuQ2FsbGJhY2tTdG9yZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmIChrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1trZXldO1xuICAgIGlmIChldmVudHMpIGV2ZW50cy5zcGxpY2UoZXZlbnRzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW52b2tlcyBhbGwgdGhlIHByZXZpb3VzbHkgZm9yIHRoaXMga2V5IHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBtZXRob2QgdHJpZ2dlclxuICogQGNoYWluYWJsZVxuICogXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICBrZXlcbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgIHBheWxvYWRcbiAqIEByZXR1cm4ge0NhbGxiYWNrU3RvcmV9IHRoaXNcbiAqL1xuQ2FsbGJhY2tTdG9yZS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIgKGtleSwgcGF5bG9hZCkge1xuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNba2V5XTtcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGV2ZW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSBldmVudHNbaV0ocGF5bG9hZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxsYmFja1N0b3JlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhbnNpdGlvbmFibGUgPSByZXF1aXJlKCdmYW1vdXMtdHJhbnNpdGlvbnMnKS5UcmFuc2l0aW9uYWJsZTtcblxuLyoqXG4gKiBAY2xhc3MgQ29sb3JcbiAqIEBjb25zdHJ1Y3RvclxuICogQGNvbXBvbmVudFxuICogQHBhcmFtIHtDb2xvcnxTdHJpbmd8QXJyYXl9IE9wdGlvbmFsIGFyZ3VtZW50IGZvciBzZXR0aW5nIGNvbG9yIHVzaW5nXG4gKiBIZXgsIGEgQ29sb3IgaW5zdGFuY2UsIGNvbG9yIG5hbWUgb3IgUkdCXG4gKiBAcGFyYW0ge09iamVjdH0gT3B0aW9uYWwgdHJhbnNpdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gQ29sb3IoY29sb3IsIHRyYW5zaXRpb24sIGNiKSB7XG4gICAgdGhpcy5fciA9IG5ldyBUcmFuc2l0aW9uYWJsZSgwKTtcbiAgICB0aGlzLl9nID0gbmV3IFRyYW5zaXRpb25hYmxlKDApO1xuICAgIHRoaXMuX2IgPSBuZXcgVHJhbnNpdGlvbmFibGUoMCk7XG4gICAgaWYgKGNvbG9yKSB0aGlzLnNldChjb2xvciwgdHJhbnNpdGlvbiwgY2IpO1xufTtcblxuLyoqXG4qIFJldHVybnMgdGhlIGRlZmluaXRpb24gb2YgdGhlIENsYXNzOiAnQ29sb3InXG4qIEBtZXRob2QgdG9TdHJpbmdcbiogQHJldHVybiB7U3RyaW5nfSBkZWZpbml0aW9uXG4qL1xuQ29sb3IudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0NvbG9yJztcbn07XG5cbi8qKlxuKiBTZXRzIHRoZSBjb2xvci4gSXQgYWNjZXB0cyBhbiBvcHRpb25hbCB0cmFuc2l0aW9uIHBhcmFtZXRlciBhbmQgY2FsbGJhY2suXG4qIHNldChDb2xvciwgdHJhbnNpdGlvbiwgY2FsbGJhY2spXG4qIHNldCgnIzAwMDAwMCcsIHRyYW5zaXRpb24sIGNhbGxiYWNrKVxuKiBzZXQoJ2JsYWNrJywgdHJhbnNpdGlvbiwgY2FsbGJhY2spXG4qIHNldChbciwgZywgYl0sIHRyYW5zaXRpb24sIGNhbGxiYWNrKVxuKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIHtDb2xvcnxTdHJpbmd8QXJyYXl9IE9wdGlvbmFsIGFyZ3VtZW50IGZvciBzZXR0aW5nIGNvbG9yIHVzaW5nXG4gKiBIZXgsIGEgQ29sb3IgaW5zdGFuY2UsIGNvbG9yIG5hbWUgb3IgUkdCXG4gKiBAcGFyYW0ge09iamVjdH0gT3B0aW9uYWwgdHJhbnNpdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ2FsbGJhY2tcbiogQGNoYWluYWJsZVxuKi9cbkNvbG9yLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoY29sb3IsIHRyYW5zaXRpb24sIGNiKSB7XG4gICAgc3dpdGNoIChDb2xvci5kZXRlcm1pbmVUeXBlKGNvbG9yKSkge1xuICAgICAgICBjYXNlICdoZXgnOiByZXR1cm4gdGhpcy5zZXRIZXgoY29sb3IsIHRyYW5zaXRpb24sIGNiKTtcbiAgICAgICAgY2FzZSAnY29sb3JOYW1lJzogcmV0dXJuIHRoaXMuc2V0Q29sb3IoY29sb3IsIHRyYW5zaXRpb24sIGNiKTtcbiAgICAgICAgY2FzZSAnaW5zdGFuY2UnOiByZXR1cm4gdGhpcy5jaGFuZ2VUbyhjb2xvciwgdHJhbnNpdGlvbiwgY2IpO1xuICAgICAgICBjYXNlICdyZ2InOiByZXR1cm4gdGhpcy5zZXRSR0IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgdHJhbnNpdGlvbiwgY2IpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIENvbG9yIGlzIHN0aWxsIGluIGFuIGFuaW1hdGluZyAodHJhbnNpdGlvbmluZykgc3RhdGUuXG4gKlxuICogQG1ldGhvZCBpc0FjdGl2ZVxuICogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW5cbiAqL1xuQ29sb3IucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3IuaXNBY3RpdmUoKSB8fCB0aGlzLl9nLmlzQWN0aXZlKCkgfHwgdGhpcy5fYi5pc0FjdGl2ZSgpO1xufTtcblxuLyoqXG4gKiBIYWx0IHRyYW5zaXRpb24gYXQgY3VycmVudCBzdGF0ZSBhbmQgZXJhc2UgYWxsIHBlbmRpbmcgYWN0aW9ucy5cbiAqXG4gKiBAbWV0aG9kIGhhbHRcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcmV0dXJuIHtDb2xvcn0gdGhpc1xuICovXG5Db2xvci5wcm90b3R5cGUuaGFsdCA9IGZ1bmN0aW9uIGhhbHQoKSB7XG4gICAgdGhpcy5fci5oYWx0KCk7XG4gICAgdGhpcy5fZy5oYWx0KCk7XG4gICAgdGhpcy5fYi5oYWx0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbG9yIHZhbHVlcyBmcm9tIGFub3RoZXIgQ29sb3IgaW5zdGFuY2UuXG4gKlxuICogQG1ldGhvZCBjaGFuZ2VUb1xuICogQHBhcmFtIHtDb2xvcn0gQ29sb3IgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2l0aW9uIE9wdGlvbmFsIHRyYW5zaXRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIE9wdGlvbmFsXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5jaGFuZ2VUbyA9IGZ1bmN0aW9uIGNoYW5nZVRvKGNvbG9yLCB0cmFuc2l0aW9uLCBjYikge1xuICAgIGlmIChDb2xvci5pc0NvbG9ySW5zdGFuY2UoY29sb3IpKSB7XG4gICAgICAgIHZhciByZ2IgPSBjb2xvci5nZXRSR0IoKTtcbiAgICAgICAgdGhpcy5zZXRSR0IocmdiWzBdLCByZ2JbMV0sIHJnYlsyXSwgdHJhbnNpdGlvbiwgY2IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29sb3IgYmFzZWQgb24gc3RhdGljIGNvbG9yIG5hbWVzLlxuICpcbiAqIEBtZXRob2Qgc2V0Q29sb3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBDb2xvciBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbiBPcHRpb25hbCB0cmFuc2l0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIE9wdGlvbmFsXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uIHNldENvbG9yKG5hbWUsIHRyYW5zaXRpb24sIGNiKSB7XG4gICAgaWYgKGNvbG9yTmFtZXNbbmFtZV0pIHtcbiAgICAgICAgdGhpcy5zZXRIZXgoY29sb3JOYW1lc1tuYW1lXSwgdHJhbnNpdGlvbiwgY2IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29sb3IgaW4gZWl0aGVyIFJHQiBvciB3aXRoIHRoZSByZXF1ZXN0ZWQgZm9ybWF0LlxuICpcbiAqIEBtZXRob2QgZ2V0Q29sb3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBPcHRpb25hbCBhcmd1bWVudCBmb3IgZGV0ZXJtaW5pbmcgd2hpY2ggdHlwZSBvZiBjb2xvciB0byBnZXQgKGRlZmF1bHQgaXMgUkdCKVxuICogQHJldHVybnMgQ29sb3IgaW4gZWl0aGVyIFJHQiBvciBzcGVjaWZpYyBvcHRpb24gdmFsdWVcbiAqL1xuQ29sb3IucHJvdG90eXBlLmdldENvbG9yID0gZnVuY3Rpb24gZ2V0Q29sb3Iob3B0aW9uKSB7XG4gICAgaWYgKENvbG9yLmlzU3RyaW5nKG9wdGlvbikpIG9wdGlvbiA9IG9wdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAob3B0aW9uID09PSAnaGV4JykgPyB0aGlzLmdldEhleCgpIDogdGhpcy5nZXRSR0IoKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgUiBvZiB0aGUgQ29sb3IncyBSR0JcbiAqXG4gKiBAbWV0aG9kIHNldFJcbiAqIEBwYXJhbSB7SW50ZWdlcn0gUiBjaGFubmVsIG9mIGNvbG9yXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbiBPcHRpb25hbCB0cmFuc2l0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIE9wdGlvbmFsXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5zZXRSID0gZnVuY3Rpb24gc2V0UihyLCB0cmFuc2l0aW9uLCBjYikge1xuICAgIHRoaXMuX3Iuc2V0KHIsIHRyYW5zaXRpb24sIGNiKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgRyBvZiB0aGUgQ29sb3IncyBSR0JcbiAqXG4gKiBAbWV0aG9kIHNldEdcbiAqIEBwYXJhbSB7SW50ZWdlcn0gRyBjaGFubmVsIG9mIGNvbG9yXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbiBPcHRpb25hbCB0cmFuc2l0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIE9wdGlvbmFsXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5zZXRHID0gZnVuY3Rpb24gc2V0RyhnLCB0cmFuc2l0aW9uLCBjYikge1xuICAgIHRoaXMuX2cuc2V0KGcsIHRyYW5zaXRpb24sIGNiKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgQiBvZiB0aGUgQ29sb3IncyBSR0JcbiAqXG4gKiBAbWV0aG9kIHNldEJcbiAqIEBwYXJhbSB7SW50ZWdlcn0gQiBjaGFubmVsIG9mIGNvbG9yXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbiBPcHRpb25hbCB0cmFuc2l0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIE9wdGlvbmFsXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5zZXRCID0gZnVuY3Rpb24gc2V0QihiLCB0cmFuc2l0aW9uLCBjYikge1xuICAgIHRoaXMuX2Iuc2V0KGIsIHRyYW5zaXRpb24sIGNiKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBSR0JcbiAqXG4gKiBAbWV0aG9kIHNldFJHQlxuICogQHBhcmFtIHtJbnRlZ2VyfSBSIGNoYW5uZWwgb2YgY29sb3JcbiAqIEBwYXJhbSB7SW50ZWdlcn0gRyBjaGFubmVsIG9mIGNvbG9yXG4gKiBAcGFyYW0ge0ludGVnZXJ9IEIgY2hhbm5lbCBvZiBjb2xvclxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb24gT3B0aW9uYWwgdHJhbnNpdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBPcHRpb25hbFxuICogQGNoYWluYWJsZVxuICovXG5Db2xvci5wcm90b3R5cGUuc2V0UkdCID0gZnVuY3Rpb24gc2V0UkdCKHIsIGcsIGIsIHRyYW5zaXRpb24sIGNiKSB7XG4gICAgdGhpcy5zZXRSKHIsIHRyYW5zaXRpb24pO1xuICAgIHRoaXMuc2V0RyhnLCB0cmFuc2l0aW9uKTtcbiAgICB0aGlzLnNldEIoYiwgdHJhbnNpdGlvbiwgY2IpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIFIgb2YgUkdCXG4gKlxuICogQG1ldGhvZCBnZXRSXG4gKiBAcmV0dXJucyBSIG9mIENvbG9yXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5nZXRSID0gZnVuY3Rpb24gZ2V0UigpIHtcbiAgICByZXR1cm4gdGhpcy5fci5nZXQoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBHIG9mIFJHQlxuICpcbiAqIEBtZXRob2QgZ2V0R1xuICogQHJldHVybnMgRyBvZiBDb2xvclxuICovXG5Db2xvci5wcm90b3R5cGUuZ2V0RyA9IGZ1bmN0aW9uIGdldEcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2cuZ2V0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgQiBvZiBSR0JcbiAqXG4gKiBAbWV0aG9kIGdldEJcbiAqIEByZXR1cm5zIEIgb2YgQ29sb3JcbiAqL1xuQ29sb3IucHJvdG90eXBlLmdldEIgPSBmdW5jdGlvbiBnZXRCKCkge1xuICAgIHJldHVybiB0aGlzLl9iLmdldCgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIFJHQlxuICpcbiAqIEBtZXRob2QgZ2V0UkdCXG4gKiBAcmV0dXJucyBSR0JcbiAqL1xuQ29sb3IucHJvdG90eXBlLmdldFJHQiA9IGZ1bmN0aW9uIGdldFJHQigpIHtcbiAgICByZXR1cm4gW3RoaXMuZ2V0UigpLCB0aGlzLmdldEcoKSwgdGhpcy5nZXRCKCldO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIE5vcm1hbGl6ZWQgUkdCXG4gKlxuICogQG1ldGhvZCBnZXROb3JtYWxpemVkUkdCXG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIFJHQlxuICovXG5Db2xvci5wcm90b3R5cGUuZ2V0Tm9ybWFsaXplZFJHQiA9IGZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRSR0IoKSB7XG4gICAgdmFyIHIgPSB0aGlzLmdldFIoKSAvIDI1NS4wO1xuICAgIHZhciBnID0gdGhpcy5nZXRHKCkgLyAyNTUuMDtcbiAgICB2YXIgYiA9IHRoaXMuZ2V0QigpIC8gMjU1LjA7XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBjb2xvciBpbiBIZXhcbiAqXG4gKiBAbWV0aG9kIGdldEhleFxuICogQHJldHVybnMgSGV4IHZhbHVlXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5nZXRIZXggPSBmdW5jdGlvbiBnZXRIZXgoKSB7XG4gICAgdmFyIHIgPSBDb2xvci50b0hleCh0aGlzLmdldFIoKSk7XG4gICAgdmFyIGcgPSBDb2xvci50b0hleCh0aGlzLmdldEcoKSk7XG4gICAgdmFyIGIgPSBDb2xvci50b0hleCh0aGlzLmdldEIoKSk7XG4gICAgcmV0dXJuICcjJyArIHIgKyBnICsgYjtcbn07XG5cbi8qKlxuICogU2V0cyBjb2xvciB1c2luZyBIZXhcbiAqXG4gKiBAbWV0aG9kIHNldEhleFxuICogQHBhcmFtIHtTdHJpbmd9IEhleCB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb24gT3B0aW9uYWwgdHJhbnNpdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBPcHRpb25hbFxuICogQGNoYWluYWJsZVxuICovXG5Db2xvci5wcm90b3R5cGUuc2V0SGV4ID0gZnVuY3Rpb24gc2V0SGV4KGhleCwgdHJhbnNpdGlvbiwgY2IpIHtcbiAgICBoZXggPSAoaGV4LmNoYXJBdCgwKSA9PT0gJyMnKSA/IGhleC5zdWJzdHJpbmcoMSwgaGV4Lmxlbmd0aCkgOiBoZXg7XG5cbiAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICB2YXIgc2hvcnRoYW5kUmVnZXggPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pO1xuICAgICAgICBoZXggPSBoZXgucmVwbGFjZShzaG9ydGhhbmRSZWdleCwgZnVuY3Rpb24obSwgciwgZywgYikge1xuICAgICAgICAgICAgcmV0dXJuIHIgKyByICsgZyArIGcgKyBiICsgYjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHIgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDAsIDIpLCAxNik7XG4gICAgdmFyIGcgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDIsIDQpLCAxNik7XG4gICAgdmFyIGIgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDQsIDYpLCAxNik7XG4gICAgdGhpcy5zZXRSR0IociwgZywgYiwgdHJhbnNpdGlvbiwgY2IpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciB0byBhIGhleCB2YWx1ZVxuICpcbiAqIEBtZXRob2QgdG9IZXhcbiAqIEBwYXJhbSB7SW50ZWdlcn0gTnVtYmVyXG4gKiBAcmV0dXJucyBIZXggdmFsdWVcbiAqL1xuQ29sb3IudG9IZXggPSBmdW5jdGlvbiB0b0hleChudW0pIHtcbiAgICB2YXIgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleDtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgZ2l2ZW4gaW5wdXQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgY29uZmlndXJhdGlvblxuICpcbiAqIEBtZXRob2QgZGV0ZXJtaW5lVHlwZVxuICogQHBhcmFtIHtDb2xvcnxTdHJpbmd8QXJyYXl9IENvbG9yIHR5cGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEFwcHJvcHJpYXRlIGNvbG9yIHR5cGVcbiAqL1xuQ29sb3IuZGV0ZXJtaW5lVHlwZSA9IGZ1bmN0aW9uIGRldGVybWluZVR5cGUodHlwZSkge1xuICAgIGlmIChDb2xvci5pc0NvbG9ySW5zdGFuY2UodHlwZSkpIHJldHVybiAnaW5zdGFuY2UnO1xuICAgIGlmIChjb2xvck5hbWVzW3R5cGVdKSByZXR1cm4gJ2NvbG9yTmFtZSc7XG4gICAgaWYgKENvbG9yLmlzSGV4KHR5cGUpKSByZXR1cm4gJ2hleCc7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHJldHVybiAncmdiJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGJvb2xlYW4gY2hlY2tpbmcgd2hldGhlciBpbnB1dCBpcyBhICdTdHJpbmcnXG4gKlxuICogQG1ldGhvZCBpc1N0cmluZ1xuICogQHBhcmFtIFByaW1pdGl2ZVxuICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW5cbiAqL1xuQ29sb3IuaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGJvb2xlYW4gY2hlY2tpbmcgd2hldGhlciBzdHJpbmcgaW5wdXQgaGFzIGEgaGFzaCAoIykgc3ltYm9sXG4gKlxuICogQG1ldGhvZCBpc0hleFxuICogQHBhcmFtIFN0cmluZ1xuICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW5cbiAqL1xuQ29sb3IuaXNIZXggPSBmdW5jdGlvbiBpc0hleCh2YWwpIHtcbiAgICBpZiAoIUNvbG9yLmlzU3RyaW5nKHZhbCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdmFsWzBdID09PSAnIyc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYm9vbGVhbiB3aGV0aGVyIHRoZSBpbnB1dCBpcyBhIENvbG9yIGluc3RhbmNlXG4gKlxuICogQG1ldGhvZCBpc0NvbG9ySW5zdGFuY2VcbiAqIEBwYXJhbSBDb2xvciBpbnN0YW5jZVxuICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW5cbiAqL1xuQ29sb3IuaXNDb2xvckluc3RhbmNlID0gZnVuY3Rpb24gaXNDb2xvckluc3RhbmNlKHZhbCkge1xuICAgIHJldHVybiAhIXZhbC5nZXRDb2xvcjtcbn07XG5cbi8qKlxuICogQ29tbW9uIGNvbG9yIG5hbWVzIHdpdGggdGhlaXIgYXNzb2NpYXRlZCBIZXggdmFsdWVzXG4gKi9cbnZhciBjb2xvck5hbWVzID0geyBhbGljZWJsdWU6ICcjZjBmOGZmJywgYW50aXF1ZXdoaXRlOiAnI2ZhZWJkNycsIGFxdWE6ICcjMDBmZmZmJywgYXF1YW1hcmluZTogJyM3ZmZmZDQnLCBhenVyZTogJyNmMGZmZmYnLCBiZWlnZTogJyNmNWY1ZGMnLCBiaXNxdWU6ICcjZmZlNGM0JywgYmxhY2s6ICcjMDAwMDAwJywgYmxhbmNoZWRhbG1vbmQ6ICcjZmZlYmNkJywgYmx1ZTogJyMwMDAwZmYnLCBibHVldmlvbGV0OiAnIzhhMmJlMicsIGJyb3duOiAnI2E1MmEyYScsIGJ1cmx5d29vZDogJyNkZWI4ODcnLCBjYWRldGJsdWU6ICcjNWY5ZWEwJywgY2hhcnRyZXVzZTogJyM3ZmZmMDAnLCBjaG9jb2xhdGU6ICcjZDI2OTFlJywgY29yYWw6ICcjZmY3ZjUwJywgY29ybmZsb3dlcmJsdWU6ICcjNjQ5NWVkJywgY29ybnNpbGs6ICcjZmZmOGRjJywgY3JpbXNvbjogJyNkYzE0M2MnLCBjeWFuOiAnIzAwZmZmZicsIGRhcmtibHVlOiAnIzAwMDA4YicsIGRhcmtjeWFuOiAnIzAwOGI4YicsIGRhcmtnb2xkZW5yb2Q6ICcjYjg4NjBiJywgZGFya2dyYXk6ICcjYTlhOWE5JywgZGFya2dyZWVuOiAnIzAwNjQwMCcsIGRhcmtncmV5OiAnI2E5YTlhOScsIGRhcmtraGFraTogJyNiZGI3NmInLCBkYXJrbWFnZW50YTogJyM4YjAwOGInLCBkYXJrb2xpdmVncmVlbjogJyM1NTZiMmYnLCBkYXJrb3JhbmdlOiAnI2ZmOGMwMCcsIGRhcmtvcmNoaWQ6ICcjOTkzMmNjJywgZGFya3JlZDogJyM4YjAwMDAnLCBkYXJrc2FsbW9uOiAnI2U5OTY3YScsIGRhcmtzZWFncmVlbjogJyM4ZmJjOGYnLCBkYXJrc2xhdGVibHVlOiAnIzQ4M2Q4YicsIGRhcmtzbGF0ZWdyYXk6ICcjMmY0ZjRmJywgZGFya3NsYXRlZ3JleTogJyMyZjRmNGYnLCBkYXJrdHVycXVvaXNlOiAnIzAwY2VkMScsIGRhcmt2aW9sZXQ6ICcjOTQwMGQzJywgZGVlcHBpbms6ICcjZmYxNDkzJywgZGVlcHNreWJsdWU6ICcjMDBiZmZmJywgZGltZ3JheTogJyM2OTY5NjknLCBkaW1ncmV5OiAnIzY5Njk2OScsIGRvZGdlcmJsdWU6ICcjMWU5MGZmJywgZmlyZWJyaWNrOiAnI2IyMjIyMicsIGZsb3JhbHdoaXRlOiAnI2ZmZmFmMCcsIGZvcmVzdGdyZWVuOiAnIzIyOGIyMicsIGZ1Y2hzaWE6ICcjZmYwMGZmJywgZ2FpbnNib3JvOiAnI2RjZGNkYycsIGdob3N0d2hpdGU6ICcjZjhmOGZmJywgZ29sZDogJyNmZmQ3MDAnLCBnb2xkZW5yb2Q6ICcjZGFhNTIwJywgZ3JheTogJyM4MDgwODAnLCBncmVlbjogJyMwMDgwMDAnLCBncmVlbnllbGxvdzogJyNhZGZmMmYnLCBncmV5OiAnIzgwODA4MCcsIGhvbmV5ZGV3OiAnI2YwZmZmMCcsIGhvdHBpbms6ICcjZmY2OWI0JywgaW5kaWFucmVkOiAnI2NkNWM1YycsIGluZGlnbzogJyM0YjAwODInLCBpdm9yeTogJyNmZmZmZjAnLCBraGFraTogJyNmMGU2OGMnLCBsYXZlbmRlcjogJyNlNmU2ZmEnLCBsYXZlbmRlcmJsdXNoOiAnI2ZmZjBmNScsIGxhd25ncmVlbjogJyM3Y2ZjMDAnLCBsZW1vbmNoaWZmb246ICcjZmZmYWNkJywgbGlnaHRibHVlOiAnI2FkZDhlNicsIGxpZ2h0Y29yYWw6ICcjZjA4MDgwJywgbGlnaHRjeWFuOiAnI2UwZmZmZicsIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnI2ZhZmFkMicsIGxpZ2h0Z3JheTogJyNkM2QzZDMnLCBsaWdodGdyZWVuOiAnIzkwZWU5MCcsIGxpZ2h0Z3JleTogJyNkM2QzZDMnLCBsaWdodHBpbms6ICcjZmZiNmMxJywgbGlnaHRzYWxtb246ICcjZmZhMDdhJywgbGlnaHRzZWFncmVlbjogJyMyMGIyYWEnLCBsaWdodHNreWJsdWU6ICcjODdjZWZhJywgbGlnaHRzbGF0ZWdyYXk6ICcjNzc4ODk5JywgbGlnaHRzbGF0ZWdyZXk6ICcjNzc4ODk5JywgbGlnaHRzdGVlbGJsdWU6ICcjYjBjNGRlJywgbGlnaHR5ZWxsb3c6ICcjZmZmZmUwJywgbGltZTogJyMwMGZmMDAnLCBsaW1lZ3JlZW46ICcjMzJjZDMyJywgbGluZW46ICcjZmFmMGU2JywgbWFnZW50YTogJyNmZjAwZmYnLCBtYXJvb246ICcjODAwMDAwJywgbWVkaXVtYXF1YW1hcmluZTogJyM2NmNkYWEnLCBtZWRpdW1ibHVlOiAnIzAwMDBjZCcsIG1lZGl1bW9yY2hpZDogJyNiYTU1ZDMnLCBtZWRpdW1wdXJwbGU6ICcjOTM3MGRiJywgbWVkaXVtc2VhZ3JlZW46ICcjM2NiMzcxJywgbWVkaXVtc2xhdGVibHVlOiAnIzdiNjhlZScsIG1lZGl1bXNwcmluZ2dyZWVuOiAnIzAwZmE5YScsIG1lZGl1bXR1cnF1b2lzZTogJyM0OGQxY2MnLCBtZWRpdW12aW9sZXRyZWQ6ICcjYzcxNTg1JywgbWlkbmlnaHRibHVlOiAnIzE5MTk3MCcsIG1pbnRjcmVhbTogJyNmNWZmZmEnLCBtaXN0eXJvc2U6ICcjZmZlNGUxJywgbW9jY2FzaW46ICcjZmZlNGI1JywgbmF2YWpvd2hpdGU6ICcjZmZkZWFkJywgbmF2eTogJyMwMDAwODAnLCBvbGRsYWNlOiAnI2ZkZjVlNicsIG9saXZlOiAnIzgwODAwMCcsIG9saXZlZHJhYjogJyM2YjhlMjMnLCBvcmFuZ2U6ICcjZmZhNTAwJywgb3JhbmdlcmVkOiAnI2ZmNDUwMCcsIG9yY2hpZDogJyNkYTcwZDYnLCBwYWxlZ29sZGVucm9kOiAnI2VlZThhYScsIHBhbGVncmVlbjogJyM5OGZiOTgnLCBwYWxldHVycXVvaXNlOiAnI2FmZWVlZScsIHBhbGV2aW9sZXRyZWQ6ICcjZGI3MDkzJywgcGFwYXlhd2hpcDogJyNmZmVmZDUnLCBwZWFjaHB1ZmY6ICcjZmZkYWI5JywgcGVydTogJyNjZDg1M2YnLCBwaW5rOiAnI2ZmYzBjYicsIHBsdW06ICcjZGRhMGRkJywgcG93ZGVyYmx1ZTogJyNiMGUwZTYnLCBwdXJwbGU6ICcjODAwMDgwJywgcmViZWNjYXB1cnBsZTogJyM2NjMzOTknLCByZWQ6ICcjZmYwMDAwJywgcm9zeWJyb3duOiAnI2JjOGY4ZicsIHJveWFsYmx1ZTogJyM0MTY5ZTEnLCBzYWRkbGVicm93bjogJyM4YjQ1MTMnLCBzYWxtb246ICcjZmE4MDcyJywgc2FuZHlicm93bjogJyNmNGE0NjAnLCBzZWFncmVlbjogJyMyZThiNTcnLCBzZWFzaGVsbDogJyNmZmY1ZWUnLCBzaWVubmE6ICcjYTA1MjJkJywgc2lsdmVyOiAnI2MwYzBjMCcsIHNreWJsdWU6ICcjODdjZWViJywgc2xhdGVibHVlOiAnIzZhNWFjZCcsIHNsYXRlZ3JheTogJyM3MDgwOTAnLCBzbGF0ZWdyZXk6ICcjNzA4MDkwJywgc25vdzogJyNmZmZhZmEnLCBzcHJpbmdncmVlbjogJyMwMGZmN2YnLCBzdGVlbGJsdWU6ICcjNDY4MmI0JywgdGFuOiAnI2QyYjQ4YycsIHRlYWw6ICcjMDA4MDgwJywgdGhpc3RsZTogJyNkOGJmZDgnLCB0b21hdG86ICcjZmY2MzQ3JywgdHVycXVvaXNlOiAnIzQwZTBkMCcsIHZpb2xldDogJyNlZTgyZWUnLCB3aGVhdDogJyNmNWRlYjMnLCB3aGl0ZTogJyNmZmZmZmYnLCB3aGl0ZXNtb2tlOiAnI2Y1ZjVmNScsIHllbGxvdzogJyNmZmZmMDAnLCB5ZWxsb3dncmVlbjogJyM5YWNkMzInIH07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29sbGVjdGlvbiB0byBtYXAga2V5Ym9hcmQgY29kZXMgaW4gcGxhaW4gZW5nbGlzaFxuICpcbiAqIEBjbGFzcyBLZXlDb2Rlc1xuICogQHN0YXRpY1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAwOiA0OCxcbiAgICAxOiA0OSxcbiAgICAyOiA1MCxcbiAgICAzOiA1MSxcbiAgICA0OiA1MixcbiAgICA1OiA1MyxcbiAgICA2OiA1NCxcbiAgICA3OiA1NSxcbiAgICA4OiA1NixcbiAgICA5OiA1NyxcbiAgICBhOiA5NyxcbiAgICBiOiA5OCxcbiAgICBjOiA5OSxcbiAgICBkOiAxMDAsXG4gICAgZTogMTAxLFxuICAgIGY6IDEwMixcbiAgICBnOiAxMDMsXG4gICAgaDogMTA0LFxuICAgIGk6IDEwNSxcbiAgICBqOiAxMDYsXG4gICAgazogMTA3LFxuICAgIGw6IDEwOCxcbiAgICBtOiAxMDksXG4gICAgbjogMTEwLFxuICAgIG86IDExMSxcbiAgICBwOiAxMTIsXG4gICAgcTogMTEzLFxuICAgIHI6IDExNCxcbiAgICBzOiAxMTUsXG4gICAgdDogMTE2LFxuICAgIHU6IDExNyxcbiAgICB2OiAxMTgsXG4gICAgdzogMTE5LFxuICAgIHg6IDEyMCxcbiAgICB5OiAxMjEsXG4gICAgejogMTIyLFxuICAgIEE6IDY1LFxuICAgIEI6IDY2LFxuICAgIEM6IDY3LFxuICAgIEQ6IDY4LFxuICAgIEU6IDY5LFxuICAgIEY6IDcwLFxuICAgIEc6IDcxLFxuICAgIEg6IDcyLFxuICAgIEk6IDczLFxuICAgIEo6IDc0LFxuICAgIEs6IDc1LFxuICAgIEw6IDc2LFxuICAgIE06IDc3LFxuICAgIE46IDc4LFxuICAgIE86IDc5LFxuICAgIFA6IDgwLFxuICAgIFE6IDgxLFxuICAgIFI6IDgyLFxuICAgIFM6IDgzLFxuICAgIFQ6IDg0LFxuICAgIFU6IDg1LFxuICAgIFY6IDg2LFxuICAgIFc6IDg3LFxuICAgIFg6IDg4LFxuICAgIFk6IDg5LFxuICAgIFo6IDkwLFxuICAgIEVOVEVSIDogMTMsXG4gICAgTEVGVF9BUlJPVzogMzcsXG4gICAgUklHSFRfQVJST1c6IDM5LFxuICAgIFVQX0FSUk9XOiAzOCxcbiAgICBET1dOX0FSUk9XOiA0MCxcbiAgICBTUEFDRTogMzIsXG4gICAgU0hJRlQ6IDE2LFxuICAgIFRBQjogOVxufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBNZXRob2RTdG9yZSAoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG59XG5cbk1ldGhvZFN0b3JlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uIChrZXksIGNiY2xhc3MsIGNibmFtZSkge1xuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNba2V5XTtcbiAgICBpZiAoIWV2ZW50cykgZXZlbnRzID0gW107XG4gICAgZXZlbnRzLnB1c2goY2JjbGFzcywgY2JuYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuTWV0aG9kU3RvcmUucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZiAoa2V5LCBjYmNsYXNzKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1trZXldO1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZXZlbnRzLmluZGV4T2YoY2JjbGFzcyk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSBldmVudHMuc3BsaWNlKGluZGV4LCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbk1ldGhvZFN0b3JlLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoa2V5LCBwYXlsb2FkKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1trZXldO1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpICs9IDIpIGV2ZW50c1tpXVtldmVudHNbaSArIDFdXShwYXlsb2FkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1ldGhvZFN0b3JlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbmdsZXRvbiBvYmplY3QgdG8gbWFuYWdlIHJlY3ljbGluZyBvZiBvYmplY3RzIHdpdGggdHlwaWNhbGx5IHNob3J0IGxpZmVzcGFucywgdXNlZCB0byBjdXQgZG93biBvbiB0aGVcbiAqIGFtb3VudCBvZiBnYXJiYWdlIGNvbGxlY3Rpb24gcmVxdWlyZWQuXG4gKlxuICogQHNpbmdsZXRvblxuICovXG52YXIgT2JqZWN0TWFuYWdlciA9IHt9O1xuXG5PYmplY3RNYW5hZ2VyLnBvb2xzID0ge307XG5cbi8qKlxuICogUmVnaXN0ZXIgcmVxdWVzdCBhbmQgZnJlZSBmdW5jdGlvbnMgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIEBtZXRob2QgcmVnaXN0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb25zdHJ1Y3RvclxuICovXG5PYmplY3RNYW5hZ2VyLnJlZ2lzdGVyID0gZnVuY3Rpb24odHlwZSwgQ29uc3RydWN0b3IpIHtcbiAgICB2YXIgcG9vbCA9IHRoaXMucG9vbHNbdHlwZV0gPSBbXTtcblxuICAgIHRoaXNbJ3JlcXVlc3QnICsgdHlwZV0gPSBfcmVxdWVzdChwb29sLCBDb25zdHJ1Y3Rvcik7XG4gICAgdGhpc1snZnJlZScgKyB0eXBlXSA9IF9mcmVlKHBvb2wpO1xufTtcblxuZnVuY3Rpb24gX3JlcXVlc3QocG9vbCwgQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdCgpIHtcbiAgICAgICAgaWYgKHBvb2wubGVuZ3RoICE9PSAwKSByZXR1cm4gcG9vbC5wb3AoKTtcbiAgICAgICAgZWxzZSByZXR1cm4gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfZnJlZShwb29sKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZyZWUob2JqKSB7XG4gICAgICAgIHBvb2wucHVzaChvYmopO1xuICAgIH1cbn1cblxuLyoqXG4gKiBVbnRyYWNrIGFsbCBvYmplY3Qgb2YgdGhlIGdpdmVuIHR5cGUuIFVzZWQgdG8gYWxsb3cgYWxsb2NhdGVkIG9iamVjdHMgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gKlxuICogQG1ldGhvZCBkaXNwb3NlT2ZcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICovXG5PYmplY3RNYW5hZ2VyLmRpc3Bvc2VPZj0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBwb29sID0gdGhpcy5wb29sc1t0eXBlXTtcbiAgICB2YXIgaSA9IHBvb2wubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHBvb2wucG9wKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdE1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogIERlZXAgY2xvbmUgYW4gb2JqZWN0LlxuICogIEBtZW1iZXJvZiBVdGlsaXRpZXNcbiAqICBAcGFyYW0gYiB7T2JqZWN0fSBPYmplY3QgdG8gY2xvbmVcbiAqICBAcmV0dXJuIGEge09iamVjdH0gQ2xvbmVkIG9iamVjdC5cbiAqL1xudmFyIGNsb25lID0gZnVuY3Rpb24gY2xvbmUoYikge1xuICAgIHZhciBhO1xuICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IChiIGluc3RhbmNlb2YgQXJyYXkpID8gW10gOiB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYltrZXldID09PSAnb2JqZWN0JyAmJiBiW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYltrZXldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgYVtrZXldID0gbmV3IEFycmF5KGJba2V5XS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYVtrZXldW2ldID0gY2xvbmUoYltrZXldW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFba2V5XSA9IGNsb25lKGJba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYVtrZXldID0gYltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhID0gYjtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEZsYXQgY2xvbmUgYW4gb2JqZWN0LlxuICogQG1lbWJlcm9mIFV0aWxpdGllc1xuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIE9iamVjdCB0byBjbG9uZVxuICogQHJldHVybiB7T2JqZWN0fSBDbG9uZWQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGZsYXRDbG9uZShvYmopIHtcbiAgICB2YXIgY2xvbmUgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBjbG9uZVtrZXldID0gb2JqW2tleV07XG4gICAgcmV0dXJuIGNsb25lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXRDbG9uZTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ2FsbGJhY2tTdG9yZTogcmVxdWlyZSgnLi9DYWxsYmFja1N0b3JlJyksXG4gICAgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKSxcbiAgICBmbGF0Q2xvbmU6IHJlcXVpcmUoJy4vZmxhdENsb25lJyksXG4gICAgS2V5Q29kZXM6IHJlcXVpcmUoJy4vS2V5Q29kZXMnKSxcbiAgICBsb2FkVVJMOiByZXF1aXJlKCcuL2xvYWRVUkwnKSxcbiAgICBNZXRob2RTdG9yZTogcmVxdWlyZSgnLi9NZXRob2RTdG9yZScpLFxuICAgIE9iamVjdE1hbmFnZXI6IHJlcXVpcmUoJy4vT2JqZWN0TWFuYWdlcicpLFxuICAgIENvbG9yOiByZXF1aXJlKCcuL0NvbG9yJyksXG4gICAgc3RyaXA6IHJlcXVpcmUoJy4vc3RyaXAnKSxcbiAgICBrZXlWYWx1ZVRvQXJyYXlzOiByZXF1aXJlKCcuL2tleVZhbHVlVG9BcnJheXMnKVxufTtcblxuIiwiLyoqXG4gKiBUYWtlcyBhbiBvYmplY3QgY29udGFpbmluZyBrZXlzIGFuZCB2YWx1ZXMgYW5kIHJldHVybnMgYW4gb2JqZWN0XG4gKiBjb21wcmlzaW5nIHR3byBcImFzc29jaWF0ZVwiIGFycmF5cywgb25lIHdpdGggdGhlIGtleXMgYW5kIHRoZSBvdGhlclxuICogd2l0aCB0aGUgdmFsdWVzLlxuICpcbiAqIEBtZXRob2Qga2V5VmFsdWVzVG9BcnJheXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gT2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3QgT2JqZWN0IGNvbnRhaW5pbmcgdHdvIGFycmF5cywgb25lIHdpdGggdGhlIGtleXMgYW5kIHRoZSBvdGhlciBmb3IgdmFsdWVzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ga2V5VmFsdWVzVG9BcnJheXMob2JqKSB7XG4gICAgdmFyIGtleXNBcnJheSA9IFtdLCB2YWx1ZXNBcnJheSA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBrZXlzQXJyYXlbaV0gPSBrZXk7XG4gICAgICAgICAgICB2YWx1ZXNBcnJheVtpXSA9IG9ialtrZXldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGtleXM6IGtleXNBcnJheSxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXNBcnJheVxuICAgIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIExvYWQgYSBVUkwgYW5kIHJldHVybiBpdHMgY29udGVudHMgaW4gYSBjYWxsYmFja1xuICpcbiAqIEBtZXRob2QgbG9hZFVSTFxuICogQG1lbWJlcm9mIFV0aWxpdGllc1xuICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgb2Ygb2JqZWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayB0byBkaXNwYXRjaCB3aXRoIGNvbnRlbnRcbiAqL1xudmFyIGxvYWRVUkwgPSBmdW5jdGlvbiBsb2FkVVJMKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIG9ucmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayh0aGlzLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgIHhoci5zZW5kKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWRVUkw7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgdmFsdWVzIG5vdCBiZWluZyBvZiBhIHByaW1pdGl2ZSB0eXBlIGZyb20gYW4gYXJiaXRyYXJ5IG9iamVjdFxuICogbGl0ZXJhbC5cbiAqXG4gKiBAbWV0aG9kIHN0cmlwXG4gKiBAbWVtYmVyb2YgVXRpbGl0aWVzXG4gKiBAcGFyYW0gIHthbnl9ICAgICAgICBwcmltaXRpdmUgb3IgKG5vbi0pc2VyaWFsaXphYmxlIG9iamVjdCB3aXRob3V0XG4gKiAgICAgICAgICAgICAgICAgICAgICBjaXJjdWxhciByZWZlcmVuY2VzXG4gKiBAcmV0dXJuIHthbnl9ICAgICAgICBwcmltaXRpdmUgb3IgKG5lc3RlZCkgb2JqZWN0IG9ubHkgY29udGFpbmluZyBwcmltaXRpdmVcbiAqICAgICAgICAgICAgICAgICAgICAgIHR5cGVzIChzZXJpYWxpemFibGUpXG4gKi9cbmZ1bmN0aW9uIHN0cmlwKG9iaikge1xuICAgIHN3aXRjaCAob2JqKSB7XG4gICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBzd2l0Y2ggKG9iai5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgY2FzZSBTeW1ib2w6XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaXBwZWQgPSBzdHJpcChvYmpba2V5XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBzdHJpcHBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaXA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoJy4vUG9zaXRpb24nKTtcblxuLyoqXG4gKiBAY2xhc3MgQWxpZ25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGNvbXBvbmVudFxuICogQHBhcmFtIHtMb2NhbERpc3BhdGNofSBub2RlIExvY2FsRGlzcGF0Y2ggdG8gYmUgcmV0cmlldmVkIGZyb20gY29ycmVzcG9uZGluZyBSZW5kZXIgTm9kZSBvZiB0aGUgQWxpZ24gY29tcG9uZW50XG4gKi9cblxuZnVuY3Rpb24gQWxpZ24obm9kZSkge1xuICAgIFBvc2l0aW9uLmNhbGwodGhpcywgbm9kZSk7XG59XG5cbi8qKlxuKlxuKiBzdHJpbmdpZmllcyBBbGlnblxuKlxuKiBAbWV0aG9kXG4qIEByZXR1cm4ge1N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIENvbXBvbmVudCBDbGFzczogJ0FsaWduJ1xuKi9cbkFsaWduLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEFsaWduLnRvU3RyaW5nO1xufTtcblxuQWxpZ24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQb3NpdGlvbi5wcm90b3R5cGUpO1xuQWxpZ24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWxpZ247XG5cbkFsaWduLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdGhpcy5fbm9kZS5zZXRBbGlnbih0aGlzLl94LmdldCgpLCB0aGlzLl95LmdldCgpLCB0aGlzLl96LmdldCgpKTtcbiAgICB0aGlzLl9jaGVja1VwZGF0ZSgpO1xufTtcblxuQWxpZ24ucHJvdG90eXBlLm9uVXBkYXRlID0gQWxpZ24ucHJvdG90eXBlLnVwZGF0ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY2xhc3MgQ2FtZXJhXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjb21wb25lbnRcbiAqIEBwYXJhbSB7UmVuZGVyTm9kZX0gUmVuZGVyTm9kZSB0byB3aGljaCB0aGUgaW5zdGFuY2Ugb2YgQ2FtZXJhIHdpbGwgYmUgYSBjb21wb25lbnQgb2ZcbiAqL1xuZnVuY3Rpb24gQ2FtZXJhKG5vZGUpIHtcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICB0aGlzLl9wcm9qZWN0aW9uVHlwZSA9IENhbWVyYS5PUlRIT0dSQVBISUNfUFJPSkVDVElPTjtcbiAgICB0aGlzLl9mb2NhbERlcHRoID0gMDtcbiAgICB0aGlzLl9uZWFyID0gMDtcbiAgICB0aGlzLl9mYXIgPSAwO1xuICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9pZCA9IG5vZGUuYWRkQ29tcG9uZW50KHRoaXMpO1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm0gPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSk7XG4gICAgdGhpcy5fdmlld0RpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5fcGVyc3BlY3RpdmVEcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5zZXRGbGF0KCk7XG59XG5cbkNhbWVyYS5GUlVTVFVNX1BST0pFQ1RJT04gPSAwO1xuQ2FtZXJhLlBJTkhPTEVfUFJPSkVDVElPTiA9IDE7XG5DYW1lcmEuT1JUSE9HUkFQSElDX1BST0pFQ1RJT04gPSAyO1xuXG4vLyBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIEVsZW1lbnQgQ2xhc3M6ICdDYW1lcmEnXG5DYW1lcmEudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0NhbWVyYSc7XG59O1xuXG5DYW1lcmEucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9uZW50OiB0aGlzLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCksXG4gICAgICAgIHByb2plY3Rpb25UeXBlOiB0aGlzLl9wcm9qZWN0aW9uVHlwZSxcbiAgICAgICAgZm9jYWxEZXB0aDogdGhpcy5fZm9jYWxEZXB0aCxcbiAgICAgICAgbmVhcjogdGhpcy5fbmVhcixcbiAgICAgICAgZmFyOiB0aGlzLl9mYXJcbiAgICB9O1xufTtcblxuXG5DYW1lcmEucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuY29tcG9uZW50ID09PSB0aGlzLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgdGhpcy5zZXQoc3RhdGUucHJvamVjdGlvblR5cGUsIHN0YXRlLmZvY2FsRGVwdGgsIHN0YXRlLm5lYXIsIHN0YXRlLmZhcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5DYW1lcmEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCh0eXBlLCBkZXB0aCwgbmVhciwgZmFyKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9wcm9qZWN0aW9uVHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fZm9jYWxEZXB0aCA9IGRlcHRoO1xuICAgIHRoaXMuX25lYXIgPSBuZWFyO1xuICAgIHRoaXMuX2ZhciA9IGZhcjtcbn07XG5cbkNhbWVyYS5wcm90b3R5cGUuc2V0RGVwdGggPSBmdW5jdGlvbiBzZXREZXB0aChkZXB0aCkge1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5faWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fcGVyc3BlY3RpdmVEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fcHJvamVjdGlvblR5cGUgPSBDYW1lcmEuUElOSE9MRV9QUk9KRUNUSU9OO1xuICAgIHRoaXMuX2ZvY2FsRGVwdGggPSBkZXB0aDtcbiAgICB0aGlzLl9uZWFyID0gMDtcbiAgICB0aGlzLl9mYXIgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5DYW1lcmEucHJvdG90eXBlLnNldEZydXN0dW0gPSBmdW5jdGlvbiBzZXRGcnVzdHVtKG5lYXIsIGZhcikge1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5faWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fcGVyc3BlY3RpdmVEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fcHJvamVjdGlvblR5cGUgPSBDYW1lcmEuRlJVU1RVTV9QUk9KRUNUSU9OO1xuICAgIHRoaXMuX2ZvY2FsRGVwdGggPSAwO1xuICAgIHRoaXMuX25lYXIgPSBuZWFyO1xuICAgIHRoaXMuX2ZhciA9IGZhcjtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuQ2FtZXJhLnByb3RvdHlwZS5zZXRGbGF0ID0gZnVuY3Rpb24gc2V0RmxhdCgpIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3BlcnNwZWN0aXZlRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3Byb2plY3Rpb25UeXBlID0gQ2FtZXJhLk9SVEhPR1JBUEhJQ19QUk9KRUNUSU9OO1xuICAgIHRoaXMuX2ZvY2FsRGVwdGggPSAwO1xuICAgIHRoaXMuX25lYXIgPSAwO1xuICAgIHRoaXMuX2ZhciA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkNhbWVyYS5wcm90b3R5cGUub25VcGRhdGUgPSBmdW5jdGlvbiBvblVwZGF0ZSgpIHtcbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgcGF0aCA9IHRoaXMuX25vZGUuZ2V0TG9jYXRpb24oKTtcblxuICAgIHRoaXMuX25vZGVcbiAgICAgICAgLnNlbmREcmF3Q29tbWFuZCgnV0lUSCcpXG4gICAgICAgIC5zZW5kRHJhd0NvbW1hbmQocGF0aCk7XG5cbiAgICBpZiAodGhpcy5fcGVyc3BlY3RpdmVEaXJ0eSkge1xuICAgICAgICB0aGlzLl9wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIHN3aXRjaCAodGhpcy5fcHJvamVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQ2FtZXJhLkZSVVNUVU1fUFJPSkVDVElPTjpcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCgnRlJVU1RVTV9QUk9KRUNUSU9OJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fbmVhcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fZmFyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ2FtZXJhLlBJTkhPTEVfUFJPSkVDVElPTjpcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCgnUElOSE9MRV9QUk9KRUNUSU9OJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fZm9jYWxEZXB0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENhbWVyYS5PUlRIT0dSQVBISUNfUFJPSkVDVElPTjpcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCgnT1JUSE9HUkFQSElDX1BST0pFQ1RJT04nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl92aWV3RGlydHkpIHtcbiAgICAgICAgdGhpcy5fdmlld0RpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQoJ0NIQU5HRV9WSUVXX1RSQU5TRk9STScpO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzBdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsxXSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMl0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzNdKTtcblxuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVs1XSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bNl0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzddKTtcblxuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzhdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVs5XSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTBdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsxMV0pO1xuXG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTJdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsxM10pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzE0XSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTVdKTtcbiAgICB9XG59O1xuXG5cbkNhbWVyYS5wcm90b3R5cGUub25UcmFuc2Zvcm1DaGFuZ2UgPSBmdW5jdGlvbiBvblRyYW5zZm9ybUNoYW5nZSh0cmFuc2Zvcm0pIHtcbiAgICB2YXIgYSA9IHRyYW5zZm9ybTtcbiAgICB0aGlzLl92aWV3RGlydHkgPSB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICBkZXQgPSAxLyhiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDYpO1xuXG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhbWVyYTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb21wb25lbnQgdG8gbWFuYWdlIGdlbmVyYWwgZXZlbnQgZW1pc3Npb24uXG4gKlxuICogQGNsYXNzIEV2ZW50RW1pdHRlclxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHNlbmQgZXZlbnRzIHRocm91Z2guXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcihub2RlKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIEV2ZW50RW1pdHRlciBhcyBhIHN0cmluZy5cbiAqXG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKiBAc3RhdGljXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICdFdmVudEVtaXR0ZXInXG4gKi9cbkV2ZW50RW1pdHRlci50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnRXZlbnRFbWl0dGVyJztcbn07XG5cbi8qKlxuICogRW1pdCBhbiBldmVudCB3aXRoIGEgcGF5bG9hZC5cbiAqXG4gKiBAbWV0aG9kIGVtaXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIFRoZSBldmVudCBwYXlsb2FkLlxuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgdGhpcy5ub2RlLmVtaXQoZXZlbnQsIHBheWxvYWQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYWxsYmFja1N0b3JlID0gcmVxdWlyZSgnZmFtb3VzLXV0aWxpdGllcycpLkNhbGxiYWNrU3RvcmU7XG5cbi8qKlxuICogQ29tcG9uZW50IHRvIGhhbmRsZSBnZW5lcmFsIGV2ZW50cy5cbiAqXG4gKiBAY2xhc3MgRXZlbnRIYW5kbGVyXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgb24gd2hpY2ggdGhpcyBjb21wb25lbnQgaXMgcmVnaXN0ZXJlZC5cbiAqL1xuZnVuY3Rpb24gRXZlbnRIYW5kbGVyIChub2RlLCBldmVudHMpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuaWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgQ2FsbGJhY2tTdG9yZSgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgRXZlbnRIYW5kbGVyIGFzIGEgc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgdG9TdHJpbmdcbiAqIEBzdGF0aWNcbiAqIEByZXR1cm4ge1N0cmluZ30gJ0V2ZW50SGFuZGxlcidcbiAqL1xuRXZlbnRIYW5kbGVyLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdFdmVudEhhbmRsZXInO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gYW4gZXZlbnQuXG4gKlxuICogQG1ldGhvZCBvblxuICogQHBhcmFtIHtTdHJpbmd9IGV2IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgVGhlIGNhbGxiYWNrLlxuICovXG5FdmVudEhhbmRsZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24gKGV2LCBjYikge1xuICAgIHRoaXMuX2V2ZW50cy5vbihldiwgY2IpO1xufTtcblxuLyoqXG4gKiBEZXJlZ2lzdGVyIGEgY2FsbGJhY2sgZnJvbSBhbiBldmVudC5cbiAqXG4gKiBAbWV0aG9kIG9uXG4gKiBAcGFyYW0ge1N0cmluZ30gZXYgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBUaGUgY2FsbGJhY2suXG4gKi9cbkV2ZW50SGFuZGxlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmIChldiwgY2IpIHtcbiAgICB0aGlzLl9ldmVudHMub2ZmKGV2LCBjYik7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgdGhlIGNhbGxiYWNrIGFzc29jaWF0ZWQgd2l0aCBhbiBldmVudCwgcGFzc2luZyBpbiBhIHBheWxvYWQuXG4gKlxuICogQG1ldGhvZCB0cmlnZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXYgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCBUaGUgZXZlbnQgcGF5bG9hZC5cbiAqL1xuRXZlbnRIYW5kbGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoZXYsIHBheWxvYWQpIHtcbiAgICB0aGlzLl9ldmVudHMudHJpZ2dlcihldiwgcGF5bG9hZCk7XG59O1xuXG5FdmVudEhhbmRsZXIucHJvdG90eXBlLm9uUmVjZWl2ZSA9IEV2ZW50SGFuZGxlci5wcm90b3R5cGUudHJpZ2dlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEhhbmRsZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYWxsYmFja1N0b3JlID0gcmVxdWlyZSgnZmFtb3VzLXV0aWxpdGllcycpLkNhbGxiYWNrU3RvcmU7XG52YXIgVmVjMiA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMjtcblxudmFyIFZFQ19SRUdJU1RFUiA9IG5ldyBWZWMyKCk7XG5cbnZhciBnZXN0dXJlcyA9IHtkcmFnOiB0cnVlLCB0YXA6IHRydWUsIHJvdGF0ZTogdHJ1ZSwgcGluY2g6IHRydWV9O1xudmFyIHByb2dyZXNzYmFja3MgPSBbX3Byb2Nlc3NQb2ludGVyU3RhcnQsIF9wcm9jZXNzUG9pbnRlck1vdmUsIF9wcm9jZXNzUG9pbnRlckVuZF07XG5cbnZhciB0b3VjaEV2ZW50cyA9IFsndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnXTtcbnZhciBtb3VzZUV2ZW50cyA9IFsnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJ107XG52YXIgbWV0aG9kcyA9IFsncHJldmVudERlZmF1bHQnXTtcbnZhciB0b3VjaFByb3BlcnRpZXMgPSBbe3RhcmdldFRvdWNoZXM6IHswOiBbJ3BhZ2VYJywgJ3BhZ2VZJywgJ2lkZW50aWZpZXInXSwgMTogWydwYWdlWCcsICdwYWdlWScsICdpZGVudGlmaWVyJ119fV07XG52YXIgbW91c2VQcm9wZXJ0aWVzID0gWydwYWdlWCcsICdwYWdlWSddO1xuXG4vKipcbiAqIENvbXBvbmVudCB0byBtYW5hZ2UgZ2VzdHVyZSBldmVudHMuIFdpbGwgdHJhY2sgJ3BpbmNoJywgJ3JvdGF0ZScsICd0YXAnLCBhbmQgJ2RyYWcnIGV2ZW50cywgb24gYW5cbiAqIGFzLXJlcXVlc3RlZCBiYXNpcy5cbiAqXG4gKiBAY2xhc3MgR2VzdHVyZUhhbmRsZXJcbiAqIEBwYXJhbSB7TG9jYWxEaXNwYXRjaH0gbm9kZSBUaGUgbm9kZSB3aXRoIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBoYW5kbGVyLlxuICogQHBhcmFtIHtPYmplY3RbXX0gZXZlbnRzIEFuIGFycmF5IG9mIGV2ZW50IG9iamVjdHMgc3BlY2lmeWluZyAuZXZlbnQgYW5kIC5jYWxsYmFjayBwcm9wZXJ0aWVzLlxuICovXG5cbmZ1bmN0aW9uIEdlc3R1cmVIYW5kbGVyIChub2RlLCBldmVudHMpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuaWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcblxuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBDYWxsYmFja1N0b3JlKCk7XG5cbiAgICB0aGlzLmxhc3QxID0gbmV3IFZlYzIoKTtcbiAgICB0aGlzLmxhc3QyID0gbmV3IFZlYzIoKTtcblxuICAgIHRoaXMuZGVsdGExID0gbmV3IFZlYzIoKTtcbiAgICB0aGlzLmRlbHRhMiA9IG5ldyBWZWMyKCk7XG5cbiAgICB0aGlzLnZlbG9jaXR5MSA9IG5ldyBWZWMyKCk7XG4gICAgdGhpcy52ZWxvY2l0eTIgPSBuZXcgVmVjMigpO1xuXG4gICAgdGhpcy5kaXN0ID0gMDtcbiAgICB0aGlzLmRpZmYxMiA9IG5ldyBWZWMyKCk7XG5cbiAgICB0aGlzLmNlbnRlciA9IG5ldyBWZWMyKCk7XG4gICAgdGhpcy5jZW50ZXJEZWx0YSA9IG5ldyBWZWMyKCk7XG4gICAgdGhpcy5jZW50ZXJWZWxvY2l0eSA9IG5ldyBWZWMyKCk7XG5cbiAgICB0aGlzLnBvaW50ZXIxID0ge1xuICAgICAgICBwb3NpdGlvbjogdGhpcy5sYXN0MSxcbiAgICAgICAgZGVsdGE6IHRoaXMuZGVsdGExLFxuICAgICAgICB2ZWxvY2l0eTogdGhpcy52ZWxvY2l0eTEsXG4gICAgfTtcblxuICAgIHRoaXMucG9pbnRlcjIgPSB7XG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLmxhc3QyLFxuICAgICAgICBkZWx0YTogdGhpcy5kZWx0YTIsXG4gICAgICAgIHZlbG9jaXR5OiB0aGlzLnZlbG9jaXR5MixcbiAgICB9O1xuXG4gICAgdGhpcy5ldmVudCA9IHtcbiAgICAgICAgc3RhdHVzOiBudWxsLFxuICAgICAgICB0aW1lOiAwLFxuICAgICAgICBwb2ludGVyczogW10sXG4gICAgICAgIGNlbnRlcjogdGhpcy5jZW50ZXIsXG4gICAgICAgIGNlbnRlckRlbHRhOiB0aGlzLmNlbnRlckRlbHRhLFxuICAgICAgICBjZW50ZXJWZWxvY2l0eTogdGhpcy5jZW50ZXJWZWxvY2l0eSxcbiAgICAgICAgcG9pbnRzOiAwLFxuICAgICAgICBjdXJyZW50OiAwXG4gICAgfTtcblxuICAgIHRoaXMudHJhY2tlZFBvaW50ZXJJRHMgPSBbLTEsIC0xXTtcbiAgICB0aGlzLnRpbWVPZlBvaW50ZXIgPSAwO1xuICAgIHRoaXMubXVsdGlUYXAgPSAwO1xuXG4gICAgdGhpcy5taWNlID0gW107XG5cbiAgICB0aGlzLmdlc3R1cmVzID0gW107XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy50cmFja2VkR2VzdHVyZXMgPSB7fTtcblxuICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5vbihldmVudHNbaV0sIGV2ZW50c1tpXS5jYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCAzIDsgaSsrKSB7XG4gICAgICAgIHZhciB0b3VjaEV2ZW50ID0gdG91Y2hFdmVudHNbaV07XG4gICAgICAgIHZhciBtb3VzZUV2ZW50ID0gbW91c2VFdmVudHNbaV07XG4gICAgICAgIG5vZGUuYWRkVUlFdmVudCh0b3VjaEV2ZW50KTtcbiAgICAgICAgbm9kZS5hZGRVSUV2ZW50KG1vdXNlRXZlbnQpO1xuICAgIH1cblxuICAgIG5vZGUuYWRkVUlFdmVudCgnbW91c2VsZWF2ZScpO1xufVxuXG5HZXN0dXJlSGFuZGxlci5wcm90b3R5cGUub25SZWNlaXZlID0gZnVuY3Rpb24gb25SZWNlaXZlIChldmVudCwgcGF5bG9hZCkge1xuICAgIHZhciBpbmRleCA9IG1vdXNlRXZlbnRzLmluZGV4T2YoZXZlbnQpO1xuICAgIGluZGV4ID0gaW5kZXggIT09IC0xID8gaW5kZXggOiB0b3VjaEV2ZW50cy5pbmRleE9mKGV2ZW50KTtcbiAgICBcbiAgICBpZiAoaW5kZXggIT09IC0xKSBwcm9ncmVzc2JhY2tzW2luZGV4XS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgIGVsc2UgaWYgKGV2ZW50ID09PSAnbW91c2VsZWF2ZScpIF9wcm9jZXNzTW91c2VMZWF2ZS5jYWxsKHRoaXMsIHBheWxvYWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIEdlc3R1cmVIYW5kbGVyIGFzIGEgc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgdG9TdHJpbmdcbiAqIEBzdGF0aWNcbiAqIEByZXR1cm4ge1N0cmluZ30gJ0dlc3R1cmVIYW5kbGVyJ1xuICovXG5HZXN0dXJlSGFuZGxlci50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnR2VzdHVyZUhhbmRsZXInO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gYW4gZXZlbnQuXG4gKlxuICogQG1ldGhvZCBvblxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBldiBUaGUgZXZlbnQgb2JqZWN0IG9yIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBUaGUgY2FsbGJhY2suXG4gKi9cbkdlc3R1cmVIYW5kbGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2LCBjYikge1xuICAgIHZhciBnZXN0dXJlID0gZXYuZXZlbnQgfHwgZXY7XG4gICAgaWYgKGdlc3R1cmVzW2dlc3R1cmVdKSB7XG4gICAgICAgIHRoaXMudHJhY2tlZEdlc3R1cmVzW2dlc3R1cmVdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5nZXN0dXJlcy5wdXNoKGdlc3R1cmUpO1xuICAgICAgICBpZiAoZXYuZXZlbnQpIHRoaXMub3B0aW9uc1tnZXN0dXJlXSA9IGV2O1xuICAgICAgICB0aGlzLl9ldmVudHMub24oZ2VzdHVyZSwgY2IpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGVyZWdpc3RlciBhIGNhbGxiYWNrIGZyb20gYW4gZXZlbnQuXG4gKlxuICogQG1ldGhvZCBvblxuICogQHBhcmFtIHtTdHJpbmd9IGV2IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgVGhlIGNhbGxiYWNrLlxuICovXG5HZXN0dXJlSGFuZGxlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2LCBjYikge1xuICAgIHRoaXMuX2V2ZW50cy5vZmYoZ2VzdHVyZSwgY2IpO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGdlc3R1cmVzIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgcmVxdWVzdGVkLCBpZiB0aGV5IG9jY3VyZWQuXG4gKlxuICogQG1ldGhvZCB0cmlnZ2VyR2VzdHVyZXNcbiAqL1xuR2VzdHVyZUhhbmRsZXIucHJvdG90eXBlLnRyaWdnZXJHZXN0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXlsb2FkID0gdGhpcy5ldmVudDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5nZXN0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZ2VzdHVyZSA9IHRoaXMuZ2VzdHVyZXNbaV07XG4gICAgICAgIHN3aXRjaCAoZ2VzdHVyZSkge1xuICAgICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ3BpbmNoJzpcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5wb2ludHMgPT09IDIpIHRoaXMudHJpZ2dlcihnZXN0dXJlLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RhcCc6XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuc3RhdHVzID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ3RhcCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHRzID0gdGhpcy5vcHRpb25zWyd0YXAnXS5wb2ludHMgfHwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubXVsdGlUYXAgPj0gcHRzICYmIHBheWxvYWQucG9pbnRzID49IHB0cykgdGhpcy50cmlnZ2VyKGdlc3R1cmUsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdGhpcy50cmlnZ2VyKGdlc3R1cmUsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKGdlc3R1cmUsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmlnZ2VyIHRoZSBjYWxsYmFjayBhc3NvY2lhdGVkIHdpdGggYW4gZXZlbnQsIHBhc3NpbmcgaW4gYSBwYXlsb2FkLlxuICpcbiAqIEBtZXRob2QgdHJpZ2dlclxuICogQHBhcmFtIHtTdHJpbmd9IGV2IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgVGhlIGV2ZW50IHBheWxvYWQuXG4gKi9cbkdlc3R1cmVIYW5kbGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoZXYsIHBheWxvYWQpIHtcbiAgICB0aGlzLl9ldmVudHMudHJpZ2dlcihldiwgcGF5bG9hZCk7XG59O1xuXG4vKipcbiAqIFByb2Nlc3MgdXAgdG8gdGhlIGZpcnN0IHR3byB0b3VjaC9tb3VzZSBtb3ZlIGV2ZW50cy4gRXhpdCBvdXQgaWYgdGhlIGZpcnN0IHR3byBwb2ludHMgYXJlIGFscmVhZHkgYmVpbmcgdHJhY2tlZC5cbiAqXG4gKiBAbWV0aG9kIF9wcm9jZXNzUG9pbnRlclN0YXJ0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX3Byb2Nlc3NQb2ludGVyU3RhcnQoZSkge1xuICAgIHZhciB0O1xuICAgIGlmICghZS50YXJnZXRUb3VjaGVzKSB7XG4gICAgICAgIHRoaXMubWljZVswXSA9IGU7XG4gICAgICAgIHQgPSB0aGlzLm1pY2U7XG4gICAgICAgIGUuaWRlbnRpZmllciA9IDE7XG4gICAgfVxuICAgIGVsc2UgdCA9IGUudGFyZ2V0VG91Y2hlcztcblxuICAgIGlmICh0WzBdICYmIHRbMV0gJiYgdGhpcy50cmFja2VkUG9pbnRlcklEc1swXSA9PT0gdFswXS5pZGVudGlmaWVyICYmIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMV0gPT09IHRbMV0uaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudC50aW1lID0gRGF0ZS5ub3coKTtcblxuICAgIGlmICh0aGlzLnRyYWNrZWRQb2ludGVySURzWzBdICE9PSB0WzBdLmlkZW50aWZpZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZEdlc3R1cmVzWyd0YXAnXSkge1xuICAgICAgICAgICAgdmFyIHRocmVzaG9sZCA9ICh0aGlzLm9wdGlvbnNbJ3RhcCddICYmIHRoaXMub3B0aW9uc1sndGFwJ10udGhyZXNob2xkKSB8fCAyNTA7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudC50aW1lIC0gdGhpcy50aW1lT2ZQb2ludGVyIDwgdGhyZXNob2xkKSB0aGlzLmV2ZW50LnRhcHMrKztcbiAgICAgICAgICAgIGVsc2UgdGhpcy5ldmVudC50YXBzID0gMTtcbiAgICAgICAgICAgIHRoaXMudGltZU9mUG9pbnRlciA9IHRoaXMuZXZlbnQudGltZTtcbiAgICAgICAgICAgIHRoaXMubXVsdGlUYXAgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnQuY3VycmVudCA9IDE7XG4gICAgICAgIHRoaXMuZXZlbnQucG9pbnRzID0gMTtcbiAgICAgICAgdmFyIGlkID0gdFswXS5pZGVudGlmaWVyO1xuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVySURzWzBdID0gaWQ7XG5cbiAgICAgICAgdGhpcy5sYXN0MS5zZXQodFswXS5wYWdlWCwgdFswXS5wYWdlWSk7XG4gICAgICAgIHRoaXMudmVsb2NpdHkxLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZGVsdGExLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZXZlbnQucG9pbnRlcnMucHVzaCh0aGlzLnBvaW50ZXIxKTtcbiAgICB9XG4gICAgaWYgKHRbMV0gJiYgdGhpcy50cmFja2VkUG9pbnRlcklEc1sxXSAhPT0gdFsxXS5pZGVudGlmaWVyKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRHZXN0dXJlc1sndGFwJ10pIHtcbiAgICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSAodGhpcy5vcHRpb25zWyd0YXAnXSAmJiB0aGlzLm9wdGlvbnNbJ3RhcCddLnRocmVzaG9sZCkgfHwgMjUwO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnQudGltZSAtIHRoaXMudGltZU9mUG9pbnRlciA8IHRocmVzaG9sZCkgdGhpcy5tdWx0aVRhcCA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudC5jdXJyZW50ID0gMjtcbiAgICAgICAgdGhpcy5ldmVudC5wb2ludHMgPSAyO1xuICAgICAgICB2YXIgaWQgPSB0WzFdLmlkZW50aWZpZXI7XG4gICAgICAgIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMV0gPSBpZDtcblxuICAgICAgICB0aGlzLmxhc3QyLnNldCh0WzFdLnBhZ2VYLCB0WzFdLnBhZ2VZKTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eTIuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5kZWx0YTIuY2xlYXIoKTtcblxuICAgICAgICBWZWMyLmFkZCh0aGlzLmxhc3QxLCB0aGlzLmxhc3QyLCB0aGlzLmNlbnRlcikuc2NhbGUoMC41KTtcbiAgICAgICAgdGhpcy5jZW50ZXJEZWx0YS5jbGVhcigpO1xuICAgICAgICB0aGlzLmNlbnRlclZlbG9jaXR5LmNsZWFyKCk7XG5cbiAgICAgICAgVmVjMi5zdWJ0cmFjdCh0aGlzLmxhc3QyLCB0aGlzLmxhc3QxLCB0aGlzLmRpZmYxMik7XG4gICAgICAgIHRoaXMuZGlzdCA9IHRoaXMuZGlmZjEyLmxlbmd0aCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRHZXN0dXJlc1sncGluY2gnXSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudC5zY2FsZSA9IHRoaXMuZXZlbnQuc2NhbGUgfHwgMTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuc2NhbGVEZWx0YSA9IDA7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnNjYWxlVmVsb2NpdHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRHZXN0dXJlc1sncm90YXRlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQucm90YXRpb24gPSB0aGlzLmV2ZW50LnJvdGF0aW9uIHx8IDA7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnJvdGF0aW9uRGVsdGEgPSAwO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5yb3RhdGlvblZlbG9jaXR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50LnBvaW50ZXJzLnB1c2godGhpcy5wb2ludGVyMik7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudC5zdGF0dXMgPSAnc3RhcnQnO1xuICAgIGlmICh0aGlzLmV2ZW50LnBvaW50cyA9PT0gMSkge1xuICAgICAgICB0aGlzLmNlbnRlci5jb3B5KHRoaXMubGFzdDEpO1xuICAgICAgICB0aGlzLmNlbnRlckRlbHRhLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY2VudGVyVmVsb2NpdHkuY2xlYXIoKTtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZEdlc3R1cmVzWydwaW5jaCddKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnNjYWxlID0gMTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuc2NhbGVEZWx0YSA9IDA7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnNjYWxlVmVsb2NpdHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRHZXN0dXJlc1sncm90YXRlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQucm90YXRpb24gPSAwO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5yb3RhdGlvbkRlbHRhID0gMDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQucm90YXRpb25WZWxvY2l0eSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyR2VzdHVyZXMoKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHVwIHRvIHRoZSBmaXJzdCB0d28gdG91Y2gvbW91c2UgbW92ZSBldmVudHMuXG4gKlxuICogQG1ldGhvZCBfcHJvY2Vzc1BvaW50ZXJNb3ZlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX3Byb2Nlc3NQb2ludGVyTW92ZShlKSB7XG4gICAgdmFyIHQ7XG4gICAgaWYgKCFlLnRhcmdldFRvdWNoZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV2ZW50LmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgdGhpcy5taWNlWzBdID0gZTtcbiAgICAgICAgdCA9IHRoaXMubWljZTtcbiAgICAgICAgZS5pZGVudGlmaWVyID0gMTtcbiAgICB9XG4gICAgZWxzZSB0ID0gZS50YXJnZXRUb3VjaGVzO1xuXG4gICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHZhciBkdCA9IHRpbWUgLSB0aGlzLmV2ZW50LnRpbWU7XG4gICAgaWYgKGR0ID09PSAwKSByZXR1cm47XG4gICAgdmFyIGludkR0ID0gMTAwMCAvIGR0O1xuICAgIHRoaXMuZXZlbnQudGltZSA9IHRpbWU7XG5cbiAgICB0aGlzLmV2ZW50LmN1cnJlbnQgPSAxO1xuICAgIHRoaXMuZXZlbnQucG9pbnRzID0gMTtcbiAgICBpZiAodGhpcy50cmFja2VkUG9pbnRlcklEc1swXSA9PT0gdFswXS5pZGVudGlmaWVyKSB7XG4gICAgICAgIFZFQ19SRUdJU1RFUi5zZXQodFswXS5wYWdlWCwgdFswXS5wYWdlWSk7XG4gICAgICAgIFZlYzIuc3VidHJhY3QoVkVDX1JFR0lTVEVSLCB0aGlzLmxhc3QxLCB0aGlzLmRlbHRhMSk7XG4gICAgICAgIFZlYzIuc2NhbGUodGhpcy5kZWx0YTEsIGludkR0LCB0aGlzLnZlbG9jaXR5MSk7XG4gICAgICAgIHRoaXMubGFzdDEuY29weShWRUNfUkVHSVNURVIpO1xuXG4gICAgfVxuICAgIGlmICh0WzFdKSB7XG4gICAgICAgIHRoaXMuZXZlbnQuY3VycmVudCA9IDI7XG4gICAgICAgIHRoaXMuZXZlbnQucG9pbnRzID0gMjtcbiAgICAgICAgVkVDX1JFR0lTVEVSLnNldCh0WzFdLnBhZ2VYLCB0WzFdLnBhZ2VZKTtcbiAgICAgICAgVmVjMi5zdWJ0cmFjdChWRUNfUkVHSVNURVIsIHRoaXMubGFzdDIsIHRoaXMuZGVsdGEyKTtcbiAgICAgICAgVmVjMi5zY2FsZSh0aGlzLmRlbHRhMiwgaW52RHQsIHRoaXMudmVsb2NpdHkyKTtcbiAgICAgICAgdGhpcy5sYXN0Mi5jb3B5KFZFQ19SRUdJU1RFUik7XG5cbiAgICAgICAgVmVjMi5hZGQodGhpcy5sYXN0MSwgdGhpcy5sYXN0MiwgVkVDX1JFR0lTVEVSKS5zY2FsZSgwLjUpO1xuICAgICAgICBWZWMyLnN1YnRyYWN0KFZFQ19SRUdJU1RFUiwgdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyRGVsdGEpO1xuICAgICAgICBWZWMyLmFkZCh0aGlzLnZlbG9jaXR5MSwgdGhpcy52ZWxvY2l0eTIsIHRoaXMuY2VudGVyVmVsb2NpdHkpLnNjYWxlKDAuNSk7XG4gICAgICAgIHRoaXMuY2VudGVyLmNvcHkoVkVDX1JFR0lTVEVSKTtcblxuICAgICAgICBWZWMyLnN1YnRyYWN0KHRoaXMubGFzdDIsIHRoaXMubGFzdDEsIFZFQ19SRUdJU1RFUik7XG5cbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZEdlc3R1cmVzWydyb3RhdGUnXSkge1xuICAgICAgICAgICAgdmFyIGRvdCA9IFZFQ19SRUdJU1RFUi5kb3QodGhpcy5kaWZmMTIpO1xuICAgICAgICAgICAgdmFyIGNyb3NzID0gVkVDX1JFR0lTVEVSLmNyb3NzKHRoaXMuZGlmZjEyKTtcbiAgICAgICAgICAgIHZhciB0aGV0YSA9IC1NYXRoLmF0YW4yKGNyb3NzLCBkb3QpO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5yb3RhdGlvbiArPSB0aGV0YTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQucm90YXRpb25EZWx0YSA9IHRoZXRhO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5yb3RhdGlvblZlbG9jaXR5ID0gdGhldGEgKiBpbnZEdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaXN0ID0gVkVDX1JFR0lTVEVSLmxlbmd0aCgpO1xuICAgICAgICB2YXIgc2NhbGUgPSBkaXN0IC8gdGhpcy5kaXN0O1xuICAgICAgICB0aGlzLmRpZmYxMi5jb3B5KFZFQ19SRUdJU1RFUik7XG4gICAgICAgIHRoaXMuZGlzdCA9IGRpc3Q7XG5cbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZEdlc3R1cmVzWydwaW5jaCddKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnNjYWxlICo9IHNjYWxlO1xuICAgICAgICAgICAgc2NhbGUgLT0gMS4wO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5zY2FsZURlbHRhID0gc2NhbGU7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnNjYWxlVmVsb2NpdHkgPSBzY2FsZSAqIGludkR0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudC5zdGF0dXMgPSAnbW92ZSc7XG4gICAgaWYgKHRoaXMuZXZlbnQucG9pbnRzID09PSAxKSB7XG4gICAgICAgIHRoaXMuY2VudGVyLmNvcHkodGhpcy5sYXN0MSk7XG4gICAgICAgIHRoaXMuY2VudGVyRGVsdGEuY29weSh0aGlzLmRlbHRhMSk7XG4gICAgICAgIHRoaXMuY2VudGVyVmVsb2NpdHkuY29weSh0aGlzLnZlbG9jaXR5MSk7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRHZXN0dXJlc1sncGluY2gnXSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudC5zY2FsZSA9IDE7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnNjYWxlRGVsdGEgPSAwO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5zY2FsZVZlbG9jaXR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFja2VkR2VzdHVyZXNbJ3JvdGF0ZSddKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnJvdGF0aW9uID0gMDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQucm90YXRpb25EZWx0YSA9IDA7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnJvdGF0aW9uVmVsb2NpdHkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMudHJpZ2dlckdlc3R1cmVzKCk7XG59XG5cbi8qKlxuICogUHJvY2VzcyB1cCB0byB0aGUgZmlyc3QgdHdvIHRvdWNoL21vdXNlIGVuZCBldmVudHMuIEV4aXQgb3V0IGlmIHRoZSB0d28gcG9pbnRzIGJlaW5nIHRyYWNrZWQgYXJlIHN0aWxsIGFjdGl2ZS5cbiAqXG4gKiBAbWV0aG9kIF9wcm9jZXNzUG9pbnRlckVuZFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIF9wcm9jZXNzUG9pbnRlckVuZChlKSB7XG4gICAgdmFyIHQ7XG4gICAgaWYgKCFlLnRhcmdldFRvdWNoZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV2ZW50LmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgdGhpcy5taWNlLnBvcCgpO1xuICAgICAgICB0ID0gdGhpcy5taWNlO1xuICAgIH1cbiAgICBlbHNlIHQgPSBlLnRhcmdldFRvdWNoZXM7XG5cbiAgICBpZiAodFswXSAmJiB0WzFdICYmIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMF0gPT09IHRbMF0uaWRlbnRpZmllciAmJiB0aGlzLnRyYWNrZWRQb2ludGVySURzWzFdID09PSB0WzFdLmlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50LnN0YXR1cyA9ICdlbmQnO1xuICAgIGlmICghdFswXSkge1xuICAgICAgICB0aGlzLmV2ZW50LmN1cnJlbnQgPSAwO1xuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVySURzWzBdID0gLTE7XG4gICAgICAgIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMV0gPSAtMTtcbiAgICAgICAgdGhpcy50cmlnZ2VyR2VzdHVyZXMoKTtcbiAgICAgICAgdGhpcy5ldmVudC5wb2ludGVycy5wb3AoKTtcbiAgICAgICAgdGhpcy5ldmVudC5wb2ludGVycy5wb3AoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmKHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMF0gIT09IHRbMF0uaWRlbnRpZmllcikge1xuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVySURzWzBdID0gLTE7XG4gICAgICAgIHZhciBpZCA9IHRbMF0uaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy50cmFja2VkUG9pbnRlcklEc1swXSA9IGlkO1xuXG4gICAgICAgIHRoaXMubGFzdDEuc2V0KHRbMF0ucGFnZVgsIHRbMF0ucGFnZVkpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5MS5jbGVhcigpO1xuICAgICAgICB0aGlzLmRlbHRhMS5jbGVhcigpO1xuICAgIH1cbiAgICBpZiAoIXRbMV0pIHtcbiAgICAgICAgdGhpcy5ldmVudC5jdXJyZW50ID0gMTtcbiAgICAgICAgdGhpcy50cmFja2VkUG9pbnRlcklEc1sxXSA9IC0xO1xuICAgICAgICB0aGlzLnRyaWdnZXJHZXN0dXJlcygpO1xuICAgICAgICB0aGlzLmV2ZW50LnBvaW50cyA9IDE7XG4gICAgICAgIHRoaXMuZXZlbnQucG9pbnRlcnMucG9wKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMV0gIT09IHRbMV0uaWRlbnRpZmllcikge1xuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVySURzWzFdID0gLTE7XG4gICAgICAgIHRoaXMuZXZlbnQucG9pbnRzID0gMjtcbiAgICAgICAgdmFyIGlkID0gdFsxXS5pZGVudGlmaWVyO1xuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVySURzWzFdID0gaWQ7XG5cbiAgICAgICAgdGhpcy5sYXN0Mi5zZXQodFsxXS5wYWdlWCwgdFsxXS5wYWdlWSk7XG4gICAgICAgIHRoaXMudmVsb2NpdHkyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZGVsdGEyLmNsZWFyKCk7XG5cbiAgICAgICAgVmVjMi5hZGQodGhpcy5sYXN0MSwgdGhpcy5sYXN0MiwgdGhpcy5jZW50ZXIpLnNjYWxlKDAuNSk7XG4gICAgICAgIHRoaXMuY2VudGVyRGVsdGEuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jZW50ZXJWZWxvY2l0eS5jbGVhcigpO1xuXG4gICAgICAgIFZlYzIuc3VidHJhY3QodGhpcy5sYXN0MiwgdGhpcy5sYXN0MSwgdGhpcy5kaWZmMTIpO1xuICAgICAgICB0aGlzLmRpc3QgPSB0aGlzLmRpZmYxMi5sZW5ndGgoKTtcbiAgICB9XG59XG5cbi8qKlxuICogVHJlYXRzIGEgbW91c2VsZWF2ZSBldmVudCBhcyBhIGdlc3R1cmUgZW5kLlxuICpcbiAqIEBtZXRob2QgX3Byb2Nlc3NNb3VzZUxlYXZlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX3Byb2Nlc3NNb3VzZUxlYXZlKGUpIHtcbiAgICBpZiAodGhpcy5ldmVudC5jdXJyZW50KSB7XG4gICAgICAgIHRoaXMuZXZlbnQuc3RhdHVzID0gJ2VuZCc7XG4gICAgICAgIHRoaXMuZXZlbnQuY3VycmVudCA9IDA7XG4gICAgICAgIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMF0gPSAtMTtcbiAgICAgICAgdGhpcy50cmlnZ2VyR2VzdHVyZXMoKTtcbiAgICAgICAgdGhpcy5ldmVudC5wb2ludGVycy5wb3AoKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR2VzdHVyZUhhbmRsZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoJy4vUG9zaXRpb24nKTtcblxuLyoqXG4gKiBAY2xhc3MgTW91bnRQb2ludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IGRpc3BhdGNoIExvY2FsRGlzcGF0Y2ggdG8gYmUgcmV0cmlldmVkIGZyb20gY29ycmVzcG9uZGluZyBSZW5kZXIgTm9kZSBvZiB0aGUgTW91bnRQb2ludCBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gTW91bnRQb2ludChub2RlKSB7XG4gICAgUG9zaXRpb24uY2FsbCh0aGlzLCBub2RlKTtcbn1cblxuLyoqXG4qXG4qIFN0cmluZ2lmaWVzIE1vdW50UG9pbnRcbipcbiogQG1ldGhvZFxuKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBDb21wb25lbnQgQ2xhc3M6ICdNb3VudFBvaW50J1xuKi9cbk1vdW50UG9pbnQudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ01vdW50UG9pbnQnO1xufTtcblxuTW91bnRQb2ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBvc2l0aW9uLnByb3RvdHlwZSk7XG5Nb3VudFBvaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vdW50UG9pbnQ7XG5cbk1vdW50UG9pbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9ub2RlLnNldE1vdW50UG9pbnQodGhpcy5feC5nZXQoKSwgdGhpcy5feS5nZXQoKSwgdGhpcy5fei5nZXQoKSk7XG4gICAgdGhpcy5fY2hlY2tVcGRhdGUoKTtcbn07XG5cbk1vdW50UG9pbnQucHJvdG90eXBlLm9uVXBkYXRlID0gTW91bnRQb2ludC5wcm90b3R5cGUudXBkYXRlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdW50UG9pbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUcmFuc2l0aW9uYWJsZSA9IHJlcXVpcmUoJ2ZhbW91cy10cmFuc2l0aW9ucycpLlRyYW5zaXRpb25hYmxlO1xuXG5cbi8qKlxuICogQGNsYXNzIE9wYWNpdHlcbiAqIEBjb25zdHJ1Y3RvclxuICogQGNvbXBvbmVudFxuICogQHBhcmFtIHtMb2NhbERpc3BhdGNofSBkaXNwYXRjaCBMb2NhbERpc3BhdGNoIHRvIGJlIHJldHJpZXZlZCBmcm9tIGNvcnJlc3BvbmRpbmcgUmVuZGVyIE5vZGUgb2YgdGhlIE9wYWNpdHkgY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIE9wYWNpdHkobm9kZSkge1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIHRoaXMuX2lkID0gbm9kZS5hZGRDb21wb25lbnQodGhpcyk7XG4gICAgdGhpcy5fdmFsdWUgPSBuZXcgVHJhbnNpdGlvbmFibGUoMSk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG59XG5cbi8qKlxuKlxuKiByZXR1cm5zIHN0cmluZ2lmaWVkIE9wYWNpdHlcbipcbiogQG1ldGhvZFxuKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBDb21wb25lbnQgQ2xhc3M6ICdPcGFjaXR5J1xuKi9cbk9wYWNpdHkudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ09wYWNpdHknO1xufTtcblxuLyoqXG4qXG4qIFJldHJpZXZlcyBzdGF0ZSBvZiBPcGFjaXR5XG4qXG4qIEBtZXRob2RcbiogQHJldHVybiB7T2JqZWN0fSBjb250YWlucyBjb21wb25lbnQga2V5IHdoaWNoIGhvbGRzIHRoZSBzdHJpbmdpZmllZCBjb25zdHJ1Y3RvciBcbiogYW5kIHZhbHVlIGtleSB3aGljaCBjb250YWlucyB0aGUgbnVtZXJpYyB2YWx1ZVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9uZW50OiB0aGlzLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCksXG4gICAgICAgIHZhbHVlOiB0aGlzLl92YWx1ZS5nZXQoKVxuICAgIH07XG59O1xuXG4vKipcbipcbiogU2V0dGVyIGZvciBPcGFjaXR5IHN0YXRlXG4qXG4qIEBtZXRob2RcbiogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGNvbnRhaW5zIGNvbXBvbmVudCBrZXksIHdoaWNoIGhvbGRzIHN0cmluZ2lmaWVkIGNvbnN0cnVjdG9yLCBhbmQgYSB2YWx1ZSBrZXksIHdoaWNoIGNvbnRhaW5zIGEgbnVtZXJpYyB2YWx1ZSB1c2VkIHRvIHNldCBvcGFjaXR5IGlmIHRoZSBjb25zdHJ1Y3RvciB2YWx1ZSBtYXRjaGVzXG4qIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc2V0IGlzIHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci50b1N0cmluZygpID09PSBzdGF0ZS5jb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5zZXQoc3RhdGUudmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4qXG4qIFNldHRlciBmb3IgT3BhY2l0eSB3aXRoIGNhbGxiYWNrXG4qXG4qIEBtZXRob2RcbiogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZhbHVlIHVzZWQgdG8gc2V0IE9wYWNpdHlcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBoYXNoXG4qIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb2xsb3dpbmcgT3BhY2l0eSBzZXRcbiogQGNoYWluYWJsZVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCh2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWUuc2V0KHZhbHVlLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbipcbiogR2V0dGVyIGZvciBPcGFjaXR5XG4qXG4qIEBtZXRob2RcbiogQHJldHVybiB7TnVtYmVyfVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUuZ2V0KCk7XG59O1xuXG4vKipcbipcbiogU3RvcHMgT3BhY2l0eSB0cmFuc2l0aW9uXG4qXG4qIEBtZXRob2RcbiogQGNoYWluYWJsZVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLmhhbHQgPSBmdW5jdGlvbiBoYWx0KCkge1xuICAgIHRoaXMuX3ZhbHVlLmhhbHQoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKXtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUuaXNBY3RpdmUoKTtcbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fbm9kZS5zZXRPcGFjaXR5KHRoaXMuX3ZhbHVlLmdldCgpKTtcbiAgICB0aGlzLl9jaGVja1VwZGF0ZSgpOyAgICBcbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLm9uVXBkYXRlID0gT3BhY2l0eS5wcm90b3R5cGUudXBkYXRlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9wYWNpdHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoJy4vUG9zaXRpb24nKTtcblxuLyoqXG4gKiBAY2xhc3MgT3JpZ2luXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjb21wb25lbnRcbiAqIEBwYXJhbSB7TG9jYWxEaXNwYXRjaH0gZGlzcGF0Y2ggTG9jYWxEaXNwYXRjaCB0byBiZSByZXRyaWV2ZWQgZnJvbSBjb3JyZXNwb25kaW5nIFJlbmRlciBOb2RlIG9mIHRoZSBPcmlnaW4gY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIE9yaWdpbihub2RlKSB7XG4gICAgUG9zaXRpb24uY2FsbCh0aGlzLCBub2RlKTtcbn1cblxuXG4vKipcbipcbiogcmV0dXJucyBzdHJpbmdpZmllZCBPcmlnaW5cbipcbiogQG1ldGhvZFxuKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBDb21wb25lbnQgQ2xhc3M6ICdPcmlnaW4nXG4qL1xuT3JpZ2luLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdPcmlnaW4nO1xufTtcblxuT3JpZ2luLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUG9zaXRpb24ucHJvdG90eXBlKTtcbk9yaWdpbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPcmlnaW47XG5cbk9yaWdpbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMuX25vZGUuc2V0T3JpZ2luKHRoaXMuX3guZ2V0KCksIHRoaXMuX3kuZ2V0KCksIHRoaXMuX3ouZ2V0KCkpO1xuICAgIHRoaXMuX2NoZWNrVXBkYXRlKCk7XG59O1xuXG5PcmlnaW4ucHJvdG90eXBlLm9uVXBkYXRlID0gT3JpZ2luLnByb3RvdHlwZS51cGRhdGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT3JpZ2luO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhbnNpdGlvbmFibGUgPSByZXF1aXJlKCdmYW1vdXMtdHJhbnNpdGlvbnMnKS5UcmFuc2l0aW9uYWJsZTtcblxuLyoqXG4gKiBAY2xhc3MgUG9zaXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGNvbXBvbmVudFxuICogQHBhcmFtIHtMb2NhbERpc3BhdGNofSBkaXNwYXRjaCBMb2NhbERpc3BhdGNoIHRvIGJlIHJldHJpZXZlZCBmcm9tIGNvcnJlc3BvbmRpbmcgUmVuZGVyIE5vZGUgb2YgdGhlIFBvc2l0aW9uIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBQb3NpdGlvbihub2RlKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgXG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgIFxuICAgIHZhciBpbml0aWFsUG9zaXRpb24gPSBub2RlLmdldFBvc2l0aW9uKCk7XG5cbiAgICB0aGlzLl94ID0gbmV3IFRyYW5zaXRpb25hYmxlKGluaXRpYWxQb3NpdGlvblswXSk7XG4gICAgdGhpcy5feSA9IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsUG9zaXRpb25bMV0pO1xuICAgIHRoaXMuX3ogPSBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbFBvc2l0aW9uWzJdKTtcbn1cblxuLyoqIFxuKlxuKiBzdHJpbmdpZmllcyBQb3NpdGlvbiBjb25zdHJ1Y3RvclxuKlxuKiBAbWV0aG9kXG4qIEByZXR1cm4ge1N0cmluZ30gdGhlIGRlZmluaXRpb24gb2YgdGhlIENvbXBvbmVudCBDbGFzczogJ1Bvc2l0aW9uJ1xuKi9cblBvc2l0aW9uLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdQb3NpdGlvbic7XG59O1xuXG4vKipcbipcbiogR2V0cyBvYmplY3QgY29udGFpbmluZyBzdHJpbmdpZmllZCBjb25zdHJ1Y3RvciwgeCwgeSwgeiBjb29yZGluYXRlc1xuKlxuKiBAbWV0aG9kXG4qIEByZXR1cm4ge09iamVjdH1cbiovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21wb25lbnQ6IHRoaXMuY29uc3RydWN0b3IudG9TdHJpbmcoKSxcbiAgICAgICAgeDogdGhpcy5feC5nZXQoKSxcbiAgICAgICAgeTogdGhpcy5feS5nZXQoKSxcbiAgICAgICAgejogdGhpcy5fei5nZXQoKVxuICAgIH07XG59O1xuXG4vKipcbipcbiogU2V0dGVyIGZvciBwb3NpdGlvbiBjb29yZGluYXRlc1xuKlxuKiBAbWV0aG9kXG4qIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBPYmplY3QgLS0gY29tcG9uZW50OiBzdHJpbmdpZmllZCBjb25zdHJ1Y3RvciwgeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlclxuKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiovXG5Qb3NpdGlvbi5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5jb21wb25lbnQgPT09IHRoaXMuY29uc3RydWN0b3IudG9TdHJpbmcoKSkge1xuICAgICAgICB0aGlzLnNldChzdGF0ZS54LCBzdGF0ZS55LCBzdGF0ZS56KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuKlxuKiBHZXR0ZXIgZm9yIFggcG9zaXRpb25cbipcbiogQG1ldGhvZFxuKiBAcmV0dXJuIHtOdW1iZXJ9XG4qL1xuUG9zaXRpb24ucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICAgIHJldHVybiB0aGlzLl94LmdldCgpO1xufTtcblxuLyoqXG4qXG4qIEdldHRlciBmb3IgWSBwb3NpdGlvblxuKlxuKiBAbWV0aG9kXG4qIEByZXR1cm4ge051bWJlcn1cbiovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3kuZ2V0KCk7XG59O1xuXG4vKipcbipcbiogR2V0dGVyIGZvciBaIHBvc2l0aW9uXG4qXG4qIEBtZXRob2RcbiogQHJldHVybiB7TnVtYmVyfVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5nZXRaID0gZnVuY3Rpb24gZ2V0WigpIHtcbiAgICByZXR1cm4gdGhpcy5fei5nZXQoKTtcbn07XG5cbi8qKlxuKlxuKiBHZXR0ZXIgZm9yIGFueSBhY3RpdmUgY29vcmRpbmF0ZXNcbipcbiogQG1ldGhvZFxuKiBAcmV0dXJuIHtCb29sZWFufVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl94LmlzQWN0aXZlKCkgfHwgdGhpcy5feS5pc0FjdGl2ZSgpIHx8IHRoaXMuX3ouaXNBY3RpdmUoKTtcbn07XG5cblBvc2l0aW9uLnByb3RvdHlwZS5fY2hlY2tVcGRhdGUgPSBmdW5jdGlvbiBfY2hlY2tVcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayh0aGlzLl9pZCk7XG4gICAgZWxzZSB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG59O1xuXG5cblBvc2l0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAgIHRoaXMuX25vZGUuc2V0UG9zaXRpb24odGhpcy5feC5nZXQoKSwgdGhpcy5feS5nZXQoKSwgdGhpcy5fei5nZXQoKSk7XG4gICAgdGhpcy5fY2hlY2tVcGRhdGUoKTtcbn07XG5cbi8qKiBcbipcbiogSWYgdHJ1ZSwgY29tcG9uZW50IGlzIHRvIGJlIHVwZGF0ZWQgb24gbmV4dCBlbmdpbmUgdGlja1xuKlxuKiBAbWV0aG9kXG4qL1xuUG9zaXRpb24ucHJvdG90eXBlLm9uVXBkYXRlID0gUG9zaXRpb24ucHJvdG90eXBlLnVwZGF0ZTtcblxuLyoqIFxuKlxuKiBTZXR0ZXIgZm9yIFggcG9zaXRpb25cbipcbiogQG1ldGhvZFxuKiBAcGFyYW0ge051bWJlcn0gdmFsIHVzZWQgdG8gc2V0IHggY29vcmRpbmF0ZVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBzZXR0aW5nIFhcbiogQGNoYWluYWJsZVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5zZXRYID0gZnVuY3Rpb24gc2V0WCh2YWwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3guc2V0KHZhbCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqIFxuKlxuKiBTZXR0ZXIgZm9yIFkgcG9zaXRpb25cbipcbiogQG1ldGhvZFxuKiBAcGFyYW0ge051bWJlcn0gdmFsIHVzZWQgdG8gc2V0IHkgY29vcmRpbmF0ZVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBzZXR0aW5nIFlcbiogQGNoYWluYWJsZVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5zZXRZID0gZnVuY3Rpb24gc2V0WSh2YWwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3kuc2V0KHZhbCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqIFxuKlxuKiBTZXR0ZXIgZm9yIFogcG9zaXRpb25cbipcbiogQG1ldGhvZFxuKiBAcGFyYW0ge051bWJlcn0gdmFsIHVzZWQgdG8gc2V0IHogY29vcmRpbmF0ZVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBzZXR0aW5nIFpcbiogQGNoYWluYWJsZVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5zZXRaID0gZnVuY3Rpb24gc2V0Wih2YWwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3ouc2V0KHZhbCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbipcbiogU2V0dGVyIGZvciBYWVogcG9zaXRpb24gd2l0aCBjYWxsYmFja1xuKlxuKiBAbWV0aG9kXG4qIEBwYXJhbSB7TnVtYmVyfSB4IHVzZWQgdG8gc2V0IHggY29vcmRpbmF0ZVxuKiBAcGFyYW0ge051bWJlcn0geSB1c2VkIHRvIHNldCB5IGNvb3JkaW5hdGVcbiogQHBhcmFtIHtOdW1iZXJ9IHogdXNlZCB0byBzZXQgeiBjb29yZGluYXRlXG4qIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgaGFzaFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHNldHRpbmcgZWFjaCBjb29yZGluYXRlXG4qIEBjaGFpbmFibGVcbiovXG5Qb3NpdGlvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KHgsIHksIHosIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciB4Q2FsbGJhY2s7XG4gICAgdmFyIHlDYWxsYmFjaztcbiAgICB2YXIgekNhbGxiYWNrO1xuXG4gICAgaWYgKHogIT0gbnVsbCkge1xuICAgICAgICB6Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgZWxzZSBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgIHlDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgeENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgaWYgKHggIT0gbnVsbCkgdGhpcy5feC5zZXQoeCwgb3B0aW9ucywgeENhbGxiYWNrKTtcbiAgICBpZiAoeSAhPSBudWxsKSB0aGlzLl95LnNldCh5LCBvcHRpb25zLCB5Q2FsbGJhY2spO1xuICAgIGlmICh6ICE9IG51bGwpIHRoaXMuX3ouc2V0KHosIG9wdGlvbnMsIHpDYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuKlxuKiBTdG9wcyB0cmFuc2l0aW9uIG9mIFBvc2l0aW9uIGNvbXBvbmVudFxuKlxuKiBAbWV0aG9kXG4qIEBjaGFpbmFibGVcbiovXG5Qb3NpdGlvbi5wcm90b3R5cGUuaGFsdCA9IGZ1bmN0aW9uIGhhbHQoKSB7XG4gICAgdGhpcy5feC5oYWx0KCk7XG4gICAgdGhpcy5feS5oYWx0KCk7XG4gICAgdGhpcy5fei5oYWx0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvc2l0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9zaXRpb24gPSByZXF1aXJlKCcuL1Bvc2l0aW9uJyk7XG5cbi8qKlxuICogQGNsYXNzIFJvdGF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjb21wb25lbnRcbiAqIEBwYXJhbSB7TG9jYWxEaXNwYXRjaH0gZGlzcGF0Y2ggTG9jYWxEaXNwYXRjaCB0byBiZSByZXRyaWV2ZWQgZnJvbSBjb3JyZXNwb25kaW5nIFJlbmRlciBOb2RlIG9mIHRoZSBSb3RhdGlvbiBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gUm90YXRpb24obm9kZSkge1xuICAgIFBvc2l0aW9uLmNhbGwodGhpcywgbm9kZSk7XG59XG5cbi8qKlxuKlxuKiBzdHJpbmdpZmllcyBSb3RhdGlvblxuKlxuKiBAbWV0aG9kXG4qIEByZXR1cm4ge1N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIENvbXBvbmVudCBDbGFzczogJ1JvdGF0aW9uJ1xuKi9cblJvdGF0aW9uLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdSb3RhdGlvbic7XG59O1xuXG5Sb3RhdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBvc2l0aW9uLnByb3RvdHlwZSk7XG5Sb3RhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbjtcblxuUm90YXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9ub2RlLnNldFJvdGF0aW9uKHRoaXMuX3guZ2V0KCksIHRoaXMuX3kuZ2V0KCksIHRoaXMuX3ouZ2V0KCkpO1xuICAgIHRoaXMuX2NoZWNrVXBkYXRlKCk7XG59O1xuXG5Sb3RhdGlvbi5wcm90b3R5cGUub25VcGRhdGUgPSBSb3RhdGlvbi5wcm90b3R5cGUudXBkYXRlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9zaXRpb24gPSByZXF1aXJlKCcuL1Bvc2l0aW9uJyk7XG5cbi8qKlxuICogQGNsYXNzIFNjYWxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjb21wb25lbnRcbiAqIEBwYXJhbSB7TG9jYWxEaXNwYXRjaH0gZGlzcGF0Y2ggTG9jYWxEaXNwYXRjaCB0byBiZSByZXRyaWV2ZWQgZnJvbSBjb3JyZXNwb25kaW5nIFJlbmRlciBOb2RlIG9mIHRoZSBTY2FsZSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gU2NhbGUobm9kZSkge1xuICAgIFBvc2l0aW9uLmNhbGwodGhpcywgbm9kZSk7XG4gICAgdGhpcy5feC5zZXQoMSk7XG4gICAgdGhpcy5feS5zZXQoMSk7XG4gICAgdGhpcy5fei5zZXQoMSk7XG59XG5cbi8qKlxuKlxuKiBzdHJpbmdpZmllcyBTY2FsZVxuKlxuKiBAbWV0aG9kIFxuKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBDb21wb25lbnQgQ2xhc3M6ICdTY2FsZSdcbiovXG5TY2FsZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnU2NhbGUnO1xufTtcblxuU2NhbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQb3NpdGlvbi5wcm90b3R5cGUpO1xuU2NhbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NhbGU7XG5cblNjYWxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdGhpcy5fbm9kZS5zZXRTY2FsZSh0aGlzLl94LmdldCgpLCB0aGlzLl95LmdldCgpLCB0aGlzLl96LmdldCgpKTtcbiAgICB0aGlzLl9jaGVja1VwZGF0ZSgpO1xufTtcblxuU2NhbGUucHJvdG90eXBlLm9uVXBkYXRlID0gU2NhbGUucHJvdG90eXBlLnVwZGF0ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2FsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRyYW5zaXRpb25hYmxlID0gcmVxdWlyZSgnZmFtb3VzLXRyYW5zaXRpb25zJykuVHJhbnNpdGlvbmFibGU7XG52YXIgQ29yZVNpemUgPSByZXF1aXJlKCdmYW1vdXMtY29yZScpLlNpemU7XG5cbi8qKlxuICogU2l6ZSBjb21wb25lbnQgdXNlZCBmb3IgbWFuYWdpbmcgdGhlIHNpemUgb2YgdGhlIHVuZGVybHlpbmcgUmVuZGVyQ29udGV4dC5cbiAqIFN1cHBvcnRzIGFic29sdXRlIGFuZCByZWxhdGl2ZSAocHJvcG9ydGlvbmFsIGFuZCBkaWZmZXJlbnRpYWwpIHNpemluZy5cbiAqIFxuICogQGNsYXNzIFNpemVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGNvbXBvbmVudFxuICogXG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IG5vZGUgTG9jYWxEaXNwYXRjaCB0byBiZSByZXRyaWV2ZWQgZnJvbVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kaW5nIFJlbmRlck5vZGUgb2YgdGhlIFNpemVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIFNpemUobm9kZSkge1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIHRoaXMuX2lkID0gbm9kZS5hZGRDb21wb25lbnQodGhpcyk7XG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3Byb3BvcnRpb25hbCA9IHtcbiAgICAgICAgeDogbmV3IFRyYW5zaXRpb25hYmxlKDEpLFxuICAgICAgICB5OiBuZXcgVHJhbnNpdGlvbmFibGUoMSksXG4gICAgICAgIHo6IG5ldyBUcmFuc2l0aW9uYWJsZSgxKVxuICAgIH07XG4gICAgdGhpcy5fZGlmZmVyZW50aWFsID0ge1xuICAgICAgICB4OiBuZXcgVHJhbnNpdGlvbmFibGUoMCksXG4gICAgICAgIHk6IG5ldyBUcmFuc2l0aW9uYWJsZSgwKSxcbiAgICAgICAgejogbmV3IFRyYW5zaXRpb25hYmxlKDApXG4gICAgfTtcbiAgICB0aGlzLl9hYnNvbHV0ZSA9IHtcbiAgICAgICAgeDogbmV3IFRyYW5zaXRpb25hYmxlKDApLFxuICAgICAgICB5OiBuZXcgVHJhbnNpdGlvbmFibGUoMCksXG4gICAgICAgIHo6IG5ldyBUcmFuc2l0aW9uYWJsZSgwKVxuICAgIH07XG59XG5cblNpemUuUkVMQVRJVkUgPSBDb3JlU2l6ZS5SRUxBVElWRTtcblNpemUuQUJTT0xVVEUgPSBDb3JlU2l6ZS5BQlNPTFVURTtcblNpemUuUkVOREVSID0gQ29yZVNpemUuUkVOREVSO1xuU2l6ZS5ERUZBVUxUID0gQ29yZVNpemUuREVGQVVMVDtcblxuU2l6ZS5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uIHNldE1vZGUoeCwgeSwgeikge1xuICAgIHRoaXMuX25vZGUuc2V0U2l6ZU1vZGUoeCwgeSwgeik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogXG4qIFN0cmluZ2lmaWVzIFNpemUuXG4qXG4qIEBtZXRob2QgdG9TdHJpbmdcbiogXG4qIEByZXR1cm4ge1N0cmluZ30gYFNpemVgXG4qL1xuU2l6ZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnU2l6ZSc7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIGFic29sdXRlU2l6ZVN0YXRlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgY3VycmVudCB0eXBlIG9mIHNpemluZyBiZWluZyBhcHBsaWVkICgnYWJzb2x1dGUnKVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGNvbXBvbmVudCBjb21wb25lbnQgbmFtZSAoJ1NpemUnKVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5XG4gKiBAcHJvcGVydHkge251bWJlcn0gelxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgcmVsYXRpdmVTaXplU3RhdGVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZSBjdXJyZW50IHR5cGUgb2Ygc2l6aW5nIGJlaW5nIGFwcGxpZWQgKCdyZWxhdGl2ZScpXG4gKiBAcHJvcGVydHkge1N0cmluZ30gY29tcG9uZW50IGNvbXBvbmVudCBuYW1lICgnU2l6ZScpXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGlmZmVyZW50aWFsXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGlmZmVyZW50aWFsLnhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaWZmZXJlbnRpYWwueVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRpZmZlcmVudGlhbC56XG4gKiBAcHJvcGVydHkge09iamVjdH0gcHJvcG9ydGlvbmFsXG4gKiBAcHJvcGVydHkge251bWJlcn0gcHJvcG9ydGlvbmFsLnhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcm9wb3J0aW9uYWwueVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHByb3BvcnRpb25hbC56XG4gKi9cblxuLyoqXG4qIFJldHVybnMgc2VyaWFsaXplZCBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LlxuKlxuKiBAbWV0aG9kIGdldFN0YXRlXG4qIFxuKiBAcmV0dXJuIHthYnNvbHV0ZVNpemVTdGF0ZXxyZWxhdGl2ZVNpemVTdGF0ZX1cbiovXG5TaXplLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpemVNb2RlOiB0aGlzLl9ub2RlLnZhbHVlLnNpemVNb2RlLFxuICAgICAgICBhYnNvbHV0ZToge1xuICAgICAgICAgICAgeDogdGhpcy5fYWJzb2x1dGUueC5nZXQoKSxcbiAgICAgICAgICAgIHk6IHRoaXMuX2Fic29sdXRlLnkuZ2V0KCksXG4gICAgICAgICAgICB6OiB0aGlzLl9hYnNvbHV0ZS56LmdldCgpXG4gICAgICAgIH0sXG4gICAgICAgIGRpZmZlcmVudGlhbDoge1xuICAgICAgICAgICAgeDogdGhpcy5fZGlmZmVyZW50aWFsLnguZ2V0KCksXG4gICAgICAgICAgICB5OiB0aGlzLl9kaWZmZXJlbnRpYWwueS5nZXQoKSxcbiAgICAgICAgICAgIHo6IHRoaXMuX2RpZmZlcmVudGlhbC56LmdldCgpXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BvcnRpb25hbDoge1xuICAgICAgICAgICAgeDogdGhpcy5fcHJvcG9ydGlvbmFsLnguZ2V0KCksXG4gICAgICAgICAgICB5OiB0aGlzLl9wcm9wb3J0aW9uYWwueS5nZXQoKSxcbiAgICAgICAgICAgIHo6IHRoaXMuX3Byb3BvcnRpb25hbC56LmdldCgpXG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyoqXG4qIFVwZGF0ZXMgc3RhdGUgb2YgY29tcG9uZW50LlxuKlxuKiBAbWV0aG9kIHNldFN0YXRlXG4qIFxuKiBAcGFyYW0ge2Fic29sdXRlU2l6ZVN0YXRlfHJlbGF0aXZlU2l6ZVN0YXRlfSBzdGF0ZSBzdGF0ZSBlbmNvZGVkIGluIHNhbWVcbiogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IGFzIHN0YXRlIHJldHJpZXZlZFxuKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdWdoIGBnZXRTdGF0ZWBcbiogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbiBpbmRpY2F0aW5nXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXRoZXIgdGhlIG5ldyBzdGF0ZSBoYXNcbiogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVlbiBhcHBsaWVkXG4qL1xuU2l6ZS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5jb21wb25lbnQgPT09IHRoaXMuY29uc3RydWN0b3IudG9TdHJpbmcoKSkge1xuICAgICAgICB0aGlzLnNldE1vZGUuYXBwbHkodGhpcywgc3RhdGUuc2l6ZU1vZGUpO1xuICAgICAgICBpZiAoc3RhdGUuYWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWJzb2x1dGUoc3RhdGUuYWJzb2x1dGUueCwgc3RhdGUuYWJzb2x1dGUueSwgc3RhdGUuYWJzb2x1dGUueik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmRpZmZlcmVudGlhbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBYnNvbHV0ZShzdGF0ZS5kaWZmZXJlbnRpYWwueCwgc3RhdGUuZGlmZmVyZW50aWFsLnksIHN0YXRlLmRpZmZlcmVudGlhbC56KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUucHJvcG9ydGlvbmFsKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFic29sdXRlKHN0YXRlLnByb3BvcnRpb25hbC54LCBzdGF0ZS5wcm9wb3J0aW9uYWwueSwgc3RhdGUucHJvcG9ydGlvbmFsLnopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblNpemUucHJvdG90eXBlLl9pc0FjdGl2ZSA9IGZ1bmN0aW9uIF9pc0FjdGl2ZSh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUueC5pc0FjdGl2ZSgpIHx8IHR5cGUueS5pc0FjdGl2ZSgpIHx8IHR5cGUuei5pc0FjdGl2ZSgpO1xufTtcblxuU2l6ZS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpe1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuX2lzQWN0aXZlKHRoaXMuX2Fic29sdXRlKSB8fFxuICAgICAgICB0aGlzLl9pc0FjdGl2ZSh0aGlzLl9wcm9wb3J0aW9uYWwpIHx8XG4gICAgICAgIHRoaXMuX2lzQWN0aXZlKHRoaXMuX2RpZmZlcmVudGlhbClcbiAgICApO1xufTtcblxuU2l6ZS5wcm90b3R5cGUub25VcGRhdGUgPSBmdW5jdGlvbiBvblVwZGF0ZSgpIHtcbiAgICB2YXIgYWJzID0gdGhpcy5fYWJzb2x1dGU7XG4gICAgdGhpcy5fbm9kZS5zZXRBYnNvbHV0ZVNpemUoXG4gICAgICAgIGFicy54LmdldCgpLFxuICAgICAgICBhYnMueS5nZXQoKSxcbiAgICAgICAgYWJzLnouZ2V0KClcbiAgICApO1xuICAgIHZhciBwcm9wID0gdGhpcy5fcHJvcG9ydGlvbmFsO1xuICAgIHZhciBkaWZmID0gdGhpcy5fZGlmZmVyZW50aWFsO1xuICAgIHRoaXMuX25vZGUuc2V0UHJvcG9ydGlvbmFsU2l6ZShcbiAgICAgICAgcHJvcC54LmdldCgpLFxuICAgICAgICBwcm9wLnkuZ2V0KCksXG4gICAgICAgIHByb3Auei5nZXQoKVxuICAgICk7XG4gICAgdGhpcy5fbm9kZS5zZXREaWZmZXJlbnRpYWxTaXplKFxuICAgICAgICBkaWZmLnguZ2V0KCksXG4gICAgICAgIGRpZmYueS5nZXQoKSxcbiAgICAgICAgZGlmZi56LmdldCgpXG4gICAgKTtcblxuICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sodGhpcy5faWQpO1xuICAgIGVsc2UgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuXG4vKipcbiogQXBwbGllcyBhYnNvbHV0ZSBzaXplLlxuKlxuKiBAbWV0aG9kIHNldEFic29sdXRlXG4qIEBjaGFpbmFibGVcbiogXG4qIEBwYXJhbSB7TnVtYmVyfSB4IHVzZWQgdG8gc2V0IGFic29sdXRlIHNpemUgaW4geC1kaXJlY3Rpb24gKHdpZHRoKVxuKiBAcGFyYW0ge051bWJlcn0geSB1c2VkIHRvIHNldCBhYnNvbHV0ZSBzaXplIGluIHktZGlyZWN0aW9uIChoZWlnaHQpXG4qIEBwYXJhbSB7TnVtYmVyfSB6IHVzZWQgdG8gc2V0IGFic29sdXRlIHNpemUgaW4gei1kaXJlY3Rpb24gKGRlcHRoKVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zIGhhdmUgYmVlbiBjb21wbGV0ZWRcbiogQHJldHVybiB7U2l6ZX0gdGhpc1xuKi9cblNpemUucHJvdG90eXBlLnNldEFic29sdXRlID0gZnVuY3Rpb24gc2V0QWJzb2x1dGUoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBhYnMgPSB0aGlzLl9hYnNvbHV0ZTtcbiAgICBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgIGFicy54LnNldCh4LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgYWJzLnkuc2V0KHksIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHogIT0gbnVsbCkge1xuICAgICAgICBhYnMuei5zZXQoeiwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbn07XG5cbi8qKlxuKiBBcHBsaWVzIHByb3BvcnRpb25hbCBzaXplLlxuKlxuKiBAbWV0aG9kIHNldFByb3BvcnRpb25hbFxuKiBAY2hhaW5hYmxlXG4qIFxuKiBAcGFyYW0ge051bWJlcn0geCB1c2VkIHRvIHNldCBwcm9wb3J0aW9uYWwgc2l6ZSBpbiB4LWRpcmVjdGlvbiAod2lkdGgpXG4qIEBwYXJhbSB7TnVtYmVyfSB5IHVzZWQgdG8gc2V0IHByb3BvcnRpb25hbCBzaXplIGluIHktZGlyZWN0aW9uIChoZWlnaHQpXG4qIEBwYXJhbSB7TnVtYmVyfSB6IHVzZWQgdG8gc2V0IHByb3BvcnRpb25hbCBzaXplIGluIHotZGlyZWN0aW9uIChkZXB0aClcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBoYXNoXG4qIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZVxuKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9ucyBoYXZlIGJlZW4gY29tcGxldGVkXG4qIEByZXR1cm4ge1NpemV9IHRoaXNcbiovXG5TaXplLnByb3RvdHlwZS5zZXRQcm9wb3J0aW9uYWwgPSBmdW5jdGlvbiBzZXRQcm9wb3J0aW9uYWwoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBwcm9wID0gdGhpcy5fcHJvcG9ydGlvbmFsO1xuICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcC54LnNldCh4LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcC55LnNldCh5LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh6ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcC56LnNldCh6LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4qIEFwcGxpZXMgZGlmZmVyZW50aWFsIHNpemUgdG8gU2l6ZSBjb21wb25lbnQuXG4qXG4qIEBtZXRob2Qgc2V0RGlmZmVyZW50aWFsXG4qIEBjaGFpbmFibGVcbiogXG4qIEBwYXJhbSB7TnVtYmVyfSB4IHVzZWQgdG8gc2V0IGRpZmZlcmVudGlhbCBzaXplIGluIHgtZGlyZWN0aW9uICh3aWR0aClcbiogQHBhcmFtIHtOdW1iZXJ9IHkgdXNlZCB0byBzZXQgZGlmZmVyZW50aWFsIHNpemUgaW4geS1kaXJlY3Rpb24gKGhlaWdodClcbiogQHBhcmFtIHtOdW1iZXJ9IHogdXNlZCB0byBzZXQgZGlmZmVyZW50aWFsIHNpemUgaW4gei1kaXJlY3Rpb24gKGRlcHRoKVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zIGhhdmUgYmVlbiBjb21wbGV0ZWRcbiovXG5TaXplLnByb3RvdHlwZS5zZXREaWZmZXJlbnRpYWwgPSBmdW5jdGlvbiBzZXREaWZmZXJlbnRpYWwoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBkaWZmID0gdGhpcy5fZGlmZmVyZW50aWFsO1xuICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgZGlmZi54LnNldCh4LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgZGlmZi55LnNldCh5LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh6ICE9IG51bGwpIHtcbiAgICAgICAgZGlmZi56LnNldCh6LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4qIFJldHJpZXZlcyB0aGUgY29tcHV0ZWQgc2l6ZSBhcHBsaWVkIHRvIHRoZSB1bmRlcmx5aW5nIFJlbmRlckNvbnRleHQuXG4qXG4qIEBtZXRob2QgZ2V0XG4qIFxuKiBAcmV0dXJuIHtOdW1iZXJbXX0gc2l6ZSB0aHJlZSBkaW1lbnNpb25hbCBjb21wdXRlZCBzaXplXG4qL1xuU2l6ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5nZXRTaXplKCk7XG59O1xuXG4vKipcbiAqIEhhbHRzIGFsbCBjdXJyZW50bHkgYWN0aXZlIHNpemUgdHJhbnNpdGlvbnMuXG4gKiBcbiAqIEBtZXRob2QgaGFsdFxuICogQGNoYWluYWJsZVxuICogXG4gKiBAcmV0dXJuIHtTaXplfSB0aGlzXG4gKi9cblNpemUucHJvdG90eXBlLmhhbHQgPSBmdW5jdGlvbiBoYWx0ICgpIHtcbiAgICB0aGlzLl9wcm9wb3J0aW9uYWwueC5oYWx0KCk7XG4gICAgdGhpcy5fcHJvcG9ydGlvbmFsLnkuaGFsdCgpO1xuICAgIHRoaXMuX3Byb3BvcnRpb25hbC56LmhhbHQoKTtcbiAgICB0aGlzLl9kaWZmZXJlbnRpYWwueC5oYWx0KCk7XG4gICAgdGhpcy5fZGlmZmVyZW50aWFsLnkuaGFsdCgpO1xuICAgIHRoaXMuX2RpZmZlcmVudGlhbC56LmhhbHQoKTtcbiAgICB0aGlzLl9hYnNvbHV0ZS54LmhhbHQoKTtcbiAgICB0aGlzLl9hYnNvbHV0ZS55LmhhbHQoKTtcbiAgICB0aGlzLl9hYnNvbHV0ZS56LmhhbHQoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2l6ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbGxiYWNrU3RvcmUgPSByZXF1aXJlKCdmYW1vdXMtdXRpbGl0aWVzJykuQ2FsbGJhY2tTdG9yZTtcblxuLyoqXG4gKiBDb21wb25lbnQgdG8gbWFuYWdlIERPTSBldmVudHMuIFdoZW4gcmVnaXN0ZXJpbmcgYW4gZXZlbnQsIHRoZSB1c2VyIG1heSBzcGVjaWZ5IC5tZXRob2RzIGFuZFxuICogLnByb3BlcnRpZXMgdG8gcHJlcHJvY2VzcyB0aGUgZXZlbnQgb2JqZWN0LlxuICpcbiAqIEBjbGFzcyBVSUV2ZW50SGFuZGxlclxuICogQHBhcmFtIHtMb2NhbERpc3BhdGNofSBkaXNwYXRjaCBUaGUgZGlzcGF0Y2ggd2l0aCB3aGljaCB0byByZWdpc3RlciB0aGUgaGFuZGxlci5cbiAqIEBwYXJhbSB7T2JqZWN0W119IGV2ZW50cyBBbiBhcnJheSBvZiBldmVudCBvYmplY3RzIHNwZWNpZnlpbmcgLmV2ZW50IGFuZCAuY2FsbGJhY2sgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gVUlFdmVudEhhbmRsZXIgKGRpc3BhdGNoLCBldmVudHMpIHtcbiAgICB0aGlzLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IENhbGxiYWNrU3RvcmUoKTtcblxuICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5vbihldmVudHNbaV0sIGV2ZW50c1tpXS5jYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBVSUV2ZW50SGFuZGxlciBhcyBhIHN0cmluZy5cbiAqXG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKiBAc3RhdGljXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICdVSUV2ZW50SGFuZGxlcidcbiAqL1xuVUlFdmVudEhhbmRsZXIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1VJRXZlbnRIYW5kbGVyJztcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGFuIGV2ZW50LlxuICpcbiAqIEBtZXRob2Qgb25cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZXYgVGhlIGV2ZW50IG9iamVjdCBvciBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgVGhlIGNhbGxiYWNrLlxuICovXG5VSUV2ZW50SGFuZGxlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldiwgY2IpIHtcbiAgICB2YXIgcmVuZGVyYWJsZXMgPSB0aGlzLmRpc3BhdGNoLmdldFJlbmRlcmFibGVzKCk7XG4gICAgdmFyIGV2ZW50TmFtZSA9IGV2LmV2ZW50IHx8IGV2O1xuICAgIHZhciBtZXRob2RzID0gZXYubWV0aG9kcztcbiAgICB2YXIgcHJvcGVydGllcyA9IGV2LnByb3BlcnRpZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlbmRlcmFibGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChyZW5kZXJhYmxlc1tpXS5vbikgcmVuZGVyYWJsZXNbaV0ub24oZXZlbnROYW1lLCBtZXRob2RzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRzLm9uKGV2ZW50TmFtZSwgY2IpO1xuICAgIHRoaXMuZGlzcGF0Y2gucmVnaXN0ZXJUYXJnZXRlZEV2ZW50KGV2ZW50TmFtZSwgdGhpcy50cmlnZ2VyLmJpbmQodGhpcywgZXZlbnROYW1lKSk7XG59O1xuXG4vKipcbiAqIERlcmVnaXN0ZXIgYSBjYWxsYmFjayBmcm9tIGFuIGV2ZW50LlxuICpcbiAqIEBtZXRob2Qgb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBldiBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIFRoZSBjYWxsYmFjay5cbiAqL1xuVUlFdmVudEhhbmRsZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZihldiwgY2IpIHtcbiAgICB0aGlzLl9ldmVudHMub2ZmKGV2LCBjYik7XG4gICAgdGhpcy5kaXNwYXRjaC5kZXJlZ2lzdGVyR2xvYmFsRXZlbnQoZXYsIHRoaXMudHJpZ2dlci5iaW5kKHRoaXMsIGV2KSlcbn07XG5cbi8qKlxuICogVHJpZ2dlciB0aGUgY2FsbGJhY2sgYXNzb2NpYXRlZCB3aXRoIGFuIGV2ZW50LCBwYXNzaW5nIGluIGEgcGF5bG9hZC5cbiAqXG4gKiBAbWV0aG9kIHRyaWdnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldiBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIFRoZSBldmVudCBwYXlsb2FkLlxuICovXG5VSUV2ZW50SGFuZGxlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIgKGV2LCBwYXlsb2FkKSB7XG4gICAgdGhpcy5fZXZlbnRzLnRyaWdnZXIoZXYsIHBheWxvYWQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVSUV2ZW50SGFuZGxlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQWxpZ246IHJlcXVpcmUoJy4vQWxpZ24nKSxcbiAgICBDYW1lcmE6IHJlcXVpcmUoJy4vQ2FtZXJhJyksXG4gICAgRXZlbnRFbWl0dGVyOiByZXF1aXJlKCcuL0V2ZW50RW1pdHRlcicpLFxuICAgIEV2ZW50SGFuZGxlcjogcmVxdWlyZSgnLi9FdmVudEhhbmRsZXInKSxcbiAgICBHZXN0dXJlSGFuZGxlcjogcmVxdWlyZSgnLi9HZXN0dXJlSGFuZGxlcicpLFxuICAgIFVJRXZlbnRIYW5kbGVyOiByZXF1aXJlKCcuL1VJRXZlbnRIYW5kbGVyJyksXG4gICAgTW91bnRQb2ludDogcmVxdWlyZSgnLi9Nb3VudFBvaW50JyksXG4gICAgT3BhY2l0eTogcmVxdWlyZSgnLi9PcGFjaXR5JyksXG4gICAgT3JpZ2luOiByZXF1aXJlKCcuL09yaWdpbicpLFxuICAgIFBvc2l0aW9uOiByZXF1aXJlKCcuL1Bvc2l0aW9uJyksXG4gICAgUm90YXRpb246IHJlcXVpcmUoJy4vUm90YXRpb24nKSxcbiAgICBTY2FsZTogcmVxdWlyZSgnLi9TY2FsZScpLFxuICAgIFNpemU6IHJlcXVpcmUoJy4vU2l6ZScpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEVxdWl2YWxlbnQgb2YgYW4gRW5naW5lIGluIHRoZSBXb3JrZXIgVGhyZWFkLiBVc2VkIHRvIHN5bmNocm9uaXplIGFuZCBtYW5hZ2VcbiAqIHRpbWUgYWNyb3NzIGRpZmZlcmVudCBUaHJlYWRzLlxuICpcbiAqIEBjbGFzcyAgQ2xvY2tcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ2xvY2sgKCkge1xuICAgIHRoaXMuX3RpbWUgPSAwO1xuICAgIHRoaXMuX2ZyYW1lID0gMDtcbiAgICB0aGlzLl90aW1lclF1ZXVlID0gW107XG4gICAgdGhpcy5fdXBkYXRpbmdJbmRleCA9IDA7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgY2xvY2sgdGltZS5cbiAqXG4gKiBAbWV0aG9kICBzdGVwXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSAge051bWJlcn0gdGltZSBoaWdoIHJlc29sdXRpb24gdGltc3RhbXAgdXNlZCBmb3IgaW52b2tpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYHVwZGF0ZWAgbWV0aG9kIG9uIGFsbCByZWdpc3RlcmVkIG9iamVjdHNcbiAqIEByZXR1cm4ge0Nsb2NrfSAgICAgICB0aGlzXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gc3RlcCAodGltZSkge1xuICAgIHRoaXMuX2ZyYW1lKys7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90aW1lclF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl90aW1lclF1ZXVlW2ldKHRoaXMuX3RpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lclF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW50ZXJuYWwgY2xvY2sgdGltZS5cbiAqXG4gKiBAbWV0aG9kICBnZXRUaW1lXG4gKiBAZGVwcmVjYXRlZCBVc2UgI25vdyBpbnN0ZWFkXG4gKiBcbiAqIEBwYXJhbSAge051bWJlcn0gdGltZSBoaWdoIHJlc29sdXRpb24gdGltc3RhbXAgdXNlZCBmb3IgaW52b2tpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYHVwZGF0ZWAgbWV0aG9kIG9uIGFsbCByZWdpc3RlcmVkIG9iamVjdHNcbiAqL1xuQ2xvY2sucHJvdG90eXBlLmdldFRpbWUgPSBmdW5jdGlvbiBnZXRUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnRlcm5hbCBjbG9jayB0aW1lLlxuICpcbiAqIEBtZXRob2QgIG5vd1xuICogXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgaGlnaCByZXNvbHV0aW9uIHRpbXN0YW1wIHVzZWQgZm9yIGludm9raW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgIGB1cGRhdGVgIG1ldGhvZCBvbiBhbGwgcmVnaXN0ZXJlZCBvYmplY3RzXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5ub3cgPSBmdW5jdGlvbiBub3cgKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZnJhbWVzIGVsYXBzZWQgc28gZmFyLlxuICpcbiAqIEBtZXRob2QgZ2V0RnJhbWVcbiAqIFxuICogQHJldHVybiB7TnVtYmVyfSBmcmFtZXNcbiAqL1xuQ2xvY2sucHJvdG90eXBlLmdldEZyYW1lID0gZnVuY3Rpb24gZ2V0RnJhbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9mcmFtZTtcbn07XG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIGEgY2VydGFpbiBhbW91bnQgb2YgdGltZS5cbiAqIEFmdGVyIGEgc2V0IGR1cmF0aW9uIGhhcyBwYXNzZWQsIGl0IGV4ZWN1dGVzIHRoZSBmdW5jdGlvbiBhbmRcbiAqIHJlbW92ZXMgaXQgYXMgYSBsaXN0ZW5lciB0byAncHJlcmVuZGVyJy5cbiAqXG4gKiBAbWV0aG9kIHNldFRpbWVvdXRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBydW4gYWZ0ZXIgYSBzcGVjaWZpZWQgZHVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSBtaWxsaXNlY29uZHMgZnJvbSBub3cgdG8gZXhlY3V0ZSB0aGUgZnVuY3Rpb25cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGltZXIgZnVuY3Rpb24gdXNlZCBmb3IgQ2xvY2sjY2xlYXJUaW1lclxuICovXG5DbG9jay5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVsYXkpIHtcbiAgICB2YXIgcGFyYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgc3RhcnRlZEF0ID0gdGhpcy5fdGltZTtcbiAgICB2YXIgdGltZXIgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgIGlmICh0aW1lIC0gc3RhcnRlZEF0ID49IGRlbGF5KSB7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBwYXJhbXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy5fdGltZXJRdWV1ZS5wdXNoKHRpbWVyKTtcbiAgICByZXR1cm4gdGltZXI7XG59O1xuXG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIGEgY2VydGFpbiBhbW91bnQgb2YgdGltZS5cbiAqICBBZnRlciBhIHNldCBkdXJhdGlvbiBoYXMgcGFzc2VkLCBpdCBleGVjdXRlcyB0aGUgZnVuY3Rpb24gYW5kXG4gKiAgcmVzZXRzIHRoZSBleGVjdXRpb24gdGltZS5cbiAqXG4gKiBAbWV0aG9kIHNldEludGVydmFsXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgcnVuIGFmdGVyIGEgc3BlY2lmaWVkIGR1cmF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gaW50ZXJ2YWwgdG8gZXhlY3V0ZSBmdW5jdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGltZXIgZnVuY3Rpb24gdXNlZCBmb3IgQ2xvY2sjY2xlYXJUaW1lclxuICovXG5DbG9jay5wcm90b3R5cGUuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiBzZXRJbnRlcnZhbChjYWxsYmFjaywgZGVsYXkpIHtcbiAgICB2YXIgcGFyYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgc3RhcnRlZEF0ID0gdGhpcy5fdGltZTtcbiAgICB2YXIgdGltZXIgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgIGlmICh0aW1lIC0gc3RhcnRlZEF0ID49IGRlbGF5KSB7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBwYXJhbXMpO1xuICAgICAgICAgICAgc3RhcnRlZEF0ID0gdGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLl90aW1lclF1ZXVlLnB1c2godGltZXIpO1xuICAgIHJldHVybiB0aW1lcjtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBwcmV2aW91c2x5IHZpYSBgQ2xvY2sjc2V0VGltZW91dGAgb3IgYENsb2NrI3NldEludGVydmFsYFxuICogcmVnaXN0ZXJlZCBjYWxsYmFjayBmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgY2xlYXJUaW1lclxuICogQGNoYWluYWJsZVxuICogXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgIHByZXZpb3VzbHkgYnkgYENsb2NrI3NldFRpbWVvdXRgIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBDbG9jayNzZXRJbnRlcnZhbGAgcmV0dXJuZWQgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm4ge0Nsb2NrfSAgICAgICAgICAgICAgdGhpc1xuICovXG5DbG9jay5wcm90b3R5cGUuY2xlYXJUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX3RpbWVyUXVldWUuaW5kZXhPZih0aW1lcik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl90aW1lclF1ZXVlLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lLlxuICogIEFmdGVyIGEgc2V0IGR1cmF0aW9uIGhhcyBwYXNzZWQsIGl0IGV4ZWN1dGVzIHRoZSBmdW5jdGlvbiBhbmRcbiAqICByZXNldHMgdGhlIGV4ZWN1dGlvbiB0aW1lLlxuICpcbiAqIEBtZXRob2Qgc2V0SW50ZXJ2YWxcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBydW4gYWZ0ZXIgYSBzcGVjaWZpZWQgZHVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBpbnRlcnZhbCB0byBleGVjdXRlIGZ1bmN0aW9uIGluIG1pbGxpc2Vjb25kc1xuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBkZWNvcmF0ZWQgcGFzc2VkIGluIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIHNldEludGVydmFsKGNhbGxiYWNrLCBkZWxheSkge1xuICAgIHZhciBwYXJhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBzdGFydGVkQXQgPSB0aGlzLl90aW1lO1xuXG4gICAgdmFyIGxvb3BlciA9IHtcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKHRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aW1lIC0gc3RhcnRlZEF0ID49IGRlbGF5KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBzdGFydGVkQXQgPSB0aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjYWxsYmFjay5fX2xvb3BlciA9IGxvb3BlcjtcbiAgICB0aGlzLnVwZGF0ZShsb29wZXIpO1xuICAgIHJldHVybiBjYWxsYmFjaztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDbG9jaztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERpc3BhdGNoID0gcmVxdWlyZSgnLi9EaXNwYXRjaGVyJyk7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xudmFyIFNpemUgPSByZXF1aXJlKCcuL1NpemUnKTtcblxuLyoqXG4gKiBDb250ZXh0IGlzIHRoZSBib3R0b20gb2YgdGhlIHNjZW5lIGdyYXBoLiBJdCBpcyBpdCdzIG93blxuICogcGFyZW50IGFuZCBwcm92aWRlcyB0aGUgZ2xvYmFsIHVwZGF0ZXIgdG8gdGhlIHNjZW5lIGdyYXBoLlxuICpcbiAqIEBjbGFzcyBDb250ZXh0XG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgYSBzdHJpbmcgd2hpY2ggaXMgYSBkb20gc2VsZWN0b3JcbiAqICAgICAgICAgICAgICAgICBzaWduaWZ5aW5nIHdoaWNoIGRvbSBlbGVtZW50IHRoZSBjb250ZXh0XG4gKiAgICAgICAgICAgICAgICAgc2hvdWxkIGJlIHNldCB1cG9uXG4gKiBAcGFyYW0ge0ZhbW91c30gYSBjbGFzcyB3aGljaCBjb25mb3JtcyB0byBGYW1vdXMnIGludGVyZmFjZVxuICogICAgICAgICAgICAgICAgIGl0IG5lZWRzIHRvIGJlIGFibGUgdG8gc2VuZCBtZXRob2RzIHRvXG4gKiAgICAgICAgICAgICAgICAgdGhlIHJlbmRlcmVycyBhbmQgdXBkYXRlIG5vZGVzIGluIHRoZSBzY2VuZSBncmFwaFxuICovXG5mdW5jdGlvbiBDb250ZXh0IChzZWxlY3RvciwgdXBkYXRlcikge1xuICAgIGlmICghc2VsZWN0b3IpIHRocm93IG5ldyBFcnJvcignQ29udGV4dCBuZWVkcyB0byBiZSBjcmVhdGVkIHdpdGggYSBET00gc2VsZWN0b3InKTtcbiAgICBpZiAoIXVwZGF0ZXIpIHRocm93IG5ldyBFcnJvcignQ29udGV4dCBuZWVkcyB0byBiZSBjcmVhdGVkIHdpdGggYSBjbGFzcyBsaWtlIEZhbW91cycpO1xuXG4gICAgTm9kZS5jYWxsKHRoaXMpOyAgICAgICAgIC8vIENvbnRleHQgaW5oZXJpdHMgZnJvbSBub2RlXG5cbiAgICB0aGlzLl91cGRhdGVyID0gdXBkYXRlcjsgLy8gVGhlIHVwZGF0ZXIgdGhhdCB3aWxsIGJvdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCBtZXNzYWdlcyB0byB0aGUgcmVuZGVyZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB1cGRhdGUgZGlydHkgbm9kZXMgXG5cbiAgICB0aGlzLl9kaXNwYXRjaCA9IG5ldyBEaXNwYXRjaCh0aGlzKTsgLy8gaW5zdGFudGlhdGVzIGEgZGlzcGF0Y2hlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBzZW5kIGV2ZW50cyB0byB0aGUgc2NlbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JhcGggYmVsb3cgdGhpcyBjb250ZXh0XG4gICAgXG4gICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjsgLy8gcmVmZXJlbmNlIHRvIHRoZSBET00gc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHJlcHJlc2VudHMgdGhlIGVsZW1uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIGRvbSB0aGF0IHRoaXMgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluaGFiaXRzXG5cbiAgICB0aGlzLm9uTW91bnQodGhpcywgc2VsZWN0b3IpOyAvLyBNb3VudCB0aGUgY29udGV4dCB0byBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoaXQgaXMgaXRzIG93biBwYXJlbnQpXG4gICAgXG4gICAgdGhpcy5fdXBkYXRlciAgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgYSByZXF1ZXN0IGZvciB0aGUgZG9tXG4gICAgICAgIC5tZXNzYWdlKCdORUVEX1NJWkVfRk9SJykgIC8vIHNpemUgb2YgdGhlIGNvbnRleHQgc28gdGhhdFxuICAgICAgICAubWVzc2FnZShzZWxlY3Rvcik7ICAgICAgICAvLyB0aGUgc2NlbmUgZ3JhcGggaGFzIGEgdG90YWwgc2l6ZVxuXG4gICAgdGhpcy5zaG93KCk7IC8vIHRoZSBjb250ZXh0IGJlZ2lucyBzaG93biAoaXQncyBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIGRvbSlcblxufVxuXG4vLyBDb250ZXh0IGluaGVyaXRzIGZyb20gbm9kZVxuQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlKTtcbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udGV4dDtcblxuLyoqXG4gKiBDb250ZXh0IGdldFVwZGF0ZXIgZnVuY3Rpb24gcmV0dXJucyB0aGUgcGFzc2VkIGluIHVwZGF0ZXJcbiAqXG4gKiBAcmV0dXJuIHtGYW1vdXN9IHRoZSB1cGRhdGVyIGZvciB0aGlzIENvbnRleHRcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuZ2V0VXBkYXRlciA9IGZ1bmN0aW9uIGdldFVwZGF0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl91cGRhdGVyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZWxlY3RvciB0aGF0IHRoZSBjb250ZXh0IHdhcyBpbnN0YW50aWF0ZWQgd2l0aFxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gZG9tIHNlbGVjdG9yXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLmdldFNlbGVjdG9yID0gZnVuY3Rpb24gZ2V0U2VsZWN0b3IgKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rvcjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGlzcGF0Y2hlciBvZiB0aGUgY29udGV4dC4gVXNlZCB0byBzZW5kIGV2ZW50c1xuICogdG8gdGhlIG5vZGVzIGluIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAcmV0dXJuIHtEaXNwYXRjaGVyfSB0aGUgQ29udGV4dCdzIERpc3BhdGNoZXJcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuZ2V0RGlzcGF0Y2ggPSBmdW5jdGlvbiBnZXREaXNwYXRjaCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoO1xufTtcblxuLyoqXG4gKiBSZWNlaXZlcyBhbiBldmVudC4gSWYgdGhlIGV2ZW50IGlzICdDT05URVhUX1JFU0laRScgaXQgc2V0cyB0aGUgc2l6ZSBvZiB0aGUgc2NlbmVcbiAqIGdyYXBoIHRvIHRoZSBwYXlsb2FkLCB3aGljaCBtdXN0IGJlIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYXQgbGVhc3RcbiAqIGxlbmd0aCB0aHJlZSByZXByZXNlbnRpbmcgdGhlIHBpeGVsIHNpemUgaW4gMyBkaW1lbnNpb25zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHsqfSBwYXlsb2FkXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLm9uUmVjZWl2ZSA9IGZ1bmN0aW9uIG9uUmVjZWl2ZSAoZXZlbnQsIHBheWxvYWQpIHtcbiAgICAvLyBUT0RPOiBJbiB0aGUgZnV0dXJlIHRoZSBkb20gZWxlbWVudCB0aGF0IHRoZSBjb250ZXh0IGlzIGF0dGFjaGVkIHRvXG4gICAgLy8gc2hvdWxkIGhhdmUgYSByZXByZXNlbnRhdGlvbiBhcyBhIGNvbXBvbmVudC4gSXQgd291bGQgYmUgcmVuZGVyIHNpemVkXG4gICAgLy8gYW5kIHRoZSBjb250ZXh0IHdvdWxkIHJlY2VpdmUgaXRzIHNpemUgdGhlIHNhbWUgd2F5IHRoYXQgYW55IHJlbmRlciBzaXplXG4gICAgLy8gY29tcG9uZW50IHJlY2VpdmVzIGl0cyBzaXplLlxuICAgIGlmIChldmVudCA9PT0gJ0NPTlRFWFRfUkVTSVpFJykge1xuICAgICAgICBcbiAgICAgICAgaWYgKHBheWxvYWQubGVuZ3RoIDwgMikgXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdDT05URVhUX1JFU0laRVxcJ3MgcGF5bG9hZCBuZWVkcyB0byBiZSBhdCBsZWFzdCBhIHBhaXInICtcbiAgICAgICAgICAgICAgICAgICAgJyBvZiBwaXhlbCBzaXplcydcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5zZXRTaXplTW9kZShTaXplLkFCU09MVVRFLCBTaXplLkFCU09MVVRFLCBTaXplLkFCU09MVVRFKTtcbiAgICAgICAgdGhpcy5zZXRBYnNvbHV0ZVNpemUocGF5bG9hZFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsyXSA/IHBheWxvYWRbMl0gOiAwKTtcblxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGV4dDtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOiBEaXNwYXRjaGVyIHNob3VsZCBiZSBnZW5lcmFsaXplZCBzbyB0aGF0IGl0IGNhbiB3b3JrIG9uIGFueSBOb2RlXG4vLyBub3QganVzdCBDb250ZXh0cy5cblxuXG4vKipcbiAqIFRoZSBEaXNwYXRjaGVyIGNsYXNzIGlzIHVzZWQgdG8gcHJvcG9nYXRlIGV2ZW50cyBkb3duIHRoZVxuICogc2NlbmUgZ3JhcGguXG4gKlxuICogQHBhcmFtIHtDb250ZXh0fSBDb250ZXh0IG9uIHdoaWNoIGl0IG9wZXJhdGVzXG4gKi9cbmZ1bmN0aW9uIERpc3BhdGNoZXIgKGNvbnRleHQpIHtcblxuICAgIGlmICghY29udGV4dCkgdGhyb3cgbmV3IEVycm9yKCdEaXNwYXRjaCBuZWVkcyB0byBiZSBpbnN0YW50aWF0ZWQgb24gYSBub2RlJyk7XG4gICAgXG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7IC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIHdoaWNoIHRoZSBkaXNwYXRjaGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wZXJhdGVzXG5cbiAgICB0aGlzLl9xdWV1ZSA9IFtdOyAvLyBUaGUgcXVldWUgaXMgdXNlZCBmb3IgdHdvIHB1cnBvc2VzXG4gICAgICAgICAgICAgICAgICAgICAgLy8gMS4gSXQgaXMgdXNlZCB0byBsaXN0IGluZGljaWVzIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vICAgIE5vZGVzIHBhdGggd2hpY2ggYXJlIHRoZW4gdXNlZCB0byBsb29rdXBcbiAgICAgICAgICAgICAgICAgICAgICAvLyAgICBhIG5vZGUgaW4gdGhlIHNjZW5lIGdyYXBoLlxuICAgICAgICAgICAgICAgICAgICAgIC8vIDIuIEl0IGlzIHVzZWQgdG8gYXNzaXN0IGRpc3BhdGNoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gICAgc3VjaCB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGRvIGEgYnJlYWR0aCBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgIC8vICAgIHRyYXZlcnNhbCBvZiB0aGUgc2NlbmUgZ3JhcGguXG59XG5cbi8qKlxuICogbG9va3VwTm9kZSB0YWtlcyBhIHBhdGggYW5kIHJldHVybnMgdGhlIG5vZGUgYXQgdGhlIGxvY2F0aW9uIHNwZWNpZmllZFxuICogYnkgdGhlIHBhdGgsIGlmIG9uZSBleGlzdHMuIElmIG5vdCwgaXQgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFRoZSBsb2NhdGlvbiBvZiB0aGUgbm9kZSBzcGVjaWZpZWQgYnkgaXRzIHBhdGhcbiAqIFxuICogQHJldHVybiB7Tm9kZSB8IHVuZGVmaW5lZH0gVGhlIG5vZGUgYXQgdGhlIHJlcXVlc3RlZCBwYXRoXG4gKi9cbkRpc3BhdGNoZXIucHJvdG90eXBlLmxvb2t1cE5vZGUgPSBmdW5jdGlvbiBsb29rdXBOb2RlIChsb2NhdGlvbikge1xuICAgIGlmICghbG9jYXRpb24pIHRocm93IG5ldyBFcnJvcignbG9va3VwTm9kZSBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgcGF0aCcpO1xuXG4gICAgdmFyIHBhdGggPSB0aGlzLl9xdWV1ZTtcblxuICAgIF9zcGxpdFRvKGxvY2F0aW9uLCBwYXRoKTtcbiAgICBcbiAgICBpZiAocGF0aFswXSAhPT0gdGhpcy5fY29udGV4dC5nZXRTZWxlY3RvcigpKSByZXR1cm4gdm9pZCAwO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY29udGV4dC5nZXRDaGlsZHJlbigpO1xuICAgIHZhciBjaGlsZDtcbiAgICB2YXIgaSA9IDE7XG4gICAgcGF0aFswXSA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICB3aGlsZSAoaSA8IHBhdGgubGVuZ3RoKSB7XG4gICAgICAgIGNoaWxkID0gY2hpbGRyZW5bcGF0aFtpXV07XG4gICAgICAgIHBhdGhbaV0gPSBjaGlsZDtcbiAgICAgICAgaWYgKGNoaWxkKSBjaGlsZHJlbiA9IGNoaWxkLmdldENoaWxkcmVuKCk7XG4gICAgICAgIGVsc2UgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZDtcbn07XG5cbi8qKlxuICogZGlzcGF0Y2ggdGFrZXMgYW4gZXZlbnQgbmFtZSBhbmQgYSBwYXlsb2FkIGFuZCBkaXNwYXRjaGVzIGl0IHRvIHRoZVxuICogZW50aXJlIHNjZW5lIGdyYXBoIGJlbG93IHRoZSBub2RlIHRoYXQgdGhlIGRpc3BhdGNoZXIgaXMgb24uIFRoZSBub2Rlc1xuICogcmVjZWl2ZSB0aGUgZXZlbnRzIGluIGEgYnJlYWR0aCBmaXJzdCB0cmF2ZXJzYWwsIG1lYW5pbmcgdGhhdCBwYXJlbnRzXG4gKiBoYXZlIHRoZSBvcHBvcnR1bml0eSB0byByZWFjdCB0byB0aGUgZXZlbnQgYmVmb3JlIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge0FueX0gcGF5bG9hZFxuICovXG5EaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoIChldmVudCwgcGF5bG9hZCkge1xuICAgIGlmICghZXZlbnQpIHRocm93IG5ldyBFcnJvcignZGlzcGF0Y2ggcmVxdWlyZXMgYW4gZXZlbnQgbmFtZSBhcyBpdFxcJ3MgZmlyc3QgYXJndW1lbnQnKTtcblxuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBpdGVtO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGNoaWxkcmVuO1xuXG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBxdWV1ZS5wdXNoKHRoaXMuX2NvbnRleHQpO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBpdGVtID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKGl0ZW0ub25SZWNlaXZlKSBpdGVtLm9uUmVjZWl2ZShldmVudCwgcGF5bG9hZCk7XG4gICAgICAgIGNoaWxkcmVuID0gaXRlbS5nZXRDaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSBxdWV1ZS5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIGRpc3BhdGNoVUlldmVudCB0YWtlcyBhIHBhdGgsIGFuIGV2ZW50IG5hbWUsIGFuZCBhIHBheWxvYWQgYW5kIGRpc3BhdGNoZXMgdGhlbSBpblxuICogYSBtYW5uZXIgYW5vbG9nb3VzIHRvIERPTSBidWJibGluZy4gSXQgZmlyc3QgdHJhdmVyc2VzIGRvd24gdG8gdGhlIG5vZGUgc3BlY2lmaWVkIGF0XG4gKiB0aGUgcGF0aC4gVGhhdCBub2RlIHJlY2VpdmVzIHRoZSBldmVudCBmaXJzdCwgYW5kIHRoZW4gZXZlcnkgYW5jZXN0b3IgcmVjZWl2ZXMgdGhlIGV2ZW50XG4gKiB1bnRpbCB0aGUgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGhlIHBhdGggb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aGUgZXZlbnQgbmFtZVxuICogQHBhcmFtIHtBbnl9IHRoZSBwYXlsb2FkXG4gKi9cbkRpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoVUlFdmVudCA9IGZ1bmN0aW9uIGRpc3BhdGNoVUlFdmVudCAocGF0aCwgZXZlbnQsIHBheWxvYWQpIHtcbiAgICBpZiAoIXBhdGgpIHRocm93IG5ldyBFcnJvcignZGlzcGF0Y2hVSUV2ZW50IG5lZWRzIGEgdmFsaWQgcGF0aCB0byBkaXNwYXRjaCB0bycpO1xuICAgIGlmICghZXZlbnQpIHRocm93IG5ldyBFcnJvcignZGlzcGF0Y2hVSUV2ZW50IG5lZWRzIGFuIGV2ZW50IG5hbWUgYXMgaXRzIHNlY29uZCBhcmd1bWVudCcpO1xuXG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBwYXlsb2FkLm5vZGUgPSB0aGlzLmxvb2t1cE5vZGUocGF0aCk7IC8vIEFmdGVyIHRoaXMgY2FsbCwgdGhlIHBhdGggaXMgbG9hZGVkIGludG8gdGhlIHF1ZXVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAobG9va1VwIG5vZGUgZG9lc24ndCBjbGVhciB0aGUgcXVldWUgYWZ0ZXIgdGhlIGxvb2t1cClcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgbm9kZSA9IHF1ZXVlLnBvcCgpOyAvLyBwb3Agbm9kZXMgb2ZmIG9mIHRoZSBxdWV1ZSB0byBtb3ZlIHVwIHRoZSBhbmNlc3RvciBjaGFpbi5cbiAgICAgICAgaWYgKG5vZGUub25SZWNlaXZlKSBub2RlLm9uUmVjZWl2ZShldmVudCwgcGF5bG9hZCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBfc3BsaXRUbyBpcyBhIHByaXZhdGUgbWV0aG9kIHdoaWNoIHRha2VzIGEgcGF0aCBhbmQgc3BsaXRzIGl0IGF0IGV2ZXJ5ICcvJ1xuICogcHVzaGluZyB0aGUgcmVzdWx0IGludG8gdGhlIHN1cHBsaWVkIGFycmF5LiBUaGlzIGlzIGEgZGVzdHJ1Y3RpdmUgY2hhbmdlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdGhlIHNwZWNpZmllZCBwYXRoXG4gKiBAcGFyYW0ge0FycmF5fSB0aGUgYXJyYXkgdG8gd2hpY2ggdGhlIHJlc3VsdCBzaG91bGQgYmUgd3JpdHRlblxuICovXG5mdW5jdGlvbiBfc3BsaXRUbyAoc3RyaW5nLCB0YXJnZXQpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gMDsgLy8gY2xlYXJzIHRoZSBhcnJheSBmaXJzdC5cbiAgICB2YXIgbGFzdCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cmluZ1tpXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChzdHJpbmcuc3Vic3RyaW5nKGxhc3QsIGkpKTtcbiAgICAgICAgICAgIGxhc3QgPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpIC0gbGFzdCA+IDApIHRhcmdldC5wdXNoKHN0cmluZy5zdWJzdHJpbmcobGFzdCwgaSkpO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXI7XG5cbiIsIi8vIFRPRE86IFRoaXMgd2lsbCB3cmFwIFVJIGV2ZW50cyBhcyB0aGUgYnViYmxlIGluIHRoZSBzY2VuZSBncmFwaCB0byBhbGxvdyAuc3RvcFByb3BvZ2F0aW9uKCkgdG8gYmUgY2FsbGVkXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIENoZWNrIHRvIHNlZSBpZiB3ZSdyZSBpbiBhIHdvcmtlclxudmFyIGlzV29ya2VyID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYud2luZG93ICE9PSBzZWxmO1xuXG52YXIgQ2xvY2sgPSByZXF1aXJlKCcuL0Nsb2NrJyk7XG52YXIgQ29udGV4dCA9IHJlcXVpcmUoJy4vQ29udGV4dCcpO1xuXG4vKipcbiAqIEZhbW91cyBoYXMgdHdvIHJlc3BvbnNpYmlsaXRpZXMsIG9uZSB0byBhY3QgYXMgdGhlIGhpZ2hlc3QgbGV2ZWxcbiAqIHVwZGF0ZXIgYW5kIGFub3RoZXIgdG8gc2VuZCBtZXNzYWdlcyBvdmVyIHRvIHRoZSByZW5kZXJlcnMuIEl0IGlzXG4gKiBhIHNpbmdsZXRvbi5cbiAqL1xuZnVuY3Rpb24gRmFtb3VzICgpIHtcbiAgICB0aGlzLl91cGRhdGVRdWV1ZSA9IFtdOyAvLyBUaGUgdXBkYXRlUXVldWUgaXMgYSBwbGFjZSB3aGVyZSBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBwbGFjZSB0aGVtc2VsdmVzIGluIG9yZGVyIHRvIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlZCBvbiB0aGUgZnJhbWUuXG4gICAgXG4gICAgdGhpcy5fbmV4dFVwZGF0ZVF1ZXVlID0gW107IC8vIHRoZSBuZXh0VXBkYXRlUXVldWUgaXMgdXNlZCB0byBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIGZvciB0aGUgbmV4dCB0aWNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHByZXZlbnRzIGluZmluaXRlIGxvb3BzIHdoZXJlIGR1cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbiB1cGRhdGUgYSBub2RlIGNvbnRpbnVvdXNseSBwdXRzIGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiYWNrIGluIHRoZSB1cGRhdGUgcXVldWUuXG5cbiAgICB0aGlzLl9jb250ZXh0cyA9IHt9OyAvLyBhIGhhc2ggb2YgYWxsIG9mIHRoZSBjb250ZXh0J3MgdGhhdCB0aGlzIGZhbW91c1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIHJlc3BvbnNpYmxlIGZvci5cblxuICAgIHRoaXMuX21lc3NhZ2VzID0gW107IC8vIGEgcXVldWUgb2YgYWxsIG9mIHRoZSBkcmF3IGNvbW1hbmRzIHRvIHNlbmQgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlbmRlcmVycyB0aGlzIGZyYW1lLlxuXG4gICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTsgLy8gd2hlbiB0aGUgZmFtb3VzIGlzIHVwZGF0aW5nIHRoaXMgaXMgdHJ1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgcmVxdWVzdHMgZm9yIHVwZGF0ZXMgd2lsbCBnZXQgcHV0IGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5leHRVcGRhdGVRdWV1ZVxuXG4gICAgdGhpcy5fY2xvY2sgPSBuZXcgQ2xvY2soKTsgLy8gYSBjbG9jayB0byBrZWVwIHRyYWNrIG9mIHRpbWUgZm9yIHRoZSBzY2VuZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdyYXBoLlxuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoaXNXb3JrZXIpXG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMucG9zdE1lc3NhZ2UoZXYuZGF0YSk7XG4gICAgICAgIH0pO1xufVxuXG4vKipcbiAqIF91cGRhdGUgaXMgdGhlIGJvZHkgb2YgdGhlIHVwZGF0ZSBsb29wLiBUaGUgZnJhbWUgY29uc2lzdHMgb2ZcbiAqIHB1bGxpbmcgaW4gYXBwZW5kaW5nIHRoZSBuZXh0VXBkYXRlUXVldWUgdG8gdGhlIGN1cnJlbnRVcGRhdGUgcXVldWVcbiAqIHRoZW4gbW92aW5nIHRocm91Z2ggdGhlIHVwZGF0ZVF1ZXVlIGFuZCBjYWxsaW5nIG9uVXBkYXRlIHdpdGggdGhlIGN1cnJlbnRcbiAqIHRpbWUgb24gYWxsIG5vZGVzLiBXaGlsZSBfdXBkYXRlIGlzIGNhbGxlZCBfaW5VcGRhdGUgaXMgc2V0IHRvIHRydWUgYW5kIFxuICogYWxsIHJlcXVlc3RzIHRvIGJlIHBsYWNlZCBpbiB0aGUgdXBkYXRlIHF1ZXVlIHdpbGwgYmUgZm9yd2FyZGVkIHRvIHRoZSBcbiAqIG5leHRVcGRhdGVRdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gVGhlIGN1cnJlbnQgdGltZVxuICovXG5GYW1vdXMucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlICh0aW1lKSB7XG4gICAgdGhpcy5faW5VcGRhdGUgPSB0cnVlO1xuICAgIHZhciBuZXh0UXVldWUgPSB0aGlzLl9uZXh0VXBkYXRlUXVldWU7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fdXBkYXRlUXVldWU7XG4gICAgdmFyIGl0ZW07XG5cbiAgICB3aGlsZSAobmV4dFF1ZXVlLmxlbmd0aCkgcXVldWUudW5zaGlmdChuZXh0UXVldWUucG9wKCkpO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBpdGVtID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblVwZGF0ZSkgaXRlbS5vblVwZGF0ZSh0aW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pblVwZGF0ZSA9IGZhbHNlO1xufTtcblxuRmFtb3VzLnByb3RvdHlwZS5yZXF1ZXN0VXBkYXRlID0gZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZSAocmVxdWVzdGVyKSB7XG4gICAgaWYgKCFyZXF1ZXN0ZXIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdyZXF1ZXN0VXBkYXRlIG11c3QgYmUgY2FsbGVkIHdpdGggYSBjbGFzcyB0byBiZSB1cGRhdGVkJ1xuICAgICAgICApO1xuXG4gICAgaWYgKHRoaXMuX2luVXBkYXRlKSB0aGlzLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHJlcXVlc3Rlcik7XG4gICAgZWxzZSB0aGlzLl91cGRhdGVRdWV1ZS5wdXNoKHJlcXVlc3Rlcik7XG59O1xuXG5GYW1vdXMucHJvdG90eXBlLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrID0gZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sgKHJlcXVlc3Rlcikge1xuICAgIHRoaXMuX25leHRVcGRhdGVRdWV1ZS5wdXNoKHJlcXVlc3Rlcik7XG59O1xuXG5GYW1vdXMucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24gcG9zdE1lc3NhZ2UgKG1lc3NhZ2VzKSB7XG4gICAgaWYgKCFtZXNzYWdlcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ3Bvc3RNZXNzYWdlIG11c3QgYmUgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgbWVzc2FnZXMnXG4gICAgICAgICk7XG5cbiAgICB3aGlsZSAobWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgY29tbWFuZCA9IG1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSAnV0lUSCc6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVXaXRoKG1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0ZSQU1FJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUZyYW1lKG1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0lOVk9LRSc6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVJbnZva2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjZWl2ZWQgdW5rbm93biBjb21tYW5kOiAnICsgY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5GYW1vdXMucHJvdG90eXBlLmhhbmRsZVdpdGggPSBmdW5jdGlvbiBoYW5kbGVXaXRoIChtZXNzYWdlcykge1xuICAgIHZhciBwYXRoID0gbWVzc2FnZXMuc2hpZnQoKTtcbiAgICB2YXIgY29tbWFuZCA9IG1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcblxuICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICBjYXNlICdUUklHR0VSJzpcbiAgICAgICAgICAgIHZhciB0eXBlID0gbWVzc2FnZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBldiA9IG1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0Q29udGV4dChwYXRoKS5nZXREaXNwYXRjaCgpLmRpc3BhdGNoVUlFdmVudChwYXRoLCB0eXBlLCBldik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjZWl2ZWQgdW5rbm93biBjb21tYW5kOiAnICsgY29tbWFuZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5GYW1vdXMucHJvdG90eXBlLmhhbmRsZUZyYW1lID0gZnVuY3Rpb24gaGFuZGxlRnJhbWUgKG1lc3NhZ2VzKSB7XG4gICAgaWYgKCFtZXNzYWdlcykgdGhyb3cgbmV3IEVycm9yKCdoYW5kbGVGcmFtZSBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIG1lc3NhZ2VzJyk7XG4gICAgaWYgKCFtZXNzYWdlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignRlJBTUUgbXVzdCBiZSBzZW50IHdpdGggYSB0aW1lJyk7XG5cbiAgICB0aGlzLnN0ZXAobWVzc2FnZXMuc2hpZnQoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5GYW1vdXMucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiBzdGVwICh0aW1lKSB7XG4gICAgaWYgKHRpbWUgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdzdGVwIG11c3QgYmUgY2FsbGVkIHdpdGggYSB0aW1lJyk7XG5cbiAgICB0aGlzLl9jbG9jay5zdGVwKHRpbWUpO1xuXG4gICAgdGhpcy5fdXBkYXRlKHRpbWUpO1xuXG4gICAgaWYgKHRoaXMuX21lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICBpZiAoaXNXb3JrZXIpIHNlbGYucG9zdE1lc3NhZ2UodGhpcy5fbWVzc2FnZXMpO1xuICAgICAgICBlbHNlIHRoaXMub25tZXNzYWdlKHRoaXMuX21lc3NhZ2VzKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5fbWVzc2FnZXMubGVuZ3RoID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuRmFtb3VzLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q29udGV4dCAoc2VsZWN0b3IpIHtcbiAgICBpZiAoIXNlbGVjdG9yKSB0aHJvdyBuZXcgRXJyb3IoJ2dldENvbnRleHQgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIHNlbGVjdG9yJyk7XG5cbiAgICByZXR1cm4gdGhpcy5fY29udGV4dHNbc2VsZWN0b3Iuc3BsaXQoJy8nKVswXV07XG59O1xuXG5GYW1vdXMucHJvdG90eXBlLmdldENsb2NrID0gZnVuY3Rpb24gZ2V0Q2xvY2sgKCkge1xuICAgIHJldHVybiB0aGlzLl9jbG9jaztcbn07XG5cbkZhbW91cy5wcm90b3R5cGUubWVzc2FnZSA9IGZ1bmN0aW9uIG1lc3NhZ2UgKGNvbW1hbmQpIHtcbiAgICB0aGlzLl9tZXNzYWdlcy5wdXNoKGNvbW1hbmQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuRmFtb3VzLnByb3RvdHlwZS5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gY3JlYXRlQ29udGV4dCAoc2VsZWN0b3IpIHtcbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yIHx8ICdib2R5JztcblxuICAgIGlmICh0aGlzLl9jb250ZXh0c1tzZWxlY3Rvcl0pIHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXS5kaXNtb3VudCgpO1xuICAgIHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXSA9IG5ldyBDb250ZXh0KHNlbGVjdG9yLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dHNbc2VsZWN0b3JdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRmFtb3VzKCk7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG52YXIgU2l6ZSA9IHJlcXVpcmUoJy4vU2l6ZScpO1xuXG52YXIgVFJBTlNGT1JNX1BST0NFU1NPUiA9IG5ldyBUcmFuc2Zvcm0oKTtcbnZhciBTSVpFX1BST0NFU1NPUiA9IG5ldyBTaXplKCk7XG5cbnZhciBJREVOVCA9IFtcbiAgICAxLCAwLCAwLCAwLFxuICAgIDAsIDEsIDAsIDAsXG4gICAgMCwgMCwgMSwgMCxcbiAgICAwLCAwLCAwLCAxXG5dO1xuXG52YXIgT05FUyA9IFsxLCAxLCAxXTtcblxuZnVuY3Rpb24gTm9kZSAoKSB7XG4gICAgdGhpcy5fY2FsY3VsYXRlZFZhbHVlcyA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiBuZXcgRmxvYXQzMkFycmF5KElERU5UKSxcbiAgICAgICAgc2l6ZTogbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIH07XG5cbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuX3VwZGF0ZVF1ZXVlID0gW107XG4gICAgdGhpcy5fbmV4dFVwZGF0ZVF1ZXVlID0gW107XG5cbiAgICB0aGlzLl9mcmVlZENvbXBvbmVudEluZGljaWVzID0gW107XG4gICAgdGhpcy5fY29tcG9uZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fZnJlZWRDaGlsZEluZGljaWVzID0gW107XG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcblxuICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgdGhpcy5fZ2xvYmFsVXBkYXRlciA9IG51bGw7XG5cbiAgICB0aGlzLnZhbHVlID0gbmV3IE5vZGUuU3BlYygpO1xufVxuXG5Ob2RlLlJFTEFUSVZFX1NJWkUgPSBTaXplLlJFTEFUSVZFO1xuTm9kZS5BQlNPTFVURV9TSVpFID0gU2l6ZS5BQlNPTFVURTtcbk5vZGUuUkVOREVSX1NJWkUgPSBTaXplLlJFTkRFUjtcbk5vZGUuREVGQVVMVF9TSVpFID0gU2l6ZS5ERUZBVUxUO1xuXG5Ob2RlLlNwZWMgPSBmdW5jdGlvbiBTcGVjICgpIHtcbiAgICB0aGlzLmxvY2F0aW9uID0gbnVsbDtcbiAgICB0aGlzLnNob3dTdGF0ZSA9IHtcbiAgICAgICAgbW91bnRlZDogZmFsc2UsXG4gICAgICAgIHNob3duOiBmYWxzZSxcbiAgICAgICAgb3BhY2l0eTogMVxuICAgIH07XG4gICAgdGhpcy5vZmZzZXRzID0ge1xuICAgICAgICBtb3VudFBvaW50OiBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICAgICAgICBhbGlnbjogbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgICAgICAgb3JpZ2luOiBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgfTtcbiAgICB0aGlzLnZlY3RvcnMgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICAgICAgICByb3RhdGlvbjogbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgICAgICAgc2NhbGU6IG5ldyBGbG9hdDMyQXJyYXkoT05FUylcbiAgICB9O1xuICAgIHRoaXMuc2l6ZSA9IHtcbiAgICAgICAgc2l6ZU1vZGU6IG5ldyBGbG9hdDMyQXJyYXkoW1NpemUuUkVMQVRJVkUsIFNpemUuUkVMQVRJVkUsIFNpemUuUkVMQVRJVkVdKSxcbiAgICAgICAgcHJvcG9ydGlvbmFsOiBuZXcgRmxvYXQzMkFycmF5KE9ORVMpLFxuICAgICAgICBkaWZmZXJlbnRpYWw6IG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gICAgICAgIGFic29sdXRlOiBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICAgICAgICByZW5kZXI6IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICB9O1xuICAgIHRoaXMuVUlFdmVudHMgPSBbXTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRDb250ZXh0XG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBkZXByZWNhdGVkIE5vZGUgY2FuIGJlIHVzZWQgZGlyZWN0bHkgaW5zdGVhZCFcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldENvbnRleHQgKCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ05vZGUjZ2V0Q29udGV4dCBpcyBkZXByZWNhdGVkIVxcbicgK1xuICAgICAgICAnTm9kZXMgY2FuIGJlIHVzZWQgZGlyZWN0bHkhJ1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZ2V0RGlzcGF0Y2hcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQGRlcHJlY2F0ZWQgTm9kZSBjYW4gYmUgdXNlZCBkaXJlY3RseSBpbnN0ZWFkIVxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5nZXREaXNwYXRjaCA9IGZ1bmN0aW9uIGdldERpc3BhdGNoICgpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdOb2RlI2dldERpc3BhdGNoIGlzIGRlcHJlY2F0ZWQhXFxuJyArXG4gICAgICAgICdDb21wb25lbnQgY29uc3RydWN0b3JzIGFjY2VwdCBhIE5vZGUgaW5zdGVhZCEnICtcbiAgICAgICAgJ1VzZSBuZXcgQ29tcG9uZW50KG5vZGUpIGluc3RlYWQgb2YgbmV3IENvbXBvbmVudChub2RlLmdldERpc3BhdGNoKCkpISdcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGdldFJlbmRlclByb3h5XG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBkZXByZWNhdGVkIE5vZGUgY2FuIGJlIHVzZWQgZGlyZWN0bHkgaW5zdGVhZCFcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0UmVuZGVyUHJveHkgPSBmdW5jdGlvbiBnZXRSZW5kZXJQcm94eSAoKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgICAnTm9kZSNnZXRSZW5kZXJQcm94eSBpcyBkZXByZWNhdGVkIVxcbicgK1xuICAgICAgICAnUmVuZGVyUHJveHkgZnVuY3Rpb25hbGl0eSBoYXMgYmVlbiBtZXJnZWQgaW50byBOb2RlISdcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGdldFJlbmRlclBhdGhcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgI2dldExvY2F0aW9uKClcbiAqIEByZXR1cm4ge3N0cmluZ30gcmVuZGVyIHBhdGhcbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0UmVuZGVyUGF0aCA9IGZ1bmN0aW9uIGdldFJlbmRlclBhdGggKCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ05vZGUjZ2V0UmVuZGVyUGF0aCBpcyBkZXByZWNhdGVkIVxcbicgK1xuICAgICAgICAnVXNlIE5vZGUjZ2V0TG9jYXRpb24gaW5zdGVhZCEnXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5nZXRMb2NhdGlvbigpO1xufVxuXG4vKipcbiAqIEBtZXRob2QgYWRkUmVuZGVyYWJsZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBhZGRDb21wb25lbnRcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IGNvbXBvbmVudCB0byBiZSBhZGRlZFxuICogQHJldHVybiB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLmFkZFJlbmRlcmFibGUgPSBmdW5jdGlvbiBhZGRSZW5kZXJhYmxlIChjb21wb25lbnQpIHtcbiAgICBjb25zb2xlLndhcm4oXCJOb2RlI2FkZFJlbmRlcmFibGUgaXMgZGVwcmljYXRlZCFcXG4gdXNlIG5vZGUuYWRkQ29tcG9uZW50IGluc3RlYWRcIik7XG4gICAgdGhpcy5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuTm9kZS5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUubG9jYXRpb247XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRJZCA9IE5vZGUucHJvdG90eXBlLmdldExvY2F0aW9uO1xuXG5Ob2RlLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCAoZXZlbnQsIHBheWxvYWQpIHtcbiAgICB2YXIgcCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgd2hpbGUgKChwID0gcC5nZXRQYXJlbnQoKSkgIT09IHApO1xuICAgIHAuZ2V0RGlzcGF0Y2goKS5kaXNwYXRjaChldmVudCwgcGF5bG9hZCk7XG59O1xuXG4vLyBUSElTIFdJTEwgQkUgREVQUklDQVRFRFxuTm9kZS5wcm90b3R5cGUuc2VuZERyYXdDb21tYW5kID0gZnVuY3Rpb24gc2VuZERyYXdDb21tYW5kIChtZXNzYWdlKSB7XG4gICAgdGhpcy5fZ2xvYmFsVXBkYXRlci5tZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSAoKSB7XG4gICAgdmFyIG51bWJlck9mQ2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG4gICAgdmFyIG51bWJlck9mQ29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcblxuICAgIHZhciB2YWx1ZSA9IHtcbiAgICAgICAgbG9jYXRpb246IHRoaXMudmFsdWUubG9jYXRpb24sXG4gICAgICAgIHNwZWM6IHRoaXMudmFsdWUsXG4gICAgICAgIGNvbXBvbmVudHM6IG5ldyBBcnJheShudW1iZXJPZkNvbXBvbmVudHMpLFxuICAgICAgICBjaGlsZHJlbjogbmV3IEFycmF5KG51bWJlck9mQ2hpbGRyZW4pXG4gICAgfTtcblxuICAgIGZvciAoOyBpIDwgbnVtYmVyT2ZDaGlsZHJlbiA7IGkrKylcbiAgICAgICAgdmFsdWUuY2hpbGRyZW5baV0gPSB0aGlzLl9jaGlsZHJlbltpXS5nZXRWYWx1ZSgpO1xuXG4gICAgZm9yIChpID0gMCA7IGkgPCBudW1iZXJPZkNvbXBvbmVudHMgOyBpKyspXG4gICAgICAgIGlmICh0aGlzLl9jb21wb25lbnRzW2ldLmdldFZhbHVlKSBcbiAgICAgICAgICAgIHZhbHVlLmNvbXBvbmVudHNbaV0gPSB0aGlzLl9jb21wb25lbnRzW2ldLmdldFZhbHVlKCk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRDb21wdXRlZFZhbHVlID0gZnVuY3Rpb24gZ2V0Q29tcHV0ZWRWYWx1ZSAoKSB7XG4gICAgdmFyIG51bWJlck9mQ2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICB2YXIgdmFsdWUgPSB7XG4gICAgICAgIGxvY2F0aW9uOiB0aGlzLnZhbHVlLmxvY2F0aW9uLFxuICAgICAgICBjb21wdXRlZFZhbHVlczogdGhpcy5fY2FsY3VsYXRlZFZhbHVlcyxcbiAgICAgICAgY2hpbGRyZW46IG5ldyBBcnJheShudW1iZXJPZkNoaWxkcmVuKVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBudW1iZXJPZkNoaWxkcmVuIDsgaSsrKVxuICAgICAgICB2YWx1ZS5jaGlsZHJlbltpXSA9IHRoaXMuX2NoaWxkcmVuW2ldLmdldENvbXB1dGVkVmFsdWUoKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Q2hpbGRyZW4gKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uIGdldFBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbn07XG5cbk5vZGUucHJvdG90eXBlLnJlcXVlc3RVcGRhdGUgPSBmdW5jdGlvbiByZXF1ZXN0VXBkYXRlIChpZCkge1xuICAgIGlmICh0aGlzLl9pblVwZGF0ZSkgcmV0dXJuIHRoaXMucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2soaWQpO1xuICAgIHRoaXMuX3VwZGF0ZVF1ZXVlLnB1c2goaWQpO1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxuTm9kZS5wcm90b3R5cGUucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sgPSBmdW5jdGlvbiByZXF1ZXN0VXBkYXRlT25OZXh0VGljayAoaWQpIHtcbiAgICB0aGlzLl9uZXh0VXBkYXRlUXVldWUucHVzaChpZCk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRVcGRhdGVyID0gZnVuY3Rpb24gZ2V0VXBkYXRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dsb2JhbFVwZGF0ZXI7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5pc01vdW50ZWQgPSBmdW5jdGlvbiBpc01vdW50ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnNob3dTdGF0ZS5tb3VudGVkO1xufTtcblxuTm9kZS5wcm90b3R5cGUuaXNTaG93biA9IGZ1bmN0aW9uIGlzU2hvd24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnNob3dTdGF0ZS5zaG93bjtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldE9wYWNpdHkgPSBmdW5jdGlvbiBnZXRPcGFjaXR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5zaG93U3RhdGUub3BhY2l0eTtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldE1vdW50UG9pbnQgPSBmdW5jdGlvbiBnZXRNb3VudFBvaW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5vZmZzZXRzLm1vdW50UG9pbnQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRBbGlnbiA9IGZ1bmN0aW9uIGdldEFsaWduICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5vZmZzZXRzLmFsaWduO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0T3JpZ2luID0gZnVuY3Rpb24gZ2V0T3JpZ2luICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5vZmZzZXRzLm9yaWdpbjtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0UG9zaXRpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnZlY3RvcnMucG9zaXRpb247XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFJvdGF0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS52ZWN0b3JzLnJvdGF0aW9uO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0U2NhbGUgPSBmdW5jdGlvbiBnZXRTY2FsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUudmVjdG9ycy5zY2FsZTtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldFNpemVNb2RlID0gZnVuY3Rpb24gZ2V0U2l6ZU1vZGUgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnNpemUuc2l6ZU1vZGU7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRQcm9wb3J0aW9uYWxTaXplID0gZnVuY3Rpb24gZ2V0UHJvcG9ydGlvbmFsU2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuc2l6ZS5wcm9wb3J0aW9uYWw7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXREaWZmZXJlbnRpYWxTaXplID0gZnVuY3Rpb24gZ2V0RGlmZmVyZW50aWFsU2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuc2l6ZS5kaWZmZXJlbnRpYWw7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRBYnNvbHV0ZVNpemUgPSBmdW5jdGlvbiBnZXRBYnNvbHV0ZVNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnNpemUuYWJzb2x1dGU7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRSZW5kZXJTaXplID0gZnVuY3Rpb24gZ2V0UmVuZGVyU2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuc2l6ZS5yZW5kZXI7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gZ2V0U2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZWRWYWx1ZXMuc2l6ZTtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIGdldFRyYW5zZm9ybSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZWRWYWx1ZXMudHJhbnNmb3JtO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0VUlFdmVudHMgPSBmdW5jdGlvbiBnZXRVSUV2ZW50cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuVUlFdmVudHM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkIChjaGlsZCkge1xuICAgIHZhciBpbmRleCA9IGNoaWxkID8gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihjaGlsZCkgOiAtMTtcbiAgICBjaGlsZCA9IGNoaWxkID8gY2hpbGQgOiBuZXcgTm9kZSgpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICBpbmRleCA9IHRoaXMuX2ZyZWVkQ2hpbGRJbmRpY2llcy5sZW5ndGggPyB0aGlzLl9mcmVlZENoaWxkSW5kaWNpZXMucG9wKCkgOiB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuW2luZGV4XSA9IGNoaWxkO1xuXG4gICAgICAgIGlmICh0aGlzLmlzTW91bnRlZCgpICYmIGNoaWxkLm9uTW91bnQpIHtcbiAgICAgICAgICAgIHZhciBteUlkID0gdGhpcy5nZXRJZCgpO1xuICAgICAgICAgICAgdmFyIGNoaWxkSWQgPSBteUlkICsgJy8nICsgaW5kZXg7XG4gICAgICAgICAgICBjaGlsZC5vbk1vdW50KHRoaXMsIGNoaWxkSWQpO1xuICAgICAgICB9XG4gICAgXG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xufTtcblxuTm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZCAoY2hpbGQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2ZyZWVkQ2hpbGRJbmRpY2llcy5wdXNoKGluZGV4KTtcblxuICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQoKSAmJiBjaGlsZC5vbkRpc21vdW50KVxuICAgICAgICAgICAgY2hpbGQub25EaXNtb3VudCgpO1xuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuW2luZGV4XSA9IG51bGw7XG4gICAgfVxufTtcblxuTm9kZS5wcm90b3R5cGUuYWRkQ29tcG9uZW50ID0gZnVuY3Rpb24gYWRkQ29tcG9uZW50IChjb21wb25lbnQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9jb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5fZnJlZWRDb21wb25lbnRJbmRpY2llcy5sZW5ndGggPyB0aGlzLl9mcmVlZENvbXBvbmVudEluZGljaWVzLnBvcCgpIDogdGhpcy5fY29tcG9uZW50cy5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdID0gY29tcG9uZW50O1xuXG4gICAgICAgIGlmICh0aGlzLmlzTW91bnRlZCgpICYmIGNvbXBvbmVudC5vbk1vdW50KVxuICAgICAgICAgICAgY29tcG9uZW50Lm9uTW91bnQodGhpcywgaW5kZXgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzU2hvd24oKSAmJiBjb21wb25lbnQub25TaG93KVxuICAgICAgICAgICAgY29tcG9uZW50Lm9uU2hvdygpO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbn07XG5cbk5vZGUucHJvdG90eXBlLnJlbW92ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIHJlbW92ZUNvbXBvbmVudCAoY29tcG9uZW50KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fY29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9mcmVlZENvbXBvbmVudEluZGljaWVzLnB1c2goaW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5pc1Nob3duKCkgJiYgY29tcG9uZW50Lm9uSGlkZSlcbiAgICAgICAgICAgIGNvbXBvbmVudC5vbkhpZGUoKTtcblxuICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQoKSAmJiBjb21wb25lbnQub25EaXNtb3VudClcbiAgICAgICAgICAgIGNvbXBvbmVudC5vbkRpc21vdW50KCk7XG5cbiAgICAgICAgdGhpcy5fY29tcG9uZW50c1tpbmRleF0gPSBudWxsO1xuICAgIH1cbn07XG5cbk5vZGUucHJvdG90eXBlLmFkZFVJRXZlbnQgPSBmdW5jdGlvbiBhZGRVSUV2ZW50IChldmVudE5hbWUpIHtcbiAgICB2YXIgVUlFdmVudHMgPSB0aGlzLmdldFVJRXZlbnRzKCk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHZhciBjb21wb25lbnQ7XG5cbiAgICBpZiAoVUlFdmVudHMuaW5kZXhPZihldmVudE5hbWUpID09PSAtMSkge1xuICAgICAgICBVSUV2ZW50cy5wdXNoKGV2ZW50TmFtZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Lm9uQWRkVUlFdmVudCkgY29tcG9uZW50Lm9uQWRkVUlFdmVudChldmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuTm9kZS5wcm90b3R5cGUuX3JlcXVlc3RVcGRhdGUgPSBmdW5jdGlvbiBfcmVxdWVzdFVwZGF0ZSAoZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UgfHwgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlICYmIHRoaXMuX2dsb2JhbFVwZGF0ZXIpKSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbFVwZGF0ZXIucmVxdWVzdFVwZGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuTm9kZS5wcm90b3R5cGUuX3ZlYzNPcHRpb25hbFNldCA9IGZ1bmN0aW9uIF92ZWMzT3B0aW9uYWxTZXQgKHZlYzMsIGluZGV4LCB2YWwpIHtcbiAgICBpZiAodmFsICE9IG51bGwgJiYgdmVjM1tpbmRleF0gIT09IHZhbCkge1xuICAgICAgICB2ZWMzW2luZGV4XSA9IHZhbDtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyAoKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpdGVtcyA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgaXRlbTtcblxuICAgIHRoaXMudmFsdWUuc2hvd1N0YXRlLnNob3duID0gdHJ1ZTtcblxuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblNob3cpIGl0ZW0ub25TaG93KCk7XG4gICAgfVxuXG4gICAgaSA9IDA7XG4gICAgaXRlbXMgPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBsZW4gPSBpdGVtcy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25QYXJlbnRTaG93KSBpdGVtLm9uUGFyZW50U2hvdygpO1xuICAgIH1cbn07XG5cbk5vZGUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiBoaWRlICgpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB2YXIgbGVuID0gaXRlbXMubGVuZ3RoO1xuICAgIHZhciBpdGVtO1xuXG4gICAgdGhpcy52YWx1ZS5zaG93U3RhdGUuc2hvd24gPSBmYWxzZTtcblxuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vbkhpZGUpIGl0ZW0ub25IaWRlKCk7XG4gICAgfVxuXG4gICAgaSA9IDA7XG4gICAgaXRlbXMgPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBsZW4gPSBpdGVtcy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25QYXJlbnRIaWRlKSBpdGVtLm9uUGFyZW50SGlkZSgpO1xuICAgIH1cbn07XG5cbk5vZGUucHJvdG90eXBlLnNldEFsaWduID0gZnVuY3Rpb24gc2V0QWxpZ24gKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUub2Zmc2V0cy5hbGlnbjtcbiAgICB2YXIgcHJvcG9nYXRlID0gZmFsc2U7XG5cbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWMzT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlYzNPcHRpb25hbFNldCh2ZWMzLCAxLCB5KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjM09wdGlvbmFsU2V0KHZlYzMsIDIsIHopIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSB2ZWMzWzBdO1xuICAgICAgICB5ID0gdmVjM1sxXTtcbiAgICAgICAgeiA9IHZlYzNbMl07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25BbGlnbkNoYW5nZSkgaXRlbS5vbkFsaWduQ2hhbmdlKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuc2V0TW91bnRQb2ludCA9IGZ1bmN0aW9uIHNldE1vdW50UG9pbnQgKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUub2Zmc2V0cy5tb3VudFBvaW50O1xuICAgIHZhciBwcm9wb2dhdGUgPSBmYWxzZTtcblxuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlYzNPcHRpb25hbFNldCh2ZWMzLCAwLCB4KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjM09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWMzT3B0aW9uYWxTZXQodmVjMywgMiwgeikgfHwgcHJvcG9nYXRlO1xuXG4gICAgaWYgKHByb3BvZ2F0ZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgeCA9IHZlYzNbMF07XG4gICAgICAgIHkgPSB2ZWMzWzFdO1xuICAgICAgICB6ID0gdmVjM1syXTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vbk1vdW50UG9pbnRDaGFuZ2UpIGl0ZW0ub25Nb3VudFBvaW50Q2hhbmdlKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuc2V0T3JpZ2luID0gZnVuY3Rpb24gc2V0T3JpZ2luICh4LCB5LCB6KSB7XG4gICAgdmFyIHZlYzMgPSB0aGlzLnZhbHVlLm9mZnNldHMub3JpZ2luO1xuICAgIHZhciBwcm9wb2dhdGUgPSBmYWxzZTtcblxuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlYzNPcHRpb25hbFNldCh2ZWMzLCAwLCB4KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjM09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWMzT3B0aW9uYWxTZXQodmVjMywgMiwgeikgfHwgcHJvcG9nYXRlO1xuXG4gICAgaWYgKHByb3BvZ2F0ZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgeCA9IHZlYzNbMF07XG4gICAgICAgIHkgPSB2ZWMzWzFdO1xuICAgICAgICB6ID0gdmVjM1syXTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vbk9yaWdpbkNoYW5nZSkgaXRlbS5vbk9yaWdpbkNoYW5nZSh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuTm9kZS5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiBzZXRQb3NpdGlvbiAoeCwgeSwgeikge1xuICAgIHZhciB2ZWMzID0gdGhpcy52YWx1ZS52ZWN0b3JzLnBvc2l0aW9uO1xuICAgIHZhciBwcm9wb2dhdGUgPSBmYWxzZTtcblxuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlYzNPcHRpb25hbFNldCh2ZWMzLCAwLCB4KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjM09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWMzT3B0aW9uYWxTZXQodmVjMywgMiwgeikgfHwgcHJvcG9nYXRlO1xuXG4gICAgaWYgKHByb3BvZ2F0ZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgeCA9IHZlYzNbMF07XG4gICAgICAgIHkgPSB2ZWMzWzFdO1xuICAgICAgICB6ID0gdmVjM1syXTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblBvc2l0aW9uQ2hhbmdlKSBpdGVtLm9uUG9zaXRpb25DaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIHNldFJvdGF0aW9uICh4LCB5LCB6KSB7XG4gICAgdmFyIHZlYzMgPSB0aGlzLnZhbHVlLnZlY3RvcnMucm90YXRpb247XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjM09wdGlvbmFsU2V0KHZlYzMsIDAsIHgpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWMzT3B0aW9uYWxTZXQodmVjMywgMSwgeSkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlYzNPcHRpb25hbFNldCh2ZWMzLCAyLCB6KSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gdmVjM1swXTtcbiAgICAgICAgeSA9IHZlYzNbMV07XG4gICAgICAgIHogPSB2ZWMzWzJdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uUm90YXRpb25DaGFuZ2UpIGl0ZW0ub25Sb3RhdGlvbkNoYW5nZSh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24gc2V0U2NhbGUgKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUudmVjdG9ycy5zY2FsZTtcbiAgICB2YXIgcHJvcG9nYXRlID0gZmFsc2U7XG5cbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWMzT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlYzNPcHRpb25hbFNldCh2ZWMzLCAxLCB5KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjM09wdGlvbmFsU2V0KHZlYzMsIDIsIHopIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSB2ZWMzWzBdO1xuICAgICAgICB5ID0gdmVjM1sxXTtcbiAgICAgICAgeiA9IHZlYzNbMl07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25TY2FsZUNoYW5nZSkgaXRlbS5vblNjYWxlQ2hhbmdlKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIHNldE9wYWNpdHkgKHZhbCkge1xuICAgIGlmICh2YWwgIT0gdGhpcy52YWx1ZS5zaG93U3RhdGUub3BhY2l0eSkge1xuICAgICAgICB0aGlzLnZhbHVlLnNob3dTdGF0ZS5vcGFjaXR5ID0gdmFsO1xuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vbk9wYWNpdHlDaGFuZ2UpIGl0ZW0ub25PcGFjaXR5Q2hhbmdlKHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zZXRTaXplTW9kZSA9IGZ1bmN0aW9uIHNldFNpemVNb2RlICh4LCB5LCB6KSB7XG4gICAgdmFyIHZlYzMgPSB0aGlzLnZhbHVlLnNpemUuc2l6ZU1vZGU7XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjM09wdGlvbmFsU2V0KHZlYzMsIDAsIHgpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWMzT3B0aW9uYWxTZXQodmVjMywgMSwgeSkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlYzNPcHRpb25hbFNldCh2ZWMzLCAyLCB6KSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gdmVjM1swXTtcbiAgICAgICAgeSA9IHZlYzNbMV07XG4gICAgICAgIHogPSB2ZWMzWzJdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uU2l6ZU1vZGVDaGFuZ2UpIGl0ZW0ub25TaXplTW9kZUNoYW5nZSh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLnNldFByb3BvcnRpb25hbFNpemUgPSBmdW5jdGlvbiBzZXRQcm9wb3J0aW9uYWxTaXplICh4LCB5LCB6KSB7XG4gICAgdmFyIHZlYzMgPSB0aGlzLnZhbHVlLnNpemUucHJvcG9ydGlvbmFsO1xuICAgIHZhciBwcm9wb2dhdGUgPSBmYWxzZTtcblxuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlYzNPcHRpb25hbFNldCh2ZWMzLCAwLCB4KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjM09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWMzT3B0aW9uYWxTZXQodmVjMywgMiwgeikgfHwgcHJvcG9nYXRlO1xuXG4gICAgaWYgKHByb3BvZ2F0ZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgeCA9IHZlYzNbMF07XG4gICAgICAgIHkgPSB2ZWMzWzFdO1xuICAgICAgICB6ID0gdmVjM1syXTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblByb3BvcnRpb25hbFNpemVDaGFuZ2UpIGl0ZW0ub25Qcm9wb3J0aW9uYWxTaXplQ2hhbmdlKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuc2V0RGlmZmVyZW50aWFsU2l6ZSA9IGZ1bmN0aW9uIHNldERpZmZlcmVudGlhbFNpemUgKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUuc2l6ZS5kaWZmZXJlbnRpYWw7XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjM09wdGlvbmFsU2V0KHZlYzMsIDAsIHgpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWMzT3B0aW9uYWxTZXQodmVjMywgMSwgeSkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlYzNPcHRpb25hbFNldCh2ZWMzLCAyLCB6KSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gdmVjM1swXTtcbiAgICAgICAgeSA9IHZlYzNbMV07XG4gICAgICAgIHogPSB2ZWMzWzJdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uRGlmZmVyZW50aWFsU2l6ZUNoYW5nZSkgaXRlbS5vbkRpZmZlcmVudGlhbFNpemVDaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zZXRBYnNvbHV0ZVNpemUgPSBmdW5jdGlvbiBzZXRBYnNvbHV0ZVNpemUgKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUuc2l6ZS5hYnNvbHV0ZTtcbiAgICB2YXIgcHJvcG9nYXRlID0gZmFsc2U7XG5cbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWMzT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlYzNPcHRpb25hbFNldCh2ZWMzLCAxLCB5KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjM09wdGlvbmFsU2V0KHZlYzMsIDIsIHopIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSB2ZWMzWzBdO1xuICAgICAgICB5ID0gdmVjM1sxXTtcbiAgICAgICAgeiA9IHZlYzNbMl07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25BYnNvbHV0ZVNpemVDaGFuZ2UpIGl0ZW0ub25BYnNvbHV0ZVNpemVDaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fdHJhbnNmb3JtQ2hhbmdlZCA9IGZ1bmN0aW9uIF90cmFuc2Zvcm1DaGFuZ2VkICh0cmFuc2Zvcm0pIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB2YXIgbGVuID0gaXRlbXMubGVuZ3RoO1xuICAgIHZhciBpdGVtO1xuXG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uVHJhbnNmb3JtQ2hhbmdlKSBpdGVtLm9uVHJhbnNmb3JtQ2hhbmdlKHRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgaSA9IDA7XG4gICAgaXRlbXMgPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBsZW4gPSBpdGVtcy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25QYXJlbnRUcmFuc2Zvcm1DaGFuZ2UpIGl0ZW0ub25QYXJlbnRUcmFuc2Zvcm1DaGFuZ2UodHJhbnNmb3JtKTtcbiAgICB9XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fc2l6ZUNoYW5nZWQgPSBmdW5jdGlvbiBfc2l6ZUNoYW5nZWQgKHNpemUpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB2YXIgbGVuID0gaXRlbXMubGVuZ3RoO1xuICAgIHZhciBpdGVtO1xuXG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uU2l6ZUNoYW5nZSkgaXRlbS5vblNpemVDaGFuZ2Uoc2l6ZSk7XG4gICAgfVxuXG4gICAgaSA9IDA7XG4gICAgaXRlbXMgPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBsZW4gPSBpdGVtcy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25QYXJlbnRTaXplQ2hhbmdlKSBpdGVtLm9uUGFyZW50U2l6ZUNoYW5nZShzaXplKTtcbiAgICB9XG59O1xuXG4vLyBERVBSSUNBVEVcbk5vZGUucHJvdG90eXBlLmdldEZyYW1lID0gZnVuY3Rpb24gZ2V0RnJhbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9nbG9iYWxVcGRhdGVyLmdldEZyYW1lKCk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKHRpbWUpe1xuICAgIHRoaXMuX2luVXBkYXRlID0gdHJ1ZTtcbiAgICB2YXIgbmV4dFF1ZXVlID0gdGhpcy5fbmV4dFVwZGF0ZVF1ZXVlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3VwZGF0ZVF1ZXVlO1xuICAgIHZhciBpdGVtO1xuXG4gICAgd2hpbGUgKG5leHRRdWV1ZS5sZW5ndGgpIHF1ZXVlLnVuc2hpZnQobmV4dFF1ZXVlLnBvcCgpKTtcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgaXRlbSA9IHRoaXMuX2NvbXBvbmVudHNbcXVldWUuc2hpZnQoKV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25VcGRhdGUpIGl0ZW0ub25VcGRhdGUodGltZSk7XG4gICAgfVxuXG4gICAgdmFyIG15U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIHZhciBwYXJlbnRTaXplID0gcGFyZW50LmdldFNpemUoKTtcbiAgICB2YXIgbXlUcmFuc2Zvcm0gPSB0aGlzLmdldFRyYW5zZm9ybSgpO1xuICAgIHZhciBwYXJlbnRUcmFuc2Zvcm0gPSBwYXJlbnQuZ2V0VHJhbnNmb3JtKCk7XG4gICAgdmFyIHNpemVDaGFuZ2VkID0gU0laRV9QUk9DRVNTT1IuZnJvbVNwZWNXaXRoUGFyZW50KHBhcmVudFNpemUsIHRoaXMudmFsdWUsIG15U2l6ZSk7XG4gICAgbXlTaXplID0gdGhpcy5nZXRTaXplKCk7XG4gXG4gICAgdmFyIHRyYW5zZm9ybUNoYW5nZWQgPSBUUkFOU0ZPUk1fUFJPQ0VTU09SLmZyb21TcGVjV2l0aFBhcmVudCh0aGlzLmdldFBhcmVudCgpLmdldFRyYW5zZm9ybSgpLCB0aGlzLnZhbHVlLCBteVNpemUsIHBhcmVudFNpemUsIHRoaXMuZ2V0VHJhbnNmb3JtKCkpO1xuICAgIGlmICh0cmFuc2Zvcm1DaGFuZ2VkKSB0aGlzLl90cmFuc2Zvcm1DaGFuZ2VkKHRoaXMuZ2V0VHJhbnNmb3JtKCkpO1xuICAgIGlmIChzaXplQ2hhbmdlZCkgdGhpcy5fc2l6ZUNoYW5nZWQodGhpcy5nZXRTaXplKCkpO1xuXG4gICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5fbmV4dFVwZGF0ZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9nbG9iYWxVcGRhdGVyLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uIG1vdW50IChwYXJlbnQsIG15SWQpIHtcbiAgICBpZiAodGhpcy5pc01vdW50ZWQoKSkgcmV0dXJuOyBcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgaXRlbTtcblxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLl9nbG9iYWxVcGRhdGVyID0gcGFyZW50LmdldFVwZGF0ZXIoKTtcbiAgICB0aGlzLnZhbHVlLmxvY2F0aW9uID0gbXlJZDtcbiAgICB0aGlzLnZhbHVlLnNob3dTdGF0ZS5tb3VudGVkID0gdHJ1ZTtcblxuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICBpZiAoaXRlbS5vbk1vdW50KSBpdGVtLm9uTW91bnQodGhpcywgaSk7XG4gICAgfVxuICAgIFxuICAgIGkgPSAwO1xuICAgIGxpc3QgPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKGl0ZW0ub25QYXJlbnRNb3VudCkgaXRlbS5vblBhcmVudE1vdW50KHRoaXMsIG15SWQsIGkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKHRydWUpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZGlzbW91bnQgPSBmdW5jdGlvbiBkaXNtb3VudCAoKSB7XG4gICAgaWYgKCF0aGlzLmlzTW91bnRlZCgpKSByZXR1cm47IFxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgIHZhciBpdGVtO1xuXG4gICAgdGhpcy52YWx1ZS5zaG93U3RhdGUubW91bnRlZCA9IGZhbHNlO1xuICAgIHRoaXMudmFsdWUubG9jYXRpb24gPSBudWxsO1xuXG4gICAgdGhpcy5fcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuXG4gICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcblxuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICBpZiAoaXRlbS5vbkRpc21vdW50KSBpdGVtLm9uRGlzbW91bnQoKTtcbiAgICB9XG4gICAgXG4gICAgaSA9IDA7XG4gICAgbGlzdCA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICBpZiAoaXRlbS5vblBhcmVudERpc21vdW50KSBpdGVtLm9uUGFyZW50RGlzbW91bnQoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICB0aGlzLl9nbG9iYWxVcGRhdGVyID0gbnVsbDtcbn07XG5cbk5vZGUucHJvdG90eXBlLm9uUGFyZW50TW91bnQgPSBmdW5jdGlvbiBvblBhcmVudE1vdW50IChwYXJlbnQsIHBhcmVudElkLCBpbmRleCkge1xuICAgIHRoaXMubW91bnQocGFyZW50LCBwYXJlbnRJZCArICcvJyArIGluZGV4KTtcbn07XG5cbk5vZGUucHJvdG90eXBlLm9uUGFyZW50RGlzbW91bnQgPSBmdW5jdGlvbiBvblBhcmVudERpc21vdW50ICgpIHtcbiAgICB0aGlzLmRpc21vdW50KCk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5yZWNlaXZlID0gZnVuY3Rpb24gcmVjZWl2ZSAodHlwZSwgZXYpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgaXRlbTtcbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblJlY2VpdmUpIGl0ZW0ub25SZWNlaXZlKHR5cGUsIGV2KTtcbiAgICB9XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5vblVwZGF0ZSA9IE5vZGUucHJvdG90eXBlLnVwZGF0ZTtcblxuTm9kZS5wcm90b3R5cGUub25QYXJlbnRTaG93ID0gTm9kZS5wcm90b3R5cGUuc2hvdztcblxuTm9kZS5wcm90b3R5cGUub25QYXJlbnRIaWRlID0gTm9kZS5wcm90b3R5cGUuaGlkZTtcblxuTm9kZS5wcm90b3R5cGUub25QYXJlbnRUcmFuc2Zvcm1DaGFuZ2UgPSBfcmVxdWVzdFVwZGF0ZVdpdGhvdXRBcmdzO1xuXG5Ob2RlLnByb3RvdHlwZS5vblBhcmVudFNpemVDaGFuZ2UgPSBfcmVxdWVzdFVwZGF0ZVdpdGhvdXRBcmdzO1xuXG5Ob2RlLnByb3RvdHlwZS5vblNob3cgPSBOb2RlLnByb3RvdHlwZS5zaG93O1xuXG5Ob2RlLnByb3RvdHlwZS5vbkhpZGUgPSBOb2RlLnByb3RvdHlwZS5oaWRlO1xuXG5Ob2RlLnByb3RvdHlwZS5vbk1vdW50ID0gTm9kZS5wcm90b3R5cGUubW91bnQ7XG5cbk5vZGUucHJvdG90eXBlLm9uRGlzbW91bnQgPSBOb2RlLnByb3RvdHlwZS5kaXNtb3VudDtcblxuTm9kZS5wcm90b3R5cGUub25SZWNlaXZlID0gTm9kZS5wcm90b3R5cGUucmVjZWl2ZTtcblxuZnVuY3Rpb24gX3JlcXVlc3RVcGRhdGVXaXRob3V0QXJncyAoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcbiIsImZ1bmN0aW9uIFNpemUgKGRpc3BhdGNoKSB7XG4gICAgdGhpcy5fc2l6ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG59XG5cblNpemUuUkVMQVRJVkUgPSAwO1xuU2l6ZS5BQlNPTFVURSA9IDE7XG5TaXplLlJFTkRFUiA9IDI7XG5TaXplLkRFRkFVTFQgPSAwO1xuXG5TaXplLnByb3RvdHlwZS5mcm9tU3BlY1dpdGhQYXJlbnQgPSBmdW5jdGlvbiBmcm9tU3BlY1dpdGhQYXJlbnQgKHBhcmVudFNpemUsIHNwZWMsIHRhcmdldCkge1xuICAgIHZhciBtb2RlID0gc3BlYy5zaXplLnNpemVNb2RlO1xuICAgIHZhciBwcmV2O1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgMyA7IGkrKykge1xuICAgICAgICBzd2l0Y2ggKG1vZGVbaV0pIHtcbiAgICAgICAgICAgIGNhc2UgU2l6ZS5SRUxBVElWRTpcbiAgICAgICAgICAgICAgICBwcmV2ID0gdGFyZ2V0W2ldO1xuICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IHBhcmVudFNpemVbaV0gKiBzcGVjLnNpemUucHJvcG9ydGlvbmFsW2ldICsgc3BlYy5zaXplLmRpZmZlcmVudGlhbFtpXTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBwcmV2ICE9PSB0YXJnZXRbaV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNpemUuQUJTT0xVVEU6XG4gICAgICAgICAgICAgICAgcHJldiA9IHRhcmdldFtpXTtcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBzcGVjLnNpemUuYWJzb2x1dGVbaV07XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgcHJldiAhPT0gdGFyZ2V0W2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTaXplLlJlbmRlcjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2l6ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gVHJhbnNmb3JtICgpIHtcbiAgICB0aGlzLl9tYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICB0aGlzLl9zY3JhdGNoID0gbmV3IEZsb2F0MzJBcnJheSg2Nyk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF0cml4O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5mcm9tU3BlY1dpdGhQYXJlbnQgPSBmdW5jdGlvbiBmcm9tU3BlY1dpdGhQYXJlbnQgKHBhcmVudE1hdHJpeCwgc3BlYywgbXlTaXplLCBwYXJlbnRTaXplLCB0YXJnZXQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQgPyB0YXJnZXQgOiB0aGlzLl9tYXRyaXg7XG5cbiAgICAvLyBsb2NhbCBjYWNoZSBvZiBldmVyeXRoaW5nXG4gICAgdmFyIHQwMCAgICAgICAgID0gdGFyZ2V0WzBdO1xuICAgIHZhciB0MDEgICAgICAgICA9IHRhcmdldFsxXTtcbiAgICB2YXIgdDAyICAgICAgICAgPSB0YXJnZXRbMl07XG4gICAgdmFyIHQwMyAgICAgICAgID0gdGFyZ2V0WzNdO1xuICAgIHZhciB0MTAgICAgICAgICA9IHRhcmdldFs0XTtcbiAgICB2YXIgdDExICAgICAgICAgPSB0YXJnZXRbNV07XG4gICAgdmFyIHQxMiAgICAgICAgID0gdGFyZ2V0WzZdO1xuICAgIHZhciB0MTMgICAgICAgICA9IHRhcmdldFs3XTtcbiAgICB2YXIgdDIwICAgICAgICAgPSB0YXJnZXRbOF07XG4gICAgdmFyIHQyMSAgICAgICAgID0gdGFyZ2V0WzldO1xuICAgIHZhciB0MjIgICAgICAgICA9IHRhcmdldFsxMF07XG4gICAgdmFyIHQyMyAgICAgICAgID0gdGFyZ2V0WzExXTtcbiAgICB2YXIgdDMwICAgICAgICAgPSB0YXJnZXRbMTJdO1xuICAgIHZhciB0MzEgICAgICAgICA9IHRhcmdldFsxM107XG4gICAgdmFyIHQzMiAgICAgICAgID0gdGFyZ2V0WzE0XTtcbiAgICB2YXIgdDMzICAgICAgICAgPSB0YXJnZXRbMTVdO1xuICAgIHZhciBwMDAgICAgICAgICA9IHBhcmVudE1hdHJpeFswXTtcbiAgICB2YXIgcDAxICAgICAgICAgPSBwYXJlbnRNYXRyaXhbMV07XG4gICAgdmFyIHAwMiAgICAgICAgID0gcGFyZW50TWF0cml4WzJdO1xuICAgIHZhciBwMDMgICAgICAgICA9IHBhcmVudE1hdHJpeFszXTtcbiAgICB2YXIgcDEwICAgICAgICAgPSBwYXJlbnRNYXRyaXhbNF07XG4gICAgdmFyIHAxMSAgICAgICAgID0gcGFyZW50TWF0cml4WzVdO1xuICAgIHZhciBwMTIgICAgICAgICA9IHBhcmVudE1hdHJpeFs2XTtcbiAgICB2YXIgcDEzICAgICAgICAgPSBwYXJlbnRNYXRyaXhbN107XG4gICAgdmFyIHAyMCAgICAgICAgID0gcGFyZW50TWF0cml4WzhdO1xuICAgIHZhciBwMjEgICAgICAgICA9IHBhcmVudE1hdHJpeFs5XTtcbiAgICB2YXIgcDIyICAgICAgICAgPSBwYXJlbnRNYXRyaXhbMTBdO1xuICAgIHZhciBwMjMgICAgICAgICA9IHBhcmVudE1hdHJpeFsxMV07XG4gICAgdmFyIHAzMCAgICAgICAgID0gcGFyZW50TWF0cml4WzEyXTtcbiAgICB2YXIgcDMxICAgICAgICAgPSBwYXJlbnRNYXRyaXhbMTNdO1xuICAgIHZhciBwMzIgICAgICAgICA9IHBhcmVudE1hdHJpeFsxNF07XG4gICAgdmFyIHAzMyAgICAgICAgID0gcGFyZW50TWF0cml4WzE1XTtcbiAgICB2YXIgcG9zWCAgICAgICAgPSBzcGVjLnZlY3RvcnMucG9zaXRpb25bMF07XG4gICAgdmFyIHBvc1kgICAgICAgID0gc3BlYy52ZWN0b3JzLnBvc2l0aW9uWzFdO1xuICAgIHZhciBwb3NaICAgICAgICA9IHNwZWMudmVjdG9ycy5wb3NpdGlvblsyXTtcbiAgICB2YXIgcm90WCAgICAgICAgPSBzcGVjLnZlY3RvcnMucm90YXRpb25bMF07XG4gICAgdmFyIHJvdFkgICAgICAgID0gc3BlYy52ZWN0b3JzLnJvdGF0aW9uWzFdO1xuICAgIHZhciByb3RaICAgICAgICA9IHNwZWMudmVjdG9ycy5yb3RhdGlvblsyXTtcbiAgICB2YXIgc2NhbGVYICAgICAgPSBzcGVjLnZlY3RvcnMuc2NhbGVbMF07XG4gICAgdmFyIHNjYWxlWSAgICAgID0gc3BlYy52ZWN0b3JzLnNjYWxlWzFdO1xuICAgIHZhciBzY2FsZVogICAgICA9IHNwZWMudmVjdG9ycy5zY2FsZVsyXTtcbiAgICB2YXIgYWxpZ25YICAgICAgPSBzcGVjLm9mZnNldHMuYWxpZ25bMF0gKiBwYXJlbnRTaXplWzBdO1xuICAgIHZhciBhbGlnblkgICAgICA9IHNwZWMub2Zmc2V0cy5hbGlnblsxXSAqIHBhcmVudFNpemVbMV07XG4gICAgdmFyIGFsaWduWiAgICAgID0gc3BlYy5vZmZzZXRzLmFsaWduWzJdICogcGFyZW50U2l6ZVsyXTtcbiAgICB2YXIgbW91bnRQb2ludFggPSBzcGVjLm9mZnNldHMubW91bnRQb2ludFswXSAqIG15U2l6ZVswXTtcbiAgICB2YXIgbW91bnRQb2ludFkgPSBzcGVjLm9mZnNldHMubW91bnRQb2ludFsxXSAqIG15U2l6ZVsxXTtcbiAgICB2YXIgbW91bnRQb2ludFogPSBzcGVjLm9mZnNldHMubW91bnRQb2ludFsyXSAqIG15U2l6ZVsyXTtcbiAgICB2YXIgb3JpZ2luWCAgICAgPSBzcGVjLm9mZnNldHMub3JpZ2luWzBdICogbXlTaXplWzBdO1xuICAgIHZhciBvcmlnaW5ZICAgICA9IHNwZWMub2Zmc2V0cy5vcmlnaW5bMV0gKiBteVNpemVbMV07XG4gICAgdmFyIG9yaWdpblogICAgID0gc3BlYy5vZmZzZXRzLm9yaWdpblsyXSAqIG15U2l6ZVsyXTtcbiAgICB2YXIgY29zWCAgICAgICAgPSBNYXRoLmNvcyhyb3RYKTtcbiAgICB2YXIgY29zWSAgICAgICAgPSBNYXRoLmNvcyhyb3RZKTtcbiAgICB2YXIgY29zWiAgICAgICAgPSBNYXRoLmNvcyhyb3RaKTtcbiAgICB2YXIgc2luWCAgICAgICAgPSBNYXRoLnNpbihyb3RYKTtcbiAgICB2YXIgc2luWSAgICAgICAgPSBNYXRoLnNpbihyb3RZKTtcbiAgICB2YXIgc2luWiAgICAgICAgPSBNYXRoLnNpbihyb3RaKTtcbiAgICB2YXIgZXhwcjEgICAgICAgPSAoY29zWSAqIGNvc1opO1xuICAgIHZhciBleHByMiAgICAgICA9IChjb3NYICogc2luWiArIHNpblggKiBzaW5ZICogY29zWik7XG4gICAgdmFyIGV4cHIzICAgICAgID0gKHNpblggKiBzaW5aIC0gY29zWCAqIHNpblkgKiBjb3NaKTtcbiAgICB2YXIgZXhwcjQgICAgICAgPSAoLWNvc1kgKiBzaW5aKTtcbiAgICB2YXIgZXhwcjUgICAgICAgPSAoY29zWCAqIGNvc1ogLSBzaW5YICogc2luWSAqIHNpblopO1xuICAgIHZhciBleHByNiAgICAgICA9IChzaW5YICogY29zWiArIGNvc1ggKiBzaW5ZICogc2luWik7XG4gICAgdmFyIGV4cHI3ICAgICAgID0gKC1zaW5YICogY29zWSk7XG4gICAgdmFyIGV4cHI4ICAgICAgID0gKGNvc1ggKiBjb3NZKTtcblxuICAgIHRhcmdldFswXSAgPSAoKCgocDAwKSAqIGV4cHIxKSArICgocDEwKSAqIGV4cHIyKSkgKyAoKHAyMCkgKiBleHByMykpICogKHNjYWxlWCk7XG4gICAgdGFyZ2V0WzFdICA9ICgoKChwMDEpICogZXhwcjEpICsgKChwMTEpICogZXhwcjIpKSArICgocDIxKSAqIGV4cHIzKSkgKiAoc2NhbGVYKTtcbiAgICB0YXJnZXRbMl0gID0gKCgoKHAwMikgKiBleHByMSkgKyAoKHAxMikgKiBleHByMikpICsgKChwMjIpICogZXhwcjMpKSAqIChzY2FsZVgpO1xuICAgIHRhcmdldFszXSAgPSAoKCgocDAzKSAqIGV4cHIxKSArICgocDEzKSAqIGV4cHIyKSkgKyAoKHAyMykgKiBleHByMykpICogKHNjYWxlWCk7XG4gICAgdGFyZ2V0WzRdICA9ICgoKChwMDApICogZXhwcjQpICsgKChwMTApICogZXhwcjUpKSArICgocDIwKSAqIGV4cHI2KSkgKiAoc2NhbGVZKTtcbiAgICB0YXJnZXRbNV0gID0gKCgoKHAwMSkgKiBleHByNCkgKyAoKHAxMSkgKiBleHByNSkpICsgKChwMjEpICogZXhwcjYpKSAqIChzY2FsZVkpO1xuICAgIHRhcmdldFs2XSAgPSAoKCgocDAyKSAqIGV4cHI0KSArICgocDEyKSAqIGV4cHI1KSkgKyAoKHAyMikgKiBleHByNikpICogKHNjYWxlWSk7XG4gICAgdGFyZ2V0WzddICA9ICgoKChwMDMpICogZXhwcjQpICsgKChwMTMpICogZXhwcjUpKSArICgocDIzKSAqIGV4cHI2KSkgKiAoc2NhbGVZKTtcbiAgICB0YXJnZXRbOF0gID0gKCgoKHAwMCkgKiAoc2luWSkpICsgKChwMTApICogZXhwcjcpKSArICgocDIwKSAqIGV4cHI4KSkgKiAoc2NhbGVaKTtcbiAgICB0YXJnZXRbOV0gID0gKCgoKHAwMSkgKiAoc2luWSkpICsgKChwMTEpICogZXhwcjcpKSArICgocDIxKSAqIGV4cHI4KSkgKiAoc2NhbGVaKTtcbiAgICB0YXJnZXRbMTBdID0gKCgoKHAwMikgKiAoc2luWSkpICsgKChwMTIpICogZXhwcjcpKSArICgocDIyKSAqIGV4cHI4KSkgKiAoc2NhbGVaKTtcbiAgICB0YXJnZXRbMTFdID0gKCgoKHAwMykgKiAoc2luWSkpICsgKChwMTMpICogZXhwcjcpKSArICgocDIzKSAqIGV4cHI4KSkgKiAoc2NhbGVaKTtcbiAgICB0YXJnZXRbMTJdID0gKCgoKCgoKHAwMCkgKiBleHByMSkgKyAoKHAxMCkgKiBleHByMikpICsgKChwMjApICogZXhwcjMpKSAqIChzY2FsZVgpKSAqICgoLW9yaWdpblgpKSkgKyAoKCgoKChwMDApICogZXhwcjQpICsgKChwMTApICogZXhwcjUpKSArICgocDIwKSAqIGV4cHI2KSkgKiAoc2NhbGVZKSkgKiAoKC1vcmlnaW5ZKSkpKSArICgoKCgoKChwMDApICogKHNpblkpKSArICgocDEwKSAqIGV4cHI3KSkgKyAoKHAyMCkgKiBleHByOCkpICogKHNjYWxlWikpICogKCgtb3JpZ2luWikpKSArICgoKChwMDApICogKHBvc1gpKSArICgocDEwKSAqIChwb3NZKSkpICsgKCgocDIwKSAqIChwb3NaKSkgKyAoKCgocDAwKSAqIChvcmlnaW5YKSkgKyAoKHAxMCkgKiAob3JpZ2luWSkpKSArICgoKHAyMCkgKiAob3JpZ2luWikpICsgKCgoKHAwMCkgKiAoKC1tb3VudFBvaW50WCkpKSArICgocDEwKSAqICgoLW1vdW50UG9pbnRZKSkpKSArICgoKHAyMCkgKiAoKC1tb3VudFBvaW50WikpKSArICgoKChwMDApICogKGFsaWduWCkpICsgKChwMTApICogKGFsaWduWSkpKSArICgoKHAyMCkgKiAoYWxpZ25aKSkgKyAocDMwKSkpKSkpKSkpKTtcbiAgICB0YXJnZXRbMTNdID0gKCgoKCgoKHAwMSkgKiBleHByMSkgKyAoKHAxMSkgKiBleHByMikpICsgKChwMjEpICogZXhwcjMpKSAqIChzY2FsZVgpKSAqICgoLW9yaWdpblgpKSkgKyAoKCgoKChwMDEpICogZXhwcjQpICsgKChwMTEpICogZXhwcjUpKSArICgocDIxKSAqIGV4cHI2KSkgKiAoc2NhbGVZKSkgKiAoKC1vcmlnaW5ZKSkpKSArICgoKCgoKChwMDEpICogKHNpblkpKSArICgocDExKSAqIGV4cHI3KSkgKyAoKHAyMSkgKiBleHByOCkpICogKHNjYWxlWikpICogKCgtb3JpZ2luWikpKSArICgoKChwMDEpICogKHBvc1gpKSArICgocDExKSAqIChwb3NZKSkpICsgKCgocDIxKSAqIChwb3NaKSkgKyAoKCgocDAxKSAqIChvcmlnaW5YKSkgKyAoKHAxMSkgKiAob3JpZ2luWSkpKSArICgoKHAyMSkgKiAob3JpZ2luWikpICsgKCgoKHAwMSkgKiAoKC1tb3VudFBvaW50WCkpKSArICgocDExKSAqICgoLW1vdW50UG9pbnRZKSkpKSArICgoKHAyMSkgKiAoKC1tb3VudFBvaW50WikpKSArICgoKChwMDEpICogKGFsaWduWCkpICsgKChwMTEpICogKGFsaWduWSkpKSArICgoKHAyMSkgKiAoYWxpZ25aKSkgKyAocDMxKSkpKSkpKSkpKTtcbiAgICB0YXJnZXRbMTRdID0gKCgoKCgoKHAwMikgKiBleHByMSkgKyAoKHAxMikgKiBleHByMikpICsgKChwMjIpICogZXhwcjMpKSAqIChzY2FsZVgpKSAqICgoLW9yaWdpblgpKSkgKyAoKCgoKChwMDIpICogZXhwcjQpICsgKChwMTIpICogZXhwcjUpKSArICgocDIyKSAqIGV4cHI2KSkgKiAoc2NhbGVZKSkgKiAoKC1vcmlnaW5ZKSkpKSArICgoKCgoKChwMDIpICogKHNpblkpKSArICgocDEyKSAqIGV4cHI3KSkgKyAoKHAyMikgKiBleHByOCkpICogKHNjYWxlWikpICogKCgtb3JpZ2luWikpKSArICgoKChwMDIpICogKHBvc1gpKSArICgocDEyKSAqIChwb3NZKSkpICsgKCgocDIyKSAqIChwb3NaKSkgKyAoKCgocDAyKSAqIChvcmlnaW5YKSkgKyAoKHAxMikgKiAob3JpZ2luWSkpKSArICgoKHAyMikgKiAob3JpZ2luWikpICsgKCgoKHAwMikgKiAoKC1tb3VudFBvaW50WCkpKSArICgocDEyKSAqICgoLW1vdW50UG9pbnRZKSkpKSArICgoKHAyMikgKiAoKC1tb3VudFBvaW50WikpKSArICgoKChwMDIpICogKGFsaWduWCkpICsgKChwMTIpICogKGFsaWduWSkpKSArICgoKHAyMikgKiAoYWxpZ25aKSkgKyAocDMyKSkpKSkpKSkpKTtcbiAgICB0YXJnZXRbMTVdID0gKCgoKCgoKHAwMykgKiBleHByMSkgKyAoKHAxMykgKiBleHByMikpICsgKChwMjMpICogZXhwcjMpKSAqIChzY2FsZVgpKSAqICgoLW9yaWdpblgpKSkgKyAoKCgoKChwMDMpICogZXhwcjQpICsgKChwMTMpICogZXhwcjUpKSArICgocDIzKSAqIGV4cHI2KSkgKiAoc2NhbGVZKSkgKiAoKC1vcmlnaW5ZKSkpKSArICgoKCgoKChwMDMpICogKHNpblkpKSArICgocDEzKSAqIGV4cHI3KSkgKyAoKHAyMykgKiBleHByOCkpICogKHNjYWxlWikpICogKCgtb3JpZ2luWikpKSArICgoKChwMDMpICogKHBvc1gpKSArICgocDEzKSAqIChwb3NZKSkpICsgKCgocDIzKSAqIChwb3NaKSkgKyAoKCgocDAzKSAqIChvcmlnaW5YKSkgKyAoKHAxMykgKiAob3JpZ2luWSkpKSArICgoKHAyMykgKiAob3JpZ2luWikpICsgKCgoKHAwMykgKiAoKC1tb3VudFBvaW50WCkpKSArICgocDEzKSAqICgoLW1vdW50UG9pbnRZKSkpKSArICgoKHAyMykgKiAoKC1tb3VudFBvaW50WikpKSArICgoKChwMDMpICogKGFsaWduWCkpICsgKChwMTMpICogKGFsaWduWSkpKSArICgoKHAyMykgKiAoYWxpZ25aKSkgKyAocDMzKSkpKSkpKSkpKTtcblxuICAgIHJldHVybiB0MDAgIT09IHRhcmdldFswXSB8fFxuICAgICAgICB0MDEgIT09IHRhcmdldFsxXSB8fFxuICAgICAgICB0MDIgIT09IHRhcmdldFsyXSB8fFxuICAgICAgICB0MDMgIT09IHRhcmdldFszXSB8fFxuICAgICAgICB0MTAgIT09IHRhcmdldFs0XSB8fFxuICAgICAgICB0MTEgIT09IHRhcmdldFs1XSB8fFxuICAgICAgICB0MTIgIT09IHRhcmdldFs2XSB8fFxuICAgICAgICB0MTMgIT09IHRhcmdldFs3XSB8fFxuICAgICAgICB0MjAgIT09IHRhcmdldFs4XSB8fFxuICAgICAgICB0MjEgIT09IHRhcmdldFs5XSB8fFxuICAgICAgICB0MjIgIT09IHRhcmdldFsxMF0gfHxcbiAgICAgICAgdDIzICE9PSB0YXJnZXRbMTFdIHx8XG4gICAgICAgIHQzMCAhPT0gdGFyZ2V0WzEyXSB8fFxuICAgICAgICB0MzEgIT09IHRhcmdldFsxM10gfHxcbiAgICAgICAgdDMyICE9PSB0YXJnZXRbMTRdIHx8XG4gICAgICAgIHQzMyAhPT0gdGFyZ2V0WzE1XTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIENsb2NrOiByZXF1aXJlKCcuL0Nsb2NrJyksXG4gICAgRXZlbnQ6IHJlcXVpcmUoJy4vRXZlbnQnKSxcbiAgICBDb250ZXh0OiByZXF1aXJlKCcuL0NvbnRleHQnKSxcbiAgICBGYW1vdXM6IHJlcXVpcmUoJy4vRmFtb3VzJyksXG4gICAgRGlzcGF0Y2hlcjogcmVxdWlyZSgnLi9EaXNwYXRjaGVyJyksXG4gICAgTm9kZTogcmVxdWlyZSgnLi9Ob2RlJyksXG4gICAgU2l6ZTogcmVxdWlyZSgnLi9TaXplJyksXG4gICAgVHJhbnNmb3JtOiByZXF1aXJlKCcuL1RyYW5zZm9ybScpXG59O1xuIiwidmFyIENhbGxiYWNrU3RvcmUgPSByZXF1aXJlKCdmYW1vdXMtdXRpbGl0aWVzJykuQ2FsbGJhY2tTdG9yZTtcblxuZnVuY3Rpb24gRE9NRWxlbWVudCAobm9kZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ0hUTUxFbGVtZW50IGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBjaGFuZ2VkIVxcbicgK1xuICAgICAgICAgICAgJ1Bhc3MgaW4gYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCB7dGFnTmFtZTogJyArIG9wdGlvbnMgKyAnfSBpbnN0ZWFkLidcbiAgICAgICAgKTtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRhZ05hbWU6IG9wdGlvbnNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcblxuICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuX2NoYW5nZVF1ZXVlID0gW107XG4gICAgXG4gICAgdGhpcy5fY2xhc3NlcyA9IFsnZmEtc3VyZmFjZSddO1xuICAgIHRoaXMuX3JlcXVlc3RpbmdFdmVudExpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3N0eWxlcyA9IHtcbiAgICAgICAgZGlzcGxheTogbm9kZS5pc1Nob3duKCkgXG4gICAgfTtcbiAgICB0aGlzLl9hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5fY29udGVudCA9ICcnO1xuXG4gICAgdGhpcy5fdGFnTmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50YWdOYW1lID8gb3B0aW9ucy50YWdOYW1lIDogJ2Rpdic7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcblxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG5ldyBDYWxsYmFja1N0b3JlKCk7XG5cbiAgICBpZiAoIW9wdGlvbnMpIHJldHVybjtcblxuICAgIGlmIChvcHRpb25zLmNsYXNzZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmNsYXNzZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLmFkZENsYXNzKG9wdGlvbnMuY2xhc3Nlc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5hdHRyaWJ1dGVzKVxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucHJvcGVydGllcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wZXJ0aWVzKVxuICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eShrZXksIG9wdGlvbnMucHJvcGVydGllc1trZXldKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pZCkgdGhpcy5zZXRJZChvcHRpb25zLmlkKTtcbiAgICBpZiAob3B0aW9ucy5jb250ZW50KSB0aGlzLnNldENvbnRlbnQob3B0aW9ucy5jb250ZW50KTtcbn1cblxuRE9NRWxlbWVudC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xhc3NlczogdGhpcy5fY2xhc3NlcyxcbiAgICAgICAgc3R5bGVzOiB0aGlzLl9zdHlsZXMsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuX2F0dHJpYnV0ZXMsXG4gICAgICAgIGNvbnRlbnQ6IHRoaXMuX2NvbnRlbnRcbiAgICB9O1xufTtcblxuRE9NRWxlbWVudC5wcm90b3R5cGUub25VcGRhdGUgPSBmdW5jdGlvbiBvblVwZGF0ZSAoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX2NoYW5nZVF1ZXVlO1xuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG5cbiAgICBpZiAobGVuICYmIG5vZGUpIHtcbiAgICAgICAgbm9kZS5zZW5kRHJhd0NvbW1hbmQoJ1dJVEgnKTtcbiAgICAgICAgbm9kZS5zZW5kRHJhd0NvbW1hbmQobm9kZS5nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgbm9kZS5zZW5kRHJhd0NvbW1hbmQoJ0RPTScpO1xuXG4gICAgICAgIHdoaWxlIChsZW4tLSkgbm9kZS5zZW5kRHJhd0NvbW1hbmQocXVldWUuc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuRE9NRWxlbWVudC5wcm90b3R5cGUub25Nb3VudCA9IGZ1bmN0aW9uIG9uTW91bnQgKG5vZGUsIGlkKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5faWQgPSBpZDtcbiAgICB0aGlzLmRyYXcoKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGF0YS1mYS1wYXRoJywgbm9kZS5nZXRMb2NhdGlvbigpKTtcbn07XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uRGlzbW91bnQgPSBmdW5jdGlvbiBvbkRpc21vdW50ICgpIHtcbiAgICB0aGlzLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGF0YS1mYS1wYXRoJywgJycpO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG59O1xuXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblNob3cgPSBmdW5jdGlvbiBvblNob3cgKCkge1xuICAgIHRoaXMuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnYmxvY2snKTtcbn07XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uSGlkZSA9IGZ1bmN0aW9uIG9uSGlkZSAoKSB7XG4gICAgdGhpcy5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJyk7XG59O1xuXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblRyYW5zZm9ybUNoYW5nZSA9IGZ1bmN0aW9uIG9uVHJhbnNmb3JtQ2hhbmdlICh0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdDSEFOR0VfVFJBTlNGT1JNJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRyYW5zZm9ybS5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKHRyYW5zZm9ybVtpXSk7XG5cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uU2l6ZUNoYW5nZSA9IGZ1bmN0aW9uIG9uU2l6ZUNoYW5nZSAoc2l6ZSkge1xuICAgIHZhciBzaXplTW9kZSA9IHRoaXMuX25vZGUuZ2V0U2l6ZU1vZGUoKTtcbiAgICB2YXIgc2l6ZWRYID0gc2l6ZU1vZGVbMF0gIT09IE5vZGUuUkVOREVSX1NJWkU7XG4gICAgdmFyIHNpemVkWSA9IHNpemVNb2RlWzFdICE9PSBOb2RlLlJFTkRFUl9TSVpFO1xuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgXG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0NIQU5HRV9TSVpFJyxcbiAgICAgICAgICAgIHNpemVkWCA/IHNpemVbMF0gOiBzaXplZFgsXG4gICAgICAgICAgICBzaXplZFkgPyBzaXplWzFdIDogc2l6ZWRZKTtcblxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuRE9NRWxlbWVudC5wcm90b3R5cGUub25BZGRVSUV2ZW50ID0gZnVuY3Rpb24gb25BZGRVSUV2ZW50IChVSUV2ZW50KSB7XG4gICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnQUREX0VWRU5UX0xJU1RFTkVSJywgVUlFdmVudCwgdm9pZCAwLCB0cnVlLCAnRVZFTlRfRU5EJyk7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG59O1xuXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblNpemVNb2RlQ2hhbmdlID0gZnVuY3Rpb24gb25TaXplTW9kZUNoYW5nZSAoc2l6ZU1vZGUpIHtcbiAgICB0aGlzLm9uU2l6ZUNoYW5nZSh0aGlzLl9ub2RlLmdldFNpemUoKSk7XG59OyBcblxuRE9NRWxlbWVudC5wcm90b3R5cGUuX3JlcXVlc3RVcGRhdGUgPSBmdW5jdGlvbiBfcmVxdWVzdFVwZGF0ZSAoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0ICgpIHtcbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdJTklUX0RPTScsIHRoaXMuX3RhZ05hbWUpO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLm9uVHJhbnNmb3JtQ2hhbmdlKHRoaXMuX25vZGUuZ2V0VHJhbnNmb3JtKCkpO1xuICAgIHRoaXMub25TaXplQ2hhbmdlKHRoaXMuX25vZGUuZ2V0U2l6ZSgpKTtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLnNldElkID0gZnVuY3Rpb24gc2V0SWQgKGlkKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuRE9NRWxlbWVudC5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fY2xhc3Nlcy5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdBRERfQ0xBU1MnLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2NsYXNzZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5EcmF3KSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnQUREX0NMQVNTJywgdmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5ET01FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzICh2YWx1ZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2NsYXNzZXMuaW5kZXhPZih2YWx1ZSk7XG5cbiAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gdGhpcztcblxuICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ1JFTU9WRV9DTEFTUycsIHZhbHVlKTtcblxuICAgIHRoaXMuX2NsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuRE9NRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzW25hbWVdICE9PSB2YWx1ZSB8fCB0aGlzLl9pbkRyYXcpIHtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0NIQU5HRV9BVFRSSUJVVEUnLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdFVwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJvcGVydHkgKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3N0eWxlc1tuYW1lXSAhPT0gdmFsdWUgfHwgdGhpcy5faW5EcmF3KSB7XG4gICAgICAgIHRoaXMuX3N0eWxlc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0NIQU5HRV9QUk9QRVJUWScsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuRE9NRWxlbWVudC5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIHNldENvbnRlbnQgKGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCAhPT0gY29udGVudCB8fCB0aGlzLl9pbkRyYXcpIHtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnQ0hBTkdFX0NPTlRFTlQnLCBjb250ZW50KTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuRE9NRWxlbWVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrcy5vbihldmVudCwgbGlzdGVuZXIpO1xufTtcblxuRE9NRWxlbWVudC5wcm90b3R5cGUub25SZWNlaXZlID0gZnVuY3Rpb24gb25SZWNlaXZlIChldmVudCwgcGF5bG9hZCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcy50cmlnZ2VyKGV2ZW50LCBwYXlsb2FkKTtcbn07XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiBkcmF3ICgpIHtcbiAgICB2YXIga2V5O1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICB0aGlzLl9pbkRyYXcgPSB0cnVlO1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9jbGFzc2VzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIHRoaXMuYWRkQ2xhc3ModGhpcy5fY2xhc3Nlc1tpXSk7XG5cbiAgICB0aGlzLnNldENvbnRlbnQodGhpcy5fY29udGVudCk7XG5cbiAgICBmb3IgKGtleSBpbiB0aGlzLl9zdHlsZXMpIFxuICAgICAgICBpZiAodGhpcy5fc3R5bGVzW2tleV0pXG4gICAgICAgICAgICB0aGlzLnNldFByb3BlcnR5KGtleSwgdGhpcy5fc3R5bGVzW2tleV0pO1xuXG4gICAgZm9yIChrZXkgaW4gdGhpcy5fYXR0cmlidXRlcylcbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXNba2V5XSlcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgdGhpcy5fYXR0cmlidXRlc1trZXldKTtcblxuICAgIHRoaXMuX2luRHJhdyA9IGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01FbGVtZW50O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBET01FbGVtZW50ID0gcmVxdWlyZSgnLi9ET01FbGVtZW50Jyk7XG52YXIgQ2FsbGJhY2tTdG9yZSA9IHJlcXVpcmUoJ2ZhbW91cy11dGlsaXRpZXMnKS5DYWxsYmFja1N0b3JlO1xuXG52YXIgV0lUSCA9ICdXSVRIJztcbnZhciBDSEFOR0VfVFJBTlNGT1JNID0gJ0NIQU5HRV9UUkFOU0ZPUk0nO1xudmFyIENIQU5HRV9QUk9QRVJUWSA9ICdDSEFOR0VfUFJPUEVSVFknO1xudmFyIElOSVRfRE9NID0gJ0lOSVRfRE9NJztcbnZhciBDSEFOR0VfQVRUUklCVVRFID0gJ0NIQU5HRV9BVFRSSUJVVEUnO1xudmFyIEFERF9DTEFTUyA9ICdBRERfQ0xBU1MnO1xudmFyIFJFTU9WRV9DTEFTUyA9ICdSRU1PVkVfQ0xBU1MnO1xudmFyIENIQU5HRV9BVFRSSUJVVEUgPSAnQ0hBTkdFX0FUVFJJQlVURSc7XG52YXIgQ0hBTkdFX0NPTlRFTlQgPSAnQ0hBTkdFX0NPTlRFTlQnO1xudmFyIEFERF9FVkVOVF9MSVNURU5FUiA9ICdBRERfRVZFTlRfTElTVEVORVInO1xudmFyIEVWRU5UX1BST1BFUlRJRVMgPSAnRVZFTlRfUFJPUEVSVElFUyc7XG52YXIgRVZFTlRfRU5EID0gJ0VWRU5UX0VORCc7XG52YXIgUkVDQUxMID0gJ1JFQ0FMTCc7XG5cbi8qKlxuICogVGhlIEVsZW1lbnQgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIHByb3ZpZGluZyB0aGUgQVBJIGZvciBob3dcbiAqICAgYSBSZW5kZXJOb2RlIHdpbGwgaW50ZXJhY3Qgd2l0aCB0aGUgRE9NIEFQSSdzLiAgVGhlIGVsZW1lbnQgaXNcbiAqICAgcmVzcG9uc2libGUgZm9yIGFkZGluZyBhIHNldCBvZiBjb21tYW5kcyB0byB0aGUgcmVuZGVyZXIuXG4gKlxuICogQGNsYXNzIEhUTUxFbGVtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBjb21wb25lbnRcbiAqIEBwYXJhbSB7UmVuZGVyTm9kZX0gUmVuZGVyTm9kZSB0byB3aGljaCB0aGUgaW5zdGFuY2Ugb2YgRWxlbWVudCB3aWxsIGJlIGEgY29tcG9uZW50IG9mXG4gKi9cbmZ1bmN0aW9uIEhUTUxFbGVtZW50KG5vZGUsIHRhZ05hbWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJIVE1MRWxlbWVudCB3YXMgZGVwcmljYXRlZFxcbiB1c2UgRE9NRWxlbWVudFwiKTtcbiAgICByZXR1cm4gbmV3IERPTUVsZW1lbnQobm9kZSwgdGFnTmFtZSk7XG59IFxuXG5tb2R1bGUuZXhwb3J0cyA9IEhUTUxFbGVtZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBIVE1MRWxlbWVudDogcmVxdWlyZSgnLi9IVE1MRWxlbWVudCcpLFxuICAgIERPTUVsZW1lbnQ6IHJlcXVpcmUoJy4vRE9NRWxlbWVudCcpXG59O1xuIiwiLy8gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbi8vIGh0dHA6Ly9teS5vcGVyYS5jb20vZW1vbGxlci9ibG9nLzIwMTEvMTIvMjAvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1lci1hbmltYXRpbmdcbiBcbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBieSBFcmlrIE3DtmxsZXIuIGZpeGVzIGZyb20gUGF1bCBJcmlzaCBhbmQgVGlubyBaaWpkZWxcbiBcbi8vIE1JVCBsaWNlbnNlXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGxhc3RUaW1lID0gMDtcbnZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcblxudmFyIHJBRiwgY0FGO1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICByQUYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgIGNBRiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cuY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXJBRjsgKyt4KSB7XG4gICAgICAgIHJBRiA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgICBjQUYgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXVxuICAgICAgICAgICAgfHwgd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXTtcbiAgICB9XG5cbiAgICBpZiAockFGICYmICFjQUYpIHtcbiAgICAgICAgLy8gY0FGIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBzZXRJbnRlcnZhbCBmb3Igbm93ICh2ZXJ5IHJhcmUpLlxuICAgICAgICByQUYgPSBudWxsO1xuICAgIH1cbn1cblxudmFyIG5vdyA9IERhdGUubm93ID8gRGF0ZS5ub3cgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufTtcblxuaWYgKCFyQUYpIHtcbiAgICByQUYgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgY3VyclRpbWUgPSBub3coKTtcbiAgICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG4gICAgICAgIHZhciBpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgICAgfSwgdGltZVRvQ2FsbCk7XG4gICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcblxuICAgIGNBRiA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZTogckFGLFxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lOiBjQUZcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZTogcmVxdWlyZSgnLi9hbmltYXRpb25GcmFtZScpLnJlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZTogcmVxdWlyZSgnLi9hbmltYXRpb25GcmFtZScpLmNhbmNlbEFuaW1hdGlvbkZyYW1lXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcG9seWZpbGxzID0gcmVxdWlyZSgnZmFtb3VzLXBvbHlmaWxscycpO1xudmFyIHJBRiA9IHBvbHlmaWxscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG52YXIgY0FGID0gcG9seWZpbGxzLmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG52YXIgX25vdztcbmlmICh0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgX25vdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIF9ub3cgPSBEYXRlLm5vdztcbn1cblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgVkVORE9SX0hJRERFTiwgVkVORE9SX1ZJU0lCSUxJVFlfQ0hBTkdFO1xuXG4gICAgLy8gT3BlcmEgMTIuMTAgYW5kIEZpcmVmb3ggMTggYW5kIGxhdGVyIHN1cHBvcnRcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgVkVORE9SX0hJRERFTiA9ICdoaWRkZW4nO1xuICAgICAgICBWRU5ET1JfVklTSUJJTElUWV9DSEFOR0UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5tb3pIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIFZFTkRPUl9ISURERU4gPSAnbW96SGlkZGVuJztcbiAgICAgICAgVkVORE9SX1ZJU0lCSUxJVFlfQ0hBTkdFID0gJ21venZpc2liaWxpdHljaGFuZ2UnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQubXNIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIFZFTkRPUl9ISURERU4gPSAnbXNIaWRkZW4nO1xuICAgICAgICBWRU5ET1JfVklTSUJJTElUWV9DSEFOR0UgPSAnbXN2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50LndlYmtpdEhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgVkVORE9SX0hJRERFTiA9ICd3ZWJraXRIaWRkZW4nO1xuICAgICAgICBWRU5ET1JfVklTSUJJTElUWV9DSEFOR0UgPSAnd2Via2l0dmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgfVxufVxuXG4vKipcbiAqIEVuZ2luZSBjbGFzcyB1c2VkIGZvciB1cGRhdGluZyBvYmplY3RzIG9uIGEgZnJhbWUtYnktZnJhbWUuIFN5bmNocm9uaXplcyB0aGVcbiAqIGB1cGRhdGVgIG1ldGhvZCBpbnZvY2F0aW9ucyB0byB0aGUgcmVmcmVzaCByYXRlIG9mIHRoZSBzY3JlZW4uIE1hbmFnZXNcbiAqIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC1sb29wIGJ5IG5vcm1hbGl6aW5nIHRoZSBwYXNzZWQgaW4gdGltZXN0YW1wXG4gKiB3aGVuIHN3aXRjaGluZyB0YWJzLlxuICogXG4gKiBAY2xhc3MgRW5naW5lXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRW5naW5lKCkge1xuICAgIHRoaXMuX3VwZGF0ZXMgPSBbXTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX2xvb3BlciA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgX3RoaXMubG9vcCh0aW1lKTtcbiAgICB9O1xuICAgIHRoaXMuX3N0b3BwZWRBdCA9IF9ub3coKTtcbiAgICB0aGlzLl9zbGVlcCA9IDA7XG4gICAgdGhpcy5fc3RhcnRPblZpc2liaWxpdHlDaGFuZ2UgPSB0cnVlO1xuICAgIHRoaXMuX3JBRiA9IG51bGw7XG4gICAgdGhpcy5zdGFydCgpO1xuXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihWRU5ET1JfVklTSUJJTElUWV9DSEFOR0UsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50W1ZFTkRPUl9ISURERU5dKSB7XG4gICAgICAgICAgICAgICAgY0FGKHRoaXMuX3JBRik7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0T25WaXNpYmlsaXR5Q2hhbmdlID0gX3RoaXMuX3N0YXJ0T25WaXNpYmlsaXR5Q2hhbmdlO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3RhcnRPblZpc2liaWxpdHlDaGFuZ2UgPSBzdGFydE9uVmlzaWJpbGl0eUNoYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc3RhcnRPblZpc2liaWxpdHlDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTdGFydHMgdGhlIEVuZ2luZS5cbiAqXG4gKiBAbWV0aG9kIHN0YXJ0XG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEByZXR1cm4ge0VuZ2luZX0gdGhpc1xuICovXG5FbmdpbmUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0T25WaXNpYmlsaXR5Q2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NsZWVwICs9IF9ub3coKSAtIHRoaXMuX3N0b3BwZWRBdDtcbiAgICAgICAgdGhpcy5fckFGID0gckFGKHRoaXMuX2xvb3Blcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdG9wcyB0aGUgRW5naW5lLlxuICpcbiAqIEBtZXRob2Qgc3RvcFxuICogQGNoYWluYWJsZVxuICogXG4gKiBAcmV0dXJuIHtFbmdpbmV9IHRoaXNcbiAqL1xuRW5naW5lLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgICB0aGlzLl9zdGFydE9uVmlzaWJpbGl0eUNoYW5nZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0b3BwZWRBdCA9IF9ub3coKTtcbiAgICAgICAgY0FGKHRoaXMuX3JBRik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIEVuZ2luZSBpcyBjdXJyZW50bHkgcnVubmluZyBvciBub3QuXG4gKlxuICogQG1ldGhvZCBpc1J1bm5pbmdcbiAqIFxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIEVuZ2luZSBpc1xuICogICAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5IHJ1bm5pbmcgb3Igbm90XG4gKi9cbkVuZ2luZS5wcm90b3R5cGUuaXNSdW5uaW5nID0gZnVuY3Rpb24gaXNSdW5uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9ydW5uaW5nO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIGFsbCByZWdpc3RlcmVkIG9iamVjdHMuXG4gKlxuICogQG1ldGhvZCBzdGVwXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSAge051bWJlcn0gdGltZSBoaWdoIHJlc29sdXRpb24gdGltc3RhbXAgdXNlZCBmb3IgaW52b2tpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYHVwZGF0ZWAgbWV0aG9kIG9uIGFsbCByZWdpc3RlcmVkIG9iamVjdHNcbiAqIEByZXR1cm4ge0VuZ2luZX0gICAgICB0aGlzXG4gKi9cbkVuZ2luZS5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uIHN0ZXAgKHRpbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdXBkYXRlcy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZXNbaV0udXBkYXRlKHRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWV0aG9kIGJlaW5nIGNhbGxlZCBieSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBvbiBldmVyeSBwYWludC4gSW5kaXJlY3RseVxuICogcmVjdXJzaXZlIGJ5IHNjaGVkdWxpbmcgYSBmdXR1cmUgaW52b2NhdGlvbiBvZiBpdHNlbGYgb24gdGhlIG5leHQgcGFpbnQuXG4gKlxuICogQG1ldGhvZCBsb29wXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSAge051bWJlcn0gdGltZSBoaWdoIHJlc29sdXRpb24gdGltc3RhbXAgdXNlZCBmb3IgaW52b2tpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYHVwZGF0ZWAgbWV0aG9kIG9uIGFsbCByZWdpc3RlcmVkIG9iamVjdHNcbiAqIEByZXR1cm4ge0VuZ2luZX0gICAgICB0aGlzXG4gKi9cbkVuZ2luZS5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uIGxvb3AodGltZSkge1xuICAgIHRoaXMuc3RlcCh0aW1lIC0gdGhpcy5fc2xlZXApO1xuICAgIHRoaXMuX3JBRiA9IHJBRih0aGlzLl9sb29wZXIpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcmVzIGFuIHVwZGF0ZWFibGUgb2JqZWN0IHdoaWNoIGB1cGRhdGVgIG1ldGhvZCBzaG91bGQgYmUgaW52b2tlZCBvblxuICogZXZlcnkgcGFpbnQsIHN0YXJ0aW5nIG9uIHRoZSBuZXh0IHBhaW50IChhc3N1bWluZyB0aGUgRW5naW5lIGlzIHJ1bm5pbmcpLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSAge09iamVjdH0gdXBkYXRlYWJsZSAgICAgICAgICBvYmplY3QgdG8gYmUgdXBkYXRlZFxuICogQHBhcmFtICB7RnVuY3Rpb259IHVwZGF0ZWFibGUudXBkYXRlIHVwZGF0ZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJlZCBvYmplY3RcbiAqIEByZXR1cm4ge0VuZ2luZX0gICAgICAgICAgICAgICAgICAgICB0aGlzXG4gKi9cbkVuZ2luZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHVwZGF0ZWFibGUpIHtcbiAgICBpZiAodGhpcy5fdXBkYXRlcy5pbmRleE9mKHVwZGF0ZWFibGUpID09PSAtMSkge1xuICAgICAgICB0aGlzLl91cGRhdGVzLnB1c2godXBkYXRlYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZXJlZ2lzdGVycyBhbiB1cGRhdGVhYmxlIG9iamVjdCBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgdXNpbmcgYHVwZGF0ZWAgdG8gYmVcbiAqIG5vIGxvbmdlciB1cGRhdGVkLlxuICpcbiAqIEBtZXRob2Qgbm9Mb25nZXJVcGRhdGVcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHBhcmFtICB7T2JqZWN0fSB1cGRhdGVhYmxlICAgICAgICAgIHVwZGF0ZWFibGUgb2JqZWN0IHByZXZpb3VzbHlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlcmVkIHVzaW5nIGB1cGRhdGVgXG4gKiBAcmV0dXJuIHtFbmdpbmV9ICAgICAgICAgICAgICAgICAgICAgdGhpc1xuICovXG5FbmdpbmUucHJvdG90eXBlLm5vTG9uZ2VyVXBkYXRlID0gZnVuY3Rpb24gbm9Mb25nZXJVcGRhdGUodXBkYXRlYWJsZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX3VwZGF0ZXMuaW5kZXhPZih1cGRhdGVhYmxlKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLl91cGRhdGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbmdpbmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xudmFyIE1hdDMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5NYXQzMztcblxudmFyIE9iamVjdE1hbmFnZXIgPSByZXF1aXJlKCdmYW1vdXMtdXRpbGl0aWVzJykuT2JqZWN0TWFuYWdlcjtcbk9iamVjdE1hbmFnZXIucmVnaXN0ZXIoJ0R5bmFtaWNHZW9tZXRyeScsIER5bmFtaWNHZW9tZXRyeSk7XG5PYmplY3RNYW5hZ2VyLnJlZ2lzdGVyKCdEeW5hbWljR2VvbWV0cnlGZWF0dXJlJywgRHluYW1pY0dlb21ldHJ5RmVhdHVyZSk7XG52YXIgT01SZXF1ZXN0RHluYW1pY0dlb21ldHJ5RmVhdHVyZSA9IE9iamVjdE1hbmFnZXIucmVxdWVzdER5bmFtaWNHZW9tZXRyeUZlYXR1cmU7XG52YXIgT01GcmVlRHluYW1pY0dlb21ldHJ5RmVhdHVyZSA9IE9iamVjdE1hbmFnZXIuZnJlZUR5bmFtaWNHZW9tZXRyeUZlYXR1cmU7XG5cbnZhciBUUklQTEVfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFRoZSBzbyBjYWxsZWQgdHJpcGxlIHByb2R1Y3QuIFVzZWQgdG8gZmluZCBhIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRvICh2MiAtIHYxKSBpbiB0aGUgZGlyZWN0aW9uIG9mIHYzLlxuICogKHYxIHggdjIpIHggdjMuXG4gKlxuICogQG1ldGhvZCB0cmlwbGVQcm9kdWN0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtWZWMzfSB2MSBUaGUgZmlyc3QgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gdjIgVGhlIHNlY29uZCBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSB2MyBUaGUgdGhpcmQgVmVjMy5cbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSByZXN1bHQgb2YgdGhlIHRyaXBsZSBwcm9kdWN0LlxuICovXG5mdW5jdGlvbiB0cmlwbGVQcm9kdWN0KHYxLCB2MiwgdjMpIHtcbiAgICB2YXIgdiA9IFRSSVBMRV9SRUdJU1RFUjtcblxuICAgIFZlYzMuY3Jvc3ModjEsIHYyLCB2KTtcbiAgICBWZWMzLmNyb3NzKHYsIHYzLCB2KTtcblxuICAgIHJldHVybiB2O1xufVxuXG4vKipcbiAqIE9mIGEgc2V0IG9mIHZlcnRpY2VzLCByZXRyaWV2ZXMgdGhlIHZlcnRleCBmdXJ0aGVzdCBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLlxuICpcbiAqIEBtZXRob2QgX2h1bGxTdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtWZWMzW119IHZlcnRpY2VzIFRoZSByZWZlcmVuY2Ugc2V0IG9mIFZlYzMncy5cbiAqIEBwYXJhbSB7VmVjM30gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdG8gY29tcGFyZSBhZ2FpbnN0LlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgdmVydGV4IGFuZCBpdHMgaW5kZXggaW4gdGhlIHZlcnRleCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gX2h1bGxTdXBwb3J0KHZlcnRpY2VzLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgZnVydGhlc3Q7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICB2YXIgZG90O1xuICAgIHZhciB2ZXJ0ZXg7XG4gICAgdmFyIGluZGV4O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgIGRvdCA9IFZlYzMuZG90KHZlcnRleCwgZGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKGRvdCA+IG1heCkge1xuICAgICAgICAgICAgZnVydGhlc3QgPSB2ZXJ0ZXg7XG4gICAgICAgICAgICBtYXggPSBkb3Q7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0ZXg6IGZ1cnRoZXN0LFxuICAgICAgICBpbmRleDogaW5kZXhcbiAgICB9O1xufVxuXG52YXIgVkVDX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBQT0lOVENIRUNLX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBBT19SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgQUJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIEFDX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBBRF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgQkNfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIEJEX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBVc2VkIGludGVybmFsbHkgdG8gcmVwcmVzZW50IHBvbHloZWRyYWwgZmFjZXQgaW5mb3JtYXRpb24uXG4gKlxuICogQGNsYXNzIER5bmFtaWNHZW9tZXRyeUZlYXR1cmVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZSBUaGUgZGlzdGFuY2Ugb2YgdGhlIGZlYXR1cmUgZnJvbSB0aGUgb3JpZ2luLlxuICogQHBhcmFtIHtWZWMzfSBub3JtYWwgVGhlIFZlYzMgb3J0aG9nb25hbCB0byB0aGUgZmVhdHVyZSwgcG9pbnRpbmcgb3V0IG9mIHRoZSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHZlcnRleEluZGljZXMgVGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzIHdoaWNoIGNvbXBvc2UgdGhlIGZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIER5bmFtaWNHZW9tZXRyeUZlYXR1cmUoZGlzdGFuY2UsIG5vcm1hbCwgdmVydGV4SW5kaWNlcykge1xuICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcbiAgICB0aGlzLnZlcnRleEluZGljZXMgPSB2ZXJ0ZXhJbmRpY2VzO1xufVxuXG4vKipcbiAqIFVzZWQgYnkgT2JqZWN0TWFuYWdlciB0byByZXNldCBvYmplY3RzLlxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJndW1lbnQgYXJyYXkgYW5hbG9nb3VzIHRvIHRoYXQgdXNlZCBpbiBpbnN0YW50aWF0aW9uLlxuICogQGNoYWluYWJsZVxuICovXG5EeW5hbWljR2VvbWV0cnlGZWF0dXJlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKGRpc3RhbmNlLCBub3JtYWwsIHZlcnRleEluZGljZXMpIHtcbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgdGhpcy52ZXJ0ZXhJbmRpY2VzID0gdmVydGV4SW5kaWNlcztcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ3Jvd2luZyBwb2x5aGVkcm9uLiBVc2VkIGluIENvbnZleEh1bGwgYW5kIGluIEdKSytFUEEgY29sbGlzaW9uIGRldGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgRHluYW1pY0dlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIER5bmFtaWNHZW9tZXRyeSgpIHtcbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG4gICAgdGhpcy5udW1WZXJ0aWNlcyA9IDA7XG4gICAgdGhpcy5mZWF0dXJlcyA9IFtdO1xuICAgIHRoaXMubnVtRmVhdHVyZXMgPSAwO1xuICAgIHRoaXMubGFzdFZlcnRleEluZGV4ID0gMDtcblxuICAgIHRoaXMuX0lEUG9vbCA9IHtcbiAgICAgICAgdmVydGljZXM6IFtdLFxuICAgICAgICBmZWF0dXJlczogW11cbiAgICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgT2JqZWN0TWFuYWdlciB0byByZXNldCBvYmplY3RzLlxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJndW1lbnQgYXJyYXkgYW5hbG9nb3VzIHRvIHRoYXQgdXNlZCBpbiBpbnN0YW50aWF0aW9uLlxuICogQGNoYWluYWJsZVxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuICAgIHRoaXMubnVtVmVydGljZXMgPSAwO1xuICAgIHRoaXMuZmVhdHVyZXMgPSBbXTtcbiAgICB0aGlzLm51bUZlYXR1cmVzID0gMDtcbiAgICB0aGlzLmxhc3RWZXJ0ZXhJbmRleCA9IDA7XG5cbiAgICB0aGlzLl9JRFBvb2wgPSB7XG4gICAgICAgIHZlcnRpY2VzOiBbXSxcbiAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSB2ZXJ0ZXggdG8gdGhlIHBvbHloZWRyb24uXG4gKlxuICogQG1ldGhvZCBhZGRWZXJ0ZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSB2ZXJ0ZXhPYmogT2JqZWN0IHJldHVybmVkIGJ5IHRoZSBzdXBwb3J0IGZ1bmN0aW9uLlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLmFkZFZlcnRleCA9IGZ1bmN0aW9uKHZlcnRleE9iaikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX0lEUG9vbC52ZXJ0aWNlcy5sZW5ndGggPyB0aGlzLl9JRFBvb2wudmVydGljZXMucG9wKCkgOiB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICB0aGlzLnZlcnRpY2VzW2luZGV4XSA9IHZlcnRleE9iajtcbiAgICB0aGlzLmxhc3RWZXJ0ZXhJbmRleCA9IGluZGV4O1xuICAgIHRoaXMubnVtVmVydGljZXMrKztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgdmVydGV4IGFuZCBwdXNoIGl0cyBsb2NhdGlvbiBpbiB0aGUgdmVydGV4IGFycmF5IHRvIHRoZSBJRFBvb2wgZm9yIGxhdGVyIHVzZS5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZVZlcnRleFxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IG9mIHRoZSB2ZXJ0ZXggdG8gcmVtb3ZlLlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnJlbW92ZVZlcnRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgdmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbaW5kZXhdO1xuICAgIHRoaXMudmVydGljZXNbaW5kZXhdID0gbnVsbDtcbiAgICB0aGlzLl9JRFBvb2wudmVydGljZXMucHVzaChpbmRleCk7XG4gICAgdGhpcy5udW1WZXJ0aWNlcy0tO1xuXG4gICAgcmV0dXJuIHZlcnRleDtcbn07XG5cbi8qKlxuICogQWRkIGEgZmVhdHVyZSAoZmFjZXQpIHRvIHRoZSBwb2x5aGVkcm9uLiBVc2VkIGludGVybmFsbHkgaW4gdGhlIHJlc2hhcGluZyBwcm9jZXNzLlxuICpcbiAqIEBtZXRob2QgYWRkRmVhdHVyZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlIFRoZSBkaXN0YW5jZSBvZiB0aGUgZmVhdHVyZSBmcm9tIHRoZSBvcmlnaW4uXG4gKiBAcGFyYW0ge1ZlYzN9IG5vcm1hbCBUaGUgZmFjZXQgbm9ybWFsLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gdmVydGV4SW5kaWNlcyBUaGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXMgd2hpY2ggY29tcG9zZSB0aGUgZmVhdHVyZS5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24oZGlzdGFuY2UsIG5vcm1hbCwgdmVydGV4SW5kaWNlcykge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX0lEUG9vbC5mZWF0dXJlcy5sZW5ndGggPyB0aGlzLl9JRFBvb2wuZmVhdHVyZXMucG9wKCkgOiB0aGlzLmZlYXR1cmVzLmxlbmd0aDtcbiAgICB0aGlzLmZlYXR1cmVzW2luZGV4XSA9IE9NUmVxdWVzdER5bmFtaWNHZW9tZXRyeUZlYXR1cmUoKS5yZXNldChkaXN0YW5jZSwgbm9ybWFsLCB2ZXJ0ZXhJbmRpY2VzKTtcbiAgICB0aGlzLm51bUZlYXR1cmVzKys7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGZlYXR1cmUgYW5kIHB1c2ggaXRzIGxvY2F0aW9uIGluIHRoZSBmZWF0dXJlIGFycmF5IHRvIHRoZSBJRFBvb2wgZm9yIGxhdGVyIHVzZS5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUZlYXR1cmVcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgZmVhdHVyZSB0byByZW1vdmUuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgdmFyIGZlYXR1cmUgPSB0aGlzLmZlYXR1cmVzW2luZGV4XTtcbiAgICB0aGlzLmZlYXR1cmVzW2luZGV4XSA9IG51bGw7XG4gICAgdGhpcy5fSURQb29sLmZlYXR1cmVzLnB1c2goaW5kZXgpO1xuICAgIHRoaXMubnVtRmVhdHVyZXMtLTtcblxuICAgIE9NRnJlZUR5bmFtaWNHZW9tZXRyeUZlYXR1cmUoZmVhdHVyZSk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsYXN0IHZlcnRleCBvYmplY3QgYWRkZWQgdG8gdGhlIGdlb21ldHJ5LlxuICpcbiAqIEBtZXRob2QgZ2V0TGFzdFZlcnRleFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLmdldExhc3RWZXJ0ZXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNlc1t0aGlzLmxhc3RWZXJ0ZXhJbmRleF07XG59O1xuXG4vKipcbiAqIE9mIHRoZSBjbG9zZXN0IGZhY2UgdG8gdGhlIG9yaWdpbiwgcmV0dXJucyB0aGUgbm9ybWFsIHZlY3RvciBwb2ludGVkIGF3YXkgZnJvbSB0aGUgb3JpZ2luLlxuICpcbiAqIEBtZXRob2QgZ2V0RmVhdHVyZUNsb3Nlc3RUb09yaWdpblxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLmdldEZlYXR1cmVDbG9zZXN0VG9PcmlnaW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgdmFyIGNsb3Nlc3QgPSBudWxsO1xuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV07XG4gICAgICAgIGlmICghZmVhdHVyZSkgY29udGludWU7XG4gICAgICAgIGlmIChmZWF0dXJlLmRpc3RhbmNlIDwgbWluKSB7XG4gICAgICAgICAgICBtaW4gPSBmZWF0dXJlLmRpc3RhbmNlO1xuICAgICAgICAgICAgY2xvc2VzdCA9IGZlYXR1cmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3Q7XG59O1xuXG4vKipcbiAqIEFkZHMgZWRnZSBpZiBub3QgYWxyZWFkeSBvbiB0aGUgZnJvbnRpZXIsIHJlbW92ZXMgaWYgdGhlIGVkZ2Ugb3IgaXRzIHJldmVyc2UgYXJlIG9uIHRoZSBmcm9udGllci5cbiAqIFVzZWQgd2hlbiByZXNoYXBpbmcgRHluYW1pY0dlb21ldHJ5J3MuXG4gKlxuICogQG1ldGhvZCBfdmFsaWRhdGVFZGdlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3RbXX0gdmVydGljZXMgVmVjMyByZWZlcmVuY2UgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcltdW119IGZyb250aWVyIEN1cnJlbnQgZWRnZXMgcG90ZW50aWFsbHkgc2VwYXJhdGluZyB0aGUgZmVhdHVyZXMgdG8gcmVtb3ZlIGZyb20gdGhlIHBlcnNpc3RhbnQgc2hhcGUuXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgVGhlIGluZGV4IG9mIHRoZSBzdGFydGluZyBWZWMzIG9uIHRoZSBlZGdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBUaGUgaW5kZXggb2YgdGhlIGN1bG1pbmF0aW5nIFZlYzMuXG4gKi9cbmZ1bmN0aW9uIF92YWxpZGF0ZUVkZ2UodmVydGljZXMsIGZyb250aWVyLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGUwID0gdmVydGljZXNbc3RhcnRdLnZlcnRleDtcbiAgICB2YXIgZTEgPSB2ZXJ0aWNlc1tlbmRdLnZlcnRleDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZnJvbnRpZXIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBmcm9udGllcltpXTtcbiAgICAgICAgaWYgKCFlZGdlKSBjb250aW51ZTtcbiAgICAgICAgdmFyIHYwID0gdmVydGljZXNbZWRnZVswXV0udmVydGV4O1xuICAgICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1tlZGdlWzFdXS52ZXJ0ZXg7XG4gICAgICAgIGlmICgoZTAgPT09IHYwICYmIChlMSA9PT0gdjEpKSB8fCAoZTAgPT09IHYxICYmIChlMSA9PT0gdjApKSkge1xuICAgICAgICAgICAgZnJvbnRpZXJbaV0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb250aWVyLnB1c2goW3N0YXJ0LCBlbmRdKTtcbn1cblxuLyoqXG4gKiBCYXNlZCBvbiB0aGUgbGFzdCAoZXh0ZXJpb3IpIHBvaW50IGFkZGVkIHRvIHRoZSBwb2x5aGVkcm9uLCByZW1vdmVzIGZlYXR1cmVzIGFzIG5lY2Vzc2FyeSBhbmQgcmVkZXRlcm1pbmVzXG4gKiBpdHMgKGNvbnZleCkgc2hhcGUgdG8gaW5jbHVkZSB0aGUgbmV3IHBvaW50IGJ5IGFkZGluZyB0cmlhbmdsZSBmZWF0dXJlcy4gVXNlcyByZWZlcmVuY2VQb2ludCwgYSBwb2ludCBvbiB0aGUgc2hhcGUnc1xuICogaW50ZXJpb3IsIHRvIGVuc3VyZSBmZWF0dXJlIG5vcm1hbHMgcG9pbnQgb3V0d2FyZCwgZWxzZSB0YWtlcyByZWZlcmVuY2VQb2ludCB0byBiZSB0aGUgb3JpZ2luLlxuICpcbiAqIEBtZXRob2QgcmVzaGFwZVxuICogQHBhcmFtIHtWZWMzfSByZWZlcmVuY2VQb2ludCBQb2ludCBrbm93biB0byBiZSBpbiB0aGUgaW50ZXJpb3IsIHVzZWQgdG8gb3JpZW50IGZlYXR1cmUgbm9ybWFscy5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24ocmVmZXJlbmNlUG9pbnQpIHtcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHZhciBwb2ludCA9IHRoaXMuZ2V0TGFzdFZlcnRleCgpLnZlcnRleDtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xuICAgIHZhciB2ZXJ0ZXhPbkZlYXR1cmU7XG4gICAgdmFyIGZlYXR1cmVWZXJ0aWNlcztcblxuICAgIHZhciBpLCBqLCBsZW47XG5cbiAgICAvLyBUaGUgcmVtb3ZhbCBvZiBmZWF0dXJlcyBjcmVhdGVzIGEgaG9sZSBpbiB0aGUgcG9seWhlZHJvbiAtLSBmcm9udGllckVkZ2VzIG1haW50YWlucyB0aGUgZWRnZXNcbiAgICAvLyBvZiB0aGlzIGhvbGUsIGVhY2ggb2Ygd2hpY2ggd2lsbCBmb3JtIG9uZSBlZGdlIG9mIGEgbmV3IGZlYXR1cmUgdG8gYmUgY3JlYXRlZFxuICAgIHZhciBmcm9udGllckVkZ2VzID0gW107XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIWZlYXR1cmVzW2ldKSBjb250aW51ZTtcbiAgICAgICAgZmVhdHVyZVZlcnRpY2VzID0gZmVhdHVyZXNbaV0udmVydGV4SW5kaWNlcztcbiAgICAgICAgdmVydGV4T25GZWF0dXJlID0gdmVydGljZXNbZmVhdHVyZVZlcnRpY2VzWzBdXS52ZXJ0ZXg7XG4gICAgICAgIC8vIElmIHBvaW50IGlzICdhYm92ZScgdGhlIGZlYXR1cmUsIHJlbW92ZSB0aGF0IGZlYXR1cmUsIGFuZCBjaGVjayB0byBhZGQgaXRzIGVkZ2VzIHRvIHRoZSBmcm9udGllci5cbiAgICAgICAgaWYgKFZlYzMuZG90KGZlYXR1cmVzW2ldLm5vcm1hbCwgVmVjMy5zdWJ0cmFjdChwb2ludCwgdmVydGV4T25GZWF0dXJlLCBQT0lOVENIRUNLX1JFR0lTVEVSKSkgPiAtMC4wMDEpIHtcbiAgICAgICAgICAgIF92YWxpZGF0ZUVkZ2UodmVydGljZXMsIGZyb250aWVyRWRnZXMsIGZlYXR1cmVWZXJ0aWNlc1swXSwgZmVhdHVyZVZlcnRpY2VzWzFdKTtcbiAgICAgICAgICAgIF92YWxpZGF0ZUVkZ2UodmVydGljZXMsIGZyb250aWVyRWRnZXMsIGZlYXR1cmVWZXJ0aWNlc1sxXSwgZmVhdHVyZVZlcnRpY2VzWzJdKTtcbiAgICAgICAgICAgIF92YWxpZGF0ZUVkZ2UodmVydGljZXMsIGZyb250aWVyRWRnZXMsIGZlYXR1cmVWZXJ0aWNlc1syXSwgZmVhdHVyZVZlcnRpY2VzWzBdKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRmVhdHVyZShpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBBID0gcG9pbnQ7XG4gICAgdmFyIGEgPSB0aGlzLmxhc3RWZXJ0ZXhJbmRleDtcbiAgICBmb3IgKGogPSAwLCBsZW4gPSBmcm9udGllckVkZ2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGlmICghZnJvbnRpZXJFZGdlc1tqXSkgY29udGludWU7XG4gICAgICAgIHZhciBiID0gZnJvbnRpZXJFZGdlc1tqXVswXTtcbiAgICAgICAgdmFyIGMgPSBmcm9udGllckVkZ2VzW2pdWzFdO1xuICAgICAgICB2YXIgQiA9IHZlcnRpY2VzW2JdLnZlcnRleDtcbiAgICAgICAgdmFyIEMgPSB2ZXJ0aWNlc1tjXS52ZXJ0ZXg7XG5cbiAgICAgICAgdmFyIEFCID0gVmVjMy5zdWJ0cmFjdChCLCBBLCBBQl9SRUdJU1RFUik7XG4gICAgICAgIHZhciBBQyA9IFZlYzMuc3VidHJhY3QoQywgQSwgQUNfUkVHSVNURVIpO1xuICAgICAgICB2YXIgQUJDID0gVmVjMy5jcm9zcyhBQiwgQUMsIG5ldyBWZWMzKCkpO1xuICAgICAgICBBQkMubm9ybWFsaXplKCk7XG5cbiAgICAgICAgaWYgKCFyZWZlcmVuY2VQb2ludCkge1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gVmVjMy5kb3QoQUJDLCBBKTtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDApIHtcbiAgICAgICAgICAgICAgICBBQkMuaW52ZXJ0KCk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoZGlzdGFuY2UsIEFCQywgW2EsIGIsIGNdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZWZlcmVuY2UgPSBWZWMzLnN1YnRyYWN0KHJlZmVyZW5jZVBvaW50LCBBLCBWRUNfUkVHSVNURVIpO1xuICAgICAgICAgICAgaWYgKFZlYzMuZG90KEFCQywgcmVmZXJlbmNlKSA+IC0wLjAwMSkgQUJDLmludmVydCgpO1xuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKG51bGwsIEFCQywgW2EsIGIsIGNdKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBTaW1wbGV4IGluc3RhbmNlIGNvbnRhaW5zIHRoZSBvcmlnaW4sIHJldHVybnMgdHJ1ZSBvciBmYWxzZS5cbiAqIElmIGZhbHNlLCByZW1vdmVzIGEgcG9pbnQgYW5kLCBhcyBhIHNpZGUgZWZmZWN0LCBjaGFuZ2VzIGlucHV0IGRpcmVjdGlvbiB0byBiZSBib3RoXG4gKiBvcnRob2dvbmFsIHRvIHRoZSBjdXJyZW50IHdvcmtpbmcgc2ltcGxleCBhbmQgcG9pbnQgdG93YXJkIHRoZSBvcmlnaW4uXG4gKiBDYWxscyBjYWxsYmFjayBvbiB0aGUgcmVtb3ZlZCBwb2ludC5cbiAqXG4gKiBAbWV0aG9kIHNpbXBsZXhDb250YWluc09yaWdpblxuICogQHBhcmFtIHtWZWMzfSBkaXJlY3Rpb24gVmVjdG9yIHVzZWQgdG8gc3RvcmUgdGhlIG5ldyBzZWFyY2ggZGlyZWN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gaW52b2tlZCB3aXRoIHRoZSByZW1vdmVkIHZlcnRleCwgdXNlZCBlLmcuIHRvIGZyZWUgdGhlIHZlcnRleCBvYmplY3RcbiAqIGluIHRoZSBvYmplY3QgbWFuYWdlci5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSByZXN1bHQgb2YgdGhlIGNvbnRhaW5tZW50IGNoZWNrLlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnNpbXBsZXhDb250YWluc09yaWdpbiA9IGZ1bmN0aW9uKGRpcmVjdGlvbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgbnVtVmVydGljZXMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgIHZhciBhID0gdGhpcy5sYXN0VmVydGV4SW5kZXg7XG4gICAgdmFyIGIgPSBhIC0gMTtcbiAgICB2YXIgYyA9IGEgLSAyO1xuICAgIHZhciBkID0gYSAtIDM7XG5cbiAgICBiID0gYiA8IDAgPyBiICsgbnVtVmVydGljZXMgOiBiO1xuICAgIGMgPSBjIDwgMCA/IGMgKyBudW1WZXJ0aWNlcyA6IGM7XG4gICAgZCA9IGQgPCAwID8gZCArIG51bVZlcnRpY2VzIDogZDtcblxuICAgIHZhciBBID0gdGhpcy52ZXJ0aWNlc1thXS52ZXJ0ZXg7XG4gICAgdmFyIEIgPSB0aGlzLnZlcnRpY2VzW2JdLnZlcnRleDtcbiAgICB2YXIgQyA9IHRoaXMudmVydGljZXNbY10udmVydGV4O1xuICAgIHZhciBEID0gdGhpcy52ZXJ0aWNlc1tkXS52ZXJ0ZXg7XG5cbiAgICB2YXIgQU8gPSBWZWMzLnNjYWxlKEEsIC0xLCBBT19SRUdJU1RFUik7XG4gICAgdmFyIEFCID0gVmVjMy5zdWJ0cmFjdChCLCBBLCBBQl9SRUdJU1RFUik7XG4gICAgdmFyIEFDLCBBRCwgQkMsIEJEO1xuICAgIHZhciBBQkMsIEFDRCwgQUJELCBCQ0Q7XG4gICAgdmFyIGRpc3RhbmNlQUJDLCBkaXN0YW5jZUFDRCwgZGlzdGFuY2VBQkQsIGRpc3RhbmNlQkNEO1xuXG4gICAgdmFyIHZlcnRleFRvUmVtb3ZlO1xuXG4gICAgaWYgKG51bVZlcnRpY2VzID09PSA0KSB7XG4gICAgICAgIC8vIFRldHJhaGVkcm9uXG4gICAgICAgIEFDID0gVmVjMy5zdWJ0cmFjdChDLCBBLCBBQ19SRUdJU1RFUik7XG4gICAgICAgIEFEID0gVmVjMy5zdWJ0cmFjdChELCBBLCBBRF9SRUdJU1RFUik7XG5cbiAgICAgICAgQUJDID0gVmVjMy5jcm9zcyhBQiwgQUMsIG5ldyBWZWMzKCkpO1xuICAgICAgICBBQ0QgPSBWZWMzLmNyb3NzKEFDLCBBRCwgbmV3IFZlYzMoKSk7XG4gICAgICAgIEFCRCA9IFZlYzMuY3Jvc3MoQUIsIEFELCBuZXcgVmVjMygpKTtcbiAgICAgICAgQUJDLm5vcm1hbGl6ZSgpO1xuICAgICAgICBBQ0Qubm9ybWFsaXplKCk7XG4gICAgICAgIEFCRC5ub3JtYWxpemUoKTtcbiAgICAgICAgaWYgKFZlYzMuZG90KEFCQywgQUQpID4gMCkgQUJDLmludmVydCgpO1xuICAgICAgICBpZiAoVmVjMy5kb3QoQUNELCBBQikgPiAwKSBBQ0QuaW52ZXJ0KCk7XG4gICAgICAgIGlmIChWZWMzLmRvdChBQkQsIEFDKSA+IDApIEFCRC5pbnZlcnQoKTtcbiAgICAgICAgLy8gRG9uJ3QgbmVlZCB0byBjaGVjayBCQ0QgYmVjYXVzZSB3ZSB3b3VsZCBoYXZlIGp1c3QgY2hlY2tlZCB0aGF0IGluIHRoZSBwcmV2aW91cyBpdGVyYXRpb25cbiAgICAgICAgLy8gLS0gd2UgYWRkZWQgQSB0byB0aGUgQkNEIHRyaWFuZ2xlIGJlY2F1c2UgQSB3YXMgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgb3JpZ2luLlxuXG4gICAgICAgIGRpc3RhbmNlQUJDID0gVmVjMy5kb3QoQUJDLCBBTyk7XG4gICAgICAgIGRpc3RhbmNlQUNEID0gVmVjMy5kb3QoQUNELCBBTyk7XG4gICAgICAgIGRpc3RhbmNlQUJEID0gVmVjMy5kb3QoQUJELCBBTyk7XG5cbiAgICAgICAgLy8gTm9ybXMgcG9pbnQgYXdheSBmcm9tIG9yaWdpbiAtPiBvcmlnaW4gaXMgaW5zaWRlIHRldHJhaGVkcm9uXG4gICAgICAgIGlmIChkaXN0YW5jZUFCQyA8IDAuMDAxICYmIGRpc3RhbmNlQUJEIDwgMC4wMDEgJiYgZGlzdGFuY2VBQ0QgPCAwLjAwMSkge1xuICAgICAgICAgICAgQkMgPSBWZWMzLnN1YnRyYWN0KEMsIEIsIEJDX1JFR0lTVEVSKTtcbiAgICAgICAgICAgIEJEID0gVmVjMy5zdWJ0cmFjdChELCBCLCBCRF9SRUdJU1RFUik7XG4gICAgICAgICAgICBCQ0QgPSBWZWMzLmNyb3NzKEJDLCBCRCwgbmV3IFZlYzMoKSk7XG4gICAgICAgICAgICBCQ0Qubm9ybWFsaXplKCk7XG4gICAgICAgICAgICBpZiAoVmVjMy5kb3QoQkNELCBBQikgPD0gMCkgQkNELmludmVydCgpO1xuICAgICAgICAgICAgZGlzdGFuY2VCQ0QgPSAtMSAqIFZlYzMuZG90KEJDRCxCKTtcbiAgICAgICAgICAgIC8vIFByZXAgZmVhdHVyZXMgZm9yIEVQQVxuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKC1kaXN0YW5jZUFCQywgQUJDLCBbYSxiLGNdKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZSgtZGlzdGFuY2VBQ0QsIEFDRCwgW2EsYyxkXSk7XG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoLWRpc3RhbmNlQUJELCBBQkQsIFthLGQsYl0pO1xuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKC1kaXN0YW5jZUJDRCwgQkNELCBbYixjLGRdKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpc3RhbmNlQUJDID49IDAuMDAxKSB7XG4gICAgICAgICAgICB2ZXJ0ZXhUb1JlbW92ZSA9IHRoaXMucmVtb3ZlVmVydGV4KGQpO1xuICAgICAgICAgICAgZGlyZWN0aW9uLmNvcHkoQUJDKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXN0YW5jZUFDRCA+PSAwLjAwMSkge1xuICAgICAgICAgICAgdmVydGV4VG9SZW1vdmUgPSB0aGlzLnJlbW92ZVZlcnRleChiKTtcbiAgICAgICAgICAgIGRpcmVjdGlvbi5jb3B5KEFDRCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ZXJ0ZXhUb1JlbW92ZSA9IHRoaXMucmVtb3ZlVmVydGV4KGMpO1xuICAgICAgICAgICAgZGlyZWN0aW9uLmNvcHkoQUJEKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChudW1WZXJ0aWNlcyA9PT0gMykge1xuICAgICAgICAvLyBUcmlhbmdsZVxuICAgICAgICBBQyA9IFZlYzMuc3VidHJhY3QoQywgQSwgQUNfUkVHSVNURVIpO1xuICAgICAgICBWZWMzLmNyb3NzKEFCLCBBQywgZGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKFZlYzMuZG90KGRpcmVjdGlvbiwgQU8pIDw9IDApIGRpcmVjdGlvbi5pbnZlcnQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIExpbmVcbiAgICAgICAgZGlyZWN0aW9uLmNvcHkodHJpcGxlUHJvZHVjdChBQiwgQU8sIEFCKSk7XG4gICAgfVxuICAgIGlmICh2ZXJ0ZXhUb1JlbW92ZSAmJiBjYWxsYmFjaykgY2FsbGJhY2sodmVydGV4VG9SZW1vdmUpO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgVmVjMydzLCBjb21wdXRlcyB0aGUgY29udmV4IGh1bGwuIFVzZWQgaW4gY29uc3RydWN0aW5nIGJvZGllcyBpbiB0aGUgcGh5c2ljcyBzeXN0ZW0gYW5kIHRvXG4gKiBjcmVhdGUgY3VzdG9tIEdMIG1lc2hlcy5cbiAqXG4gKiBAY2xhc3MgQ29udmV4SHVsbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1ZlYzNbXX0gdmVydGljZXMgQ2xvdWQgb2YgdmVydGljZXMgb2Ygd2hpY2ggdGhlIGVuY2xvc2luZyBjb252ZXggaHVsbCBpcyBkZXNpcmVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtpdGVyYXRpb25zID0gMWUzXSBNYXhpbXVtIG51bWJlciBvZiB2ZXJ0aWNlcyB0byBjb21wb3NlIHRoZSBjb252ZXggaHVsbC5cbiAqL1xuZnVuY3Rpb24gQ29udmV4SHVsbCh2ZXJ0aWNlcywgaXRlcmF0aW9ucykge1xuICAgIGl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zIHx8IDFlMztcbiAgICB2YXIgaHVsbCA9IF9jb21wdXRlQ29udmV4SHVsbCh2ZXJ0aWNlcywgaXRlcmF0aW9ucyk7XG5cbiAgICB2YXIgaSwgbGVuO1xuXG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBodWxsLmZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBmID0gaHVsbC5mZWF0dXJlc1tpXTtcbiAgICAgICAgaWYgKGYpIGluZGljZXMucHVzaChmLnZlcnRleEluZGljZXMpO1xuICAgIH1cblxuICAgIHZhciBwb2x5aGVkcmFsUHJvcGVydGllcyA9IF9jb21wdXRlUG9seWhlZHJhbFByb3BlcnRpZXMoaHVsbC52ZXJ0aWNlcywgaW5kaWNlcyk7XG4gICAgdmFyIGNlbnRyb2lkID0gcG9seWhlZHJhbFByb3BlcnRpZXMuY2VudHJvaWQ7XG5cbiAgICB2YXIgd29ybGRWZXJ0aWNlcyA9IFtdO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGh1bGwudmVydGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgd29ybGRWZXJ0aWNlcy5wdXNoKFZlYzMuc3VidHJhY3QoaHVsbC52ZXJ0aWNlc1tpXS52ZXJ0ZXgsIGNlbnRyb2lkLCBuZXcgVmVjMygpKSk7XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB3b3JsZFZlcnRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG5vcm1hbHMucHVzaChWZWMzLm5vcm1hbGl6ZSh3b3JsZFZlcnRpY2VzW2ldLCBuZXcgVmVjMygpKSk7XG4gICAgfVxuXG4gICAgdmFyIGdyYXBoID0ge307XG4gICAgdmFyIF9uZWlnaGJvck1hdHJpeCA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhID0gaW5kaWNlc1tpXVswXTtcbiAgICAgICAgdmFyIGIgPSBpbmRpY2VzW2ldWzFdO1xuICAgICAgICB2YXIgYyA9IGluZGljZXNbaV1bMl07XG5cbiAgICAgICAgX25laWdoYm9yTWF0cml4W2FdID0gX25laWdoYm9yTWF0cml4W2FdIHx8IHt9O1xuICAgICAgICBfbmVpZ2hib3JNYXRyaXhbYl0gPSBfbmVpZ2hib3JNYXRyaXhbYl0gfHwge307XG4gICAgICAgIF9uZWlnaGJvck1hdHJpeFtjXSA9IF9uZWlnaGJvck1hdHJpeFtjXSB8fCB7fTtcblxuICAgICAgICBncmFwaFthXSA9IGdyYXBoW2FdIHx8IFtdO1xuICAgICAgICBncmFwaFtiXSA9IGdyYXBoW2JdIHx8IFtdO1xuICAgICAgICBncmFwaFtjXSA9IGdyYXBoW2NdIHx8IFtdO1xuXG4gICAgICAgIGlmICghX25laWdoYm9yTWF0cml4W2FdW2JdKSB7XG4gICAgICAgICAgICBfbmVpZ2hib3JNYXRyaXhbYV1bYl0gPSAxO1xuICAgICAgICAgICAgZ3JhcGhbYV0ucHVzaChiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9uZWlnaGJvck1hdHJpeFthXVtjXSkge1xuICAgICAgICAgICAgX25laWdoYm9yTWF0cml4W2FdW2NdID0gMTtcbiAgICAgICAgICAgIGdyYXBoW2FdLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfbmVpZ2hib3JNYXRyaXhbYl1bYV0pIHtcbiAgICAgICAgICAgIF9uZWlnaGJvck1hdHJpeFtiXVthXSA9IDE7XG4gICAgICAgICAgICBncmFwaFtiXS5wdXNoKGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX25laWdoYm9yTWF0cml4W2JdW2NdKSB7XG4gICAgICAgICAgICBfbmVpZ2hib3JNYXRyaXhbYl1bY10gPSAxO1xuICAgICAgICAgICAgZ3JhcGhbYl0ucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9uZWlnaGJvck1hdHJpeFtjXVthXSkge1xuICAgICAgICAgICAgX25laWdoYm9yTWF0cml4W2NdW2FdID0gMTtcbiAgICAgICAgICAgIGdyYXBoW2NdLnB1c2goYSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfbmVpZ2hib3JNYXRyaXhbY11bYl0pIHtcbiAgICAgICAgICAgIF9uZWlnaGJvck1hdHJpeFtjXVtiXSA9IDE7XG4gICAgICAgICAgICBncmFwaFtjXS5wdXNoKGIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcztcbiAgICB0aGlzLnZlcnRpY2VzID0gd29ybGRWZXJ0aWNlcztcbiAgICB0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xuICAgIHRoaXMucG9seWhlZHJhbFByb3BlcnRpZXMgPSBwb2x5aGVkcmFsUHJvcGVydGllcztcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgdGhlIGFjdHVhbCBjb21wdXRhdGlvbiBvZiB0aGUgY29udmV4IGh1bGwuXG4gKlxuICogQG1ldGhvZCBfY29tcHV0ZUNvbnZleEh1bGxcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1ZlYzNbXX0gdmVydGljZXMgQ2xvdWQgb2YgdmVydGljZXMgb2Ygd2hpY2ggdGhlIGVuY2xvc2luZyBjb252ZXggaHVsbCBpcyBkZXNpcmVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEl0ZXJhdGlvbnMgTWF4aW11bSBudW1iZXIgb2YgdmVydGljZXMgdG8gY29tcG9zZSB0aGUgY29udmV4IGh1bGwuXG4gKiBAcmV0dXJuIHtEeW5hbWljR2VvbWV0cnl9IFRoZSBjb21wdXRlZCBodWxsLlxuICovXG5mdW5jdGlvbiBfY29tcHV0ZUNvbnZleEh1bGwodmVydGljZXMsIG1heEl0ZXJhdGlvbnMpIHtcbiAgICB2YXIgaHVsbCA9IG5ldyBEeW5hbWljR2VvbWV0cnkoKTtcblxuICAgIGh1bGwuYWRkVmVydGV4KF9odWxsU3VwcG9ydCh2ZXJ0aWNlcywgbmV3IFZlYzMoMSwgMCwgMCkpKTtcbiAgICBodWxsLmFkZFZlcnRleChfaHVsbFN1cHBvcnQodmVydGljZXMsIG5ldyBWZWMzKC0xLCAwLCAwKSkpO1xuICAgIHZhciBBID0gaHVsbC52ZXJ0aWNlc1swXS52ZXJ0ZXg7XG4gICAgdmFyIEIgPSBodWxsLnZlcnRpY2VzWzFdLnZlcnRleDtcbiAgICB2YXIgQUIgPSBWZWMzLnN1YnRyYWN0KEIsIEEsIEFCX1JFR0lTVEVSKTtcblxuICAgIHZhciBkb3Q7XG4gICAgdmFyIHZlcnRleDtcbiAgICB2YXIgZnVydGhlc3Q7XG4gICAgdmFyIGluZGV4O1xuICAgIHZhciBpLCBsZW47XG5cbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgIGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgaWYgKHZlcnRleCA9PT0gQSB8fCB2ZXJ0ZXggPT09IEIpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgQVYgPSBWZWMzLnN1YnRyYWN0KHZlcnRleCwgQSwgVkVDX1JFR0lTVEVSKTtcbiAgICAgICAgZG90ID0gVmVjMy5kb3QoQVYsIHRyaXBsZVByb2R1Y3QoQUIsIEFWLCBBQikpO1xuICAgICAgICBkb3QgPSBkb3QgPCAwID8gZG90ICogLTEgOiBkb3Q7XG4gICAgICAgIGlmIChkb3QgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IGRvdDtcbiAgICAgICAgICAgIGZ1cnRoZXN0ID0gdmVydGV4O1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGh1bGwuYWRkVmVydGV4KHtcbiAgICAgICAgdmVydGV4OiBmdXJ0aGVzdCxcbiAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSk7XG5cbiAgICB2YXIgQyA9IGZ1cnRoZXN0O1xuICAgIHZhciBBQyA9IFZlYzMuc3VidHJhY3QoQywgQSwgQUNfUkVHSVNURVIpO1xuICAgIHZhciBBQkMgPSBWZWMzLmNyb3NzKEFCLCBBQywgbmV3IFZlYzMoKSk7XG4gICAgQUJDLm5vcm1hbGl6ZSgpO1xuXG4gICAgbWF4ID0gLUluZmluaXR5O1xuICAgIGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgaWYgKHZlcnRleCA9PT0gQSB8fCB2ZXJ0ZXggPT09IEIgfHwgdmVydGV4ID09PSBDKSBjb250aW51ZTtcbiAgICAgICAgZG90ID0gVmVjMy5kb3QoVmVjMy5zdWJ0cmFjdCh2ZXJ0ZXgsIEEsIFZFQ19SRUdJU1RFUiksIEFCQyk7XG4gICAgICAgIGRvdCA9IGRvdCA8IDAgPyBkb3QgKiAtMSA6IGRvdDtcbiAgICAgICAgaWYgKGRvdCA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gZG90O1xuICAgICAgICAgICAgZnVydGhlc3QgPSB2ZXJ0ZXg7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaHVsbC5hZGRWZXJ0ZXgoe1xuICAgICAgICB2ZXJ0ZXg6IGZ1cnRoZXN0LFxuICAgICAgICBpbmRleDogaW5kZXhcbiAgICB9KTtcblxuICAgIHZhciBEID0gZnVydGhlc3Q7XG4gICAgdmFyIEFEID0gVmVjMy5zdWJ0cmFjdChELCBBLCBBRF9SRUdJU1RFUik7XG4gICAgdmFyIEJDID0gVmVjMy5zdWJ0cmFjdChDLCBCLCBCQ19SRUdJU1RFUik7XG4gICAgdmFyIEJEID0gVmVjMy5zdWJ0cmFjdChELCBCLCBCRF9SRUdJU1RFUik7XG5cbiAgICB2YXIgQUNEID0gVmVjMy5jcm9zcyhBQywgQUQsIG5ldyBWZWMzKCkpO1xuICAgIHZhciBBQkQgPSBWZWMzLmNyb3NzKEFCLCBBRCwgbmV3IFZlYzMoKSk7XG4gICAgdmFyIEJDRCA9IFZlYzMuY3Jvc3MoQkMsIEJELCBuZXcgVmVjMygpKTtcbiAgICBBQ0Qubm9ybWFsaXplKCk7XG4gICAgQUJELm5vcm1hbGl6ZSgpO1xuICAgIEJDRC5ub3JtYWxpemUoKTtcbiAgICBpZiAoVmVjMy5kb3QoQUJDLCBBRCkgPiAwKSBBQkMuaW52ZXJ0KCk7XG4gICAgaWYgKFZlYzMuZG90KEFDRCwgQUIpID4gMCkgQUNELmludmVydCgpO1xuICAgIGlmIChWZWMzLmRvdChBQkQsIEFDKSA+IDApIEFCRC5pbnZlcnQoKTtcbiAgICBpZiAoVmVjMy5kb3QoQkNELCBBQikgPCAwKSBCQ0QuaW52ZXJ0KCk7XG5cbiAgICB2YXIgYSA9IDA7XG4gICAgdmFyIGIgPSAxO1xuICAgIHZhciBjID0gMjtcbiAgICB2YXIgZCA9IDM7XG5cbiAgICBodWxsLmFkZEZlYXR1cmUobnVsbCwgQUJDLCBbYSwgYiwgY10pO1xuICAgIGh1bGwuYWRkRmVhdHVyZShudWxsLCBBQ0QsIFthLCBjLCBkXSk7XG4gICAgaHVsbC5hZGRGZWF0dXJlKG51bGwsIEFCRCwgW2EsIGIsIGRdKTtcbiAgICBodWxsLmFkZEZlYXR1cmUobnVsbCwgQkNELCBbYiwgYywgZF0pO1xuXG4gICAgdmFyIGFzc2lnbmVkID0ge307XG4gICAgZm9yIChpID0gMCwgbGVuID0gaHVsbC52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgIGFzc2lnbmVkW2h1bGwudmVydGljZXNbaV0uaW5kZXhdID0gdHJ1ZTtcbiAgICB9XG5cblxuICAgIHZhciBjeCA9IEEueCArIEIueCArIEMueCArIEQueDtcbiAgICB2YXIgY3kgPSBBLnkgKyBCLnkgKyBDLnkgKyBELnk7XG4gICAgdmFyIGN6ID0gQS56ICsgQi56ICsgQy56ICsgRC56O1xuICAgIHZhciByZWZlcmVuY2VQb2ludCA9IG5ldyBWZWMzKGN4LCBjeSwgY3opO1xuICAgIHJlZmVyZW5jZVBvaW50LnNjYWxlKDAuMjUpO1xuXG4gICAgdmFyIGZlYXR1cmVzID0gaHVsbC5mZWF0dXJlcztcbiAgICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgICB3aGlsZSAoaXRlcmF0aW9uKysgPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgIHZhciBjdXJyZW50RmVhdHVyZSA9IG51bGw7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWZlYXR1cmVzW2ldIHx8IGZlYXR1cmVzW2ldLmRvbmUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY3VycmVudEZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcbiAgICAgICAgICAgIGZ1cnRoZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIGluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIEEgPSBodWxsLnZlcnRpY2VzW2N1cnJlbnRGZWF0dXJlLnZlcnRleEluZGljZXNbMF1dLnZlcnRleDtcbiAgICAgICAgICAgIHZhciBzID0gX2h1bGxTdXBwb3J0KHZlcnRpY2VzLCBjdXJyZW50RmVhdHVyZS5ub3JtYWwpO1xuICAgICAgICAgICAgZnVydGhlc3QgPSBzLnZlcnRleDtcbiAgICAgICAgICAgIGluZGV4ID0gcy5pbmRleDtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gVmVjMy5kb3QoVmVjMy5zdWJ0cmFjdChmdXJ0aGVzdCwgQSwgVkVDX1JFR0lTVEVSKSwgY3VycmVudEZlYXR1cmUubm9ybWFsKTtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCAwLjAwMSB8fCBhc3NpZ25lZFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RmVhdHVyZS5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXNzaWduZWRbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIGh1bGwuYWRkVmVydGV4KHMpO1xuICAgICAgICAgICAgaHVsbC5yZXNoYXBlKHJlZmVyZW5jZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gZmVhdHVyZSBoYXMgcG9pbnRzICdhYm92ZScgaXQgLT4gZmluaXNoZWRcbiAgICAgICAgaWYgKGN1cnJlbnRGZWF0dXJlID09PSBudWxsKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gaHVsbDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCBpbiBfY29tcHV0ZVBvbHloZWRyYWxQcm9wZXJ0aWVzLlxuICogU2V0cyBmMCAtIGYyIGFuZCBnMCAtIGcyIGRlcGVuZGluZyBvbiB3MCAtIHcyLlxuICpcbiAqIEBtZXRob2QgX3N1YmV4cHJlc3Npb25zXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHcwIFJlZmVyZW5jZSB4IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge051bWJlcn0gdzEgUmVmZXJlbmNlIHkgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB3MiBSZWZlcmVuY2UgeiBjb29yZGluYXRlLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gZiBPbmUgb2YgdHdvIG91dHB1dCByZWdpc3RlcnMgdG8gY29udGFpbiB0aGUgcmVzdWx0IG9mIHRoZSBjYWxjdWxhdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyW119IGcgT25lIG9mIHR3byBvdXRwdXQgcmVnaXN0ZXJzIHRvIGNvbnRhaW4gdGhlIHJlc3VsdCBvZiB0aGUgY2FsY3VsYXRpb24uXG4gKi9cbmZ1bmN0aW9uIF9zdWJleHByZXNzaW9ucyh3MCwgdzEsIHcyLCBmLCBnKSB7XG4gICAgdmFyIHQwID0gdzAgKyB3MTtcbiAgICBmWzBdID0gdDAgKyB3MjtcbiAgICB2YXIgdDEgPSB3MCAqIHcwO1xuICAgIHZhciB0MiA9IHQxICsgdzEgKiB0MDtcbiAgICBmWzFdID0gdDIgKyB3MiAqIGZbMF07XG4gICAgZlsyXSA9IHcwICogdDEgKyB3MSAqIHQyICsgdzIgKiBmWzFdO1xuICAgIGdbMF0gPSBmWzFdICsgdzAgKiAoZlswXSArIHcwKTtcbiAgICBnWzFdID0gZlsxXSArIHcxICogKGZbMF0gKyB3MSk7XG4gICAgZ1syXSA9IGZbMV0gKyB3MiAqIChmWzBdICsgdzIpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgdmFyaW91cyBwcm9wZXJ0aWVzIG9mIHRoZSB2b2x1bWUuXG4gKlxuICogQG1ldGhvZCBfY29tcHV0ZVBvbHloZWRyYWxQcm9wZXJ0aWVzXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtWZWMzW119IHZlcnRpY2VzIFRoZSB2ZXJ0aWNlcyBvZiB0aGUgcG9seWhlZHJvbi5cbiAqIEBwYXJhbSB7TnVtYmVyW11bXX0gaW5kaWNlcyBBcnJheSBvZiBhcnJheXMgb2YgaW5kaWNlcyBvZiB2ZXJ0aWNlcyBjb21wb3NpbmcgdGhlIHRyaWFuZ3VsYXIgZmVhdHVyZXMgb2YgdGhlIHBvbHloZWRyb24sXG4gKiBvbmUgYXJyYXkgZm9yIGVhY2ggZmVhdHVyZS5cbiAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGhvbGRpbmcgdGhlIGNhbGN1bGF0ZWQgc3Bhbiwgdm9sdW1lLCBjZW50ZXIsIGFuZCBldWxlciB0ZW5zb3IuXG4gKi9cbmZ1bmN0aW9uIF9jb21wdXRlUG9seWhlZHJhbFByb3BlcnRpZXModmVydGljZXMsIGluZGljZXMpIHtcbiAgICAvLyBPcmRlcjogMSwgeCwgeSwgeiwgeF4yLCB5XjIsIHpeMiwgeHksIHl6LCB6eFxuICAgIHZhciBpbnRlZ3JhbHMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgdmFyIGZ4ID0gW107XG4gICAgdmFyIGZ5ID0gW107XG4gICAgdmFyIGZ6ID0gW107XG4gICAgdmFyIGd4ID0gW107XG4gICAgdmFyIGd5ID0gW107XG4gICAgdmFyIGd6ID0gW107XG5cbiAgICB2YXIgaSwgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgQSA9IHZlcnRpY2VzW2luZGljZXNbaV1bMF1dLnZlcnRleDtcbiAgICAgICAgdmFyIEIgPSB2ZXJ0aWNlc1tpbmRpY2VzW2ldWzFdXS52ZXJ0ZXg7XG4gICAgICAgIHZhciBDID0gdmVydGljZXNbaW5kaWNlc1tpXVsyXV0udmVydGV4O1xuICAgICAgICB2YXIgQUIgPSBWZWMzLnN1YnRyYWN0KEIsIEEsIEFCX1JFR0lTVEVSKTtcbiAgICAgICAgdmFyIEFDID0gVmVjMy5zdWJ0cmFjdChDLCBBLCBBQ19SRUdJU1RFUik7XG4gICAgICAgIHZhciBBQkMgPSBBQi5jcm9zcyhBQyk7XG4gICAgICAgIGlmIChWZWMzLmRvdChBLCBBQkMpIDwgMCkgQUJDLmludmVydCgpO1xuXG4gICAgICAgIHZhciBkMCA9IEFCQy54O1xuICAgICAgICB2YXIgZDEgPSBBQkMueTtcbiAgICAgICAgdmFyIGQyID0gQUJDLno7XG5cbiAgICAgICAgdmFyIHgwID0gQS54O1xuICAgICAgICB2YXIgeTAgPSBBLnk7XG4gICAgICAgIHZhciB6MCA9IEEuejtcbiAgICAgICAgdmFyIHgxID0gQi54O1xuICAgICAgICB2YXIgeTEgPSBCLnk7XG4gICAgICAgIHZhciB6MSA9IEIuejtcbiAgICAgICAgdmFyIHgyID0gQy54O1xuICAgICAgICB2YXIgeTIgPSBDLnk7XG4gICAgICAgIHZhciB6MiA9IEMuejtcblxuICAgICAgICBfc3ViZXhwcmVzc2lvbnMoeDAsIHgxLCB4MiwgZngsIGd4KTtcbiAgICAgICAgX3N1YmV4cHJlc3Npb25zKHkwLCB5MSwgeTIsIGZ5LCBneSk7XG4gICAgICAgIF9zdWJleHByZXNzaW9ucyh6MCwgejEsIHoyLCBmeiwgZ3opO1xuXG4gICAgICAgIGludGVncmFsc1swXSArPSBkMCAqIGZ4WzBdO1xuICAgICAgICBpbnRlZ3JhbHNbMV0gKz0gZDAgKiBmeFsxXTtcbiAgICAgICAgaW50ZWdyYWxzWzJdICs9IGQxICogZnlbMV07XG4gICAgICAgIGludGVncmFsc1szXSArPSBkMiAqIGZ6WzFdO1xuICAgICAgICBpbnRlZ3JhbHNbNF0gKz0gZDAgKiBmeFsyXTtcbiAgICAgICAgaW50ZWdyYWxzWzVdICs9IGQxICogZnlbMl07XG4gICAgICAgIGludGVncmFsc1s2XSArPSBkMiAqIGZ6WzJdO1xuICAgICAgICBpbnRlZ3JhbHNbN10gKz0gZDAgKiAoeTAgKiBneFswXSArIHkxICogZ3hbMV0gKyB5MiAqIGd4WzJdKTtcbiAgICAgICAgaW50ZWdyYWxzWzhdICs9IGQxICogKHowICogZ3lbMF0gKyB6MSAqIGd5WzFdICsgejIgKiBneVsyXSk7XG4gICAgICAgIGludGVncmFsc1s5XSArPSBkMiAqICh4MCAqIGd6WzBdICsgeDEgKiBnelsxXSArIHgyICogZ3pbMl0pO1xuICAgIH1cblxuICAgIGludGVncmFsc1swXSAvPSA2O1xuICAgIGludGVncmFsc1sxXSAvPSAyNDtcbiAgICBpbnRlZ3JhbHNbMl0gLz0gMjQ7XG4gICAgaW50ZWdyYWxzWzNdIC89IDI0O1xuICAgIGludGVncmFsc1s0XSAvPSA2MDtcbiAgICBpbnRlZ3JhbHNbNV0gLz0gNjA7XG4gICAgaW50ZWdyYWxzWzZdIC89IDYwO1xuICAgIGludGVncmFsc1s3XSAvPSAxMjA7XG4gICAgaW50ZWdyYWxzWzhdIC89IDEyMDtcbiAgICBpbnRlZ3JhbHNbOV0gLz0gMTIwO1xuXG4gICAgdmFyIG1pblggPSBJbmZpbml0eSwgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWluWSA9IEluZmluaXR5LCBtYXhZID0gLUluZmluaXR5O1xuICAgIHZhciBtaW5aID0gSW5maW5pdHksIG1heFogPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbaV0udmVydGV4O1xuICAgICAgICBpZiAodmVydGV4LnggPCBtaW5YKSBtaW5YID0gdmVydGV4Lng7XG4gICAgICAgIGlmICh2ZXJ0ZXgueCA+IG1heFgpIG1heFggPSB2ZXJ0ZXgueDtcbiAgICAgICAgaWYgKHZlcnRleC55IDwgbWluWSkgbWluWSA9IHZlcnRleC55O1xuICAgICAgICBpZiAodmVydGV4LnkgPiBtYXhZKSBtYXhZID0gdmVydGV4Lnk7XG4gICAgICAgIGlmICh2ZXJ0ZXgueiA8IG1pblopIG1pblogPSB2ZXJ0ZXguejtcbiAgICAgICAgaWYgKHZlcnRleC56ID4gbWF4WikgbWF4WiA9IHZlcnRleC56O1xuICAgIH1cblxuICAgIHZhciBzaXplID0gW21heFggLSBtaW5YLCBtYXhZIC0gbWluWSwgbWF4WiAtIG1pblpdO1xuICAgIHZhciB2b2x1bWUgPSBpbnRlZ3JhbHNbMF07XG4gICAgdmFyIGNlbnRyb2lkID0gbmV3IFZlYzMoaW50ZWdyYWxzWzFdLCBpbnRlZ3JhbHNbMl0sIGludGVncmFsc1szXSk7XG4gICAgY2VudHJvaWQuc2NhbGUoMSAvIHZvbHVtZSk7XG5cbiAgICB2YXIgZXVsZXJUZW5zb3IgPSBuZXcgTWF0MzMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVncmFsc1s0XSwgaW50ZWdyYWxzWzddLCBpbnRlZ3JhbHNbOV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZWdyYWxzWzddLCBpbnRlZ3JhbHNbNV0sIGludGVncmFsc1s4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhbHNbOV0sIGludGVncmFsc1s4XSwgaW50ZWdyYWxzWzZdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIHZvbHVtZTogdm9sdW1lLFxuICAgICAgICBjZW50cm9pZDogY2VudHJvaWQsXG4gICAgICAgIGV1bGVyVGVuc29yOiBldWxlclRlbnNvclxuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIER5bmFtaWNHZW9tZXRyeTogRHluYW1pY0dlb21ldHJ5LFxuICAgIENvbnZleEh1bGw6IENvbnZleEh1bGxcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vYm9kaWVzL1BhcnRpY2xlJyk7XG52YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4vY29uc3RyYWludHMvQ29uc3RyYWludCcpO1xudmFyIEZvcmNlID0gcmVxdWlyZSgnLi9mb3JjZXMvRm9yY2UnKTtcblxudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuUXVhdGVybmlvbjtcblxudmFyIFZFQ19SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgWllYX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBRVUFUX1JFR0lTVEVSID0gbmV3IFF1YXRlcm5pb24oKTtcbnZhciBERUxUQV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogU2luZ2xldG9uIFBoeXNpY3NFbmdpbmUgb2JqZWN0LlxuICogTWFuYWdlcyBib2RpZXMsIGZvcmNlcywgY29uc3RyYWludHMuXG4gKlxuICogQGNsYXNzIFBoeXNpY3NFbmdpbmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgaGFzaCBvZiBjb25maWd1cmFibGUgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gUGh5c2ljc0VuZ2luZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgLyoqIEBwcm9wIGJvZGllcyBUaGUgYm9kaWVzIGN1cnJlbnRseSBhY3RpdmUgaW4gdGhlIGVuZ2luZS4gKi9cbiAgICB0aGlzLmJvZGllcyA9IFtdO1xuICAgIC8qKiBAcHJvcCBmb3JjZXMgVGhlIGZvcmNlcyBjdXJyZW50bHkgYWN0aXZlIGluIHRoZSBlbmdpbmUuICovXG4gICAgdGhpcy5mb3JjZXMgPSBbXTtcbiAgICAvKiogQHByb3AgY29uc3RyYWludHMgVGhlIGNvbnN0cmFpbnRzIGN1cnJlbnRseSBhY3RpdmUgaW4gdGhlIGVuZ2luZS4gKi9cbiAgICB0aGlzLmNvbnN0cmFpbnRzID0gW107XG5cbiAgICAvKiogQHByb3Agc3RlcCBUaGUgdGltZSBiZXR3ZWVuIGZyYW1lcyBpbiB0aGUgZW5naW5lLiAqL1xuICAgIHRoaXMuc3RlcCA9IG9wdGlvbnMuc3RlcCB8fCAxMDAwLzYwO1xuICAgIC8qKiBAcHJvcCBpdGVyYXRpb25zIFRoZSBudW1iZXIgb2YgdGltZXMgZWFjaCBjb25zdHJhaW50IGlzIHNvbHZlZCBwZXIgZnJhbWUuICovXG4gICAgdGhpcy5pdGVyYXRpb25zID0gb3B0aW9ucy5pdGVyYXRpb25zIHx8IDEwO1xuICAgIC8qKiBAcHJvcCBfaW5kZXhQb29sIFBvb2xzIG9mIGluZGljaWVzIHRvIHRyYWNrIGhvbGVzIGluIHRoZSBhcnJheXMuICovXG4gICAgdGhpcy5faW5kZXhQb29scyA9IHtcbiAgICAgICAgYm9kaWVzOiBbXSxcbiAgICAgICAgZm9yY2VzOiBbXSxcbiAgICAgICAgY29uc3RyYWludHM6IFtdXG4gICAgfTtcblxuICAgIHRoaXMuX2VudGl0eU1hcHMgPSB7XG4gICAgICAgIGJvZGllczoge30sXG4gICAgICAgIGZvcmNlczoge30sXG4gICAgICAgIGNvbnN0cmFpbnRzOiB7fVxuICAgIH07XG5cbiAgICB0aGlzLnNwZWVkID0gb3B0aW9ucy5zcGVlZCB8fCAxLjA7XG4gICAgdGhpcy50aW1lID0gMDtcbiAgICB0aGlzLmRlbHRhID0gMDtcblxuICAgIHRoaXMub3JpZ2luID0gb3B0aW9ucy5vcmlnaW4gfHwgbmV3IFZlYzMoKTtcbiAgICB0aGlzLm9yaWVudGF0aW9uID0gb3B0aW9ucy5vcmllbnRhdGlvbiA/IG9wdGlvbnMub3JpZW50YXRpb24ubm9ybWFsaXplKCkgOiAgbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIHRoaXMucHJlc3RlcCA9IFtdO1xuICAgIHRoaXMucG9zdHN0ZXAgPSBbXTtcblxuICAgIHRoaXMuZnJhbWVEZXBlbmRlbnQgPSBvcHRpb25zLmZyYW1lRGVwZW5kZW50IHx8IGZhbHNlO1xuXG4gICAgdGhpcy50cmFuc2Zvcm1CdWZmZXJzID0ge1xuICAgICAgICBwb3NpdGlvbjogWzAsIDAsIDBdLFxuICAgICAgICByb3RhdGlvbjogWzAsIDAsIDBdXG4gICAgfTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIG9yaWdpbiBvZiB0aGUgd29ybGQuXG4gKlxuICogQG1ldGhvZCBzZXRPcmlnaW5cbiAqIEBjaGFpbmFibGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudC5cbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUuc2V0T3JpZ2luID0gZnVuY3Rpb24gc2V0T3JpZ2luKHgsIHksIHopIHtcbiAgICB0aGlzLm9yaWdpbi5zZXQoeCwgeSwgeik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHdvcmxkLlxuICpcbiAqIEBtZXRob2Qgc2V0T3JpZW50YXRpb25cbiAqIEBjaGFpbmFibGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSB3IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudC5cbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUuc2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbiBzZXRPcmllbnRhdGlvbih3LCB4LCB5LCB6KSB7XG4gICAgdGhpcy5vcmllbnRhdGlvbi5zZXQodywgeCwgeSwgeikubm9ybWFsaXplKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIG1ldGhvZCB0byBzdG9yZSBhbiBlbGVtZW50IGluIGEgbGlicmFyeSBhcnJheS5cbiAqXG4gKiBAbWV0aG9kIF9hZGRFbGVtZW50XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgVGhlIGJvZHksIGZvcmNlLCBvciBjb25zdHJhaW50IHRvIGFkZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgV2hlcmUgdG8gc3RvcmUgdGhlIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIF9hZGRFbGVtZW50KGNvbnRleHQsIGVsZW1lbnQsIGtleSkge1xuICAgIHZhciBtYXAgPSBjb250ZXh0Ll9lbnRpdHlNYXBzW2tleV07XG4gICAgaWYgKG1hcFtlbGVtZW50Ll9JRF0gPT0gbnVsbCkge1xuICAgICAgICB2YXIgbGlicmFyeSA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgdmFyIGluZGV4UG9vbCA9IGNvbnRleHQuX2luZGV4UG9vbHNba2V5XTtcbiAgICAgICAgaWYgKGluZGV4UG9vbC5sZW5ndGgpIG1hcFtlbGVtZW50Ll9JRF0gPSBpbmRleFBvb2wucG9wKCk7XG4gICAgICAgIGVsc2UgbWFwW2VsZW1lbnQuX0lEXSA9IGxpYnJhcnkubGVuZ3RoO1xuICAgICAgICBsaWJyYXJ5W21hcFtlbGVtZW50Ll9JRF1dID0gZWxlbWVudDtcbiAgICB9XG59XG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgbWV0aG9kIHRvIHJlbW92ZSBhbiBlbGVtZW50IGZyb20gYSBsaWJyYXJ5IGFycmF5LlxuICpcbiAqIEBtZXRob2QgX3JlbW92ZUVsZW1lbnRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCBUaGUgYm9keSwgZm9yY2UsIG9yIGNvbnN0cmFpbnQgdG8gcmVtb3ZlLlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBXaGVyZSB0byBzdG9yZSB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gX3JlbW92ZUVsZW1lbnQoY29udGV4dCwgZWxlbWVudCwga2V5KSB7XG4gICAgdmFyIG1hcCA9IGNvbnRleHQuX2VudGl0eU1hcHNba2V5XTtcbiAgICB2YXIgaW5kZXggPSBtYXBbZWxlbWVudC5fSURdO1xuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnRleHQuX2luZGV4UG9vbHNba2V5XS5wdXNoKGluZGV4KTtcbiAgICAgICAgY29udGV4dFtrZXldW2luZGV4XSA9IG51bGw7XG4gICAgICAgIG1hcFtlbGVtZW50Ll9JRF0gPSBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBZGQgYSBncm91cCBvZiBib2RpZXMsIGZvcmNlLCBvciBjb25zdHJhaW50cyB0byB0aGUgZW5naW5lLlxuICpcbiAqIEBtZXRob2QgYWRkXG4gKiBAY2hhaW5hYmxlXG4gKi9cblBoeXNpY3NFbmdpbmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCgpIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbGVuaiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW5qOyBqKyspIHtcbiAgICAgICAgdmFyIGVudGl0eSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZW50aXR5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBlbnRpdHlbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgUGFydGljbGUpIHRoaXMuYWRkQm9keShlbnRpdHkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZW50aXR5IGluc3RhbmNlb2YgQ29uc3RyYWludCkgdGhpcy5hZGRDb25zdHJhaW50KGVudGl0eSk7XG4gICAgICAgICAgICBlbHNlIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBGb3JjZSkgdGhpcy5hZGRGb3JjZShlbnRpdHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBncm91cCBvZiBib2RpZXMsIGZvcmNlLCBvciBjb25zdHJhaW50cyBmcm9tIHRoZSBlbmdpbmUuXG4gKlxuICogQG1ldGhvZCByZW1vdmVcbiAqIEBjaGFpbmFibGVcbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgIGZvciAodmFyIGogPSAwLCBsZW5qID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbmo7IGorKykge1xuICAgICAgICB2YXIgZW50aXR5ID0gYXJndW1lbnRzW2pdO1xuICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbnRpdHkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGVudGl0eVtpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBQYXJ0aWNsZSkgdGhpcy5yZW1vdmVCb2R5KGVudGl0eSk7XG4gICAgICAgICAgICBlbHNlIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBDb25zdHJhaW50KSB0aGlzLnJlbW92ZUNvbnN0cmFpbnQoZW50aXR5KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVudGl0eSBpbnN0YW5jZW9mIEZvcmNlKSB0aGlzLnJlbW92ZUZvcmNlKGVudGl0eSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEJlZ2luIHRyYWNraW5nIGEgYm9keS5cbiAqXG4gKiBAbWV0aG9kIGFkZEJvZHlcbiAqIEBwYXJhbSB7UGFydGljbGV9IGJvZHkgVGhlIGJvZHkgdG8gdHJhY2suXG4gKi9cblBoeXNpY3NFbmdpbmUucHJvdG90eXBlLmFkZEJvZHkgPSBmdW5jdGlvbiBhZGRCb2R5KGJvZHkpIHtcbiAgICBfYWRkRWxlbWVudCh0aGlzLCBib2R5LCAnYm9kaWVzJyk7XG59O1xuXG4vKipcbiAqIEJlZ2luIHRyYWNraW5nIGEgZm9yY2UuXG4gKlxuICogQG1ldGhvZCBhZGRGb3JjZVxuICogQHBhcmFtIHtGb3JjZX0gZm9yY2UgVGhlIGZvcmNlIHRvIHRyYWNrLlxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS5hZGRGb3JjZSA9IGZ1bmN0aW9uIGFkZEZvcmNlKGZvcmNlKSB7XG4gICAgX2FkZEVsZW1lbnQodGhpcywgZm9yY2UsICdmb3JjZXMnKTtcbn07XG5cbi8qKlxuICogQmVnaW4gdHJhY2tpbmcgYSBjb25zdHJhaW50LlxuICpcbiAqIEBtZXRob2QgYWRkQ29uc3RyYWludFxuICogQHBhcmFtIHtDb25zdHJhaW50fSBjb25zdHJhaW50IFRoZSBjb25zdHJhaW50IHRvIHRyYWNrLlxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS5hZGRDb25zdHJhaW50ID0gZnVuY3Rpb24gYWRkQ29uc3RyYWludChjb25zdHJhaW50KSB7XG4gICAgX2FkZEVsZW1lbnQodGhpcywgY29uc3RyYWludCwgJ2NvbnN0cmFpbnRzJyk7XG59O1xuXG4vKipcbiAqIFN0b3AgdHJhY2tpbmcgYSBib2R5LlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQm9keVxuICogQHBhcmFtIHtQYXJ0aWNsZX0gYm9keSBUaGUgYm9keSB0byBzdG9wIHRyYWNraW5nLlxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS5yZW1vdmVCb2R5ID0gZnVuY3Rpb24gcmVtb3ZlQm9keShib2R5KSB7XG4gICAgX3JlbW92ZUVsZW1lbnQodGhpcywgYm9keSwgJ2JvZGllcycpO1xufTtcblxuLyoqXG4gKiBTdG9wIHRyYWNraW5nIGEgZm9yY2UuXG4gKlxuICogQG1ldGhvZCByZW1vdmVGb3JjZVxuICogQHBhcmFtIHtGb3JjZX0gZm9yY2UgVGhlIGZvcmNlIHRvIHN0b3AgdHJhY2tpbmcuXG4gKi9cblBoeXNpY3NFbmdpbmUucHJvdG90eXBlLnJlbW92ZUZvcmNlID0gZnVuY3Rpb24gcmVtb3ZlRm9yY2UoZm9yY2UpIHtcbiAgICBfcmVtb3ZlRWxlbWVudCh0aGlzLCBmb3JjZSwgJ2ZvcmNlcycpO1xufTtcblxuLyoqXG4gKiBTdG9wIHRyYWNraW5nIGEgY29uc3RyYWludC5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRcbiAqIEBwYXJhbSB7Q29uc3RyYWludH0gY29uc3RyYWludCBUaGUgY29uc3RyYWludCB0byBzdG9wIHRyYWNraW5nLlxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24gcmVtb3ZlQ29uc3RyYWludChjb25zdHJhaW50KSB7XG4gICAgX3JlbW92ZUVsZW1lbnQodGhpcywgY29uc3RyYWludCwgJ2NvbnN0cmFpbnRzJyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgcGh5c2ljcyBzeXN0ZW0gdG8gcmVmbGVjdCB0aGUgY2hhbmdlcyBzaW5jZSB0aGUgbGFzdCBmcmFtZS4gU3RlcHMgZm9yd2FyZCBpbiBpbmNyZW1lbnRzIG9mXG4gKiBQaHlzaWNzRW5naW5lLnN0ZXAuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXG4gKi9cblBoeXNpY3NFbmdpbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh0aW1lKSB7XG4gICAgaWYgKHRoaXMudGltZSA9PT0gMCkgdGhpcy50aW1lID0gdGltZTtcblxuICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcbiAgICB2YXIgZm9yY2VzID0gdGhpcy5mb3JjZXM7XG4gICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcblxuICAgIHZhciBmcmFtZURlcGVuZGVudCA9IHRoaXMuZnJhbWVEZXBlbmRlbnQ7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXA7XG4gICAgdmFyIGR0ID0gc3RlcCAqIDAuMDAxO1xuICAgIHZhciBzcGVlZCA9IHRoaXMuc3BlZWQ7XG5cbiAgICB2YXIgZGVsdGEgPSB0aGlzLmRlbHRhO1xuICAgIGRlbHRhICs9ICh0aW1lIC0gdGhpcy50aW1lKSAqIHNwZWVkO1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG5cbiAgICB2YXIgaSwgbGVuO1xuICAgIHZhciBmb3JjZSwgYm9keSwgY29uc3RyYWludDtcblxuICAgIHdoaWxlKGRlbHRhID4gc3RlcCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnByZXN0ZXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3RlcFtpXSh0aW1lLCBkdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgRm9yY2VzIG9uIHBhcnRpY2xlc1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBmb3JjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGZvcmNlID0gZm9yY2VzW2ldO1xuICAgICAgICAgICAgaWYgKGZvcmNlID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZvcmNlLnVwZGF0ZSh0aW1lLCBkdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW50YXRpdmVseSB1cGRhdGUgdmVsb2NpdGllc1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBib2RpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICBpZiAoYm9keSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgICBfaW50ZWdyYXRlVmVsb2NpdHkoYm9keSwgZHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJlcCBjb25zdHJhaW50cyBmb3Igc29sdmVyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50ID0gY29uc3RyYWludHNbaV07XG4gICAgICAgICAgICBpZiAoY29uc3RyYWludCA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdHJhaW50LnVwZGF0ZSh0aW1lLCBkdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdGVyYXRpdmVseSByZXNvbHZlIGNvbnN0cmFpbnRzXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBudW1JdGVyYXRpb25zID0gdGhpcy5pdGVyYXRpb25zOyBqIDwgbnVtSXRlcmF0aW9uczsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb25zdHJhaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQgPSBjb25zdHJhaW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludCA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludC5yZXNvbHZlKHRpbWUsIGR0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY3JlbWVudCBwb3NpdGlvbnMgYW5kIG9yaWVudGF0aW9uc1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBib2RpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICBpZiAoYm9keSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgICBfaW50ZWdyYXRlUG9zZShib2R5LCBkdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnBvc3RzdGVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnBvc3RzdGVwW2ldKHRpbWUsIGR0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcmFtZURlcGVuZGVudCkgZGVsdGEgPSAwO1xuICAgICAgICBlbHNlIGRlbHRhIC09IHN0ZXA7XG4gICAgfVxuXG4gICAgdGhpcy5kZWx0YSA9IGRlbHRhO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHRyYW5zZm9ybSBlcXVpdmFsZW50IHRvIHRoZSBQYXJ0aWNsZSdzIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGdldFRyYW5zZm9ybVxuICogQHJldHVybiB7T2JqZWN0fSBQb3NpdGlvbiBhbmQgcm90YXRpb24gb2YgdGhlIGJveSwgdGFraW5nIGludG8gYWNjb3VudFxuICogdGhlIG9yaWdpbiBhbmQgb3JpZW50YXRpb24gb2YgdGhlIHdvcmxkLlxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBnZXRUcmFuc2Zvcm0oYm9keSkge1xuICAgIHZhciBvID0gdGhpcy5vcmlnaW47XG4gICAgdmFyIG9xID0gdGhpcy5vcmllbnRhdGlvbjtcbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm1CdWZmZXJzO1xuXG4gICAgdmFyIHAgPSBib2R5LnBvc2l0aW9uO1xuICAgIHZhciBxID0gYm9keS5vcmllbnRhdGlvbjtcbiAgICB2YXIgcm90ID0gcTtcbiAgICB2YXIgbG9jID0gcDtcblxuICAgIGlmIChvcS53ICE9PSAxKSB7XG4gICAgICAgIHJvdCA9IFF1YXRlcm5pb24ubXVsdGlwbHkocSwgb3EsIFFVQVRfUkVHSVNURVIpO1xuICAgICAgICBsb2MgPSBvcS5yb3RhdGVWZWN0b3IocCwgVkVDX1JFR0lTVEVSKTtcbiAgICB9XG4gICAgdmFyIFpZWCA9IHJvdC50b0V1bGVyKFpZWF9SRUdJU1RFUik7XG5cbiAgICB0cmFuc2Zvcm0ucG9zaXRpb25bMF0gPSBvLngrbG9jLng7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uWzFdID0gby55K2xvYy55O1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvblsyXSA9IG8ueitsb2MuejtcblxuICAgIHRyYW5zZm9ybS5yb3RhdGlvblswXSA9IFpZWC54O1xuICAgIHRyYW5zZm9ybS5yb3RhdGlvblsxXSA9IFpZWC55O1xuICAgIHRyYW5zZm9ybS5yb3RhdGlvblsyXSA9IFpZWC56O1xuXG4gICAgcmV0dXJuIHRyYW5zZm9ybTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBQYXJ0aWNsZSBtb21lbnRhIGJhc2VkIG9mZiBvZiBjdXJyZW50IGluY2lkZW50IGZvcmNlIGFuZCB0b3JxdWUuXG4gKlxuICogQG1ldGhvZCBfaW50ZWdyYXRlVmVsb2NpdHlcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BhcnRpY2xlfSBib2R5XG4gKiBAcGFyYW0ge051bWJlcn0gZHQgZGVsdGEgdGltZVxuICovXG5mdW5jdGlvbiBfaW50ZWdyYXRlVmVsb2NpdHkoYm9keSwgZHQpIHtcbiAgICBib2R5Lm1vbWVudHVtLmFkZChWZWMzLnNjYWxlKGJvZHkuZm9yY2UsIGR0LCBERUxUQV9SRUdJU1RFUikpO1xuICAgIGJvZHkuYW5ndWxhck1vbWVudHVtLmFkZChWZWMzLnNjYWxlKGJvZHkudG9ycXVlLCBkdCwgREVMVEFfUkVHSVNURVIpKTtcbiAgICBWZWMzLnNjYWxlKGJvZHkubW9tZW50dW0sIGJvZHkuaW52ZXJzZU1hc3MsIGJvZHkudmVsb2NpdHkpO1xuICAgIGJvZHkuaW52ZXJzZUluZXJ0aWEudmVjdG9yTXVsdGlwbHkoYm9keS5hbmd1bGFyTW9tZW50dW0sIGJvZHkuYW5ndWxhclZlbG9jaXR5KTtcbiAgICBib2R5LmZvcmNlLmNsZWFyKCk7XG4gICAgYm9keS50b3JxdWUuY2xlYXIoKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIFBhcnRpY2xlIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBiYXNlZCBvZmYgY3VycmVudCB0cmFuc2xhdGlvbmFsIGFuZCBhbmd1bGFyIHZlbG9jaXRpZXMuXG4gKlxuICogQG1ldGhvZCBfaW50ZWdyYXRlUG9zZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UGFydGljbGV9IGJvZHlcbiAqIEBwYXJhbSBkdCB7TnVtYmVyfSBkZWx0YSB0aW1lXG4gKi9cbmZ1bmN0aW9uIF9pbnRlZ3JhdGVQb3NlKGJvZHksIGR0KSB7XG4gICAgaWYgKGJvZHkucmVzdHJpY3Rpb25zICE9PSAwKSB7XG4gICAgICAgIHZhciByZXN0cmljdGlvbnMgPSBib2R5LnJlc3RyaWN0aW9ucztcbiAgICAgICAgdmFyIHggPSBudWxsO1xuICAgICAgICB2YXIgeSA9IG51bGw7XG4gICAgICAgIHZhciB6ID0gbnVsbDtcbiAgICAgICAgdmFyIGF4ID0gbnVsbDtcbiAgICAgICAgdmFyIGF5ID0gbnVsbDtcbiAgICAgICAgdmFyIGF6ID0gbnVsbDtcblxuICAgICAgICBpZiAocmVzdHJpY3Rpb25zICYgMzIpIHggPSAwO1xuICAgICAgICBpZiAocmVzdHJpY3Rpb25zICYgMTYpIHkgPSAwO1xuICAgICAgICBpZiAocmVzdHJpY3Rpb25zICYgOCkgeiA9IDA7XG4gICAgICAgIGlmIChyZXN0cmljdGlvbnMgJiA0KSBheCA9IDA7XG4gICAgICAgIGlmIChyZXN0cmljdGlvbnMgJiAyKSBheSA9IDA7XG4gICAgICAgIGlmIChyZXN0cmljdGlvbnMgJiAxKSBheiA9IDA7XG5cbiAgICAgICAgaWYgKHggIT09IG51bGwgfHwgeSAhPT0gbnVsbCB8fCB6ICE9PSBudWxsKSBib2R5LnNldFZlbG9jaXR5KHgseSx6KTtcbiAgICAgICAgaWYgKGF4ICE9PSBudWxsIHx8IGF5ICE9PSBudWxsIHx8IGF6ICE9PSBudWxsKSBib2R5LnNldEFuZ3VsYXJWZWxvY2l0eShheCwgYXksIGF6KTtcbiAgICB9XG5cbiAgICBib2R5LnBvc2l0aW9uLmFkZChWZWMzLnNjYWxlKGJvZHkudmVsb2NpdHksIGR0LCBERUxUQV9SRUdJU1RFUikpO1xuXG4gICAgdmFyIHcgPSBib2R5LmFuZ3VsYXJWZWxvY2l0eTtcbiAgICB2YXIgcSA9IGJvZHkub3JpZW50YXRpb247XG4gICAgdmFyIHd4ID0gdy54O1xuICAgIHZhciB3eSA9IHcueTtcbiAgICB2YXIgd3ogPSB3Lno7XG5cbiAgICB2YXIgcXcgPSBxLnc7XG4gICAgdmFyIHF4ID0gcS54O1xuICAgIHZhciBxeSA9IHEueTtcbiAgICB2YXIgcXogPSBxLno7XG5cbiAgICB2YXIgaGR0ID0gZHQgKiAwLjU7XG4gICAgcS53ICs9ICgtd3ggKiBxeCAtIHd5ICogcXkgLSB3eiAqIHF6KSAqIGhkdDtcbiAgICBxLnggKz0gKHd4ICogcXcgKyB3eSAqIHF6IC0gd3ogKiBxeSkgKiBoZHQ7XG4gICAgcS55ICs9ICh3eSAqIHF3ICsgd3ogKiBxeCAtIHd4ICogcXopICogaGR0O1xuICAgIHEueiArPSAod3ogKiBxdyArIHd4ICogcXkgLSB3eSAqIHF4KSAqIGhkdDtcblxuICAgIHEubm9ybWFsaXplKCk7XG5cbiAgICBib2R5LnVwZGF0ZUluZXJ0aWEoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQaHlzaWNzRW5naW5lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcbnZhciBDb252ZXhCb2R5RmFjdG9yeSA9IHJlcXVpcmUoJy4vQ29udmV4Qm9keUZhY3RvcnknKTtcblxudmFyIF9Cb3ggPSBDb252ZXhCb2R5RmFjdG9yeShbXG4gICAgICAgICAgICAvLyBPcmRlcjogYmFjay1sZWZ0LGJhY2stcmlnaHQsZnJvbnQtbGVmdCxmcm9udC1yaWdodFxuICAgICAgICAgICAgLy8gVG9wIGhhbGZcbiAgICAgICAgICAgIG5ldyBWZWMzKC0xMDAsIC0xMDAsIC0xMDApLFxuICAgICAgICAgICAgbmV3IFZlYzMoMTAwLCAtMTAwLCAtMTAwKSxcbiAgICAgICAgICAgIG5ldyBWZWMzKC0xMDAsIC0xMDAsIDEwMCksXG4gICAgICAgICAgICBuZXcgVmVjMygxMDAsIC0xMDAsIDEwMCksXG4gICAgICAgICAgICAvLyBCb3R0b20gaGFsZlxuICAgICAgICAgICAgbmV3IFZlYzMoLTEwMCwgMTAwLCAtMTAwKSxcbiAgICAgICAgICAgIG5ldyBWZWMzKDEwMCwgMTAwLCAtMTAwKSxcbiAgICAgICAgICAgIG5ldyBWZWMzKC0xMDAsIDEwMCwgMTAwKSxcbiAgICAgICAgICAgIG5ldyBWZWMzKDEwMCwgMTAwLCAxMDApLFxuICAgICAgICBdKTtcblxuLyoqXG4gKiBAY2xhc3MgQm94XG4gKiBAZXh0ZW5kcyBQYXJ0aWNsZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gQm94KG9wdGlvbnMpIHtcbiAgICBfQm94LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5ub3JtYWxzID0gW1xuICAgICAgICAvLyBPcmRlcjogdG9wLCByaWdodCwgZnJvbnRcbiAgICAgICAgbmV3IFZlYzMoMCwgMSwgMCksXG4gICAgICAgIG5ldyBWZWMzKDEsIDAsIDApLFxuICAgICAgICBuZXcgVmVjMygwLCAwLCAxKVxuICAgIF07XG5cbiAgICB0aGlzLnR5cGUgPSAxIDw8IDE7XG59XG5cbkJveC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9Cb3gucHJvdG90eXBlKTtcbkJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3g7XG5cbm1vZHVsZS5leHBvcnRzID0gQm94O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUGFydGljbGUgPSByZXF1aXJlKCcuLi9ib2RpZXMvUGFydGljbGUnKTtcbnZhciBNYXQzMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuTWF0MzM7XG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG52YXIgQ29udmV4SHVsbCA9IEdlb21ldHJ5LkNvbnZleEh1bGw7XG5cbnZhciBURU1QX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgY29uc3RydWN0b3IgZm9yIGEgcGh5c2ljYWwgYm9keSByZWZsZWN0aW5nIHRoZSBzaGFwZSBkZWZpbmVkIGJ5IGlucHV0IENvbnZleEh1bGwgb3IgVmVjMyBhcnJheS5cbiAqXG4gKiBAbWV0aG9kIENvbnZleEJvZHlGYWN0b3J5XG4gKiBAcGFyYW0ge0NvbnZleEh1bGwgfCBWZWMzW119IGh1bGxcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY29uc3RydWN0b3IuXG4gKi9cbmZ1bmN0aW9uIENvbnZleEJvZHlGYWN0b3J5KGh1bGwpIHtcbiAgICBpZiAoIShodWxsIGluc3RhbmNlb2YgQ29udmV4SHVsbCkpIHtcbiAgICAgICAgaWYgKCEoaHVsbCBpbnN0YW5jZW9mIEFycmF5KSkgdGhyb3cgbmV3IEVycm9yKCdDb252ZXhCb2R5RmFjdG9yeSByZXF1aXJlcyBhIENvbnZleEh1bGwgb2JqZWN0IG9yIGFuIGFycmF5IG9mIFZlYzNcXCdzIGFzIGlucHV0LicpO1xuICAgICAgICBlbHNlIGh1bGwgPSBuZXcgQ29udmV4SHVsbChodWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm9keSBjbGFzcyB3aXRoIGluZXJ0aWEgYW5kIHZlcnRpY2VzIGluZmVycmVkIGZyb20gdGhlIGlucHV0IENvbnZleEh1bGwgb3IgVmVjMyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBDb252ZXhCb2R5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgaGFzaC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb252ZXhCb2R5KG9wdGlvbnMpIHtcbiAgICAgICAgUGFydGljbGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgb3JpZ2luYWxTaXplID0gaHVsbC5wb2x5aGVkcmFsUHJvcGVydGllcy5zaXplO1xuICAgICAgICB2YXIgc2l6ZSA9IG9wdGlvbnMuc2l6ZSB8fCBvcmlnaW5hbFNpemU7XG5cbiAgICAgICAgdmFyIHNjYWxlWCA9IHNpemVbMF0gLyBvcmlnaW5hbFNpemVbMF07XG4gICAgICAgIHZhciBzY2FsZVkgPSBzaXplWzFdIC8gb3JpZ2luYWxTaXplWzFdO1xuICAgICAgICB2YXIgc2NhbGVaID0gc2l6ZVsyXSAvIG9yaWdpbmFsU2l6ZVsyXTtcblxuICAgICAgICB0aGlzLl9zY2FsZSA9IFtzY2FsZVgsIHNjYWxlWSwgc2NhbGVaXTtcblxuICAgICAgICB2YXIgVCA9IG5ldyBNYXQzMyhbc2NhbGVYLCAwLCAwLCAwLCBzY2FsZVksIDAsIDAsIDAsIHNjYWxlWl0pO1xuXG4gICAgICAgIHRoaXMuaHVsbCA9IGh1bGw7XG5cbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaHVsbC52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKFQudmVjdG9yTXVsdGlwbHkoaHVsbC52ZXJ0aWNlc1tpXSwgbmV3IFZlYzMoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2NvbXB1dGVJbmVydGlhUHJvcGVydGllcy5jYWxsKHRoaXMsIFQpO1xuICAgICAgICB0aGlzLmludmVyc2VJbmVydGlhLmNvcHkodGhpcy5sb2NhbEludmVyc2VJbmVydGlhKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbmVydGlhKCk7XG4gICAgfVxuXG4gICAgQ29udmV4Qm9keS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhcnRpY2xlLnByb3RvdHlwZSk7XG4gICAgQ29udmV4Qm9keS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb252ZXhCb2R5O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzaXplIGFuZCByZWNhbGN1bGF0ZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRTaXplXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHNwYW4uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgc3Bhbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geiBUaGUgeiBzcGFuLlxuICAgICAqL1xuICAgIENvbnZleEJvZHkucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiBzZXRTaXplKHgseSx6KSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFNpemUgPSBodWxsLnBvbHloZWRyYWxQcm9wZXJ0aWVzLnNpemU7XG5cbiAgICAgICAgdGhpcy5zaXplWzBdID0geDtcbiAgICAgICAgdGhpcy5zaXplWzFdID0geTtcbiAgICAgICAgdGhpcy5zaXplWzJdID0gejtcblxuICAgICAgICB2YXIgc2NhbGVYID0geCAvIG9yaWdpbmFsU2l6ZVswXTtcbiAgICAgICAgdmFyIHNjYWxlWSA9IHkgLyBvcmlnaW5hbFNpemVbMV07XG4gICAgICAgIHZhciBzY2FsZVogPSB6IC8gb3JpZ2luYWxTaXplWzJdO1xuXG4gICAgICAgIHRoaXMuX3NjYWxlID0gW3NjYWxlWCwgc2NhbGVZLCBzY2FsZVpdO1xuXG4gICAgICAgIHZhciBUID0gbmV3IE1hdDMzKFtzY2FsZVgsIDAsIDAsIDAsIHNjYWxlWSwgMCwgMCwgMCwgc2NhbGVaXSk7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGh1bGwudmVydGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIFQudmVjdG9yTXVsdGlwbHkoaHVsbC52ZXJ0aWNlc1tpXSwgdmVydGljZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgbG9jYWwgaW5lcnRpYSBhbmQgaW52ZXJzZSBpbmVydGlhIHRvIHJlZmxlY3QgdGhlIGN1cnJlbnQgc2l6ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdXBkYXRlTG9jYWxJbmVydGlhXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIENvbnZleEJvZHkucHJvdG90eXBlLnVwZGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uIHVwZGF0ZUluZXJ0aWEoKSB7XG4gICAgICAgIHZhciBzY2FsZVggPSB0aGlzLl9zY2FsZVswXTtcbiAgICAgICAgdmFyIHNjYWxlWSA9IHRoaXMuX3NjYWxlWzFdO1xuICAgICAgICB2YXIgc2NhbGVaID0gdGhpcy5fc2NhbGVbMl07XG5cbiAgICAgICAgdmFyIFQgPSBuZXcgTWF0MzMoW3NjYWxlWCwgMCwgMCwgMCwgc2NhbGVZLCAwLCAwLCAwLCBzY2FsZVpdKTtcblxuICAgICAgICBfY29tcHV0ZUluZXJ0aWFQcm9wZXJ0aWVzLmNhbGwodGhpcywgVCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSB2ZXJ0ZXggZnVydGhlc3QgaW4gYSBkaXJlY3Rpb24uIFVzZWQgaW50ZXJuYWxseSBmb3IgY29sbGlzaW9uIGRldGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc3VwcG9ydFxuICAgICAqIEByZXR1cm4ge1ZlYzN9IFRoZSBmdXJ0aGVzdCB2ZXJ0ZXguXG4gICAgICovXG4gICAgQ29udmV4Qm9keS5wcm90b3R5cGUuc3VwcG9ydCA9IGZ1bmN0aW9uIHN1cHBvcnQoZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgICAgIHZhciB2ZXJ0ZXgsIGRvdCwgZnVydGhlc3Q7XG4gICAgICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICBkb3QgPSBWZWMzLmRvdCh2ZXJ0ZXgsZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChkb3QgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBmdXJ0aGVzdCA9IHZlcnRleDtcbiAgICAgICAgICAgICAgICBtYXggPSBkb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1cnRoZXN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdmVydGljZXMgdG8gcmVmbGVjdCBjdXJyZW50IG9yaWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB1cGRhdGVTaGFwZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBDb252ZXhCb2R5LnByb3RvdHlwZS51cGRhdGVTaGFwZSA9IGZ1bmN0aW9uIHVwZGF0ZVNoYXBlKCkge1xuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgICB2YXIgcSA9IHRoaXMub3JpZW50YXRpb247XG4gICAgICAgIHZhciBtb2RlbFZlcnRpY2VzID0gdGhpcy5odWxsLnZlcnRpY2VzO1xuXG4gICAgICAgIHZhciBzY2FsZVggPSB0aGlzLl9zY2FsZVswXTtcbiAgICAgICAgdmFyIHNjYWxlWSA9IHRoaXMuX3NjYWxlWzFdO1xuICAgICAgICB2YXIgc2NhbGVaID0gdGhpcy5fc2NhbGVbMl07XG5cbiAgICAgICAgdmFyIHQgPSBURU1QX1JFR0lTVEVSO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHQuY29weShtb2RlbFZlcnRpY2VzW2ldKTtcbiAgICAgICAgICAgIHQueCAqPSBzY2FsZVg7XG4gICAgICAgICAgICB0LnkgKj0gc2NhbGVZO1xuICAgICAgICAgICAgdC56ICo9IHNjYWxlWjtcbiAgICAgICAgICAgIFZlYzMuYXBwbHlSb3RhdGlvbih0LCBxLCB2ZXJ0aWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbnZleEJvZHk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBtYXNzIGFuZCBpbmVydGlhIHRlbnNvciBiYXNlZCBvZmYgdGhlIGRlbnNpdHksIHNpemUsIGFuZCBmYWNldCBpbmZvcm1hdGlvbiBvZiB0aGUgcG9seWhlZHJvbi5cbiAqXG4gKiBAbWV0aG9kIF9jb21wdXRlSW5lcnRpYVByb3BlcnRpZXNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge01hdDMzfSBUIFRoZSBtYXRyaXggdHJhbnNmb3JtaW5nIHRoZSBpbnRpYWwgc2V0IG9mIHZlcnRpY2VzIHRvIGEgc2V0IHJlZmxlY3RpbmcgdGhlIGJvZHkgc2l6ZS5cbiAqL1xuZnVuY3Rpb24gX2NvbXB1dGVJbmVydGlhUHJvcGVydGllcyhUKSB7XG4gICAgdmFyIHBvbHloZWRyYWxQcm9wZXJ0aWVzID0gdGhpcy5odWxsLnBvbHloZWRyYWxQcm9wZXJ0aWVzO1xuICAgIHZhciBUX3ZhbHVlcyA9IFQuZ2V0KCk7XG4gICAgdmFyIGRldFQgPSBUX3ZhbHVlc1swXSAqIFRfdmFsdWVzWzRdICogVF92YWx1ZXNbOF07XG5cbiAgICB2YXIgRV9vID0gcG9seWhlZHJhbFByb3BlcnRpZXMuZXVsZXJUZW5zb3I7XG5cbiAgICB2YXIgRSA9IG5ldyBNYXQzMygpO1xuICAgIE1hdDMzLm11bHRpcGx5KFQsIEVfbywgRSk7XG4gICAgTWF0MzMubXVsdGlwbHkoRSwgVCwgRSk7XG4gICAgdmFyIEVfdmFsdWVzID0gRS5nZXQoKTtcblxuICAgIHZhciBFeHggPSBFX3ZhbHVlc1swXTtcbiAgICB2YXIgRXl5ID0gRV92YWx1ZXNbNF07XG4gICAgdmFyIEV6eiA9IEVfdmFsdWVzWzhdO1xuICAgIHZhciBFeHkgPSBFX3ZhbHVlc1sxXTtcbiAgICB2YXIgRXl6ID0gRV92YWx1ZXNbN107XG4gICAgdmFyIEV4eiA9IEVfdmFsdWVzWzJdO1xuXG4gICAgdmFyIG5ld1ZvbHVtZSA9IHBvbHloZWRyYWxQcm9wZXJ0aWVzLnZvbHVtZSAqIGRldFQ7XG4gICAgdmFyIG1hc3MgPSB0aGlzLm1hc3M7XG4gICAgdmFyIGRlbnNpdHkgPSBtYXNzIC8gbmV3Vm9sdW1lO1xuXG4gICAgdmFyIEl4eCA9IEV5eSArIEV6ejtcbiAgICB2YXIgSXl5ID0gRXh4ICsgRXp6O1xuICAgIHZhciBJenogPSBFeHggKyBFeXk7XG4gICAgdmFyIEl4eSA9IC1FeHk7XG4gICAgdmFyIEl5eiA9IC1FeXo7XG4gICAgdmFyIEl4eiA9IC1FeHo7XG5cbiAgICB2YXIgY2VudHJvaWQgPSBwb2x5aGVkcmFsUHJvcGVydGllcy5jZW50cm9pZDtcblxuICAgIEl4eCAtPSBuZXdWb2x1bWUgKiAoY2VudHJvaWQueSAqIGNlbnRyb2lkLnkgKyBjZW50cm9pZC56ICogY2VudHJvaWQueik7XG4gICAgSXl5IC09IG5ld1ZvbHVtZSAqIChjZW50cm9pZC56ICogY2VudHJvaWQueiArIGNlbnRyb2lkLnggKiBjZW50cm9pZC54KTtcbiAgICBJenogLT0gbmV3Vm9sdW1lICogKGNlbnRyb2lkLnggKiBjZW50cm9pZC54ICsgY2VudHJvaWQueSAqIGNlbnRyb2lkLnkpO1xuICAgIEl4eSArPSBuZXdWb2x1bWUgKiBjZW50cm9pZC54ICogY2VudHJvaWQueTtcbiAgICBJeXogKz0gbmV3Vm9sdW1lICogY2VudHJvaWQueSAqIGNlbnRyb2lkLno7XG4gICAgSXh6ICs9IG5ld1ZvbHVtZSAqIGNlbnRyb2lkLnogKiBjZW50cm9pZC54O1xuXG4gICAgSXh4ICo9IGRlbnNpdHkgKiBkZXRUO1xuICAgIEl5eSAqPSBkZW5zaXR5ICogZGV0VDtcbiAgICBJenogKj0gZGVuc2l0eSAqIGRldFQ7XG4gICAgSXh5ICo9IGRlbnNpdHkgKiBkZXRUO1xuICAgIEl5eiAqPSBkZW5zaXR5ICogZGV0VDtcbiAgICBJeHogKj0gZGVuc2l0eSAqIGRldFQ7XG5cbiAgICB2YXIgaW5lcnRpYSA9IFtcbiAgICAgICAgSXh4LCBJeHksIEl4eixcbiAgICAgICAgSXh5LCBJeXksIEl5eixcbiAgICAgICAgSXh6LCBJeXosIEl6elxuICAgIF07XG5cbiAgICB0aGlzLmxvY2FsSW5lcnRpYS5zZXQoaW5lcnRpYSk7XG4gICAgTWF0MzMuaW52ZXJzZSh0aGlzLmxvY2FsSW5lcnRpYSwgdGhpcy5sb2NhbEludmVyc2VJbmVydGlhKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb252ZXhCb2R5RmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuUXVhdGVybmlvbjtcbnZhciBNYXQzMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuTWF0MzM7XG5cbnZhciBDYWxsYmFja1N0b3JlID0gcmVxdWlyZSgnZmFtb3VzLXV0aWxpdGllcycpLkNhbGxiYWNrU3RvcmU7XG5cbnZhciBaRVJPX1ZFQ1RPUiA9IG5ldyBWZWMzKCk7XG5cbnZhciBNQVQxX1JFR0lTVEVSID0gbmV3IE1hdDMzKCk7XG5cbnZhciBfSUQgPSAwO1xuLyoqXG4gKiBGdW5kYW1lbnRhbCBwaHlzaWNhbCBib2R5LiBNYWludGFpbnMgdHJhbnNsYXRpb25hbCBhbmQgYW5ndWxhciBtb21lbnR1bSwgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uLCBhbmQgb3RoZXIgcHJvcGVydGllc1xuICogc3VjaCBhcyBzaXplIGFuZCBjb2VmZmljaWVudHMgb2YgcmVzdGl0dXRpb24gYW5kIGZyaWN0aW9uIHVzZWQgaW4gY29sbGlzaW9uIHJlc3BvbnNlLlxuICpcbiAqIEBjbGFzcyBQYXJ0aWNsZVxuICogQGV4dGVuZHMgUGFydGljbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHNldHMgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIFBhcnRpY2xlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUGFydGljbGUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5ldmVudHMgPSBuZXcgQ2FsbGJhY2tTdG9yZSgpO1xuXG4gICAgdGhpcy5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb24gfHwgbmV3IFZlYzMoKTtcbiAgICB0aGlzLm9yaWVudGF0aW9uID0gb3B0aW9ucy5vcmllbnRhdGlvbiB8fCBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5tb21lbnR1bSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYW5ndWxhck1vbWVudHVtID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMubWFzcyA9IG9wdGlvbnMubWFzcyB8fCAxO1xuICAgIHRoaXMuaW52ZXJzZU1hc3MgPSAxIC8gdGhpcy5tYXNzO1xuXG4gICAgdGhpcy5mb3JjZSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy50b3JxdWUgPSBuZXcgVmVjMygpO1xuXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IG9wdGlvbnMucmVzdGl0dXRpb24gIT0gbnVsbCA/IG9wdGlvbnMucmVzdGl0dXRpb24gOiAwLjQ7XG4gICAgdGhpcy5mcmljdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb24gIT0gbnVsbCA/IG9wdGlvbnMuZnJpY3Rpb24gOiAwLjI7XG5cbiAgICB0aGlzLmludmVyc2VJbmVydGlhID0gbmV3IE1hdDMzKFswLDAsMCwwLDAsMCwwLDAsMF0pO1xuXG4gICAgdGhpcy5sb2NhbEluZXJ0aWEgPSBuZXcgTWF0MzMoWzAsMCwwLDAsMCwwLDAsMCwwXSk7XG4gICAgdGhpcy5sb2NhbEludmVyc2VJbmVydGlhID0gbmV3IE1hdDMzKFswLDAsMCwwLDAsMCwwLDAsMF0pO1xuXG4gICAgdGhpcy5zaXplID0gb3B0aW9ucy5zaXplIHx8IFswLCAwLCAwXTtcblxuICAgIHZhciB2ID0gb3B0aW9ucy52ZWxvY2l0eTtcbiAgICB2YXIgdyA9IG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5O1xuICAgIGlmICh2KSB0aGlzLnNldFZlbG9jaXR5KHYueCwgdi55LCB2LnopO1xuICAgIGlmICh3KSB0aGlzLnNldEFuZ3VsYXJWZWxvY2l0eSh3LngsIHcueSwgdy56KTtcblxuICAgIHRoaXMucmVzdHJpY3Rpb25zID0gMDtcbiAgICB0aGlzLnNldFJlc3RyaWN0aW9ucy5hcHBseSh0aGlzLCBvcHRpb25zLnJlc3RyaWN0aW9ucyB8fCBbXSk7XG5cbiAgICB0aGlzLmNvbGxpc2lvbk1hc2sgPSBvcHRpb25zLmNvbGxpc2lvbk1hc2sgfHwgMTtcbiAgICB0aGlzLmNvbGxpc2lvbkdyb3VwID0gb3B0aW9ucy5jb2xsaXNpb25Hcm91cCB8fCAxO1xuXG4gICAgdGhpcy50eXBlID0gMSA8PCAwO1xuXG4gICAgdGhpcy5fSUQgPSBfSUQrKztcbn1cblxuLyoqXG4gKiBHZXR0ZXIgZm9yIHRoZSByZXN0cmljdGlvbiBiaXRtYXNrLiBDb252ZXJ0cyB0aGUgcmVzdHJpY3Rpb25zIHRvIHRoZWlyIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGdldFJlc3RyaWN0aW9uc1xuICogQHJldHVybiB7U3RyaW5nW119IHJlc3RyaWN0aW9uc1xuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuZ2V0UmVzdHJpY3Rpb25zID0gZnVuY3Rpb24gZ2V0UmVzdHJpY3Rpb25zKCkge1xuICAgIHZhciBsaW5lYXIgPSAnJztcbiAgICB2YXIgYW5ndWxhciA9ICcnO1xuICAgIHZhciByZXN0cmljdGlvbnMgPSB0aGlzLnJlc3RyaWN0aW9ucztcbiAgICBpZiAocmVzdHJpY3Rpb25zICYgMzIpIGxpbmVhciArPSAneCc7XG4gICAgaWYgKHJlc3RyaWN0aW9ucyAmIDE2KSBsaW5lYXIgKz0gJ3knO1xuICAgIGlmIChyZXN0cmljdGlvbnMgJiA4KSBsaW5lYXIgKz0gJ3onO1xuICAgIGlmIChyZXN0cmljdGlvbnMgJiA0KSBhbmd1bGFyICs9ICd4JztcbiAgICBpZiAocmVzdHJpY3Rpb25zICYgMikgYW5ndWxhciArPSAneSc7XG4gICAgaWYgKHJlc3RyaWN0aW9ucyAmIDEpIGFuZ3VsYXIgKz0gJ3onO1xuXG4gICAgcmV0dXJuIFtsaW5lYXIsIGFuZ3VsYXJdO1xufTtcblxuLyoqXG4gKiBTZXR0ZXIgZm9yIHRoZSBwYXJ0aWNsZSByZXN0cmljdGlvbiBiaXRtYXNrLlxuICpcbiAqIEBtZXRob2Qgc2V0UmVzdHJpY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNSZXN0cmljdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByb3RSZXN0cmljdGlvbnNcbiAqIEBjaGFpbmFibGVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnNldFJlc3RyaWN0aW9ucyA9IGZ1bmN0aW9uIHNldFJlc3RyaWN0aW9ucyh0cmFuc1Jlc3RyaWN0aW9ucywgcm90UmVzdHJpY3Rpb25zKSB7XG4gICAgdHJhbnNSZXN0cmljdGlvbnMgPSB0cmFuc1Jlc3RyaWN0aW9ucyB8fCAnJztcbiAgICByb3RSZXN0cmljdGlvbnMgPSByb3RSZXN0cmljdGlvbnMgfHwgJyc7XG4gICAgdGhpcy5yZXN0cmljdGlvbnMgPSAwO1xuICAgIGlmICh0cmFuc1Jlc3RyaWN0aW9ucy5pbmRleE9mKCd4JykgPiAtMSkgdGhpcy5yZXN0cmljdGlvbnMgfD0gMzI7XG4gICAgaWYgKHRyYW5zUmVzdHJpY3Rpb25zLmluZGV4T2YoJ3knKSA+IC0xKSB0aGlzLnJlc3RyaWN0aW9ucyB8PSAxNjtcbiAgICBpZiAodHJhbnNSZXN0cmljdGlvbnMuaW5kZXhPZigneicpID4gLTEpIHRoaXMucmVzdHJpY3Rpb25zIHw9IDg7XG4gICAgaWYgKHJvdFJlc3RyaWN0aW9ucy5pbmRleE9mKCd4JykgPiAtMSkgdGhpcy5yZXN0cmljdGlvbnMgfD0gNDtcbiAgICBpZiAocm90UmVzdHJpY3Rpb25zLmluZGV4T2YoJ3knKSA+IC0xKSB0aGlzLnJlc3RyaWN0aW9ucyB8PSAyO1xuICAgIGlmIChyb3RSZXN0cmljdGlvbnMuaW5kZXhPZigneicpID4gLTEpIHRoaXMucmVzdHJpY3Rpb25zIHw9IDE7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgbWFzc1xuICpcbiAqIEBtZXRob2QgZ2V0TWFzc1xuICogQHJldHVybiB7TnVtYmVyfSBtYXNzXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5nZXRNYXNzID0gZnVuY3Rpb24gZ2V0TWFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXNzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1hc3Mgb2YgdGhlIFBhcnRpY2xlLiAgQ2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZSBtYXNzIHNldmVyYWwgdGltZXNcbiAqXG4gKiBAbWV0aG9kIHNldE1hc3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXNzXG4gKiBAY2hhaW5hYmxlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5zZXRNYXNzID0gZnVuY3Rpb24gc2V0TWFzcyhtYXNzKSB7XG4gICAgdGhpcy5tYXNzID0gbWFzcztcbiAgICB0aGlzLmludmVyc2VNYXNzID0gMSAvIG1hc3M7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgaW52ZXJzZSBtYXNzXG4gKlxuICogQG1ldGhvZCBnZXRJbnZlcnNlTWFzc1xuICogQHJldHVybiB7TnVtYmVyfSBpbnZlcnNlIG1hc3NcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmdldEludmVyc2VNYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52ZXJzZU1hc3M7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgaW5lcnRpYSB0ZW5zb3IgYW5kIGl0cyBpbnZlcnNlIHRvIHJlZmxlY3QgdGhlIGN1cnJlbnQgc2hhcGUuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVMb2NhbEluZXJ0aWFcbiAqIEBjaGFpbmFibGVcbiAqIEBwYXJhbSB7TWF0MzN9IE1hdDMzXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS51cGRhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbiB1cGRhdGVMb2NhbEluZXJ0aWEoKSB7XG4gICAgdGhpcy5sb2NhbEluZXJ0aWEuc2V0KFswLDAsMCwwLDAsMCwwLDAsMF0pO1xuICAgIHRoaXMubG9jYWxJbnZlcnNlSW5lcnRpYS5zZXQoWzAsMCwwLDAsMCwwLDAsMCwwXSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHdvcmxkIGludmVyc2UgaW5lcnRpYSB0ZW5zb3IuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVJbmVydGlhXG4gKiBAY2hhaW5hYmxlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS51cGRhdGVJbmVydGlhID0gZnVuY3Rpb24gdXBkYXRlSW5lcnRpYSgpIHtcbiAgICB2YXIgbG9jYWxJbnZJID0gdGhpcy5sb2NhbEludmVyc2VJbmVydGlhO1xuICAgIHZhciBxID0gdGhpcy5vcmllbnRhdGlvbjtcbiAgICBpZiAobG9jYWxJbnZJWzBdID09PSBsb2NhbEludklbNF0gJiYgbG9jYWxJbnZJWzRdID09PSBsb2NhbEludklbOF0pIHJldHVybjtcbiAgICBpZiAocS53ID09PSAxKSByZXR1cm47XG4gICAgdmFyIFIgPSBxLnRvTWF0cml4KE1BVDFfUkVHSVNURVIpO1xuICAgIE1hdDMzLm11bHRpcGx5KFIsIHRoaXMuaW52ZXJzZUluZXJ0aWEsIHRoaXMuaW52ZXJzZUluZXJ0aWEpO1xuICAgIE1hdDMzLm11bHRpcGx5KHRoaXMubG9jYWxJbnZlcnNlSW5lcnRpYSwgUi50cmFuc3Bvc2UoKSwgdGhpcy5pbnZlcnNlSW5lcnRpYSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgcG9zaXRpb25cbiAqXG4gKiBAbWV0aG9kIGdldFBvc2l0aW9uXG4gKiBAcmV0dXJuIHtWZWMzfSBwb3NpdGlvblxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbjtcbn07XG5cbi8qKlxuICogU2V0dGVyIGZvciBwb3NpdGlvblxuICpcbiAqIEBtZXRob2Qgc2V0UG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIHBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0geSB0aGUgeSBjb29yZGluYXRlIGZvciBwb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHogdGhlIHogY29vcmRpbmF0ZSBmb3IgcG9zaXRpb25cbiAqIEByZXR1cm4ge1BhcnRpY2xlfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIHNldFBvc2l0aW9uKHgsIHksIHopIHtcbiAgICB0aGlzLnBvc2l0aW9uLnNldCh4LCB5LCB6KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0dGVyIGZvciB2ZWxvY2l0eVxuICpcbiAqIEBtZXRob2QgZ2V0VmVsb2NpdHlcbiAqIEByZXR1cm4ge1ZlYzN9IHZlbG9jaXR5XG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5nZXRWZWxvY2l0eSA9IGZ1bmN0aW9uIGdldFZlbG9jaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnZlbG9jaXR5O1xufTtcblxuLyoqXG4gKiBTZXR0ZXIgZm9yIHZlbG9jaXR5XG4gKlxuICogQG1ldGhvZCBzZXR2ZWxvY2l0eVxuICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHggY29vcmRpbmF0ZSBmb3IgdmVsb2NpdHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIHZlbG9jaXR5XG4gKiBAcGFyYW0ge051bWJlcn0geiB0aGUgeiBjb29yZGluYXRlIGZvciB2ZWxvY2l0eVxuICogQGNoYWluYWJsZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuc2V0VmVsb2NpdHkgPSBmdW5jdGlvbiBzZXRWZWxvY2l0eSh4LCB5LCB6KSB7XG4gICAgdGhpcy52ZWxvY2l0eS5zZXQoeCwgeSwgeik7XG4gICAgVmVjMy5zY2FsZSh0aGlzLnZlbG9jaXR5LCB0aGlzLm1hc3MsIHRoaXMubW9tZW50dW0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIG1vbWVudXRtXG4gKlxuICogQG1ldGhvZCBnZXRNb21lbnR1bVxuICogQHJldHVybiB7VmVjM30gbW9tZW50dW1cbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmdldE1vbWVudHVtID0gZnVuY3Rpb24gZ2V0TW9tZW50dW0oKSB7XG4gICAgcmV0dXJuIHRoaXMubW9tZW50dW07XG59O1xuXG4vKipcbiAqIFNldHRlciBmb3IgbW9tZW50dW1cbiAqXG4gKiBAbWV0aG9kIHNldE1vbWVudHVtXG4gKiBAcGFyYW0ge051bWJlcn0geCB0aGUgeCBjb29yZGluYXRlIGZvciBtb21lbnR1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHkgY29vcmRpbmF0ZSBmb3IgbW9tZW50dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IHRoZSB6IGNvb3JkaW5hdGUgZm9yIG1vbWVudHVtXG4gKiBAY2hhaW5hYmxlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5zZXRNb21lbnR1bSA9IGZ1bmN0aW9uIHNldE1vbWVudHVtKHgsIHksIHopIHtcbiAgICB0aGlzLm1vbWVudHVtLnNldCh4LCB5LCB6KTtcbiAgICBWZWMzLnNjYWxlKHRoaXMubW9tZW50dW0sIHRoaXMuaW52ZXJzZU1hc3MsIHRoaXMudmVsb2NpdHkpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIG9yaWVudGF0aW9uXG4gKlxuICogQG1ldGhvZCBnZXRPcmllbnRhdGlvblxuICogQHJldHVybiB7UXVhdGVybmlvbn0gb3JpZW50YXRpb25cbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmdldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gZ2V0T3JpZW50YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb247XG59O1xuXG4vKipcbiAqIFNldHRlciBmb3Igb3JpZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHNldE9yaWVudGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gd1xuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gelxuICogQGNoYWluYWJsZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuc2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbiBzZXRPcmllbnRhdGlvbih3LHgseSx6KSB7XG4gICAgdGhpcy5vcmllbnRhdGlvbi5zZXQodyx4LHkseikubm9ybWFsaXplKCk7XG4gICAgdGhpcy51cGRhdGVJbmVydGlhKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgYW5ndWxhciB2ZWxvY2l0eVxuICpcbiAqIEBtZXRob2QgZ2V0QW5ndWxhclZlbG9jaXR5XG4gKiBAcmV0dXJuIHtWZWMzfSBhbmd1bGFyVmVsb2NpdHlcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmdldEFuZ3VsYXJWZWxvY2l0eSA9IGZ1bmN0aW9uIGdldEFuZ3VsYXJWZWxvY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmd1bGFyVmVsb2NpdHk7XG59O1xuXG4vKipcbiAqIFNldHRlciBmb3IgYW5ndWxhciB2ZWxvY2l0eVxuICpcbiAqIEBtZXRob2Qgc2V0QW5ndWxhclZlbG9jaXR5XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5zZXRBbmd1bGFyVmVsb2NpdHkgPSBmdW5jdGlvbiBzZXRBbmd1bGFyVmVsb2NpdHkoeCx5LHopIHtcbiAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5zZXQoeCx5LHopO1xuICAgIHZhciBJID0gTWF0MzMuaW52ZXJzZSh0aGlzLmludmVyc2VJbmVydGlhLCBNQVQxX1JFR0lTVEVSKTtcbiAgICBpZiAoSSkgSS52ZWN0b3JNdWx0aXBseSh0aGlzLmFuZ3VsYXJWZWxvY2l0eSwgdGhpcy5hbmd1bGFyTW9tZW50dW0pO1xuICAgIGVsc2UgdGhpcy5hbmd1bGFyTW9tZW50dW0uY2xlYXIoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0dGVyIGZvciBhbmd1bGFyIG1vbWVudHVtXG4gKlxuICogQG1ldGhvZCBnZXRBbmd1bGFyTW9tZW50dW1cbiAqIEByZXR1cm4ge1ZlYzN9IGFuZ3VsYXIgbW9tZW50dW1cbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmdldEFuZ3VsYXJNb21lbnR1bSA9IGZ1bmN0aW9uIGdldEFuZ3VsYXJNb21lbnR1bSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmd1bGFyTW9tZW50dW07XG59O1xuXG4vKipcbiAqIFNldHRlciBmb3IgYW5ndWxhciBtb21lbnR1bVxuICpcbiAqIEBtZXRob2Qgc2V0QW5ndWxhck1vbWVudHVtXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5zZXRBbmd1bGFyTW9tZW50dW0gPSBmdW5jdGlvbiBzZXRBbmd1bGFyTW9tZW50dW0oeCx5LHopIHtcbiAgICB0aGlzLmFuZ3VsYXJNb21lbnR1bS5zZXQoeCx5LHopO1xuICAgIHRoaXMuaW52ZXJzZUluZXJ0aWEudmVjdG9yTXVsdGlwbHkodGhpcy5hbmd1bGFyTW9tZW50dW0sIHRoaXMuYW5ndWxhclZlbG9jaXR5KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0dGVyIGZvciB0aGUgZm9yY2Ugb24gdGhlIFBhcnRpY2xlXG4gKlxuICogQG1ldGhvZCBnZXRGb3JjZVxuICogQHJldHVybiB7VmVjM30gZm9yY2VcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmdldEZvcmNlID0gZnVuY3Rpb24gZ2V0Rm9yY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yY2U7XG59O1xuXG4vKipcbiAqIFNldHRlciBmb3IgdGhlIGZvcmNlIG9uIHRoZSBQYXJ0aWNsZVxuICpcbiAqIEBtZXRob2Qgc2V0Rm9yY2VcbiAqIEBwYXJhbSB7VmVjM30gdiB0aGUgbmV3IEZvcmNlXG4gKiBAY2hhaW5hYmxlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5zZXRGb3JjZSA9IGZ1bmN0aW9uIHNldEZvcmNlKHgsIHksIHopIHtcbiAgICB0aGlzLmZvcmNlLnNldCh4LCB5LCB6KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0dGVyIGZvciB0b3JxdWUuXG4gKlxuICogQG1ldGhvZCBnZXRUb3JxdWVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmdldFRvcnF1ZSA9IGZ1bmN0aW9uIGdldFRvcnF1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b3JxdWU7XG59O1xuXG4vKipcbiAqIFNldHRlciBmb3IgdG9ycXVlLlxuICpcbiAqIEBtZXRob2Qgc2V0VG9ycXVlXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEBjaGFpbmFibGVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnNldFRvcnF1ZSA9IGZ1bmN0aW9uIHNldFRvcnF1ZSh4LCB5LCB6KSB7XG4gICAgdGhpcy50b3JxdWUuc2V0KHgsIHksIHopO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeHRlbmRzIFBhcnRpY2xlLmFwcGx5Rm9yY2Ugd2l0aCBhbiBvcHRpb25hbCBhcmd1bWVudFxuICogdG8gYXBwbHkgdGhlIGZvcmNlIGF0IGFuIG9mZi1jZW50ZXJlZCBsb2NhdGlvbiwgcmVzdWx0aW5nIGluIGEgdG9ycXVlLlxuICpcbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICogQHBhcmFtIGZvcmNlIHtWZWMzfSBmb3JjZVxuICogQHBhcmFtIHtWZWMzfSBsb2NhdGlvbiBvZmYtY2VudGVyIGxvY2F0aW9uIG9uIHRoZSBQYXJ0aWNsZSAob3B0aW9uYWwpXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24gYXBwbHlGb3JjZShmb3JjZSkge1xuICAgIHRoaXMuZm9yY2UuYWRkKGZvcmNlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbGllZCBhIHRvcnF1ZSBmb3JjZSB0byBhIFBhcnRpY2xlLCBpbmR1Y2luZyBhIHJvdGF0aW9uLlxuICpcbiAqIEBtZXRob2QgYXBwbHlUb3JxdWVcbiAqIEBwYXJhbSB0b3JxdWUge1ZlYzN9IHRvcnF1ZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuYXBwbHlUb3JxdWUgPSBmdW5jdGlvbiBhcHBseVRvcnF1ZSh0b3JxdWUpIHtcbiAgICB0aGlzLnRvcnF1ZS5hZGQodG9ycXVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbGllcyBhbiBpbXB1bHNlIHRvIG1vbWVudHVtIGFuZCB1cGRhdGVzIHZlbG9jaXR5LlxuICpcbiAqIEBtZXRob2QgYXBwbHlJbXB1bHNlXG4gKiBAcGFyYW0ge1ZlYzN9IGltcHVsc2VcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmFwcGx5SW1wdWxzZSA9IGZ1bmN0aW9uIGFwcGx5SW1wdWxzZShpbXB1bHNlKSB7XG4gICAgdGhpcy5tb21lbnR1bS5hZGQoaW1wdWxzZSk7XG4gICAgVmVjMy5zY2FsZSh0aGlzLm1vbWVudHVtLCB0aGlzLmludmVyc2VNYXNzLCB0aGlzLnZlbG9jaXR5KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbGllcyBhbiBhbmd1bGFyIGltcHVsc2UgdG8gYW5ndWxhciBtb21lbnR1bSBhbmQgdXBkYXRlcyBhbmd1bGFyIHZlbG9jaXR5LlxuICpcbiAqIEBtZXRob2QgYXBwbHlBbmd1bGFySW1wdWxzZVxuICogQHBhcmFtIHtWZWMzfSBhbmd1bGFySW1wdWxzZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuYXBwbHlBbmd1bGFySW1wdWxzZSA9IGZ1bmN0aW9uIGFwcGx5QW5ndWxhckltcHVsc2UoYW5ndWxhckltcHVsc2UpIHtcbiAgICB0aGlzLmFuZ3VsYXJNb21lbnR1bS5hZGQoYW5ndWxhckltcHVsc2UpO1xuICAgIHRoaXMuaW52ZXJzZUluZXJ0aWEudmVjdG9yTXVsdGlwbHkodGhpcy5hbmd1bGFyTW9tZW50dW0sIHRoaXMuYW5ndWxhclZlbG9jaXR5KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVXNlZCBpbiBjb2xsaXNpb24gZGV0ZWN0aW9uLiBUaGUgc3VwcG9ydCBmdW5jdGlvbiBzaG91bGQgYWNjZXB0IGEgVmVjMyBkaXJlY3Rpb25cbiAqIGFuZCByZXR1cm4gdGhlIHBvaW50IG9uIHRoZSBib2R5J3Mgc2hhcGUgZnVydGhlc3QgaW4gdGhhdCBkaXJlY3Rpb24uIEZvciBwb2ludCBwYXJ0aWNsZXMsXG4gKiB0aGlzIHJldHVybnMgdGhlIHplcm8gdmVjdG9yLlxuICpcbiAqIEBtZXRob2Qgc3VwcG9ydFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnN1cHBvcnQgPSBmdW5jdGlvbiBzdXBwb3J0KCkge1xuICAgIHJldHVybiBaRVJPX1ZFQ1RPUjtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib2R5J3Mgc2hhcGUgdG8gcmVmbGVjdCBjdXJyZW50IG9yaWVudGF0aW9uLiBDYWxsZWQgaW4gX2ludGVncmF0ZVBvc2UuXG4gKiBOb29wIGZvciBwb2ludCBwYXJ0aWNsZXMuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVTaGFwZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlU2hhcGUgPSBmdW5jdGlvbiB1cGRhdGVTaGFwZSgpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUGFydGljbGUgPSByZXF1aXJlKCcuL1BhcnRpY2xlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcblxudmFyIFNVUFBPUlRfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFNwaGVyaWNhbCBSaWdpZCBib2R5XG4gKlxuICogQGNsYXNzIFNwaGVyZVxuICogQGV4dGVuZHMgUGFydGljbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFNwaGVyZShvcHRpb25zKSB7XG4gICAgUGFydGljbGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB2YXIgciAgPSBvcHRpb25zLnJhZGl1cyB8fCAxO1xuICAgIHRoaXMucmFkaXVzID0gcjtcbiAgICB0aGlzLnNpemUgPSBbMipyLCAyKnIsIDIqcl07XG4gICAgdGhpcy51cGRhdGVMb2NhbEluZXJ0aWEoKTtcbiAgICB0aGlzLmludmVyc2VJbmVydGlhLmNvcHkodGhpcy5sb2NhbEludmVyc2VJbmVydGlhKTtcblxuICAgIHRoaXMudHlwZSA9IDEgPDwgMjtcbn1cblxuU3BoZXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFydGljbGUucHJvdG90eXBlKTtcblNwaGVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGhlcmU7XG5cbi8qKlxuICogR2V0dGVyIGZvciByYWRpdXMuXG4gKlxuICogQG1ldGhvZCBnZXRSYWRpdXNcbiAqIEByZXR1cm4ge051bWJlcn0gcmFkaXVzXG4gKi9cblNwaGVyZS5wcm90b3R5cGUuZ2V0UmFkaXVzID0gZnVuY3Rpb24gZ2V0UmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1cztcbn07XG5cbi8qKlxuICogU2V0dGVyIGZvciByYWRpdXMuXG4gKlxuICogQG1ldGhvZCBzZXRSYWRpdXNcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgVGhlIGludGVuZGVkIHJhZGl1cyBvZiB0aGUgc3BoZXJlLlxuICogQGNoYWluYWJsZVxuICovXG5TcGhlcmUucHJvdG90eXBlLnNldFJhZGl1cyA9IGZ1bmN0aW9uIHNldFJhZGl1cyhyYWRpdXMpIHtcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICB0aGlzLnNpemUgPSBbMip0aGlzLnJhZGl1cywgMip0aGlzLnJhZGl1cywgMip0aGlzLnJhZGl1c107XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluZmVycyB0aGUgaW5lcnRpYSB0ZW5zb3IuXG4gKlxuICogQG92ZXJyaWRlXG4gKiBAbWV0aG9kIHVwZGF0ZUluZXJ0aWFcbiAqL1xuU3BoZXJlLnByb3RvdHlwZS51cGRhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbiB1cGRhdGVJbmVydGlhKCkge1xuICAgIHZhciBtID0gdGhpcy5tYXNzO1xuICAgIHZhciByID0gdGhpcy5yYWRpdXM7XG5cbiAgICB2YXIgbXJyID0gbSAqIHIgKiByO1xuXG4gICAgdGhpcy5sb2NhbEluZXJ0aWEuc2V0KFtcbiAgICAgICAgMC40ICogbXJyLCAwLCAwLFxuICAgICAgICAwLCAwLjQgKiBtcnIsIDAsXG4gICAgICAgIDAsIDAsIDAuNCAqIG1yclxuICAgIF0pO1xuXG4gICAgdGhpcy5sb2NhbEludmVyc2VJbmVydGlhLnNldChbXG4gICAgICAgIDIuNSAvIG1yciwgMCwgMCxcbiAgICAgICAgMCwgMi41IC8gbXJyLCAwLFxuICAgICAgICAwLCAwLCAyLjUgLyBtcnJcbiAgICBdKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcG9pbnQgb24gdGhlIHNwaGVyZSBmdXJ0aGVzdCBpbiBhIGdpdmVuIGRpcmVjdGlvbi5cbiAqXG4gKiBAbWV0aG9kIHN1cHBvcnRcbiAqIEBwYXJhbSB7VmVjM30gZGlyZWN0aW9uXG4gKiBAcGFyYW0ge1ZlYzN9XG4gKi9cblNwaGVyZS5wcm90b3R5cGUuc3VwcG9ydCA9IGZ1bmN0aW9uIHN1cHBvcnQoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIFZlYzMuc2NhbGUoZGlyZWN0aW9uLCB0aGlzLnJhZGl1cywgU1VQUE9SVF9SRUdJU1RFUik7XG59O1xuXG4vKipcbiAqIEBleHBvcnRzIFNwaGVyZVxuICogQG1vZHVsZSBTcGhlcmVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBTcGhlcmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vUGFydGljbGUnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xuXG4vKipcbiAqIEBlbnVtIGRpcmVjdGlvbnNcbiAqL1xuV2FsbC5ET1dOID0gMDtcbldhbGwuVVAgPSAxO1xuV2FsbC5MRUZUID0gMjtcbldhbGwuUklHSFQgPSAzO1xuV2FsbC5GT1JXQVJEID0gNDtcbldhbGwuQkFDS1dBUkQgPSA1O1xuXG4vKipcbiAqIEFuIGF4aXMtYWxpZ25lZCBib3VuZGFyeS4gV2lsbCBub3QgcmVzcG9uZCB0byBmb3JjZXMgb3IgaW1wdWxzZXMuXG4gKlxuICogQGNsYXNzIFdhbGxcbiAqIEBleHRlbmRzIFBhcnRpY2xlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBXYWxsKG9wdGlvbnMpIHtcbiAgICBQYXJ0aWNsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG4gPSB0aGlzLm5vcm1hbCA9IG5ldyBWZWMzKCk7XG5cbiAgICB2YXIgZCA9IHRoaXMuZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb247XG4gICAgc3dpdGNoIChkKSB7XG4gICAgICAgIGNhc2UgV2FsbC5ET1dOOlxuICAgICAgICAgICAgbi5zZXQoMCwgMSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBXYWxsLlVQOlxuICAgICAgICAgICAgbi5zZXQoMCwgLTEsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgV2FsbC5MRUZUOlxuICAgICAgICAgICAgbi5zZXQoLTEsIDAsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgV2FsbC5SSUdIVDpcbiAgICAgICAgICAgIG4uc2V0KDEsIDAsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgV2FsbC5GT1JXQVJEOlxuICAgICAgICAgICAgbi5zZXQoMCwgMCwgLTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgV2FsbC5CQUNLV0FSRDpcbiAgICAgICAgICAgIG4uc2V0KDAsIDAsIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLmludk5vcm1hbCA9IFZlYzMuY2xvbmUobiwgbmV3IFZlYzMoKSkuaW52ZXJ0KCk7XG5cbiAgICB0aGlzLm1hc3MgPSBJbmZpbml0eTtcbiAgICB0aGlzLmludmVyc2VNYXNzID0gMDtcblxuICAgIHRoaXMudHlwZSA9IDEgPDwgMztcbn1cblxuV2FsbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhcnRpY2xlLnByb3RvdHlwZSk7XG5XYWxsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdhbGw7XG5cbm1vZHVsZS5leHBvcnRzID0gV2FsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xudmFyIE1hdDMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5NYXQzMztcblxudmFyIERFTFRBX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiAgQSBjb25zdHJhaW50IHRoYXQga2VlcHMgYSBwaHlzaWNzIGJvZHkgYSBnaXZlbiBkaXJlY3Rpb24gYXdheSBmcm9tIGEgZ2l2ZW5cbiAqICBhbmNob3IsIG9yIGFub3RoZXIgYXR0YWNoZWQgYm9keS5cbiAqXG4gKiAgQGNsYXNzIEFuZ2xlXG4gKiAgQGV4dGVuZHMgQ29uc3RyYWludFxuICogIEBwYXJhbSB7UGFydGljbGV9IGEgT25lIG9mIHRoZSBib2RpZXMuXG4gKiAgQHBhcmFtIHtQYXJ0aWNsZX0gYiBUaGUgb3RoZXIgYm9keS5cbiAqICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3Qgb2YgY29uZmlndXJhYmxlIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIEFuZ2xlKGEsIGIsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmEgPSBhO1xuICAgIHRoaXMuYiA9IGI7XG5cbiAgICBDb25zdHJhaW50LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmVmZmVjdGl2ZUluZXJ0aWEgPSBuZXcgTWF0MzMoKTtcbiAgICB0aGlzLmFuZ3VsYXJJbXB1bHNlID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmVycm9yID0gMDtcbn1cblxuQW5nbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb25zdHJhaW50LnByb3RvdHlwZSk7XG5BbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbmdsZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBBbmdsZS4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5BbmdsZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29zQW5nbGUgPSB0aGlzLmNvc0FuZ2xlIHx8IHRoaXMuYS5vcmllbnRhdGlvbi5kb3QodGhpcy5iLm9yaWVudGF0aW9uKTtcbn07XG5cbi8qKlxuICogV2FybXN0YXJ0IHRoZSBjb25zdHJhaW50IGFuZCBwcmVwYXJlIGNhbGN1bGF0aW9ucyB1c2VkIGluIC5yZXNvbHZlLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkFuZ2xlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgcTEgPSBhLm9yaWVudGF0aW9uO1xuICAgIHZhciBxMiA9IGIub3JpZW50YXRpb247XG5cbiAgICB2YXIgY29zVGhldGEgPSBxMS5kb3QocTIpO1xuICAgIHZhciBkaWZmID0gMiooY29zVGhldGEgLSB0aGlzLmNvc0FuZ2xlKTtcblxuICAgIHRoaXMuZXJyb3IgPSBkaWZmO1xuXG4gICAgdmFyIGFuZ3VsYXJJbXB1bHNlID0gdGhpcy5hbmd1bGFySW1wdWxzZTtcbiAgICBiLmFwcGx5QW5ndWxhckltcHVsc2UoYW5ndWxhckltcHVsc2UpO1xuICAgIGEuYXBwbHlBbmd1bGFySW1wdWxzZShhbmd1bGFySW1wdWxzZS5pbnZlcnQoKSk7XG5cbiAgICBNYXQzMy5hZGQoYS5pbnZlcnNlSW5lcnRpYSwgYi5pbnZlcnNlSW5lcnRpYSwgdGhpcy5lZmZlY3RpdmVJbmVydGlhKTtcbiAgICB0aGlzLmVmZmVjdGl2ZUluZXJ0aWEuaW52ZXJzZSgpO1xuXG4gICAgYW5ndWxhckltcHVsc2UuY2xlYXIoKTtcbn07XG5cbi8qKlxuICogQWRkcyBhbiBhbmd1bGFyIGltcHVsc2UgdG8gYSBwaHlzaWNzIGJvZHkncyBhbmd1bGFyIHZlbG9jaXR5LlxuICpcbiAqIEBtZXRob2QgcmVzb2x2ZVxuICovXG5BbmdsZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcblxuICAgIHZhciBkaWZmVyA9IERFTFRBX1JFR0lTVEVSO1xuXG4gICAgdmFyIHcxID0gYS5hbmd1bGFyVmVsb2NpdHk7XG4gICAgdmFyIHcyID0gYi5hbmd1bGFyVmVsb2NpdHk7XG5cbiAgICBWZWMzLnN1YnRyYWN0KHcxLCB3MiwgZGlmZlcpO1xuICAgIGRpZmZXLnNjYWxlKDEgKyB0aGlzLmVycm9yKTtcblxuICAgIHZhciBhbmd1bGFySW1wdWxzZSA9IGRpZmZXLmFwcGx5TWF0cml4KHRoaXMuZWZmZWN0aXZlSW5lcnRpYSk7XG5cbiAgICBiLmFwcGx5QW5ndWxhckltcHVsc2UoYW5ndWxhckltcHVsc2UpO1xuICAgIGEuYXBwbHlBbmd1bGFySW1wdWxzZShhbmd1bGFySW1wdWxzZS5pbnZlcnQoKSk7XG4gICAgYW5ndWxhckltcHVsc2UuaW52ZXJ0KCk7XG4gICAgdGhpcy5hbmd1bGFySW1wdWxzZS5hZGQoYW5ndWxhckltcHVsc2UpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmdsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG52YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4vQ29uc3RyYWludCcpO1xuXG52YXIgU3dlZXBBbmRQcnVuZSA9IHJlcXVpcmUoJy4vY29sbGlzaW9uL1N3ZWVwQW5kUHJ1bmUnKTtcbnZhciBCcnV0ZUZvcmNlID0gcmVxdWlyZSgnLi9jb2xsaXNpb24vQnJ1dGVGb3JjZScpO1xudmFyIENvbnZleENvbGxpc2lvbiA9IHJlcXVpcmUoJy4vY29sbGlzaW9uL0NvbnZleENvbGxpc2lvbkRldGVjdGlvbicpO1xudmFyIEdKSyA9IENvbnZleENvbGxpc2lvbi5HSks7XG52YXIgRVBBID0gQ29udmV4Q29sbGlzaW9uLkVQQTtcbnZhciBDb250YWN0TWFuaWZvbGRUYWJsZSA9IHJlcXVpcmUoJy4vY29sbGlzaW9uL0NvbnRhY3RNYW5pZm9sZCcpO1xuXG52YXIgT2JqZWN0TWFuYWdlciA9IHJlcXVpcmUoJ2ZhbW91cy11dGlsaXRpZXMnKS5PYmplY3RNYW5hZ2VyO1xuT2JqZWN0TWFuYWdlci5yZWdpc3RlcignQ29sbGlzaW9uRGF0YScsIENvbGxpc2lvbkRhdGEpO1xudmFyIE9NUmVxdWVzdENvbGxpc2lvbkRhdGEgPSBPYmplY3RNYW5hZ2VyLnJlcXVlc3RDb2xsaXNpb25EYXRhO1xuXG52YXIgVkVDX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2xhbXAgYSB2YWx1ZSB0byBhIGdpdmVuIHJhbmdlLlxuICpcbiAqIEBtZXRob2QgY2xhbXBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dlclxuICogQHBhcmFtIHtOdW1iZXJ9IHVwcGVyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBsb3dlciwgdXBwZXIpIHtcbiAgICByZXR1cm4gdmFsdWUgPCBsb3dlciA/IGxvd2VyIDogdmFsdWUgPiB1cHBlciA/IHVwcGVyIDogdmFsdWU7XG59XG5cbi8qKlxuICogT2JqZWN0IG1haW50YWluaW5nIHZhcmlvdXMgZmlndXJlcyBvZiBhIGNvbGxpc2lvbi4gUmVnaXN0ZXJlZCBpbiBPYmplY3RNYW5hZ2VyLlxuICpcbiAqIEBjbGFzcyBDb2xsaXNpb25EYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gcGVuZXRyYXRpb25cbiAqIEBwYXJhbSB7VmVjM30gbm9ybWFsXG4gKiBAcGFyYW0ge1ZlYzN9IHdvcmxkQ29udGFjdEFcbiAqIEBwYXJhbSB7VmVjM30gd29ybGRDb250YWN0QlxuICogQHBhcmFtIHtWZWMzfSBsb2NhbENvbnRhY3RBXG4gKiBAcGFyYW0ge1ZlYzN9IGxvY2FsQ29udGFjdEJcbiAqL1xuZnVuY3Rpb24gQ29sbGlzaW9uRGF0YShwZW5ldHJhdGlvbiwgbm9ybWFsLCB3b3JsZENvbnRhY3RBLCB3b3JsZENvbnRhY3RCLCBsb2NhbENvbnRhY3RBLCBsb2NhbENvbnRhY3RCKSB7XG4gICAgdGhpcy5wZW5ldHJhdGlvbiA9IHBlbmV0cmF0aW9uO1xuICAgIHRoaXMubm9ybWFsID0gbm9ybWFsO1xuICAgIHRoaXMud29ybGRDb250YWN0QSA9IHdvcmxkQ29udGFjdEE7XG4gICAgdGhpcy53b3JsZENvbnRhY3RCID0gd29ybGRDb250YWN0QjtcbiAgICB0aGlzLmxvY2FsQ29udGFjdEEgPSBsb2NhbENvbnRhY3RBO1xuICAgIHRoaXMubG9jYWxDb250YWN0QiA9IGxvY2FsQ29udGFjdEI7XG59XG5cbi8qKlxuICogVXNlZCBieSBPYmplY3RNYW5hZ2VyIHRvIHJlc2V0IHRoZSBvYmplY3Qgd2l0aCBkaWZmZXJlbnQgZGF0YS5cbiAqXG4gKiBAbWV0aG9kIHJlc2V0XG4gKiBAcGFyYW0ge09iamVjdFtdfSBhcmdzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkNvbGxpc2lvbkRhdGEucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQocGVuZXRyYXRpb24sIG5vcm1hbCwgd29ybGRDb250YWN0QSwgd29ybGRDb250YWN0QiwgbG9jYWxDb250YWN0QSwgbG9jYWxDb250YWN0Qikge1xuICAgIHRoaXMucGVuZXRyYXRpb24gPSBwZW5ldHJhdGlvbjtcbiAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcbiAgICB0aGlzLndvcmxkQ29udGFjdEEgPSB3b3JsZENvbnRhY3RBO1xuICAgIHRoaXMud29ybGRDb250YWN0QiA9IHdvcmxkQ29udGFjdEI7XG4gICAgdGhpcy5sb2NhbENvbnRhY3RBID0gbG9jYWxDb250YWN0QTtcbiAgICB0aGlzLmxvY2FsQ29udGFjdEIgPSBsb2NhbENvbnRhY3RCO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJpZGlkIGJvZHkgRWxhc3RpYyBDb2xsaXNpb25cbiAqXG4gKiBAY2xhc3MgQ29sbGlzaW9uXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBDb2xsaXNpb24odGFyZ2V0cywgb3B0aW9ucykge1xuICAgIHRoaXMudGFyZ2V0cyA9IFtdLmNvbmNhdCh0YXJnZXRzKTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuQ29sbGlzaW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29uc3RyYWludC5wcm90b3R5cGUpO1xuQ29sbGlzaW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbGxpc2lvbjtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBDb2xsaXNpb24gdHJhY2tlci4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5Db2xsaXNpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5icm9hZFBoYXNlKSB7XG4gICAgICAgIGlmICh0aGlzLmJyb2FkUGhhc2UgaW5zdGFuY2VvZiBGdW5jdGlvbikgdGhpcy5icm9hZFBoYXNlID0gbmV3IHRoaXMuYnJvYWRQaGFzZSh0aGlzLnRhcmdldHMpO1xuICAgIH1cbiAgICBlbHNlIHRoaXMuYnJvYWRQaGFzZSA9IG5ldyBTd2VlcEFuZFBydW5lKHRoaXMudGFyZ2V0cyk7XG4gICAgdGhpcy5jb250YWN0TWFuaWZvbGRUYWJsZSA9IHRoaXMuY29udGFjdE1hbmlmb2xkVGFibGUgfHwgbmV3IENvbnRhY3RNYW5pZm9sZFRhYmxlKCk7XG59O1xuXG4vKipcbiAqIENvbGxpc29uIGRldGVjdGlvbi4gVXBkYXRlcyB0aGUgZXhpc3RpbmcgY29udGFjdCBtYW5pZm9sZHMsIHJ1bnMgdGhlIGJyb2FkcGhhc2UsIGFuZCBwZXJmb3JtcyBuYXJyb3dwaGFzZVxuICogY29sbGlzaW9uIGRldGVjdGlvbi4gV2FybSBzdGFydHMgdGhlIGNvbnRhY3RzIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyBwaHlzaWNzIGZyYW1lXG4gKiBhbmQgcHJlcGFyZXMgbmVjZXNzc2FyeSBjYWxjdWxhdGlvbnMgZm9yIHRoZSByZXNvbHV0aW9uLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCBUaGUgcGh5c2ljcyBlbmdpbmUgZnJhbWUgZGVsdGEuXG4gKi9cbiBDb2xsaXNpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh0aW1lLCBkdCkge1xuICAgIHRoaXMuY29udGFjdE1hbmlmb2xkVGFibGUudXBkYXRlKGR0KTtcbiAgICBpZiAodGhpcy50YXJnZXRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciBpLCBsZW47XG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy50YXJnZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0c1tpXS51cGRhdGVTaGFwZSgpO1xuICAgIH1cbiAgICB2YXIgcG90ZW50aWFsQ29sbGlzaW9ucyA9IHRoaXMuYnJvYWRQaGFzZS51cGRhdGUoKTtcbiAgICB2YXIgcGFpcjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBwb3RlbnRpYWxDb2xsaXNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIChwYWlyID0gcG90ZW50aWFsQ29sbGlzaW9uc1tpXSkgJiYgdGhpcy5hcHBseU5hcnJvd1BoYXNlKHBhaXIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhY3RNYW5pZm9sZFRhYmxlLnByZXBDb250YWN0cyhkdCk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGltcHVsc2VzIHRvIHJlc29sdmUgYWxsIENvbnRhY3QgY29uc3RyYWludHMuXG4gKlxuICogQG1ldGhvZCByZXNvbHZlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCBUaGUgcGh5c2ljcyBlbmdpbmUgZnJhbWUgZGVsdGEuXG4gKi9cbkNvbGxpc2lvbi5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUodGltZSwgZHQpIHtcbiAgICB0aGlzLmNvbnRhY3RNYW5pZm9sZFRhYmxlLnJlc29sdmVNYW5pZm9sZHMoZHQpO1xufTtcblxuLyoqXG4gKiBBZGQgYSB0YXJnZXQgb3IgdGFyZ2V0cyB0byB0aGUgY29sbGlzaW9uIHN5c3RlbS5cbiAqXG4gKiBAbWV0aG9kIGFkZFRhcmdldFxuICogQHBhcmFtIHtQYXJ0aWNsZX1cbiAqL1xuQ29sbGlzaW9uLnByb3RvdHlwZS5hZGRUYXJnZXQgPSBmdW5jdGlvbiBhZGRUYXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICB0aGlzLmJyb2FkUGhhc2UuYWRkKHRhcmdldCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHRhcmdldCBvciB0YXJnZXRzIGZyb20gdGhlIGNvbGxpc2lvbiBzeXN0ZW0uXG4gKlxuICogQG1ldGhvZCBhZGRUYXJnZXRcbiAqIEBwYXJhbSB7UGFydGljbGV9XG4gKi9cbkNvbGxpc2lvbi5wcm90b3R5cGUucmVtb3ZlVGFyZ2V0ID0gZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0KHRhcmdldCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuO1xuICAgIHRoaXMudGFyZ2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMuYnJvYWRQaGFzZS5yZW1vdmUodGFyZ2V0KTtcbn07XG5cblxudmFyIENPTlZFWCA9IDEgPDwgMDtcbnZhciBCT1ggPSAxIDw8IDE7XG52YXIgU1BIRVJFID0gMSA8PCAyO1xudmFyIFdBTEwgPSAxIDw8IDM7XG5cbnZhciBDT05WRVhfQ09OVkVYID0gQ09OVkVYIHwgQ09OVkVYO1xudmFyIEJPWF9CT1ggPSBCT1ggfCBCT1g7XG52YXIgQk9YX0NPTlZFWCA9IEJPWCB8IENPTlZFWDtcbnZhciBTUEhFUkVfU1BIRVJFID0gU1BIRVJFIHwgU1BIRVJFO1xudmFyIEJPWF9TUEhFUkUgPSBCT1ggfCBTUEhFUkU7XG52YXIgQ09OVkVYX1NQSEVSRSA9IENPTlZFWCB8IFNQSEVSRTtcbnZhciBDT05WRVhfV0FMTCA9IENPTlZFWCB8IFdBTEw7XG52YXIgQk9YX1dBTEwgPSBCT1ggfCBXQUxMO1xudmFyIFNQSEVSRV9XQUxMID0gU1BIRVJFIHwgV0FMTDtcblxudmFyIGRpc3BhdGNoID0ge307XG5kaXNwYXRjaFtDT05WRVhfQ09OVkVYXSA9IGNvbnZleEludGVyc2VjdENvbnZleDtcbmRpc3BhdGNoW0JPWF9CT1hdID0gY29udmV4SW50ZXJzZWN0Q29udmV4O1xuZGlzcGF0Y2hbQk9YX0NPTlZFWF0gPSBjb252ZXhJbnRlcnNlY3RDb252ZXg7XG5kaXNwYXRjaFtDT05WRVhfU1BIRVJFXSA9IGNvbnZleEludGVyc2VjdENvbnZleDtcbmRpc3BhdGNoW1NQSEVSRV9TUEhFUkVdID0gc3BoZXJlSW50ZXJzZWN0U3BoZXJlO1xuZGlzcGF0Y2hbQk9YX1NQSEVSRV0gPSBib3hJbnRlcnNlY3RTcGhlcmU7XG5kaXNwYXRjaFtDT05WRVhfV0FMTF0gPSBjb252ZXhJbnRlcnNlY3RXYWxsO1xuZGlzcGF0Y2hbQk9YX1dBTExdID0gY29udmV4SW50ZXJzZWN0V2FsbDtcbmRpc3BhdGNoW1NQSEVSRV9XQUxMXSA9IGNvbnZleEludGVyc2VjdFdhbGw7XG5cbi8qKlxuICogTmFycm93cGhhc2UgY29sbGlzaW9uIGRldGVjdGlvbixcbiAqIHJlZ2lzdGVycyB0aGUgQ29udGFjdCBjb25zdHJhaW50cyBmb3IgY29sbGlkaW5nIGJvZGllcy5cbiAqXG4gKiBXaWxsIGRldGVjdCB0aGUgdHlwZSBvZiBib2RpZXMgaW4gdGhlIGNvbGxpc2lvbi5cbiAqXG4gKiBAbWV0aG9kIGFwcGx5TmFycm93UGhhc2VcbiAqIEBwYXJhbSB7UGFydGljbGVbXX0gdGFyZ2V0c1xuICovXG5Db2xsaXNpb24ucHJvdG90eXBlLmFwcGx5TmFycm93UGhhc2UgPSBmdW5jdGlvbiBhcHBseU5hcnJvd1BoYXNlKHRhcmdldHMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgdmFyICBhID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgICAgIHZhciBiID0gdGFyZ2V0c1tqXTtcblxuICAgICAgICAgICAgaWYgKChhLmNvbGxpc2lvbk1hc2sgJiBiLmNvbGxpc2lvbkdyb3VwICYmIGEuY29sbGlzaW9uR3JvdXAgJiBiLmNvbGxpc2lvbk1hc2spID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGNvbGxpc2lvblR5cGUgPSBhLnR5cGUgfCBiLnR5cGU7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoW2NvbGxpc2lvblR5cGVdICYmIGRpc3BhdGNoW2NvbGxpc2lvblR5cGVdKHRoaXMsIGEsIGIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXRlY3RzIHNwaGVyZS1zcGhlcmUgY29sbGlzaW9ucyBhbmQgcmVnaXN0ZXJzIHRoZSBDb250YWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIHNwaGVyZUludGVyc2VjdFNwaGVyZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7U3BoZXJlfSBzcGhlcmUxXG4gKiBAcGFyYW0ge1NwaGVyZX0gc3BoZXJlMlxuICovXG5mdW5jdGlvbiBzcGhlcmVJbnRlcnNlY3RTcGhlcmUoY29udGV4dCwgc3BoZXJlMSwgc3BoZXJlMikge1xuICAgIHZhciBwMSA9IHNwaGVyZTEucG9zaXRpb247XG4gICAgdmFyIHAyID0gc3BoZXJlMi5wb3NpdGlvbjtcbiAgICB2YXIgcmVsYXRpdmVQb3NpdGlvbiA9IFZlYzMuc3VidHJhY3QocDIsIHAxLCBuZXcgVmVjMygpKTtcbiAgICB2YXIgZGlzdGFuY2UgPSByZWxhdGl2ZVBvc2l0aW9uLmxlbmd0aCgpO1xuICAgIHZhciBzdW1SYWRpaSA9IHNwaGVyZTEucmFkaXVzICsgc3BoZXJlMi5yYWRpdXM7XG4gICAgdmFyIG4gPSByZWxhdGl2ZVBvc2l0aW9uLnNjYWxlKDEvZGlzdGFuY2UpO1xuXG4gICAgdmFyIG92ZXJsYXAgPSBzdW1SYWRpaSAtIGRpc3RhbmNlO1xuXG4gICAgLy8gRGlzdGFuY2UgY2hlY2tcbiAgICBpZiAob3ZlcmxhcCA8IDApIHJldHVybjtcblxuICAgIHZhciByU3BoZXJlMSA9IFZlYzMuc2NhbGUobiwgc3BoZXJlMS5yYWRpdXMsIG5ldyBWZWMzKCkpO1xuICAgIHZhciByU3BoZXJlMiA9IFZlYzMuc2NhbGUobiwgLXNwaGVyZTIucmFkaXVzLCBuZXcgVmVjMygpKTtcblxuICAgIHZhciB3U3BoZXJlMSA9IFZlYzMuYWRkKHAxLCByU3BoZXJlMSwgbmV3IFZlYzMoKSk7XG4gICAgdmFyIHdTcGhlcmUyID0gVmVjMy5hZGQocDIsIHJTcGhlcmUyLCBuZXcgVmVjMygpKTtcblxuICAgIHZhciBjb2xsaXNpb25EYXRhID0gT01SZXF1ZXN0Q29sbGlzaW9uRGF0YSgpLnJlc2V0KG92ZXJsYXAsIG4sIHdTcGhlcmUxLCB3U3BoZXJlMiwgclNwaGVyZTEsIHJTcGhlcmUyKTtcblxuICAgIGNvbnRleHQuY29udGFjdE1hbmlmb2xkVGFibGUucmVnaXN0ZXJDb250YWN0KHNwaGVyZTEsIHNwaGVyZTIsIGNvbGxpc2lvbkRhdGEpO1xufVxuXG4vKipcbiogRGV0ZWN0cyBib3gtc3BoZXJlIGNvbGxpc2lvbnMgYW5kIHJlZ2lzdGVycyB0aGUgQ29udGFjdC5cbipcbiogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiogQHBhcmFtIHtCb3h9IGJveFxuKiBAcGFyYW0ge1NwaGVyZX0gc3BoZXJlXG4qL1xuZnVuY3Rpb24gYm94SW50ZXJzZWN0U3BoZXJlKGNvbnRleHQsIGJveCwgc3BoZXJlKSB7XG4gICAgaWYgKGJveC50eXBlID09PSBTUEhFUkUpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBzcGhlcmU7XG4gICAgICAgIHNwaGVyZSA9IGJveDtcbiAgICAgICAgYm94ID0gdGVtcDtcbiAgICB9XG5cbiAgICB2YXIgcGIgPSBib3gucG9zaXRpb247XG4gICAgdmFyIHBzID0gc3BoZXJlLnBvc2l0aW9uO1xuICAgIHZhciByZWxhdGl2ZVBvc2l0aW9uID0gVmVjMy5zdWJ0cmFjdChwcywgcGIsIFZFQ19SRUdJU1RFUik7XG5cbiAgICB2YXIgcSA9IGJveC5vcmllbnRhdGlvbjtcblxuICAgIHZhciByID0gc3BoZXJlLnJhZGl1cztcblxuICAgIHZhciBic2l6ZSA9IGJveC5zaXplO1xuICAgIHZhciBoYWxmV2lkdGggPSBic2l6ZVswXSowLjU7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBic2l6ZVsxXSowLjU7XG4gICAgdmFyIGhhbGZEZXB0aCA9IGJzaXplWzJdKjAuNTtcblxuICAgIC8vIHgsIHksIHpcbiAgICB2YXIgYm5vcm1hbHMgPSBib3gubm9ybWFscztcbiAgICB2YXIgbjEgPSBxLnJvdGF0ZVZlY3Rvcihibm9ybWFsc1sxXSwgbmV3IFZlYzMoKSk7XG4gICAgdmFyIG4yID0gcS5yb3RhdGVWZWN0b3IoYm5vcm1hbHNbMF0sIG5ldyBWZWMzKCkpO1xuICAgIHZhciBuMyA9IHEucm90YXRlVmVjdG9yKGJub3JtYWxzWzJdLCBuZXcgVmVjMygpKTtcblxuICAgIC8vIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBjdWJlIGNsb3Nlc3QgdG8gdGhlIGNlbnRlciBvZiB0aGUgc3BoZXJlXG4gICAgdmFyIGNsb3Nlc3RQb2ludCA9IG5ldyBWZWMzKCk7XG4gICAgY2xvc2VzdFBvaW50LnggPSBjbGFtcChWZWMzLmRvdChyZWxhdGl2ZVBvc2l0aW9uLG4xKSwgLWhhbGZXaWR0aCwgaGFsZldpZHRoKTtcbiAgICBjbG9zZXN0UG9pbnQueSA9IGNsYW1wKFZlYzMuZG90KHJlbGF0aXZlUG9zaXRpb24sbjIpLCAtaGFsZkhlaWdodCwgaGFsZkhlaWdodCk7XG4gICAgY2xvc2VzdFBvaW50LnogPSBjbGFtcChWZWMzLmRvdChyZWxhdGl2ZVBvc2l0aW9uLG4zKSwgLWhhbGZEZXB0aCwgaGFsZkRlcHRoKTtcbiAgICAvLyBUaGUgdmVjdG9yIGZvdW5kIGlzIHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHVucm90YXRlZCBib3ggLS0gcm90YXRlIGl0XG4gICAgLy8gdG8gZmluZCB0aGUgcG9pbnQgdy5yLnQuIHRvIGN1cnJlbnQgb3JpZW50YXRpb25cbiAgICBjbG9zZXN0UG9pbnQuYXBwbHlSb3RhdGlvbihxKTtcblxuICAgIC8vIFRoZSBpbXBhY3QgcG9pbnQgaW4gd29ybGQgc3BhY2VcbiAgICB2YXIgaW1wYWN0UG9pbnQgPSBWZWMzLmFkZChwYiwgY2xvc2VzdFBvaW50LCBuZXcgVmVjMygpKTtcbiAgICB2YXIgc3BoZXJlVG9JbXBhY3QgPSBWZWMzLnN1YnRyYWN0KGltcGFjdFBvaW50LCBwcywgaW1wYWN0UG9pbnQpO1xuICAgIHZhciBkaXN0YW5jZVRvU3BoZXJlID0gc3BoZXJlVG9JbXBhY3QubGVuZ3RoKCk7XG5cbiAgICAvLyBJZiBpbXBhY3QgcG9pbnQgaXMgbm90IGNsb3NlciB0byB0aGUgc3BoZXJlJ3MgY2VudGVyIHRoYW4gaXRzIHJhZGl1cyAtPiBubyBjb2xsaXNpb25cbiAgICB2YXIgb3ZlcmxhcCA9IHIgLSBkaXN0YW5jZVRvU3BoZXJlO1xuICAgIGlmIChvdmVybGFwIDwgMCkgcmV0dXJuO1xuXG4gICAgdmFyIG4gPSBWZWMzLnNjYWxlKHNwaGVyZVRvSW1wYWN0LCAtMSAvIGRpc3RhbmNlVG9TcGhlcmUsIG5ldyBWZWMzKCkpO1xuICAgIHZhciByQm94ID0gY2xvc2VzdFBvaW50O1xuICAgIHZhciByU3BoZXJlID0gc3BoZXJlVG9JbXBhY3Q7XG5cbiAgICB2YXIgd0JveCA9IFZlYzMuYWRkKHBiLCByQm94LCBuZXcgVmVjMygpKTtcbiAgICB2YXIgd1NwaGVyZSA9IFZlYzMuYWRkKHBzLCByU3BoZXJlLCBuZXcgVmVjMygpKTtcblxuICAgIHZhciBjb2xsaXNpb25EYXRhID0gT01SZXF1ZXN0Q29sbGlzaW9uRGF0YSgpLnJlc2V0KG92ZXJsYXAsIG4sIHdCb3gsIHdTcGhlcmUsIHJCb3gsIHJTcGhlcmUpO1xuXG4gICAgY29udGV4dC5jb250YWN0TWFuaWZvbGRUYWJsZS5yZWdpc3RlckNvbnRhY3QoYm94LCBzcGhlcmUsIGNvbGxpc2lvbkRhdGEpO1xufVxuXG4vKipcbiogRGV0ZWN0cyBjb252ZXgtY29udmV4IGNvbGxpc2lvbnMgYW5kIHJlZ2lzdGVycyB0aGUgQ29udGFjdC4gVXNlcyBHSksgdG8gZGV0ZXJtaW5lIG92ZXJsYXAgYW5kIHRoZW5cbiogRVBBIHRvIGRldGVybWluZSB0aGUgYWN0dWFsIGNvbGxpc2lvbiBkYXRhLlxuKlxuKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuKiBAcGFyYW0ge0NvbnZleEJvZHl9IGNvbnZleDFcbiogQHBhcmFtIHtDb252ZXhCb2R5fSBjb252ZXgyXG4qL1xuZnVuY3Rpb24gY29udmV4SW50ZXJzZWN0Q29udmV4KGNvbnRleHQsIGNvbnZleDEsIGNvbnZleDIpIHtcbiAgICB2YXIgZ2xrU2ltcGxleCA9IEdKSyhjb252ZXgxLCBjb252ZXgyKTtcblxuICAgIC8vIE5vIHNpbXBsZXggLT4gbm8gY29sbGlzaW9uXG4gICAgaWYgKCFnbGtTaW1wbGV4KSByZXR1cm47XG5cbiAgICB2YXIgY29sbGlzaW9uRGF0YSA9IEVQQShjb252ZXgxLCBjb252ZXgyLCBnbGtTaW1wbGV4KTtcbiAgICBpZiAoY29sbGlzaW9uRGF0YSAhPT0gbnVsbCkgY29udGV4dC5jb250YWN0TWFuaWZvbGRUYWJsZS5yZWdpc3RlckNvbnRhY3QoY29udmV4MSwgY29udmV4MiwgY29sbGlzaW9uRGF0YSk7XG59XG5cbi8qKlxuKiBEZXRlY3RzIGNvbnZleC13YWxsIGNvbGxpc2lvbnMgYW5kIHJlZ2lzdGVycyB0aGUgQ29udGFjdC5cbipcbiogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiogQHBhcmFtIHtDb252ZXhCb2R5fSBjb252ZXhcbiogQHBhcmFtIHtDb252ZXhCb2R5fSB3YWxsXG4qL1xuZnVuY3Rpb24gY29udmV4SW50ZXJzZWN0V2FsbChjb250ZXh0LCBjb252ZXgsIHdhbGwpIHtcbiAgICBpZiAoY29udmV4LnR5cGUgPT09IFdBTEwpIHtcbiAgICAgICAgdmFyIHRlbXAgPSB3YWxsO1xuICAgICAgICB3YWxsID0gY29udmV4O1xuICAgICAgICBjb252ZXggPSB0ZW1wO1xuICAgIH1cblxuICAgIHZhciBjb252ZXhQb3MgPSBjb252ZXgucG9zaXRpb247XG4gICAgdmFyIHdhbGxQb3MgPSB3YWxsLnBvc2l0aW9uO1xuXG4gICAgdmFyIG4gPSB3YWxsLm5vcm1hbDtcbiAgICB2YXIgaW52TiA9IHdhbGwuaW52Tm9ybWFsO1xuXG4gICAgdmFyIHJDb252ZXggPSBjb252ZXguc3VwcG9ydChpbnZOKTtcbiAgICB2YXIgd0NvbnZleCA9IFZlYzMuYWRkKGNvbnZleFBvcywgckNvbnZleCwgbmV3IFZlYzMoKSk7XG5cbiAgICB2YXIgZGlmZiA9IFZlYzMuc3VidHJhY3Qod0NvbnZleCwgd2FsbFBvcywgVkVDX1JFR0lTVEVSKTtcblxuICAgIHZhciBwZW5ldHJhdGlvbiA9IFZlYzMuZG90KGRpZmYsIGludk4pO1xuXG4gICAgaWYgKHBlbmV0cmF0aW9uIDwgMCkgcmV0dXJuO1xuXG4gICAgdmFyIHdXYWxsID0gVmVjMy5zY2FsZShuLCBwZW5ldHJhdGlvbiwgbmV3IFZlYzMoKSkuYWRkKHdDb252ZXgpO1xuICAgIHZhciByV2FsbCA9IFZlYzMuc3VidHJhY3Qod1dhbGwsIHdhbGwucG9zaXRpb24sIG5ldyBWZWMzKCkpO1xuXG4gICAgdmFyIGNvbGxpc2lvbkRhdGEgPSBPTVJlcXVlc3RDb2xsaXNpb25EYXRhKCkucmVzZXQocGVuZXRyYXRpb24sIGludk4sIHdDb252ZXgsIHdXYWxsLCByQ29udmV4LCByV2FsbCk7XG5cbiAgICBjb250ZXh0LmNvbnRhY3RNYW5pZm9sZFRhYmxlLnJlZ2lzdGVyQ29udGFjdChjb252ZXgsIHdhbGwsIGNvbGxpc2lvbkRhdGEpO1xufVxuXG5Db2xsaXNpb24uU3dlZXBBbmRQcnVuZSA9IFN3ZWVwQW5kUHJ1bmU7XG5Db2xsaXNpb24uQnJ1dGVGb3JjZSA9IEJydXRlRm9yY2UuQnJ1dGVGb3JjZTtcbkNvbGxpc2lvbi5CcnV0ZUZvcmNlQUFCQiA9IEJydXRlRm9yY2UuQnJ1dGVGb3JjZUFBQkI7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGlzaW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX0lEID0gMDtcbi8qKlxuICogQmFzZSBDb25zdHJhaW50IGNsYXNzIHRvIGJlIHVzZWQgaW4gdGhlIFBoeXNpY3NcbiAqIFN1YmNsYXNzIHRoaXMgY2xhc3MgdG8gaW1wbGVtZW50IGEgY29uc3RyYWludFxuICpcbiAqIEB2aXJ0dWFsXG4gKiBAY2xhc3MgQ29uc3RyYWludFxuICovXG5mdW5jdGlvbiBDb25zdHJhaW50KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9JRCA9IF9JRCsrO1xufVxuXG4vKipcbiAqIERlY29yYXRlcyB0aGUgQ29uc3RyYWludCB3aXRoIHRoZSBvcHRpb25zIG9iamVjdC5cbiAqXG4gKiBAbWV0aG9kIHNldE9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIGludm9rZWQgdXBvbiBpbnN0YW50aWF0aW9uIGFuZCB0aGUgc2V0dGluZyBvZiBvcHRpb25zLlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgaGFzaC5cbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge307XG5cbi8qKlxuICogRGV0ZWN0IHZpb2xhdGlvbnMgb2YgdGhlIGNvbnN0cmFpbnQuIFdhcm0gc3RhcnQgdGhlIGNvbnN0cmFpbnQsIGlmIHBvc3NpYmxlLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCBUaGUgcGh5c2ljcyBlbmdpbmUgZnJhbWUgZGVsdGEuXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh0aW1lLCBkdCkge307XG5cbi8qKlxuICogQXBwbHkgaW1wdWxzZXMgdG8gcmVzb2x2ZSB0aGUgY29uc3RyYWludC5cbiAqXG4gKiBAbWV0aG9kIHJlc29sdmVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSBjdXJyZW50IHRpbWUgaW4gdGhlIHBoeXNpY3MgZW5naW5lLlxuICogQHBhcmFtIHtOdW1iZXJ9IGR0IFRoZSBwaHlzaWNzIGVuZ2luZSBmcmFtZSBkZWx0YS5cbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUodGltZSwgZHQpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnN0cmFpbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50Jyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcblxudmFyIElNUFVMU0VfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIE5PUk1BTF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKiBAY29uc3QgKi9cbnZhciBFUFNJTFNPTiA9IDFlLTc7XG4vKiogQGNvbnN0ICovXG52YXIgUEkgPSBNYXRoLlBJO1xuXG5cbi8qKlxuICogIEEgY29uc3RyYWludCB0aGF0IGtlZXBzIGEgcGh5c2ljcyBib2R5IG9uIGEgZ2l2ZW4gaW1wbGljaXQgY3VydmUuXG4gKlxuICogIEBjbGFzcyBDdXJ2ZVxuICogIEBjb25zdHJ1Y3RvclxuICogIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqL1xuZnVuY3Rpb24gQ3VydmUodGFyZ2V0cywgb3B0aW9ucykge1xuICAgIGlmICh0YXJnZXRzKSB7XG4gICAgICAgIGlmICh0YXJnZXRzIGluc3RhbmNlb2YgQXJyYXkpIHRoaXMudGFyZ2V0cyA9IHRhcmdldHM7XG4gICAgICAgIGVsc2UgdGhpcy50YXJnZXRzID0gW3RhcmdldHNdO1xuICAgIH1cbiAgICBlbHNlIHRoaXMudGFyZ2V0cyA9IFtdO1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5pbXB1bHNlcyA9IHt9O1xuICAgIHRoaXMubm9ybWFscyA9IHt9O1xuICAgIHRoaXMudmVsb2NpdHlCaWFzZXMgPSB7fTtcbiAgICB0aGlzLmRpdmlzb3JzID0ge307XG59XG5cbkN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29uc3RyYWludC5wcm90b3R5cGUpO1xuQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3VydmU7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgQ3VydmUuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICovXG5DdXJ2ZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZXF1YXRpb24xID0gdGhpcy5lcXVhdGlvbjEgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgdGhpcy5lcXVhdGlvbjIgPSB0aGlzLmVxdWF0aW9uMiB8fCBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgICAgIHJldHVybiB6O1xuICAgIH07XG4gICAgdGhpcy5wZXJpb2QgPSB0aGlzLnBlcmlvZCB8fCAxO1xuICAgIHRoaXMuZGFtcGluZ1JhdGlvID0gdGhpcy5kYW1waW5nUmF0aW8gfHwgMC41O1xuXG4gICAgdGhpcy5zdGlmZm5lc3MgPSA0ICogUEkgKiBQSSAvICh0aGlzLnBlcmlvZCAqIHRoaXMucGVyaW9kKTtcbiAgICB0aGlzLmRhbXBpbmcgPSA0ICogUEkgKiB0aGlzLmRhbXBpbmdSYXRpbyAvIHRoaXMucGVyaW9kO1xufTtcblxuLyoqXG4gKiBXYXJtc3RhcnQgdGhlIGNvbnN0cmFpbnQgYW5kIHByZXBhcmUgY2FsY3VsYXRpb25zIHVzZWQgaW4gdGhlIC5yZXNvbHZlIHN0ZXAuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSBjdXJyZW50IHRpbWUgaW4gdGhlIHBoeXNpY3MgZW5naW5lLlxuICogQHBhcmFtIHtOdW1iZXJ9IGR0IFRoZSBwaHlzaWNzIGVuZ2luZSBmcmFtZSBkZWx0YS5cbiAqL1xuQ3VydmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh0aW1lLCBkdCkge1xuICAgIHZhciB0YXJnZXRzID0gdGhpcy50YXJnZXRzO1xuXG4gICAgdmFyIG5vcm1hbHMgPSB0aGlzLm5vcm1hbHM7XG4gICAgdmFyIHZlbG9jaXR5Qmlhc2VzID0gdGhpcy52ZWxvY2l0eUJpYXNlcztcbiAgICB2YXIgZGl2aXNvcnMgPSB0aGlzLmRpdmlzb3JzO1xuICAgIHZhciBpbXB1bHNlcyA9IHRoaXMuaW1wdWxzZXM7XG5cbiAgICB2YXIgaW1wdWxzZSA9IElNUFVMU0VfUkVHSVNURVI7XG4gICAgdmFyIG4gPSBOT1JNQUxfUkVHSVNURVI7XG5cbiAgICB2YXIgZiA9IHRoaXMuZXF1YXRpb24xO1xuICAgIHZhciBnID0gdGhpcy5lcXVhdGlvbjI7XG5cbiAgICB2YXIgX2MgPSB0aGlzLmRhbXBpbmc7XG4gICAgdmFyIF9rID0gdGhpcy5zdGlmZm5lc3M7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYm9keSA9IHRhcmdldHNbaV07XG4gICAgICAgIHZhciBJRCA9IGJvZHkuX0lEO1xuICAgICAgICBpZiAoYm9keS5pbW11bmUpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBwID0gYm9keS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIG0gPSBib2R5Lm1hc3M7XG5cbiAgICAgICAgdmFyIGdhbW1hO1xuICAgICAgICB2YXIgYmV0YTtcblxuICAgICAgICBpZiAodGhpcy5wZXJpb2QgPT09IDApIHtcbiAgICAgICAgICAgIGdhbW1hID0gMDtcbiAgICAgICAgICAgIGJldGEgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGMgPSBfYyAqIG07XG4gICAgICAgICAgICB2YXIgayA9IF9rICogbTtcblxuICAgICAgICAgICAgZ2FtbWEgPSAxIC8gKGR0KihjICsgZHQqaykpO1xuICAgICAgICAgICAgYmV0YSAgPSBkdCprIC8gKGMgKyBkdCprKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0gcC54O1xuICAgICAgICB2YXIgeSA9IHAueTtcbiAgICAgICAgdmFyIHogPSBwLno7XG5cbiAgICAgICAgdmFyIGYwID0gZih4LCB5LCB6KTtcbiAgICAgICAgdmFyIGRmeCA9IChmKHggKyBFUFNJTFNPTiwgeSwgeikgLSBmMCkgLyBFUFNJTFNPTjtcbiAgICAgICAgdmFyIGRmeSA9IChmKHgsIHkgKyBFUFNJTFNPTiwgeikgLSBmMCkgLyBFUFNJTFNPTjtcbiAgICAgICAgdmFyIGRmeiA9IChmKHgsIHksIHogKyBFUFNJTFNPTikgLSBmMCkgLyBFUFNJTFNPTjtcblxuICAgICAgICB2YXIgZzAgPSBnKHgsIHksIHopO1xuICAgICAgICB2YXIgZGd4ID0gKGcoeCArIEVQU0lMU09OLCB5LCB6KSAtIGcwKSAvIEVQU0lMU09OO1xuICAgICAgICB2YXIgZGd5ID0gKGcoeCwgeSArIEVQU0lMU09OLCB6KSAtIGcwKSAvIEVQU0lMU09OO1xuICAgICAgICB2YXIgZGd6ID0gKGcoeCwgeSwgeiArIEVQU0lMU09OKSAtIGcwKSAvIEVQU0lMU09OO1xuXG4gICAgICAgIG4uc2V0KGRmeCArIGRneCwgZGZ5ICsgZGd5LCBkZnogKyBkZ3opO1xuICAgICAgICBuLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHZhciBiYXVtZ2FydGUgPSBiZXRhICogKGYwICsgZzApIC8gZHQ7XG4gICAgICAgIHZhciBkaXZpc29yID0gZ2FtbWEgKyAxIC8gbTtcblxuICAgICAgICB2YXIgbGFtYmRhID0gaW1wdWxzZXNbSURdIHx8IDA7XG4gICAgICAgIFZlYzMuc2NhbGUobiwgbGFtYmRhLCBpbXB1bHNlKTtcbiAgICAgICAgYm9keS5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG5cbiAgICAgICAgbm9ybWFsc1tJRF0gPSBub3JtYWxzW0lEXSB8fCBuZXcgVmVjMygpO1xuICAgICAgICBub3JtYWxzW0lEXS5jb3B5KG4pO1xuICAgICAgICB2ZWxvY2l0eUJpYXNlc1tJRF0gPSBiYXVtZ2FydGU7XG4gICAgICAgIGRpdmlzb3JzW0lEXSA9IGRpdmlzb3I7XG4gICAgICAgIGltcHVsc2VzW0lEXSA9IDA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGRzIGEgY3VydmUgaW1wdWxzZSB0byBhIHBoeXNpY3MgYm9keS5cbiAqXG4gKiBAbWV0aG9kIHJlc29sdmVcbiAqL1xuQ3VydmUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIHZhciB0YXJnZXRzID0gdGhpcy50YXJnZXRzO1xuXG4gICAgdmFyIG5vcm1hbHMgPSB0aGlzLm5vcm1hbHM7XG4gICAgdmFyIHZlbG9jaXR5Qmlhc2VzID0gdGhpcy52ZWxvY2l0eUJpYXNlcztcbiAgICB2YXIgZGl2aXNvcnMgPSB0aGlzLmRpdmlzb3JzO1xuICAgIHZhciBpbXB1bHNlcyA9IHRoaXMuaW1wdWxzZXM7XG5cbiAgICB2YXIgaW1wdWxzZSA9IElNUFVMU0VfUkVHSVNURVI7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYm9keSA9IHRhcmdldHNbaV07XG4gICAgICAgIHZhciBJRCA9IGJvZHkuX0lEO1xuICAgICAgICBpZiAoYm9keS5pbW11bmUpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciB2ID0gYm9keS52ZWxvY2l0eTtcbiAgICAgICAgdmFyIG4gPSBub3JtYWxzW0lEXTtcblxuICAgICAgICB2YXIgbGFtYmRhID0gLShWZWMzLmRvdChuLCB2KSArIHZlbG9jaXR5Qmlhc2VzW0lEXSkgLyBkaXZpc29yc1tJRF07XG5cbiAgICAgICAgVmVjMy5zY2FsZShuLCBsYW1iZGEsIGltcHVsc2UpO1xuICAgICAgICBib2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcblxuXG4gICAgICAgIGltcHVsc2VzW0lEXSArPSBsYW1iZGE7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDdXJ2ZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50Jyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcblxudmFyIE5PUk1BTF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgSU1QVUxTRV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgUF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgRElSRUNUSU9OX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqIEBjb25zdCAqL1xudmFyIFBJID0gTWF0aC5QSTtcblxuLyoqXG4gKiAgQSBjb25zdHJhaW50IHRoYXQgbWFpbnRhaW5zIHRoZSBkaXJlY3Rpb24gb2Ygb25lIGJvZHkgZnJvbSBhbm90aGVyLlxuICpcbiAqICBAY2xhc3MgRGlyZWN0aW9uXG4gKiAgQGV4dGVuZHMgQ29uc3RyYWludFxuICogIEBwYXJhbSB7UGFydGljbGV9IGEgT25lIG9mIHRoZSBib2RpZXMuXG4gKiAgQHBhcmFtIHtQYXJ0aWNsZX0gYiBUaGUgb3RoZXIgYm9keS5cbiAqICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3Qgb2YgY29uZmlndXJhYmxlIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIERpcmVjdGlvbihhLCBiLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5pbXB1bHNlID0gMDtcbiAgICB0aGlzLmRpc3RhbmNlID0gMDtcbiAgICB0aGlzLm5vcm1hbCA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy52ZWxvY2l0eUJpYXMgPSAwO1xuICAgIHRoaXMuZGl2aXNvciA9IDA7XG59XG5cbkRpcmVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbnN0cmFpbnQucHJvdG90eXBlKTtcbkRpcmVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXJlY3Rpb247XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgRGlyZWN0aW9uLiBTZXRzIGRlZmF1bHRzIGlmIGEgcHJvcGVydHkgd2FzIG5vdCBhbHJlYWR5IHNldC5cbiAqXG4gKiBAbWV0aG9kIGluaXRcbiAqL1xuRGlyZWN0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbiB8fCBWZWMzLnN1YnRyYWN0KHRoaXMuYi5wb3NpdGlvbiwgdGhpcy5hLnBvc2l0aW9uLCBuZXcgVmVjMygpKTtcbiAgICB0aGlzLmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICB0aGlzLm1pbkxlbmd0aCA9IHRoaXMubWluTGVuZ3RoIHx8IDA7XG4gICAgdGhpcy5wZXJpb2QgPSB0aGlzLnBlcmlvZCB8fCAwLjI7XG4gICAgdGhpcy5kYW1waW5nUmF0aW8gPSB0aGlzLmRhbXBpbmdSYXRpbyB8fCAwLjU7XG5cbiAgICB0aGlzLnN0aWZmbmVzcyA9IDQgKiBQSSAqIFBJIC8gKHRoaXMucGVyaW9kICogdGhpcy5wZXJpb2QpO1xuICAgIHRoaXMuZGFtcGluZyA9IDQgKiBQSSAqIHRoaXMuZGFtcGluZ1JhdGlvIC8gdGhpcy5wZXJpb2Q7XG59O1xuXG4vKipcbiAqIFdhcm1zdGFydCB0aGUgY29uc3RyYWludCBhbmQgcHJlcGFyZSBjYWxjdWxhdGlvbnMgdXNlZCBpbiAucmVzb2x2ZS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIGN1cnJlbnQgdGltZSBpbiB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgVGhlIHBoeXNpY3MgZW5naW5lIGZyYW1lIGRlbHRhLlxuICovXG5EaXJlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh0aW1lLCBkdCkge1xuICAgIHZhciBhID0gdGhpcy5hO1xuICAgIHZhciBiID0gdGhpcy5iO1xuXG4gICAgdmFyIG4gPSBOT1JNQUxfUkVHSVNURVI7XG4gICAgdmFyIGRpZmZQID0gUF9SRUdJU1RFUjtcbiAgICB2YXIgaW1wdWxzZSA9IElNUFVMU0VfUkVHSVNURVI7XG4gICAgdmFyIGRpcmVjdGlvblZlY3RvciA9IERJUkVDVElPTl9SRUdJU1RFUjtcblxuICAgIHZhciBwMSA9IGEucG9zaXRpb247XG4gICAgdmFyIHcxID0gYS5pbnZlcnNlTWFzcztcblxuICAgIHZhciBwMiA9IGIucG9zaXRpb247XG4gICAgdmFyIHcyID0gYi5pbnZlcnNlTWFzcztcblxuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjtcblxuICAgIFZlYzMuc3VidHJhY3QocDIsIHAxLCBkaWZmUCk7XG4gICAgVmVjMy5zY2FsZShkaXJlY3Rpb24sIFZlYzMuZG90KGRpcmVjdGlvbiwgZGlmZlApLCBkaXJlY3Rpb25WZWN0b3IpO1xuICAgIHZhciBnb2FsID0gZGlyZWN0aW9uVmVjdG9yLmFkZChwMSk7XG5cbiAgICBWZWMzLnN1YnRyYWN0KHAyLCBnb2FsLCBuKTtcbiAgICB2YXIgZGlzdCA9IG4ubGVuZ3RoKCk7XG4gICAgbi5ub3JtYWxpemUoKTtcblxuICAgIHZhciBpbnZFZmZlY3RpdmVNYXNzID0gdzEgKyB3MjtcbiAgICB2YXIgZWZmZWN0aXZlTWFzcyA9IDEgLyBpbnZFZmZlY3RpdmVNYXNzO1xuICAgIHZhciBnYW1tYTtcbiAgICB2YXIgYmV0YTtcblxuICAgIGlmICh0aGlzLnBlcmlvZCA9PT0gMCkge1xuICAgICAgICBnYW1tYSA9IDA7XG4gICAgICAgIGJldGEgID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5kYW1waW5nICogZWZmZWN0aXZlTWFzcztcbiAgICAgICAgdmFyIGsgPSB0aGlzLnN0aWZmbmVzcyAqIGVmZmVjdGl2ZU1hc3M7XG5cbiAgICAgICAgZ2FtbWEgPSAxIC8gKGR0KihjICsgZHQqaykpO1xuICAgICAgICBiZXRhICA9IGR0KmsgLyAoYyArIGR0KmspO1xuICAgIH1cblxuICAgIHZhciBiYXVtZ2FydGUgPSBiZXRhICogZGlzdCAvIGR0O1xuICAgIHZhciBkaXZpc29yID0gZ2FtbWEgKyBpbnZFZmZlY3RpdmVNYXNzO1xuXG4gICAgdmFyIGxhbWJkYSA9IHRoaXMuaW1wdWxzZTtcbiAgICBWZWMzLnNjYWxlKG4sIGxhbWJkYSwgaW1wdWxzZSk7XG4gICAgYi5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYS5hcHBseUltcHVsc2UoaW1wdWxzZS5pbnZlcnQoKSk7XG5cbiAgICB0aGlzLm5vcm1hbC5jb3B5KG4pO1xuICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0O1xuICAgIHRoaXMudmVsb2NpdHlCaWFzID0gYmF1bWdhcnRlO1xuICAgIHRoaXMuZGl2aXNvciA9IGRpdmlzb3I7XG4gICAgdGhpcy5pbXB1bHNlID0gMDtcbn07XG5cbi8qKlxuICogQWRkcyBhbiBpbXB1bHNlIHRvIGEgcGh5c2ljcyBib2R5J3MgdmVsb2NpdHkgZHVlIHRvIHRoZSBjb25zdHJhaW50XG4gKlxuICogQG1ldGhvZCByZXNvbHZlXG4gKi9cbkRpcmVjdGlvbi5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcblxuICAgIHZhciBpbXB1bHNlICA9IElNUFVMU0VfUkVHSVNURVI7XG4gICAgdmFyIGRpZmZWID0gVl9SRUdJU1RFUjtcblxuICAgIHZhciBtaW5MZW5ndGggPSB0aGlzLm1pbkxlbmd0aDtcblxuICAgIHZhciBkaXN0ID0gdGhpcy5kaXN0YW5jZTtcbiAgICBpZiAoTWF0aC5hYnMoZGlzdCkgPCBtaW5MZW5ndGgpIHJldHVybjtcblxuICAgIHZhciB2MSA9IGEudmVsb2NpdHk7XG4gICAgdmFyIHYyID0gYi52ZWxvY2l0eTtcbiAgICB2YXIgbiA9IHRoaXMubm9ybWFsO1xuXG4gICAgVmVjMy5zdWJ0cmFjdCh2MiwgdjEsIGRpZmZWKTtcblxuICAgIHZhciBsYW1iZGEgPSAtKFZlYzMuZG90KG4sIGRpZmZWKSArIHRoaXMudmVsb2NpdHlCaWFzKSAvIHRoaXMuZGl2aXNvcjtcbiAgICBWZWMzLnNjYWxlKG4sIGxhbWJkYSwgaW1wdWxzZSk7XG4gICAgYi5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYS5hcHBseUltcHVsc2UoaW1wdWxzZS5pbnZlcnQoKSk7XG5cbiAgICB0aGlzLmltcHVsc2UgKz0gbGFtYmRhO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXJlY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50Jyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcblxudmFyIE5PUk1BTF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgSU1QVUxTRV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgUF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKiBAY29uc3QgKi9cbnZhciBQSSA9IE1hdGguUEk7XG5cbi8qKlxuICogIEEgY29uc3RyYWludCB0aGF0IGtlZXBzIHR3byBib2RpZXMgd2l0aGluIGEgY2VydGFpbiBkaXN0YW5jZS5cbiAqXG4gKiAgQGNsYXNzIERpc3RhbmNlXG4gKiAgQGV4dGVuZHMgQ29uc3RyYWludFxuICogIEBwYXJhbSB7UGFydGljbGV9IGEgT25lIG9mIHRoZSBib2RpZXMuXG4gKiAgQHBhcmFtIHtQYXJ0aWNsZX0gYiBUaGUgb3RoZXIgYm9keS5cbiAqICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3Qgb2YgY29uZmlndXJhYmxlIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIERpc3RhbmNlKGEsIGIsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmEgPSBhO1xuICAgIHRoaXMuYiA9IGI7XG5cbiAgICBDb25zdHJhaW50LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmltcHVsc2UgPSAwO1xuICAgIHRoaXMuZGlzdGFuY2UgPSAwO1xuICAgIHRoaXMubm9ybWFsID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnZlbG9jaXR5QmlhcyA9IDA7XG4gICAgdGhpcy5kaXZpc29yID0gMDtcbn1cblxuRGlzdGFuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb25zdHJhaW50LnByb3RvdHlwZSk7XG5EaXN0YW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXN0YW5jZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBEaXN0YW5jZS4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKi9cbkRpc3RhbmNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCBWZWMzLnN1YnRyYWN0KHRoaXMuYi5wb3NpdGlvbiwgdGhpcy5hLnBvc2l0aW9uLCBQX1JFR0lTVEVSKS5sZW5ndGgoKTtcbiAgICB0aGlzLm1pbkxlbmd0aCA9IHRoaXMubWluTGVuZ3RoIHx8IDA7XG4gICAgdGhpcy5wZXJpb2QgPSB0aGlzLnBlcmlvZCB8fCAwLjI7XG4gICAgdGhpcy5kYW1waW5nUmF0aW8gPSB0aGlzLmRhbXBpbmdSYXRpbyB8fCAwLjU7XG5cbiAgICB0aGlzLnN0aWZmbmVzcyA9IDQgKiBQSSAqIFBJIC8gKHRoaXMucGVyaW9kICogdGhpcy5wZXJpb2QpO1xuICAgIHRoaXMuZGFtcGluZyA9IDQgKiBQSSAqIHRoaXMuZGFtcGluZ1JhdGlvIC8gdGhpcy5wZXJpb2Q7XG59O1xuXG4vKipcbiAqIERldGVjdCB2aW9sYXRpb25zIG9mIHRoZSBjb25zdHJhaW50LiBXYXJtIHN0YXJ0IHRoZSBjb25zdHJhaW50LCBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIGN1cnJlbnQgdGltZSBpbiB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgVGhlIHBoeXNpY3MgZW5naW5lIGZyYW1lIGRlbHRhLlxuICovXG5EaXN0YW5jZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24odGltZSwgZHQpIHtcbiAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcblxuICAgIHZhciBuID0gTk9STUFMX1JFR0lTVEVSO1xuICAgIHZhciBkaWZmUCA9IFBfUkVHSVNURVI7XG4gICAgdmFyIGltcHVsc2UgPSBJTVBVTFNFX1JFR0lTVEVSO1xuXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgdmFyIHAxID0gYS5wb3NpdGlvbjtcbiAgICB2YXIgdzEgPSBhLmludmVyc2VNYXNzO1xuXG4gICAgdmFyIHAyID0gYi5wb3NpdGlvbjtcbiAgICB2YXIgdzIgPSBiLmludmVyc2VNYXNzO1xuXG4gICAgVmVjMy5zdWJ0cmFjdChwMiwgcDEsIGRpZmZQKTtcblxuICAgIHZhciBzZXBhcmF0aW9uID0gZGlmZlAubGVuZ3RoKCk7XG5cbiAgICBWZWMzLnNjYWxlKGRpZmZQLCAxIC8gc2VwYXJhdGlvbiwgbik7XG5cbiAgICB2YXIgZGlzdCA9IHNlcGFyYXRpb24gLSBsZW5ndGg7XG5cbiAgICB2YXIgaW52RWZmZWN0aXZlTWFzcyA9IHcxICsgdzI7XG4gICAgdmFyIGVmZmVjdGl2ZU1hc3MgPSAxIC8gaW52RWZmZWN0aXZlTWFzcztcbiAgICB2YXIgZ2FtbWE7XG4gICAgdmFyIGJldGE7XG5cbiAgICBpZiAodGhpcy5wZXJpb2QgPT09IDApIHtcbiAgICAgICAgZ2FtbWEgPSAwO1xuICAgICAgICBiZXRhICA9IDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYyA9IHRoaXMuZGFtcGluZyAqIGVmZmVjdGl2ZU1hc3M7XG4gICAgICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MgKiBlZmZlY3RpdmVNYXNzO1xuXG4gICAgICAgIGdhbW1hID0gMSAvIChkdCooYyArIGR0KmspKTtcbiAgICAgICAgYmV0YSAgPSBkdCprIC8gKGMgKyBkdCprKTtcbiAgICB9XG5cbiAgICB2YXIgYmF1bWdhcnRlID0gYmV0YSAqIGRpc3QgLyBkdDtcbiAgICB2YXIgZGl2aXNvciA9IGdhbW1hICsgaW52RWZmZWN0aXZlTWFzcztcblxuICAgIHZhciBsYW1iZGEgPSB0aGlzLmltcHVsc2U7XG4gICAgVmVjMy5zY2FsZShuLCBsYW1iZGEsIGltcHVsc2UpO1xuICAgIGIuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGEuYXBwbHlJbXB1bHNlKGltcHVsc2UuaW52ZXJ0KCkpO1xuXG4gICAgdGhpcy5ub3JtYWwuY29weShuKTtcbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdDtcbiAgICB0aGlzLnZlbG9jaXR5QmlhcyA9IGJhdW1nYXJ0ZTtcbiAgICB0aGlzLmRpdmlzb3IgPSBkaXZpc29yO1xuICAgIHRoaXMuaW1wdWxzZSA9IDA7XG59O1xuXG4vKipcbiAqIEFwcGx5IGltcHVsc2VzIHRvIHJlc29sdmUgdGhlIGNvbnN0cmFpbnQuXG4gKlxuICogQG1ldGhvZCByZXNvbHZlXG4gKi9cbkRpc3RhbmNlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcblxuICAgIHZhciBpbXB1bHNlID0gSU1QVUxTRV9SRUdJU1RFUjtcbiAgICB2YXIgZGlmZlYgPSBWX1JFR0lTVEVSO1xuXG4gICAgdmFyIG1pbkxlbmd0aCA9IHRoaXMubWluTGVuZ3RoO1xuXG4gICAgdmFyIGRpc3QgPSB0aGlzLmRpc3RhbmNlO1xuICAgIGlmIChNYXRoLmFicyhkaXN0KSA8IG1pbkxlbmd0aCkgcmV0dXJuO1xuXG4gICAgdmFyIHYxID0gYS5nZXRWZWxvY2l0eSgpO1xuICAgIHZhciB2MiA9IGIuZ2V0VmVsb2NpdHkoKTtcblxuICAgIHZhciBuID0gdGhpcy5ub3JtYWw7XG5cbiAgICBWZWMzLnN1YnRyYWN0KHYyLCB2MSwgZGlmZlYpO1xuICAgIHZhciBsYW1iZGEgPSAtKFZlYzMuZG90KG4sIGRpZmZWKSArIHRoaXMudmVsb2NpdHlCaWFzKSAvIHRoaXMuZGl2aXNvcjtcbiAgICBWZWMzLnNjYWxlKG4sIGxhbWJkYSwgaW1wdWxzZSk7XG4gICAgYi5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYS5hcHBseUltcHVsc2UoaW1wdWxzZS5pbnZlcnQoKSk7XG5cbiAgICB0aGlzLmltcHVsc2UgKz0gbGFtYmRhO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xudmFyIE1hdDMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5NYXQzMztcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5RdWF0ZXJuaW9uO1xuXG52YXIgVkVDMV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkVDMl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkVDM19SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkVDNF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkIxX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBWQjJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFd4Ul9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgREVMVEFfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqICBBIGNvbnN0cmFpbnQgdGhhdCBjb25maW5lcyB0d28gYm9kaWVzIHRvIHRoZSBwbGFuZSBkZWZpbmVkIGJ5IHRoZSBheGlzIG9mIHRoZSBoaW5nZS5cbiAqXG4gKiAgQGNsYXNzIEhpbmdlXG4gKiAgQGV4dGVuZHMgQ29uc3RyYWludFxuICogIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIEFuIG9iamVjdCBvZiBjb25maWd1cmFibGUgb3B0aW9ucy5cbiAqXG4gKi9cbmZ1bmN0aW9uIEhpbmdlKGEsIGIsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmEgPSBhO1xuICAgIHRoaXMuYiA9IGI7XG5cbiAgICBDb25zdHJhaW50LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmltcHVsc2UgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYW5nSW1wdWxzZUEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYW5nSW1wdWxzZUIgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuZXJyb3IgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuZXJyb3JSb3QgPSBbMCwwXTtcbiAgICB0aGlzLmVmZk1hc3NNYXRyaXggPSBuZXcgTWF0MzMoKTtcbiAgICB0aGlzLmVmZk1hc3NNYXRyaXhSb3QgPSBbXTtcbn1cblxuSGluZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb25zdHJhaW50LnByb3RvdHlwZSk7XG5IaW5nZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIaW5nZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBIaW5nZS4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKi9cbkhpbmdlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHcgPSB0aGlzLmFuY2hvcjtcblxuICAgIHZhciB1ID0gdGhpcy5heGlzLm5vcm1hbGl6ZSgpO1xuXG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgcTF0ID0gUXVhdGVybmlvbi5jb25qdWdhdGUoYS5vcmllbnRhdGlvbiwgbmV3IFF1YXRlcm5pb24oKSk7XG4gICAgdmFyIHEydCA9IFF1YXRlcm5pb24uY29uanVnYXRlKGIub3JpZW50YXRpb24sIG5ldyBRdWF0ZXJuaW9uKCkpO1xuXG4gICAgdGhpcy5yQSA9IFZlYzMuc3VidHJhY3QodywgYS5wb3NpdGlvbiwgbmV3IFZlYzMoKSk7XG4gICAgdGhpcy5yQiA9IFZlYzMuc3VidHJhY3QodywgYi5wb3NpdGlvbiwgbmV3IFZlYzMoKSk7XG5cbiAgICB0aGlzLmJvZHlSQSA9IHExdC5yb3RhdGVWZWN0b3IodGhpcy5yQSwgbmV3IFZlYzMoKSk7XG4gICAgdGhpcy5ib2R5UkIgPSBxMnQucm90YXRlVmVjdG9yKHRoaXMuckIsIG5ldyBWZWMzKCkpO1xuXG4gICAgdGhpcy5heGlzQSA9IFZlYzMuY2xvbmUodSk7XG4gICAgdGhpcy5heGlzQiA9IFZlYzMuY2xvbmUodSk7XG5cbiAgICB0aGlzLmF4aXNCVGFuZ2VudDEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYXhpc0JUYW5nZW50MiA9IG5ldyBWZWMzKCk7XG5cbiAgICB0aGlzLnQxeEEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMudDJ4QSA9IG5ldyBWZWMzKCk7XG5cbiAgICB0aGlzLmJvZHlBeGlzQSA9IHExdC5yb3RhdGVWZWN0b3IodSwgbmV3IFZlYzMoKSk7XG4gICAgdGhpcy5ib2R5QXhpc0IgPSBxMnQucm90YXRlVmVjdG9yKHUsIG5ldyBWZWMzKCkpO1xufTtcblxuLyoqXG4gKiBEZXRlY3QgdmlvbGF0aW9ucyBvZiB0aGUgY29uc3RyYWludC4gV2FybSBzdGFydCB0aGUgY29uc3RyYWludCwgaWYgcG9zc2libGUuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSBjdXJyZW50IHRpbWUgaW4gdGhlIHBoeXNpY3MgZW5naW5lLlxuICogQHBhcmFtIHtOdW1iZXJ9IGR0IFRoZSBwaHlzaWNzIGVuZ2luZSBmcmFtZSBkZWx0YS5cbiAqL1xuSGluZ2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHRpbWUsIGR0KSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgYXhpc0EgPSBhLm9yaWVudGF0aW9uLnJvdGF0ZVZlY3Rvcih0aGlzLmJvZHlBeGlzQSwgdGhpcy5heGlzQSk7XG4gICAgdmFyIGF4aXNCID0gYi5vcmllbnRhdGlvbi5yb3RhdGVWZWN0b3IodGhpcy5ib2R5QXhpc0IsIHRoaXMuYXhpc0IpO1xuICAgIHRoaXMuYXhpcy5jb3B5KGF4aXNCKTtcblxuICAgIHZhciBuID0gYXhpc0I7XG4gICAgdmFyIHQxID0gdGhpcy5heGlzQlRhbmdlbnQxO1xuICAgIHZhciB0MiA9IHRoaXMuYXhpc0JUYW5nZW50MjtcblxuICAgIGlmIChuLnggPj0gMC41NzczNSkge1xuICAgICAgICB0MS5zZXQobi55LCAtbi54LCAwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHQxLnNldCgwLCBuLnosIC1uLnkpO1xuICAgIH1cbiAgICB0MS5ub3JtYWxpemUoKTtcbiAgICBWZWMzLmNyb3NzKG4sIHQxLCB0Mik7XG5cbiAgICB2YXIgdDF4QSA9IFZlYzMuY3Jvc3ModDEsIGF4aXNBLCB0aGlzLnQxeEEpO1xuICAgIHZhciB0MnhBID0gVmVjMy5jcm9zcyh0MiwgYXhpc0EsIHRoaXMudDJ4QSk7XG5cbiAgICB2YXIgckEgPSBhLm9yaWVudGF0aW9uLnJvdGF0ZVZlY3Rvcih0aGlzLmJvZHlSQSwgdGhpcy5yQSk7XG4gICAgdmFyIHJCID0gYi5vcmllbnRhdGlvbi5yb3RhdGVWZWN0b3IodGhpcy5ib2R5UkIsIHRoaXMuckIpO1xuXG4gICAgdmFyIHhSQSA9IG5ldyBNYXQzMyhbMCxyQS56LC1yQS55LC1yQS56LDAsckEueCxyQS55LC1yQS54LDBdKTtcbiAgICB2YXIgeFJCID0gbmV3IE1hdDMzKFswLHJCLnosLXJCLnksLXJCLnosMCxyQi54LHJCLnksLXJCLngsMF0pO1xuXG4gICAgdmFyIFJJYVJ0ID0gTWF0MzMubXVsdGlwbHkoeFJBLCBhLmludmVyc2VJbmVydGlhLCBuZXcgTWF0MzMoKSkubXVsdGlwbHkoeFJBLnRyYW5zcG9zZSgpKTtcbiAgICB2YXIgUkliUnQgPSBNYXQzMy5tdWx0aXBseSh4UkIsIGIuaW52ZXJzZUluZXJ0aWEsIG5ldyBNYXQzMygpKS5tdWx0aXBseSh4UkIudHJhbnNwb3NlKCkpO1xuXG4gICAgdmFyIGludkVmZkluZXJ0aWEgPSBNYXQzMy5hZGQoUklhUnQsIFJJYlJ0LCBSSWFSdCk7XG5cbiAgICB2YXIgd29ybGRBID0gVmVjMy5hZGQoYS5wb3NpdGlvbiwgdGhpcy5yQSwgdGhpcy5hbmNob3IpO1xuICAgIHZhciB3b3JsZEIgPSBWZWMzLmFkZChiLnBvc2l0aW9uLCB0aGlzLnJCLCBWRUMxX1JFR0lTVEVSKTtcblxuICAgIHZhciBpbnZEdCA9IDEvZHQ7XG4gICAgVmVjMy5zdWJ0cmFjdCh3b3JsZEIsIHdvcmxkQSwgdGhpcy5lcnJvcik7XG4gICAgdGhpcy5lcnJvci5zY2FsZSgwLjIqaW52RHQpO1xuXG4gICAgdmFyIGltQSA9IGEuaW52ZXJzZU1hc3M7XG4gICAgdmFyIGltQiA9IGIuaW52ZXJzZU1hc3M7XG5cbiAgICB2YXIgaW52RWZmTWFzcyA9IG5ldyBNYXQzMyhbaW1BICsgaW1CLDAsMCwwLGltQSArIGltQiwwLDAsMCxpbUEgKyBpbUJdKTtcblxuICAgIE1hdDMzLmFkZChpbnZFZmZJbmVydGlhLCBpbnZFZmZNYXNzLCB0aGlzLmVmZk1hc3NNYXRyaXgpO1xuICAgIHRoaXMuZWZmTWFzc01hdHJpeC5pbnZlcnNlKCk7XG5cbiAgICB2YXIgaW52SUF0MXhBID0gYS5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseSh0MXhBLCBWRUMxX1JFR0lTVEVSKTtcbiAgICB2YXIgaW52SUF0MnhBID0gYS5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseSh0MnhBLCBWRUMyX1JFR0lTVEVSKTtcbiAgICB2YXIgaW52SUJ0MXhBID0gYi5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseSh0MXhBLCBWRUMzX1JFR0lTVEVSKTtcbiAgICB2YXIgaW52SUJ0MnhBID0gYi5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseSh0MnhBLCBWRUM0X1JFR0lTVEVSKTtcblxuICAgIHZhciBhMTEgPSBWZWMzLmRvdCh0MXhBLCBpbnZJQXQxeEEpICsgVmVjMy5kb3QodDF4QSwgaW52SUJ0MXhBKTtcbiAgICB2YXIgYTEyID0gVmVjMy5kb3QodDF4QSwgaW52SUF0MnhBKSArIFZlYzMuZG90KHQxeEEsIGludklCdDJ4QSk7XG4gICAgdmFyIGEyMSA9IFZlYzMuZG90KHQyeEEsIGludklBdDF4QSkgKyBWZWMzLmRvdCh0MnhBLCBpbnZJQnQxeEEpO1xuICAgIHZhciBhMjIgPSBWZWMzLmRvdCh0MnhBLCBpbnZJQXQyeEEpICsgVmVjMy5kb3QodDJ4QSwgaW52SUJ0MnhBKTtcblxuICAgIHZhciBkZXQgPSAxIC8gKGExMSphMjIgLSBhMTIqYTIxKTtcblxuICAgIHRoaXMuZWZmTWFzc01hdHJpeFJvdFswXSA9IGEyMiAqIGRldDtcbiAgICB0aGlzLmVmZk1hc3NNYXRyaXhSb3RbMV0gPSAtYTIxICogZGV0O1xuICAgIHRoaXMuZWZmTWFzc01hdHJpeFJvdFsyXSA9IC1hMTIgKiBkZXQ7XG4gICAgdGhpcy5lZmZNYXNzTWF0cml4Um90WzNdID0gYTExICogZGV0O1xuXG4gICAgdGhpcy5lcnJvclJvdFswXSA9IFZlYzMuZG90KGF4aXNBLCB0MSkgKiAwLjIqaW52RHQ7XG4gICAgdGhpcy5lcnJvclJvdFsxXSA9IFZlYzMuZG90KGF4aXNBLCB0MikgKiAwLjIqaW52RHQ7XG5cbiAgICB2YXIgaW1wdWxzZSA9IHRoaXMuaW1wdWxzZS5zY2FsZSgwLjUpO1xuICAgIHZhciBhbmdJbXB1bHNlQSA9IHRoaXMuYW5nSW1wdWxzZUEuc2NhbGUoMC41KTtcbiAgICB2YXIgYW5nSW1wdWxzZUIgPSB0aGlzLmFuZ0ltcHVsc2VCLnNjYWxlKDAuNSk7XG5cbiAgICBiLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBiLmFwcGx5QW5ndWxhckltcHVsc2UoYW5nSW1wdWxzZUIpO1xuICAgIGltcHVsc2UuaW52ZXJ0KCk7XG4gICAgYS5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYS5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ0ltcHVsc2VBKTtcblxuICAgIGltcHVsc2UuY2xlYXIoKTtcbiAgICBhbmdJbXB1bHNlQS5jbGVhcigpO1xuICAgIGFuZ0ltcHVsc2VCLmNsZWFyKCk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGltcHVsc2VzIHRvIHJlc29sdmUgdGhlIGNvbnN0cmFpbnQuXG4gKlxuICogQG1ldGhvZCByZXNvbHZlXG4gKi9cbkhpbmdlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcblxuICAgIHZhciByQSA9IHRoaXMuckE7XG4gICAgdmFyIHJCID0gdGhpcy5yQjtcblxuICAgIHZhciB0MXhBID0gdGhpcy50MXhBO1xuICAgIHZhciB0MnhBID0gdGhpcy50MnhBO1xuXG4gICAgdmFyIHcxID0gYS5hbmd1bGFyVmVsb2NpdHk7XG4gICAgdmFyIHcyID0gYi5hbmd1bGFyVmVsb2NpdHk7XG5cbiAgICB2YXIgdjEgPSBWZWMzLmFkZChhLnZlbG9jaXR5LCBWZWMzLmNyb3NzKHcxLCByQSwgV3hSX1JFR0lTVEVSKSwgVkIxX1JFR0lTVEVSKTtcbiAgICB2YXIgdjIgPSBWZWMzLmFkZChiLnZlbG9jaXR5LCBWZWMzLmNyb3NzKHcyLCByQiwgV3hSX1JFR0lTVEVSKSwgVkIyX1JFR0lTVEVSKTtcblxuICAgIHZhciBpbXB1bHNlID0gdjEuc3VidHJhY3QodjIpLnN1YnRyYWN0KHRoaXMuZXJyb3IpLmFwcGx5TWF0cml4KHRoaXMuZWZmTWFzc01hdHJpeCk7XG5cbiAgICB2YXIgZGlmZlcgPSBWZWMzLnN1YnRyYWN0KHcyLCB3MSwgREVMVEFfUkVHSVNURVIpO1xuXG4gICAgdmFyIGVycm9yUm90ID0gdGhpcy5lcnJvclJvdDtcbiAgICB2YXIganYxID0gVmVjMy5kb3QodDF4QSwgZGlmZlcpICsgZXJyb3JSb3RbMF07XG4gICAgdmFyIGp2MiA9IFZlYzMuZG90KHQyeEEsIGRpZmZXKSArIGVycm9yUm90WzFdO1xuXG4gICAgdmFyIEsgPSB0aGlzLmVmZk1hc3NNYXRyaXhSb3Q7XG5cbiAgICB2YXIgbDEgPSAtKEtbMF0qanYxICsgS1sxXSpqdjIpO1xuICAgIHZhciBsMiA9IC0oS1syXSpqdjEgKyBLWzNdKmp2Mik7XG5cbiAgICB2YXIgYW5nSW1wdWxzZSA9IFZlYzMuc2NhbGUodDF4QSwgbDEsIFZFQzJfUkVHSVNURVIpLmFkZChWZWMzLnNjYWxlKHQyeEEsIGwyLCBWRUMzX1JFR0lTVEVSKSk7XG5cbiAgICB2YXIgYW5nSW1wdWxzZUIgPSBWZWMzLmNyb3NzKHJCLCBpbXB1bHNlLCBWRUMxX1JFR0lTVEVSKS5hZGQoYW5nSW1wdWxzZSk7XG4gICAgdmFyIGFuZ0ltcHVsc2VBID0gVmVjMy5jcm9zcyhyQSwgaW1wdWxzZSwgVkVDNF9SRUdJU1RFUikuaW52ZXJ0KCkuc3VidHJhY3QoYW5nSW1wdWxzZSk7XG5cbiAgICBiLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBiLmFwcGx5QW5ndWxhckltcHVsc2UoYW5nSW1wdWxzZUIpO1xuICAgIGltcHVsc2UuaW52ZXJ0KCk7XG4gICAgYS5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYS5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ0ltcHVsc2VBKTtcbiAgICBpbXB1bHNlLmludmVydCgpO1xuXG4gICAgdGhpcy5pbXB1bHNlLmFkZChpbXB1bHNlKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VBLmFkZChhbmdJbXB1bHNlQSk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQi5hZGQoYW5nSW1wdWxzZUIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIaW5nZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xudmFyIE1hdDMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5NYXQzMztcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5RdWF0ZXJuaW9uO1xuXG52YXIgVkVDMV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkVDMl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkIxX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBWQjJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFd4Ul9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogIEEgY29uc3RyYWludCB0aGF0IG1haW50YWlucyBwb3NpdGlvbnMgYW5kIG9yaWVudGF0aW9ucyB3aXRoIHJlc3BlY3QgdG8gYSBzcGVjaWZpYyBhbmNob3IgcG9pbnQuXG4gKlxuICogIEBjbGFzcyBQb2ludDJQb2ludFxuICogIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqICBAcGFyYW0ge1BhcnRpY2xlfSBhIE9uZSBvZiB0aGUgYm9kaWVzLlxuICogIEBwYXJhbSB7UGFydGljbGV9IGIgVGhlIG90aGVyIGJvZHkuXG4gKiAgQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEFuIG9iamVjdCBvZiBjb25maWd1cmFibGUgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gUG9pbnQyUG9pbnQoYSwgYiwgb3B0aW9ucykge1xuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuaW1wdWxzZSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5lcnJvciA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5lZmZNYXNzTWF0cml4ID0gbmV3IE1hdDMzKCk7XG59XG5cblBvaW50MlBvaW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29uc3RyYWludC5wcm90b3R5cGUpO1xuUG9pbnQyUG9pbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9pbnQyUG9pbnQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgUG9pbnQyUG9pbnQuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICovXG5Qb2ludDJQb2ludC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3ID0gdGhpcy5hbmNob3I7XG5cbiAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcblxuICAgIHZhciBxMXQgPSBRdWF0ZXJuaW9uLmNvbmp1Z2F0ZShhLm9yaWVudGF0aW9uLCBuZXcgUXVhdGVybmlvbigpKTtcbiAgICB2YXIgcTJ0ID0gUXVhdGVybmlvbi5jb25qdWdhdGUoYi5vcmllbnRhdGlvbiwgbmV3IFF1YXRlcm5pb24oKSk7XG5cbiAgICB0aGlzLnJBID0gVmVjMy5zdWJ0cmFjdCh3LCBhLnBvc2l0aW9uLCBuZXcgVmVjMygpKTtcbiAgICB0aGlzLnJCID0gVmVjMy5zdWJ0cmFjdCh3LCBiLnBvc2l0aW9uLCBuZXcgVmVjMygpKTtcblxuICAgIHRoaXMuYm9keVJBID0gcTF0LnJvdGF0ZVZlY3Rvcih0aGlzLnJBLCBuZXcgVmVjMygpKTtcbiAgICB0aGlzLmJvZHlSQiA9IHEydC5yb3RhdGVWZWN0b3IodGhpcy5yQiwgbmV3IFZlYzMoKSk7XG59O1xuXG4vKipcbiAqIERldGVjdCB2aW9sYXRpb25zIG9mIHRoZSBjb25zdHJhaW50LiBXYXJtIHN0YXJ0IHRoZSBjb25zdHJhaW50LCBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIGN1cnJlbnQgdGltZSBpbiB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgVGhlIHBoeXNpY3MgZW5naW5lIGZyYW1lIGRlbHRhLlxuICovXG5Qb2ludDJQb2ludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24odGltZSwgZHQpIHtcbiAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcblxuICAgIHZhciByQSA9IGEub3JpZW50YXRpb24ucm90YXRlVmVjdG9yKHRoaXMuYm9keVJBLCB0aGlzLnJBKTtcbiAgICB2YXIgckIgPSBiLm9yaWVudGF0aW9uLnJvdGF0ZVZlY3Rvcih0aGlzLmJvZHlSQiwgdGhpcy5yQik7XG5cbiAgICB2YXIgeFJBID0gbmV3IE1hdDMzKFswLHJBLnosLXJBLnksLXJBLnosMCxyQS54LHJBLnksLXJBLngsMF0pO1xuICAgIHZhciB4UkIgPSBuZXcgTWF0MzMoWzAsckIueiwtckIueSwtckIueiwwLHJCLngsckIueSwtckIueCwwXSk7XG5cbiAgICB2YXIgUklhUnQgPSBNYXQzMy5tdWx0aXBseSh4UkEsIGEuaW52ZXJzZUluZXJ0aWEsIG5ldyBNYXQzMygpKS5tdWx0aXBseSh4UkEudHJhbnNwb3NlKCkpO1xuICAgIHZhciBSSWJSdCA9IE1hdDMzLm11bHRpcGx5KHhSQiwgYi5pbnZlcnNlSW5lcnRpYSwgbmV3IE1hdDMzKCkpLm11bHRpcGx5KHhSQi50cmFuc3Bvc2UoKSk7XG5cbiAgICB2YXIgaW52RWZmSW5lcnRpYSA9IE1hdDMzLmFkZChSSWFSdCwgUkliUnQsIFJJYVJ0KTtcblxuICAgIHZhciB3b3JsZEEgPSBWZWMzLmFkZChhLnBvc2l0aW9uLCB0aGlzLnJBLCB0aGlzLmFuY2hvcik7XG4gICAgdmFyIHdvcmxkQiA9IFZlYzMuYWRkKGIucG9zaXRpb24sIHRoaXMuckIsIFZFQzJfUkVHSVNURVIpO1xuXG4gICAgVmVjMy5zdWJ0cmFjdCh3b3JsZEIsIHdvcmxkQSwgdGhpcy5lcnJvcik7XG4gICAgdGhpcy5lcnJvci5zY2FsZSgwLjIvZHQpO1xuXG4gICAgdmFyIGltQSA9IGEuaW52ZXJzZU1hc3M7XG4gICAgdmFyIGltQiA9IGIuaW52ZXJzZU1hc3M7XG5cbiAgICB2YXIgaW52RWZmTWFzcyA9IG5ldyBNYXQzMyhbaW1BICsgaW1CLDAsMCwwLGltQSArIGltQiwwLDAsMCxpbUEgKyBpbUJdKTtcblxuICAgIE1hdDMzLmFkZChpbnZFZmZJbmVydGlhLCBpbnZFZmZNYXNzLCB0aGlzLmVmZk1hc3NNYXRyaXgpO1xuICAgIHRoaXMuZWZmTWFzc01hdHJpeC5pbnZlcnNlKCk7XG5cbiAgICB2YXIgaW1wdWxzZSA9IHRoaXMuaW1wdWxzZTtcbiAgICB2YXIgYW5nSW1wdWxzZUEgPSB0aGlzLmFuZ0ltcHVsc2VBO1xuICAgIHZhciBhbmdJbXB1bHNlQiA9IHRoaXMuYW5nSW1wdWxzZUI7XG5cbiAgICBiLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBiLmFwcGx5QW5ndWxhckltcHVsc2UoYW5nSW1wdWxzZUIpO1xuICAgIGltcHVsc2UuaW52ZXJ0KCk7XG4gICAgYS5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYS5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ0ltcHVsc2VBKTtcblxuICAgIGltcHVsc2UuY2xlYXIoKTtcbiAgICBhbmdJbXB1bHNlQS5jbGVhcigpO1xuICAgIGFuZ0ltcHVsc2VCLmNsZWFyKCk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGltcHVsc2VzIHRvIHJlc29sdmUgdGhlIGNvbnN0cmFpbnQuXG4gKlxuICogQG1ldGhvZCByZXNvbHZlXG4gKi9cblBvaW50MlBvaW50LnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcblxuICAgIHZhciByQSA9IHRoaXMuckE7XG4gICAgdmFyIHJCID0gdGhpcy5yQjtcblxuICAgIHZhciB2MSA9IFZlYzMuYWRkKGEudmVsb2NpdHksIFZlYzMuY3Jvc3MoYS5hbmd1bGFyVmVsb2NpdHksIHJBLCBXeFJfUkVHSVNURVIpLCBWQjFfUkVHSVNURVIpO1xuICAgIHZhciB2MiA9IFZlYzMuYWRkKGIudmVsb2NpdHksIFZlYzMuY3Jvc3MoYi5hbmd1bGFyVmVsb2NpdHksIHJCLCBXeFJfUkVHSVNURVIpLCBWQjJfUkVHSVNURVIpO1xuXG4gICAgdmFyIGltcHVsc2UgPSB2MS5zdWJ0cmFjdCh2Mikuc3VidHJhY3QodGhpcy5lcnJvcikuYXBwbHlNYXRyaXgodGhpcy5lZmZNYXNzTWF0cml4KTtcbiAgICB2YXIgYW5nSW1wdWxzZUIgPSBWZWMzLmNyb3NzKHJCLCBpbXB1bHNlLCBWRUMxX1JFR0lTVEVSKTtcbiAgICB2YXIgYW5nSW1wdWxzZUEgPSBWZWMzLmNyb3NzKHJBLCBpbXB1bHNlLCBWRUMyX1JFR0lTVEVSKS5pbnZlcnQoKTtcblxuICAgIGIuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGIuYXBwbHlBbmd1bGFySW1wdWxzZShhbmdJbXB1bHNlQik7XG4gICAgaW1wdWxzZS5pbnZlcnQoKTtcbiAgICBhLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBhLmFwcGx5QW5ndWxhckltcHVsc2UoYW5nSW1wdWxzZUEpO1xuICAgIGltcHVsc2UuaW52ZXJ0KCk7XG5cbiAgICB0aGlzLmltcHVsc2UuYWRkKGltcHVsc2UpO1xuICAgIHRoaXMuYW5nSW1wdWxzZUEuYWRkKGFuZ0ltcHVsc2VBKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VCLmFkZChhbmdJbXB1bHNlQik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50MlBvaW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEF4aXMtYWxpZ25lZCBib3VuZGluZyBib3guIFVzZWQgaW4gY29sbGlzaW9uIGJyb2FkcGhhc2VzLlxuICpcbiAqIEBjbGFzcyBBQUJCXG4gKi9cbmZ1bmN0aW9uIEFBQkIoYm9keSkge1xuICAgIHRoaXMuX2JvZHkgPSBib2R5O1xuICAgIHRoaXMuX0lEID0gYm9keS5fSUQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IG51bGw7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHtcbiAgICAgICAgeDogW10sXG4gICAgICAgIHk6IFtdLFxuICAgICAgICB6OiBbXVxuICAgIH07XG4gICAgdGhpcy51cGRhdGUoKTtcbn1cblxudmFyIFNQSEVSRSA9IDEgPDwgMjtcbnZhciBXQUxMID0gMSA8PCAzO1xuXG52YXIgRE9XTiA9IDA7XG52YXIgVVAgPSAxO1xudmFyIExFRlQgPSAyO1xudmFyIFJJR0hUID0gMztcbnZhciBGT1JXQVJEID0gNDtcbnZhciBCQUNLV0FSRCA9IDU7XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib3VuZHMgdG8gcmVmbGVjdCB0aGUgY3VycmVudCBvcmllbnRhdGlvbiBhbmQgcG9zaXRpb24gb2YgdGhlIHBhcmVudCBCb2R5LlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkFBQkIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBib2R5ID0gdGhpcy5fYm9keTtcbiAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbiA9IGJvZHkucG9zaXRpb247XG5cbiAgICB2YXIgbWluWCA9IEluZmluaXR5LCBtYXhYID0gLUluZmluaXR5O1xuICAgIHZhciBtaW5ZID0gSW5maW5pdHksIG1heFkgPSAtSW5maW5pdHk7XG4gICAgdmFyIG1pblogPSBJbmZpbml0eSwgbWF4WiA9IC1JbmZpbml0eTtcblxuICAgIHZhciB0eXBlID0gYm9keS50eXBlO1xuICAgIGlmICh0eXBlID09PSBTUEhFUkUpIHtcbiAgICAgICAgbWF4WCA9IG1heFkgPSBtYXhaID0gYm9keS5yYWRpdXM7XG4gICAgICAgIG1pblggPSBtaW5ZID0gbWluWiA9IC1ib2R5LnJhZGl1cztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gV0FMTCkge1xuICAgICAgICB2YXIgZCA9IGJvZHkuZGlyZWN0aW9uO1xuICAgICAgICBtYXhYID0gbWF4WSA9IG1heFogPSAxZTY7XG4gICAgICAgIG1pblggPSBtaW5ZID0gbWluWiA9IC0xZTY7XG4gICAgICAgIHN3aXRjaCAoZCkge1xuICAgICAgICAgICAgY2FzZSBET1dOOlxuICAgICAgICAgICAgICAgIG1heFkgPSAyNTtcbiAgICAgICAgICAgICAgICBtaW5ZID0gLTFlMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVVA6XG4gICAgICAgICAgICAgICAgbWF4WSA9IDFlMztcbiAgICAgICAgICAgICAgICBtaW5ZID0gLTI1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMRUZUOlxuICAgICAgICAgICAgICAgIG1heFggPSAyNTtcbiAgICAgICAgICAgICAgICBtaW5YID0gLTFlMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUklHSFQ6XG4gICAgICAgICAgICAgICAgbWF4WCA9IDFlMztcbiAgICAgICAgICAgICAgICBtaW5YID0gLTI1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBGT1JXQVJEOlxuICAgICAgICAgICAgICAgIG1heFogPSAyNTtcbiAgICAgICAgICAgICAgICBtaW5aID0gLTFlMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQkFDS1dBUkQ6XG4gICAgICAgICAgICAgICAgbWF4WiA9IDFlMztcbiAgICAgICAgICAgICAgICBtaW5aID0gLTI1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJvZHkudmVydGljZXMpIHtcbiAgICAgICAgLy8gQ29udmV4Qm9keVxuICAgICAgICB2YXIgYm9keVZlcnRpY2VzID0gYm9keS52ZXJ0aWNlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJvZHlWZXJ0aWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHZlcnRleCA9IGJvZHlWZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXgueCA8IG1pblgpIG1pblggPSB2ZXJ0ZXgueDtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXgueCA+IG1heFgpIG1heFggPSB2ZXJ0ZXgueDtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXgueSA8IG1pblkpIG1pblkgPSB2ZXJ0ZXgueTtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXgueSA+IG1heFkpIG1heFkgPSB2ZXJ0ZXgueTtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXgueiA8IG1pblopIG1pblogPSB2ZXJ0ZXguejtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXgueiA+IG1heFopIG1heFogPSB2ZXJ0ZXguejtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBhcnRpY2xlXG4gICAgICAgIG1heFggPSBtYXhZID0gbWF4WiA9IDI1O1xuICAgICAgICBtaW5YID0gbWluWSA9IG1pblogPSAtMjU7XG4gICAgfVxuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgdmVydGljZXMueFswXSA9IG1pblggKyBwb3MueDtcbiAgICB2ZXJ0aWNlcy54WzFdID0gbWF4WCArIHBvcy54O1xuICAgIHZlcnRpY2VzLnlbMF0gPSBtaW5ZICsgcG9zLnk7XG4gICAgdmVydGljZXMueVsxXSA9IG1heFkgKyBwb3MueTtcbiAgICB2ZXJ0aWNlcy56WzBdID0gbWluWiArIHBvcy56O1xuICAgIHZlcnRpY2VzLnpbMV0gPSBtYXhaICsgcG9zLno7XG59O1xuXG4vKipcbiAqIENoZWNrIGZvciBvdmVybGFwIGJldHdlZW4gdHdvIEFBQkIncy5cbiAqXG4gKiBAbWV0aG9kIGNoZWNrT3ZlcmxhcFxuICogQHBhcmFtIHtBQUJCfSBhYWJiMVxuICogQHBhcmFtIHtBQUJCfSBhYWJiMlxuICovXG5BQUJCLmNoZWNrT3ZlcmxhcCA9IGZ1bmN0aW9uKGFhYmIxLCBhYWJiMikge1xuICAgIHZhciB2ZXJ0aWNlczEgPSBhYWJiMS52ZXJ0aWNlcztcbiAgICB2YXIgdmVydGljZXMyID0gYWFiYjIudmVydGljZXM7XG5cbiAgICB2YXIgeDEwID0gdmVydGljZXMxLnhbMF07XG4gICAgdmFyIHgxMSA9IHZlcnRpY2VzMS54WzFdO1xuICAgIHZhciB4MjAgPSB2ZXJ0aWNlczIueFswXTtcbiAgICB2YXIgeDIxID0gdmVydGljZXMyLnhbMV07XG4gICAgaWYgKCh4MjAgPD0geDEwICYmIHgxMCA8PSB4MjEpIHx8ICh4MTAgPD0geDIwICYmIHgyMCA8PSB4MTEpKSB7XG4gICAgICAgIHZhciB5MTAgPSB2ZXJ0aWNlczEueVswXTtcbiAgICAgICAgdmFyIHkxMSA9IHZlcnRpY2VzMS55WzFdO1xuICAgICAgICB2YXIgeTIwID0gdmVydGljZXMyLnlbMF07XG4gICAgICAgIHZhciB5MjEgPSB2ZXJ0aWNlczIueVsxXTtcbiAgICAgICAgaWYgKCh5MjAgPD0geTEwICYmIHkxMCA8PSB5MjEpIHx8ICh5MTAgPD0geTIwICYmIHkyMCA8PSB5MTEpKSB7XG4gICAgICAgICAgICB2YXIgejEwID0gdmVydGljZXMxLnpbMF07XG4gICAgICAgICAgICB2YXIgejExID0gdmVydGljZXMxLnpbMV07XG4gICAgICAgICAgICB2YXIgejIwID0gdmVydGljZXMyLnpbMF07XG4gICAgICAgICAgICB2YXIgejIxID0gdmVydGljZXMyLnpbMV07XG4gICAgICAgICAgICBpZiAoKHoyMCA8PSB6MTAgJiYgejEwIDw9IHoyMSkgfHwgKHoxMCA8PSB6MjAgJiYgejIwIDw9IHoxMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5BQUJCLnZlcnRleFRocmVzaG9sZCA9IDEwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBBQUJCO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQUFCQiA9IHJlcXVpcmUoJy4vQUFCQicpO1xuXG4vKipcbiAqIE8obl4yKSBjb21wYXJpc29ucyB3aXRoIGFuIEFBQkIgY2hlY2sgZm9yIGEgbWlkcGhhc2UuIExpa2VseSB0byBiZSBtb3JlIHBlcmZvcm1hbnRcbiAqIHRoYXQgdGhlIEJydXRlRm9yY2Ugd2hlbiB0aGUgYm9kaWVzIGhhdmUgbWFueSB2ZXJ0aWNlcy4gT25seSBmZWFzaWJsZSBmb3IgYSBzbWFsbCBudW1iZXIgb2YgYm9kaWVzLlxuICpcbiAqIEBjbGFzcyBCcnV0ZUZvckFBQkJcbiAqIEBwYXJhbSB7UGFydGljbGVzW119IHRhcmdldHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIEJydXRlRm9yY2VBQUJCKHRhcmdldHMpIHtcbiAgICB0aGlzLl92b2x1bWVzID0gW107XG4gICAgdGhpcy5fZW50aXR5UmVnaXN0cnkgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGQodGFyZ2V0c1tpXSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFN0YXJ0IHRyYWNraW5nIGEgUGFydGljbGUuXG4gKlxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7UGFydGljbGV9IGJvZHlcbiAqL1xuQnJ1dGVGb3JjZUFBQkIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChib2R5KSB7XG4gICAgdmFyIGJvdW5kaW5nVm9sdW1lID0gbmV3IEFBQkIoYm9keSk7XG5cbiAgICB0aGlzLl9lbnRpdHlSZWdpc3RyeVtib2R5Ll9JRF0gPSBib2R5O1xuICAgIHRoaXMuX3ZvbHVtZXMucHVzaChib3VuZGluZ1ZvbHVtZSk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBvZiBwb3NzaWJsZSBjb2xsaXNpb24gcGFpcnMsIGN1bGxlZCBieSBhbiBBQUJCIGludGVyc2VjdGlvbiB0ZXN0LlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcmV0dXJuIHtQYXJ0aWNsZVtdW119XG4gKi9cbkJydXRlRm9yY2VBQUJCLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIF92b2x1bWVzID0gdGhpcy5fdm9sdW1lcztcbiAgICB2YXIgX2VudGl0eVJlZ2lzdHJ5ID0gdGhpcy5fZW50aXR5UmVnaXN0cnk7XG5cbiAgICBmb3IgKHZhciBrID0gMCwgbGVuID0gX3ZvbHVtZXMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgX3ZvbHVtZXNba10udXBkYXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1UYXJnZXRzID0gX3ZvbHVtZXMubGVuZ3RoOyBpIDwgbnVtVGFyZ2V0czsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG51bVRhcmdldHM7IGorKykge1xuICAgICAgICAgICAgaWYgKEFBQkIuY2hlY2tPdmVybGFwKF92b2x1bWVzW2ldLCBfdm9sdW1lc1tqXSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbX2VudGl0eVJlZ2lzdHJ5W2ldLCBfZW50aXR5UmVnaXN0cnlbal1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUaGUgbW9zdCBzaW1wbGUgeWV0IGNvbXB1dGF0aW9uYWxseSBpbnRlbnNpdmUgYnJvYWQtcGhhc2UuIEltbWVkaWF0ZWx5IHBhc3NlcyBpdHMgdGFyZ2V0cyB0byB0aGUgbmFycm93LXBoYXNlLFxuICogcmVzdWx0aW5nIGluIGFuIE8obl4yKSBwcm9jZXNzLiBPbmx5IGZlYXNpYmxlIGZvciBhIHJlbGF0aXZlbHkgc21hbGwgbnVtYmVyIG9mIGJvZGllcy5cbiAqXG4gKiBAY2xhc3MgQnJ1dGVGb3JjZVxuICogQHBhcmFtIHtQYXJ0aWNsZVtdfSB0YXJnZXRzXG4gKi9cbmZ1bmN0aW9uIEJydXRlRm9yY2UodGFyZ2V0cykge1xuICAgIHRoaXMudGFyZ2V0cyA9IHRhcmdldHM7XG59XG5cbi8qKlxuICogU3RhcnQgdHJhY2tpbmcgYSBQYXJ0aWNsZS5cbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtQYXJ0aWNsZX0gYm9keVxuICovXG5CcnV0ZUZvcmNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYm9keSkge1xuICAgIHRoaXMudGFyZ2V0cy5wdXNoKGJvZHkpO1xufTtcblxuLyoqXG4gKiBJbW1lZGlhdGVseSByZXR1cm5zIGFuIGFycmF5IG9mIHBvc3NpYmxlIGNvbGxpc2lvbnMuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEByZXR1cm4ge1BhcnRpY2xlW11bXX1cbiAqL1xuQnJ1dGVGb3JjZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHJldHVybiBbdGhpcy50YXJnZXRzXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkJydXRlRm9yY2VBQUJCID0gQnJ1dGVGb3JjZUFBQkI7XG5tb2R1bGUuZXhwb3J0cy5CcnV0ZUZvcmNlID0gQnJ1dGVGb3JjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG52YXIgT2JqZWN0TWFuYWdlciA9IHJlcXVpcmUoJ2ZhbW91cy11dGlsaXRpZXMnKS5PYmplY3RNYW5hZ2VyO1xuXG5PYmplY3RNYW5hZ2VyLnJlZ2lzdGVyKCdNYW5pZm9sZCcsIE1hbmlmb2xkKTtcbk9iamVjdE1hbmFnZXIucmVnaXN0ZXIoJ0NvbnRhY3QnLCBDb250YWN0KTtcbnZhciBPTVJlcXVlc3RNYW5pZm9sZCA9IE9iamVjdE1hbmFnZXIucmVxdWVzdE1hbmlmb2xkO1xudmFyIE9NUmVxdWVzdENvbnRhY3QgPSBPYmplY3RNYW5hZ2VyLnJlcXVlc3RDb250YWN0O1xudmFyIE9NRnJlZU1hbmlmb2xkID0gT2JqZWN0TWFuYWdlci5mcmVlTWFuaWZvbGQ7XG52YXIgT01GcmVlQ29udGFjdCA9IE9iamVjdE1hbmFnZXIuZnJlZUNvbnRhY3Q7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNsYW1wIGEgdmFsdWUgdG8gYSBnaXZlbiByYW5nZS5cbiAqXG4gKiBAbWV0aG9kIGNsYW1wXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dlclxuICogQHBhcmFtIHtOdW1iZXJ9IHVwcGVyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbG93ZXIsIHVwcGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgbG93ZXIgPyBsb3dlciA6IHZhbHVlID4gdXBwZXIgPyB1cHBlciA6IHZhbHVlO1xufVxuXG52YXIgVkVDMV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkVDMl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkIxX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBWQjJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFd4Ul9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgUjFfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFIyX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBOT1JNQUxJTVBVTFNFX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBUQU5HRU5USU1QVUxTRTFfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFRBTkdFTlRJTVBVTFNFMl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgV0FfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFdCX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBQRU5FVFJBVElOR19SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgRFJJRlRBX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBEUklGVEJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFRhYmxlIG1haW50YWluaW5nIGFuZCBtYW5hZ2luZyBjdXJyZW50IGNvbnRhY3QgbWFuaWZvbGRzLlxuICpcbiAqIEBjbGFzcyBDb250YWN0TWFuaWZvbGRUYWJsZVxuICovXG5mdW5jdGlvbiBDb250YWN0TWFuaWZvbGRUYWJsZSgpIHtcbiAgICB0aGlzLm1hbmlmb2xkcyA9IFtdO1xuICAgIHRoaXMuY29sbGlzaW9uTWF0cml4ID0ge307XG4gICAgdGhpcy5fSURQb29sID0gW107XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNvbnRhY3QgbWFuaWZvbGQuIFRyYWNrZWQgYnkgdGhlIGNvbGxpc2lvbk1hdHJpeCBhY2NvcmRpbmcgdG9cbiAqIGl0cyBsb3ctaGlnaCBvcmRlcmVkIElEIHBhaXIuXG4gKlxuICogQG1ldGhvZCBhZGRNYW5pZm9sZFxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd0lkXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaElEXG4gKiBAcGFyYW0ge1BhcnRpY2xlfSBib2R5QVxuICogQHBhcmFtIHtQYXJ0aWNsZX0gYm9keUJcbiAqIEByZXR1cm4ge0NvbnRhY3RNYW5pZm9sZH1cbiAqL1xuQ29udGFjdE1hbmlmb2xkVGFibGUucHJvdG90eXBlLmFkZE1hbmlmb2xkID0gZnVuY3Rpb24gYWRkTWFuaWZvbGQobG93SUQsIGhpZ2hJRCwgYm9keUEsIGJvZHlCKSB7XG4gICAgdmFyIGNvbGxpc2lvbk1hdHJpeCA9IHRoaXMuY29sbGlzaW9uTWF0cml4O1xuICAgIGNvbGxpc2lvbk1hdHJpeFtsb3dJRF0gPSBjb2xsaXNpb25NYXRyaXhbbG93SURdIHx8IHt9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fSURQb29sLmxlbmd0aCA/IHRoaXMuX0lEUG9vbC5wb3AoKSA6IHRoaXMubWFuaWZvbGRzLmxlbmd0aDtcbiAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeFtsb3dJRF1baGlnaElEXSA9IGluZGV4O1xuICAgIHZhciBtYW5pZm9sZCA9IE9NUmVxdWVzdE1hbmlmb2xkKCkucmVzZXQobG93SUQsIGhpZ2hJRCwgYm9keUEsIGJvZHlCKTtcbiAgICB0aGlzLm1hbmlmb2xkc1tpbmRleF0gPSBtYW5pZm9sZDtcblxuICAgIHJldHVybiBtYW5pZm9sZDtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgbWFuaWZvbGQgYW5kIGZyZWUgaXQgZm9yIGxhdGVyIHJldXNlLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlTWFuaWZvbGRcbiAqIEBwYXJhbSB7Q29udGFjdE1hbmlmb2xkfSBtYW5pZm9sZFxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKi9cbkNvbnRhY3RNYW5pZm9sZFRhYmxlLnByb3RvdHlwZS5yZW1vdmVNYW5pZm9sZCA9IGZ1bmN0aW9uIHJlbW92ZU1hbmlmb2xkKG1hbmlmb2xkLCBpbmRleCkge1xuICAgIHZhciBjb2xsaXNpb25NYXRyaXggPSB0aGlzLmNvbGxpc2lvbk1hdHJpeDtcblxuICAgIHRoaXMubWFuaWZvbGRzW2luZGV4XSA9IG51bGw7XG4gICAgY29sbGlzaW9uTWF0cml4W21hbmlmb2xkLmxvd0lEXVttYW5pZm9sZC5oaWdoSURdID0gbnVsbDtcbiAgICB0aGlzLl9JRFBvb2wucHVzaChpbmRleCk7XG5cbiAgICBPTUZyZWVNYW5pZm9sZChtYW5pZm9sZCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBlYWNoIG9mIHRoZSBtYW5pZm9sZHMsIHJlbW92aW5nIHRob3NlIHRoYXQgbm8gbG9uZ2VyIGNvbnRhaW4gY29udGFjdCBwb2ludHMuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkdFxuICovXG5Db250YWN0TWFuaWZvbGRUYWJsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGR0KSB7XG4gICAgdmFyIG1hbmlmb2xkcyA9IHRoaXMubWFuaWZvbGRzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYW5pZm9sZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIG1hbmlmb2xkID0gbWFuaWZvbGRzW2ldO1xuICAgICAgICBpZiAoIW1hbmlmb2xkKSBjb250aW51ZTtcbiAgICAgICAgdmFyIHBlcnNpc3RzID0gbWFuaWZvbGQudXBkYXRlKGR0KTtcbiAgICAgICAgaWYgKCFwZXJzaXN0cykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVNYW5pZm9sZChtYW5pZm9sZCwgaSk7XG4gICAgICAgICAgICBtYW5pZm9sZC5ib2R5QS5ldmVudHMudHJpZ2dlcignY29sbGlzaW9uOmVuZCcsIG1hbmlmb2xkKTtcbiAgICAgICAgICAgIG1hbmlmb2xkLmJvZHlCLmV2ZW50cy50cmlnZ2VyKCdjb2xsaXNpb246ZW5kJywgbWFuaWZvbGQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBXYXJtIHN0YXJ0IGFsbCBDb250YWN0cywgYW5kIHBlcmZvcm0gcHJlY2FsY3VsYXRpb25zIG5lZWRlZCBpbiB0aGUgaXRlcmF0aXZlIHNvbHZlci5cbiAqXG4gKiBAbWV0aG9kIHByZXBDb250YWN0c1xuICogQHBhcmFtIHtOdW1iZXJ9IGR0XG4gKi9cbkNvbnRhY3RNYW5pZm9sZFRhYmxlLnByb3RvdHlwZS5wcmVwQ29udGFjdHMgPSBmdW5jdGlvbiBwcmVwQ29udGFjdHMoZHQpIHtcbiAgICB2YXIgbWFuaWZvbGRzID0gdGhpcy5tYW5pZm9sZHM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hbmlmb2xkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgbWFuaWZvbGQgPSBtYW5pZm9sZHNbaV07XG4gICAgICAgIGlmICghbWFuaWZvbGQpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgY29udGFjdHMgPSBtYW5pZm9sZC5jb250YWN0cztcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmogPSBjb250YWN0cy5sZW5ndGg7IGogPCBsZW5qOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjb250YWN0ID0gY29udGFjdHNbal07XG4gICAgICAgICAgICBpZiAoIWNvbnRhY3QpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29udGFjdC51cGRhdGUoZHQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXNvbHZlIGFsbCBjb250YWN0IG1hbmlmb2xkcy5cbiAqXG4gKiBAbWV0aG9kIHJlc29sdmVNYW5pZm9sZHNcbiAqL1xuQ29udGFjdE1hbmlmb2xkVGFibGUucHJvdG90eXBlLnJlc29sdmVNYW5pZm9sZHMgPSBmdW5jdGlvbiByZXNvbHZlTWFuaWZvbGRzKCkge1xuICAgIHZhciBtYW5pZm9sZHMgPSB0aGlzLm1hbmlmb2xkcztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFuaWZvbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBtYW5pZm9sZCA9IG1hbmlmb2xkc1tpXTtcbiAgICAgICAgaWYgKCFtYW5pZm9sZCkgY29udGludWU7XG4gICAgICAgIG1hbmlmb2xkLnJlc29sdmVDb250YWN0cygpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IENvbnRhY3QsIGFsc28gY3JlYXRpbmcgYSBuZXcgTWFuaWZvbGQgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QgZm9yIHRoYXQgcGFpci5cbiAqXG4gKiBAbWV0aG9kIHJlZ2lzdGVyQ29udGFjdFxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtDb2xsaXNpb25EYXRhfSBjb2xsaXNpb25EYXRhXG4gKi9cbkNvbnRhY3RNYW5pZm9sZFRhYmxlLnByb3RvdHlwZS5yZWdpc3RlckNvbnRhY3QgPSBmdW5jdGlvbiByZWdpc3RlckNvbnRhY3QoYm9keUEsIGJvZHlCLCBjb2xsaXNpb25EYXRhKSB7XG4gICAgdmFyIGxvd0lEO1xuICAgIHZhciBoaWdoSUQ7XG5cbiAgICBpZiAoYm9keUEuX0lEIDwgYm9keUIuX0lEKSB7XG4gICAgICAgIGxvd0lEID0gYm9keUEuX0lEO1xuICAgICAgICBoaWdoSUQgPSBib2R5Qi5fSUQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG93SUQgPSBib2R5Qi5fSUQ7XG4gICAgICAgIGhpZ2hJRCA9IGJvZHlBLl9JRDtcbiAgICB9XG5cbiAgICB2YXIgbWFuaWZvbGRzID0gdGhpcy5tYW5pZm9sZHM7XG4gICAgdmFyIGNvbGxpc2lvbk1hdHJpeCA9IHRoaXMuY29sbGlzaW9uTWF0cml4O1xuICAgIHZhciBtYW5pZm9sZDtcbiAgICBpZiAoIWNvbGxpc2lvbk1hdHJpeFtsb3dJRF0gfHwgY29sbGlzaW9uTWF0cml4W2xvd0lEXVtoaWdoSURdID09IG51bGwpIHtcbiAgICAgICAgbWFuaWZvbGQgPSB0aGlzLmFkZE1hbmlmb2xkKGxvd0lELCBoaWdoSUQsIGJvZHlBLCBib2R5Qik7XG4gICAgICAgIG1hbmlmb2xkLmFkZENvbnRhY3QoYm9keUEsIGJvZHlCLCBjb2xsaXNpb25EYXRhKTtcbiAgICAgICAgYm9keUEuZXZlbnRzLnRyaWdnZXIoJ2NvbGxpc2lvbjpzdGFydCcsIG1hbmlmb2xkKTtcbiAgICAgICAgYm9keUIuZXZlbnRzLnRyaWdnZXIoJ2NvbGxpc2lvbjpzdGFydCcsIG1hbmlmb2xkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtYW5pZm9sZCA9IG1hbmlmb2xkc1sgY29sbGlzaW9uTWF0cml4W2xvd0lEXVtoaWdoSURdIF07XG4gICAgICAgIG1hbmlmb2xkLmNvbnRhaW5zKGNvbGxpc2lvbkRhdGEpO1xuICAgICAgICBtYW5pZm9sZC5hZGRDb250YWN0KGJvZHlBLCBib2R5QiwgY29sbGlzaW9uRGF0YSk7XG4gICAgfVxufTtcblxudmFyIFRIUkVTSE9MRCA9IDEwO1xuXG4vKipcbiAqIENsYXNzIHRvIGtlZXAgdHJhY2sgb2YgQ29udGFjdCBwb2ludHMuXG4gKiBAY2xhc3MgbWFuaWZvbGRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dJZFxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hJZFxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5mdW5jdGlvbiBNYW5pZm9sZChsb3dJRCwgaGlnaElELCBib2R5QSwgYm9keUIpIHtcbiAgICB0aGlzLmxvd0lEID0gbG93SUQ7XG4gICAgdGhpcy5oaWdoSUQgPSBoaWdoSUQ7XG5cbiAgICB0aGlzLmNvbnRhY3RzID0gW107XG4gICAgdGhpcy5udW1Db250YWN0cyA9IDA7XG5cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgdGhpcy5scnUgPSAwO1xufVxuXG4vKipcbiAqIFVzZWQgYnkgT2JqZWN0TWFuYWdlciB0byByZXNldCB0aGUgb2JqZWN0IHdpdGggZGlmZmVyZW50IGRhdGEuXG4gKlxuICogQG1ldGhvZCByZXNldFxuICogQHBhcmFtIHtPYmplY3RbXX0gYXJnc1xuICogQGNoYWluYWJsZVxuICovXG5NYW5pZm9sZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldChsb3dJRCwgaGlnaElELCBib2R5QSwgYm9keUIpIHtcbiAgICB0aGlzLmxvd0lEID0gbG93SUQ7XG4gICAgdGhpcy5oaWdoSUQgPSBoaWdoSUQ7XG5cbiAgICB0aGlzLmNvbnRhY3RzID0gW107XG4gICAgdGhpcy5udW1Db250YWN0cyA9IDA7XG5cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgdGhpcy5scnUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBDb250YWN0IHBvaW50IGFuZCBhZGQgaXQgdG8gdGhlIE1hbmlmb2xkLlxuICpcbiAqIEBtZXRob2QgYWRkQ29udGFjdFxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtDb2xsaXNpb25EYXRhfSBjb2xsaXNpb25EYXRhXG4gKi9cbk1hbmlmb2xkLnByb3RvdHlwZS5hZGRDb250YWN0ID0gZnVuY3Rpb24gYWRkQ29udGFjdChib2R5QSwgYm9keUIsIGNvbGxpc2lvbkRhdGEpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmxydTtcbiAgICBpZiAodGhpcy5jb250YWN0c1tpbmRleF0pIHRoaXMucmVtb3ZlQ29udGFjdCh0aGlzLmNvbnRhY3RzW2luZGV4XSwgaW5kZXgpO1xuICAgIHRoaXMuY29udGFjdHNbaW5kZXhdID0gT01SZXF1ZXN0Q29udGFjdCgpLnJlc2V0KGJvZHlBLCBib2R5QiwgY29sbGlzaW9uRGF0YSk7XG4gICAgdGhpcy5scnUgPSAodGhpcy5scnUgKyAxKSAlIDQ7XG4gICAgdGhpcy5udW1Db250YWN0cysrO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW5kIGZyZWUgYSBDb250YWN0IGZvciBsYXRlciByZXVzZS5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNvbnRhY3RcbiAqIEBwYXJhbSB7Q29udGFjdH0gY29udGFjdFxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKi9cbk1hbmlmb2xkLnByb3RvdHlwZS5yZW1vdmVDb250YWN0ID0gZnVuY3Rpb24gcmVtb3ZlQ29udGFjdChjb250YWN0LCBpbmRleCkge1xuICAgIHRoaXMuY29udGFjdHNbaW5kZXhdID0gbnVsbDtcbiAgICB0aGlzLm51bUNvbnRhY3RzLS07XG5cbiAgICBPYmplY3RNYW5hZ2VyLmZyZWVDb2xsaXNpb25EYXRhKGNvbnRhY3QuZGF0YSk7XG4gICAgY29udGFjdC5kYXRhID0gbnVsbDtcbiAgICBPTUZyZWVDb250YWN0KGNvbnRhY3QpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIENvbnRhY3QgYWxyZWFkeSBleGlzdHMgZm9yIHRoZSBjb2xsaXNpb24gZGF0YSB3aXRoaW4gYSBjZXJ0YWluIHRvbGVyYW5jZS5cbiAqIElmIGZvdW5kLCByZW1vdmUgdGhlIENvbnRhY3QuXG4gKlxuICogQG1ldGhvZCBjb250YWluc1xuICogQHBhcmFtIHtDb2xsaXNpb25EYXRhfSBjb2xsaXNpb25EYXRhXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5NYW5pZm9sZC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhjb2xsaXNpb25EYXRhKSB7XG4gICAgdmFyIHdBID0gY29sbGlzaW9uRGF0YS53b3JsZENvbnRhY3RBO1xuICAgIHZhciB3QiA9IGNvbGxpc2lvbkRhdGEud29ybGRDb250YWN0QjtcblxuICAgIHZhciBjb250YWN0cyA9IHRoaXMuY29udGFjdHM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbnRhY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb250YWN0ID0gY29udGFjdHNbaV07XG4gICAgICAgIGlmICghY29udGFjdCkgY29udGludWU7XG4gICAgICAgIHZhciBkYXRhID0gY29udGFjdC5kYXRhO1xuICAgICAgICB2YXIgZGlzdEEgPSBWZWMzLnN1YnRyYWN0KGRhdGEud29ybGRDb250YWN0QSwgd0EsIERSSUZUQV9SRUdJU1RFUikubGVuZ3RoKCk7XG4gICAgICAgIHZhciBkaXN0QiA9IFZlYzMuc3VidHJhY3QoZGF0YS53b3JsZENvbnRhY3RCLCB3QiwgRFJJRlRCX1JFR0lTVEVSKS5sZW5ndGgoKTtcblxuICAgICAgICBpZiAoZGlzdEEgPCBUSFJFU0hPTEQgfHwgZGlzdEIgPCBUSFJFU0hPTEQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29udGFjdChjb250YWN0LCBpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgQ29udGFjdHMgdGhlIGxvY2FsIHBvaW50cyBvZiB3aGljaCBoYXZlIGRyaWZ0ZWQgYWJvdmUgYSBjZXJ0YWluIHRvbGVyYW5jZS5cbiAqIFJldHVybiB0cnVlIG9yIGZhbHNlIHRvIGluZGljYXRlIHRoYXQgdGhlIE1hbmlmb2xkIHN0aWxsIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBDb250YWN0LlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbWFuaWZvbGQgcGVyc2lzdHNcbiAqL1xuTWFuaWZvbGQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgY29udGFjdHMgPSB0aGlzLmNvbnRhY3RzO1xuICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUE7XG4gICAgdmFyIGJvZHlCID0gdGhpcy5ib2R5QjtcblxuICAgIHZhciBwb3NBID0gYm9keUEucG9zaXRpb247XG4gICAgdmFyIHBvc0IgPSBib2R5Qi5wb3NpdGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb250YWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY29udGFjdCA9IGNvbnRhY3RzW2ldO1xuICAgICAgICBpZiAoIWNvbnRhY3QpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgZGF0YSA9IGNvbnRhY3QuZGF0YTtcbiAgICAgICAgdmFyIG4gPSBkYXRhLm5vcm1hbDtcbiAgICAgICAgdmFyIHJBID0gZGF0YS5sb2NhbENvbnRhY3RBO1xuICAgICAgICB2YXIgckIgPSBkYXRhLmxvY2FsQ29udGFjdEI7XG5cbiAgICAgICAgdmFyIGNhY2hlZF93QSA9IGRhdGEud29ybGRDb250YWN0QTtcbiAgICAgICAgdmFyIGNhY2hlZF93QiA9IGRhdGEud29ybGRDb250YWN0QjtcblxuICAgICAgICB2YXIgd0EgPSBWZWMzLmFkZChwb3NBLCByQSwgV0FfUkVHSVNURVIpO1xuICAgICAgICB2YXIgd0IgPSBWZWMzLmFkZChwb3NCLCByQiwgV0JfUkVHSVNURVIpO1xuXG4gICAgICAgIHZhciBub3RQZW5ldHJhdGluZyA9IFZlYzMuZG90KFZlYzMuc3VidHJhY3Qod0IsIHdBLCBQRU5FVFJBVElOR19SRUdJU1RFUiksIG4pID4gMDtcblxuICAgICAgICB2YXIgZHJpZnRBID0gVmVjMy5zdWJ0cmFjdChjYWNoZWRfd0EsIHdBLCBEUklGVEFfUkVHSVNURVIpO1xuICAgICAgICB2YXIgZHJpZnRCID0gVmVjMy5zdWJ0cmFjdChjYWNoZWRfd0IsIHdCLCBEUklGVEJfUkVHSVNURVIpO1xuXG5cbiAgICAgICAgaWYgKGRyaWZ0QS5sZW5ndGgoKSA+PSBUSFJFU0hPTEQgfHwgZHJpZnRCLmxlbmd0aCgpID49IFRIUkVTSE9MRCB8fCBub3RQZW5ldHJhdGluZykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDb250YWN0KGNvbnRhY3QsIGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubnVtQ29udGFjdHMpIHJldHVybiB0cnVlO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlIGFsbCBjb250YWN0cy5cbiAqXG4gKiBAbWV0aG9kIHJlc29sdmVDb250YWN0c1xuICovXG5NYW5pZm9sZC5wcm90b3R5cGUucmVzb2x2ZUNvbnRhY3RzID0gZnVuY3Rpb24gcmVzb2x2ZUNvbnRhY3RzKCkge1xuICAgIHZhciBjb250YWN0cyA9IHRoaXMuY29udGFjdHM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbnRhY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghY29udGFjdHNbaV0pIGNvbnRpbnVlO1xuICAgICAgICBjb250YWN0c1tpXS5yZXNvbHZlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGFzcyB0byBtYWludGFpbiBjb2xsaXNpb24gZGF0YSBiZXR3ZWVuIHR3byBib2RpZXMuXG4gKiBUaGUgZW5kIG9mIHRoZSByZXNvbHZlIGNoYWluLCBhbmQgd2hlcmUgdGhlIGFjdHVhbCBpbXB1bHNlcyBhcmUgYXBwbGllZC5cbiAqXG4gKiBAY2xhc3MgQ29udGFjdFxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtDb2xsaXNpb25EYXRhfSBjb2xsaXNpb25EYXRhXG4gKi9cbmZ1bmN0aW9uIENvbnRhY3QoYm9keUEsIGJvZHlCLCBjb2xsaXNpb25EYXRhKSB7XG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcbiAgICB0aGlzLmRhdGEgPSBjb2xsaXNpb25EYXRhO1xuXG4gICAgdGhpcy5ub3JtYWxJbXB1bHNlID0gMDtcbiAgICB0aGlzLnRhbmdlbnRJbXB1bHNlMSA9IDA7XG4gICAgdGhpcy50YW5nZW50SW1wdWxzZTIgPSAwO1xuXG4gICAgdGhpcy5pbXB1bHNlID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VBID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VCID0gbmV3IFZlYzMoKTtcblxuICAgIGlmIChjb2xsaXNpb25EYXRhKSB0aGlzLmluaXQoKTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IE9iamVjdE1hbmFnZXIgdG8gcmVzZXQgdGhlIG9iamVjdCB3aXRoIGRpZmZlcmVudCBkYXRhLlxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqIEBwYXJhbSB7T2JqZWN0W119IGFyZ3NcbiAqIEBjaGFpbmFibGVcbiAqL1xuQ29udGFjdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldChib2R5QSwgYm9keUIsIGNvbGxpc2lvbkRhdGEpIHtcbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuICAgIHRoaXMuZGF0YSA9IGNvbGxpc2lvbkRhdGE7XG5cbiAgICB0aGlzLm5vcm1hbEltcHVsc2UgPSAwO1xuICAgIHRoaXMudGFuZ2VudEltcHVsc2UxID0gMDtcbiAgICB0aGlzLnRhbmdlbnRJbXB1bHNlMiA9IDA7XG5cbiAgICB0aGlzLmltcHVsc2UuY2xlYXIoKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VBLmNsZWFyKCk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQi5jbGVhcigpO1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6YXRpb24gbWV0aG9kIGNhbGxlZCBvbiBpbnN0YW50aWFudGlvbiBvciByZXNldCBvZiB0aGUgQ29udGFjdC4gUGVyZm9ybXNcbiAqIHByZWNhbGN1bGF0aW9ucyB0aGF0IHdpbGwgbm90IGNoYW5nZSBvdmVyIHRoZSBsaWZlIG9mIHRoZSBDb250YWN0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICovXG5Db250YWN0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgbiA9IGRhdGEubm9ybWFsO1xuICAgIHZhciB0MSA9IG5ldyBWZWMzKCk7XG4gICAgaWYgKG4ueCA+PSAwLjU3NzM1KSB7XG4gICAgICAgIHQxLnNldChuLnksIC1uLngsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHQxLnNldCgwLCBuLnosIC1uLnkpO1xuICAgIH1cbiAgICB0MS5ub3JtYWxpemUoKTtcbiAgICB2YXIgdDIgPSBWZWMzLmNyb3NzKG4sIHQxLCBuZXcgVmVjMygpKTtcblxuICAgIHRoaXMudGFuZ2VudDEgPSB0MTtcbiAgICB0aGlzLnRhbmdlbnQyID0gdDI7XG5cbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBO1xuICAgIHZhciBib2R5QiA9IHRoaXMuYm9keUI7XG5cbiAgICB2YXIgckJvZHlBID0gZGF0YS5sb2NhbENvbnRhY3RBO1xuICAgIHZhciByQm9keUIgPSBkYXRhLmxvY2FsQ29udGFjdEI7XG5cbiAgICB2YXIgaW52RWZmZWN0aXZlTWFzcyA9IGJvZHlBLmludmVyc2VNYXNzICsgYm9keUIuaW52ZXJzZU1hc3M7XG5cbiAgICB2YXIgcjFuID0gVmVjMy5jcm9zcyhyQm9keUEsIG4sIFIxX1JFR0lTVEVSKTtcbiAgICB2YXIgcjJuID0gVmVjMy5jcm9zcyhyQm9keUIsIG4sIFIyX1JFR0lTVEVSKTtcbiAgICB0aGlzLmVmZk5vcm1hbE1hc3MgPSAxIC8gKGludkVmZmVjdGl2ZU1hc3MgK1xuICAgICAgICBWZWMzLmRvdChyMW4sIGJvZHlBLmludmVyc2VJbmVydGlhLnZlY3Rvck11bHRpcGx5KHIxbiwgVkVDMV9SRUdJU1RFUikpICtcbiAgICAgICAgVmVjMy5kb3QocjJuLCBib2R5Qi5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseShyMm4sIFZFQzFfUkVHSVNURVIpKSk7XG5cbiAgICB2YXIgcjF0MSA9IFZlYzMuY3Jvc3MockJvZHlBLCB0MSwgUjFfUkVHSVNURVIpO1xuICAgIHZhciByMnQxID0gVmVjMy5jcm9zcyhyQm9keUIsIHQxLCBSMl9SRUdJU1RFUik7XG4gICAgdGhpcy5lZmZUYW5nZW50aWFsTWFzczEgPSAxIC8gKGludkVmZmVjdGl2ZU1hc3MgK1xuICAgICAgICBWZWMzLmRvdChyMXQxLCBib2R5QS5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseShyMXQxLCBWRUMxX1JFR0lTVEVSKSkgK1xuICAgICAgICAgVmVjMy5kb3QocjJ0MSwgYm9keUIuaW52ZXJzZUluZXJ0aWEudmVjdG9yTXVsdGlwbHkocjJ0MSwgVkVDMV9SRUdJU1RFUikpKTtcblxuICAgIHZhciByMXQyID0gVmVjMy5jcm9zcyhyQm9keUEsIHQyLCBSMV9SRUdJU1RFUik7XG4gICAgdmFyIHIydDIgPSBWZWMzLmNyb3NzKHJCb2R5QiwgdDIsIFIyX1JFR0lTVEVSKTtcbiAgICB0aGlzLmVmZlRhbmdlbnRpYWxNYXNzMiA9IDEgLyAoaW52RWZmZWN0aXZlTWFzcyArXG4gICAgICAgIFZlYzMuZG90KHIxdDIsIGJvZHlBLmludmVyc2VJbmVydGlhLnZlY3Rvck11bHRpcGx5KHIxdDIsIFZFQzFfUkVHSVNURVIpKSArXG4gICAgICAgICBWZWMzLmRvdChyMnQyLCBib2R5Qi5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseShyMnQyLCBWRUMxX1JFR0lTVEVSKSkpO1xuXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IE1hdGgubWluKGJvZHlBLnJlc3RpdHV0aW9uLCBib2R5Qi5yZXN0aXR1dGlvbik7XG4gICAgdGhpcy5mcmljdGlvbiA9IGJvZHlBLmZyaWN0aW9uICogYm9keUIuZnJpY3Rpb247XG59O1xuXG4vKipcbiAqIFdhcm0gc3RhcnQgdGhlIENvbnRhY3QsIHByZXBhcmUgZm9yIHRoZSBpdGVyYXRpdmUgc29sdmVyLCBhbmQgcmVzZXQgaW1wdWxzZXMuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkdFxuICovXG5Db250YWN0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZHQpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBO1xuICAgIHZhciBib2R5QiA9IHRoaXMuYm9keUI7XG5cbiAgICB2YXIgckJvZHlBID0gZGF0YS5sb2NhbENvbnRhY3RBO1xuICAgIHZhciByQm9keUIgPSBkYXRhLmxvY2FsQ29udGFjdEI7XG5cbiAgICB2YXIgbiA9IGRhdGEubm9ybWFsO1xuXG4gICAgdmFyIHZiMSA9IFZlYzMuYWRkKGJvZHlBLnZlbG9jaXR5LCBWZWMzLmNyb3NzKGJvZHlBLmFuZ3VsYXJWZWxvY2l0eSwgckJvZHlBLCBXeFJfUkVHSVNURVIpLCBWQjFfUkVHSVNURVIpO1xuICAgIHZhciB2YjIgPSBWZWMzLmFkZChib2R5Qi52ZWxvY2l0eSwgVmVjMy5jcm9zcyhib2R5Qi5hbmd1bGFyVmVsb2NpdHksIHJCb2R5QiwgV3hSX1JFR0lTVEVSKSwgVkIyX1JFR0lTVEVSKTtcbiAgICB2YXIgcmVsYXRpdmVWZWxvY2l0eSA9IHZiMi5zdWJ0cmFjdCh2YjEpO1xuICAgIHZhciBjb250YWN0U3BlZWQgPSBWZWMzLmRvdChyZWxhdGl2ZVZlbG9jaXR5LCBuKTtcblxuICAgIHZhciBiZXRhID0gMC4xNTtcbiAgICB2YXIgc2xvcCA9IDEuNTtcbiAgICB2YXIgdmVsb2NpdHlUb2xlcmFuY2UgPSAyMC4wO1xuXG4gICAgdmFyIHJlc3RpdHV0aW9uID0gTWF0aC5hYnMoY29udGFjdFNwZWVkKSA8IHZlbG9jaXR5VG9sZXJhbmNlID8gMC4wIDogdGhpcy5yZXN0aXR1dGlvbjtcbiAgICB0aGlzLnZlbG9jaXR5QmlhcyA9IC1iZXRhICogTWF0aC5tYXgoZGF0YS5wZW5ldHJhdGlvbiAtIHNsb3AsIDAuMCkgLyBkdDtcbiAgICB0aGlzLnZlbG9jaXR5QmlhcyArPSByZXN0aXR1dGlvbiAqIGNvbnRhY3RTcGVlZDtcblxuICAgIHZhciBpbXB1bHNlID0gdGhpcy5pbXB1bHNlLnNjYWxlKDAuMjUpO1xuICAgIHZhciBhbmdJbXB1bHNlQSA9IHRoaXMuYW5nSW1wdWxzZUEuc2NhbGUoMC4yNSk7XG4gICAgdmFyIGFuZ0ltcHVsc2VCID0gdGhpcy5hbmdJbXB1bHNlQi5zY2FsZSgwLjI1KTtcblxuICAgIGJvZHlCLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBib2R5Qi5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ0ltcHVsc2VCKTtcbiAgICBpbXB1bHNlLmludmVydCgpO1xuICAgIGJvZHlBLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBib2R5QS5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ0ltcHVsc2VBKTtcblxuICAgIHRoaXMubm9ybWFsSW1wdWxzZSA9IDA7XG4gICAgdGhpcy50YW5nZW50SW1wdWxzZTEgPSAwO1xuICAgIHRoaXMudGFuZ2VudEltcHVsc2UyID0gMDtcblxuICAgIGltcHVsc2UuY2xlYXIoKTtcbiAgICBhbmdJbXB1bHNlQS5jbGVhcigpO1xuICAgIGFuZ0ltcHVsc2VCLmNsZWFyKCk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGltcHVsc2VzIHRvIHJlc29sdmUgdGhlIGNvbnRhY3QgYW5kIHNpbXVsYXRlIGZyaWN0aW9uLlxuICpcbiAqIEBtZXRob2QgcmVzb2x2ZVxuICovXG5Db250YWN0LnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBO1xuICAgIHZhciBib2R5QiA9IHRoaXMuYm9keUI7XG5cbiAgICB2YXIgckJvZHlBID0gZGF0YS5sb2NhbENvbnRhY3RBO1xuICAgIHZhciByQm9keUIgPSBkYXRhLmxvY2FsQ29udGFjdEI7XG5cbiAgICB2YXIgbiA9IGRhdGEubm9ybWFsO1xuICAgIHZhciB0MSA9IHRoaXMudGFuZ2VudDE7XG4gICAgdmFyIHQyID0gdGhpcy50YW5nZW50MjtcblxuICAgIHZhciB2YjEgPSBWZWMzLmFkZChib2R5QS52ZWxvY2l0eSwgVmVjMy5jcm9zcyhib2R5QS5hbmd1bGFyVmVsb2NpdHksIHJCb2R5QSwgV3hSX1JFR0lTVEVSKSwgVkIxX1JFR0lTVEVSKTtcbiAgICB2YXIgdmIyID0gVmVjMy5hZGQoYm9keUIudmVsb2NpdHksIFZlYzMuY3Jvc3MoYm9keUIuYW5ndWxhclZlbG9jaXR5LCByQm9keUIsIFd4Ul9SRUdJU1RFUiksIFZCMl9SRUdJU1RFUik7XG4gICAgdmFyIHJlbGF0aXZlVmVsb2NpdHkgPSB2YjIuc3VidHJhY3QodmIxKTtcblxuICAgIHZhciBub3JtYWxMYW1iZGEgPSAtKFZlYzMuZG90KHJlbGF0aXZlVmVsb2NpdHksIG4pICsgdGhpcy52ZWxvY2l0eUJpYXMpICogdGhpcy5lZmZOb3JtYWxNYXNzO1xuICAgIHZhciBuZXdOb3JtYWxJbXB1bHNlID0gTWF0aC5tYXgodGhpcy5ub3JtYWxJbXB1bHNlICsgbm9ybWFsTGFtYmRhLCAwKTtcbiAgICBub3JtYWxMYW1iZGEgPSBuZXdOb3JtYWxJbXB1bHNlIC0gdGhpcy5ub3JtYWxJbXB1bHNlO1xuXG4gICAgdmFyIG1heEZyaWN0aW9uID0gdGhpcy5mcmljdGlvbiAqIG5ld05vcm1hbEltcHVsc2U7XG5cbiAgICB2YXIgdGFuZ2VudExhbWJkYTEgPSAtVmVjMy5kb3QocmVsYXRpdmVWZWxvY2l0eSwgdDEpICogdGhpcy5lZmZUYW5nZW50aWFsTWFzczE7XG4gICAgdmFyIG5ld1RhbmdlbnRJbXB1bHNlMSA9IGNsYW1wKHRoaXMudGFuZ2VudEltcHVsc2UxICsgdGFuZ2VudExhbWJkYTEsIC1tYXhGcmljdGlvbiwgbWF4RnJpY3Rpb24pO1xuICAgIHRhbmdlbnRMYW1iZGExID0gbmV3VGFuZ2VudEltcHVsc2UxIC0gdGhpcy50YW5nZW50SW1wdWxzZTE7XG5cbiAgICB2YXIgdGFuZ2VudExhbWJkYTIgPSAtVmVjMy5kb3QocmVsYXRpdmVWZWxvY2l0eSwgdDIpICogdGhpcy5lZmZUYW5nZW50aWFsTWFzczI7XG4gICAgdmFyIG5ld1RhbmdlbnRJbXB1bHNlMiA9IGNsYW1wKHRoaXMudGFuZ2VudEltcHVsc2UyICsgdGFuZ2VudExhbWJkYTIsIC1tYXhGcmljdGlvbiwgbWF4RnJpY3Rpb24pO1xuICAgIHRhbmdlbnRMYW1iZGEyID0gbmV3VGFuZ2VudEltcHVsc2UyIC0gdGhpcy50YW5nZW50SW1wdWxzZTI7XG5cbiAgICB2YXIgaW1wdWxzZSA9IFZlYzMuc2NhbGUobiwgbm9ybWFsTGFtYmRhLCBOT1JNQUxJTVBVTFNFX1JFR0lTVEVSKTtcbiAgICB2YXIgdGFuZ2VudEltcHVsc2UxID0gVmVjMy5zY2FsZSh0MSwgdGFuZ2VudExhbWJkYTEsIFRBTkdFTlRJTVBVTFNFMV9SRUdJU1RFUik7XG4gICAgdmFyIHRhbmdlbnRJbXB1bHNlMiA9IFZlYzMuc2NhbGUodDIsIHRhbmdlbnRMYW1iZGEyLCBUQU5HRU5USU1QVUxTRTJfUkVHSVNURVIpO1xuXG4gICAgaW1wdWxzZS5hZGQodGFuZ2VudEltcHVsc2UxKS5hZGQodGFuZ2VudEltcHVsc2UyKTtcblxuICAgIHZhciBhbmdJbXB1bHNlQiA9IFZlYzMuY3Jvc3MockJvZHlCLCBpbXB1bHNlLCBWRUMxX1JFR0lTVEVSKTtcbiAgICB2YXIgYW5nSW1wdWxzZUEgPSBWZWMzLmNyb3NzKHJCb2R5QSwgaW1wdWxzZSwgVkVDMl9SRUdJU1RFUikuaW52ZXJ0KCk7XG5cbiAgICBib2R5Qi5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYm9keUIuYXBwbHlBbmd1bGFySW1wdWxzZShhbmdJbXB1bHNlQik7XG4gICAgaW1wdWxzZS5pbnZlcnQoKTtcbiAgICBib2R5QS5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYm9keUEuYXBwbHlBbmd1bGFySW1wdWxzZShhbmdJbXB1bHNlQSk7XG5cbiAgICB0aGlzLm5vcm1hbEltcHVsc2UgPSBuZXdOb3JtYWxJbXB1bHNlO1xuICAgIHRoaXMudGFuZ2VudEltcHVsc2UxID0gbmV3VGFuZ2VudEltcHVsc2UxO1xuICAgIHRoaXMudGFuZ2VudEltcHVsc2UyID0gbmV3VGFuZ2VudEltcHVsc2UyO1xuXG4gICAgdGhpcy5pbXB1bHNlLmFkZChpbXB1bHNlKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VBLmFkZChhbmdJbXB1bHNlQSk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQi5hZGQoYW5nSW1wdWxzZUIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWN0TWFuaWZvbGRUYWJsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG52YXIgT2JqZWN0TWFuYWdlciA9IHJlcXVpcmUoJ2ZhbW91cy11dGlsaXRpZXMnKS5PYmplY3RNYW5hZ2VyO1xuXG5PYmplY3RNYW5hZ2VyLnJlZ2lzdGVyKCdHSktfRVBBU3VwcG9ydFBvaW50JywgR0pLX0VQQVN1cHBvcnRQb2ludCk7XG52YXIgT01SZXF1ZXN0R0pLX0VQQVN1cHBvcnRQb2ludCA9IE9iamVjdE1hbmFnZXIucmVxdWVzdEdKS19FUEFTdXBwb3J0UG9pbnQ7XG52YXIgT01SZXF1ZXN0RHluYW1pY0dlb21ldHJ5ID0gT2JqZWN0TWFuYWdlci5yZXF1ZXN0RHluYW1pY0dlb21ldHJ5O1xudmFyIE9NRnJlZUdKS19FUEFTdXBwb3J0UG9pbnQgPSBPYmplY3RNYW5hZ2VyLmZyZWVHSktfRVBBU3VwcG9ydFBvaW50O1xudmFyIE9NRnJlZUR5bmFtaWNHZW9tZXRyeSA9IE9iamVjdE1hbmFnZXIuZnJlZUR5bmFtaWNHZW9tZXRyeTtcbnZhciBPTUZyZWVEeW5hbWljR2VvbWV0cnlGZWF0dXJlID0gT2JqZWN0TWFuYWdlci5mcmVlRHluYW1pY0dlb21ldHJ5RmVhdHVyZTtcblxudmFyIFBfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFYwX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBWMV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVjJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG52YXIgRElSRUNUSU9OX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBJTlZESVJFQ1RJT05fUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFN1cHBvcnQgcG9pbnQgdG8gYmUgYWRkZWQgdG8gdGhlIER5bmFtaWNHZW9tZXRyeS4gVGhlIHBvaW50IGluIE1pbmtvd3NraSBzcGFjZSBhcyB3ZWxsIGFzIHRoZVxuICogb3JpZ2luYWwgcGFpci5cbiAqXG4gKiBAY2xhc3MgR0pLX0VQQVN1cHBvcnRQb2ludFxuICogQHBhcmFtIHtWZWMzfSB2ZXJ0ZXhcbiAqIEBwYXJhbSB7VmVjM30gd29ybGRWZXJ0ZXhBXG4gKiBAcGFyYW0ge1ZlYzN9IHdvcmxkVmVydGV4QUJcbiAqL1xuZnVuY3Rpb24gR0pLX0VQQVN1cHBvcnRQb2ludCh2ZXJ0ZXgsIHdvcmxkVmVydGV4QSwgd29ybGRWZXJ0ZXhCKSB7XG4gICAgdGhpcy52ZXJ0ZXggPSB2ZXJ0ZXg7XG4gICAgdGhpcy53b3JsZFZlcnRleEEgPSB3b3JsZFZlcnRleEE7XG4gICAgdGhpcy53b3JsZFZlcnRleEIgPSB3b3JsZFZlcnRleEI7XG59XG5cbi8qKlxuICogVXNlZCBieSBPYmplY3RNYW5hZ2VyIHRvIHJlc2V0IHRoZSBvYmplY3Qgd2l0aCBkaWZmZXJlbnQgZGF0YS5cbiAqXG4gKiBAbWV0aG9kIHJlc2V0XG4gKiBAcGFyYW0ge09iamVjdFtdfSBhcmdzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkdKS19FUEFTdXBwb3J0UG9pbnQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQodmVydGV4LCB3b3JsZFZlcnRleEEsIHdvcmxkVmVydGV4Qikge1xuICAgIHRoaXMudmVydGV4ID0gdmVydGV4O1xuICAgIHRoaXMud29ybGRWZXJ0ZXhBID0gd29ybGRWZXJ0ZXhBO1xuICAgIHRoaXMud29ybGRWZXJ0ZXhCID0gd29ybGRWZXJ0ZXhCO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZyZWUgdGhlIER5bmFtaWNHZW9tdGV0cnkgYW5kIGFzc29jaWF0ZSB2ZXJ0aWNlcyBhbmQgZmVhdHVyZXMgZm9yIGxhdGVyIHJldXNlLlxuICpcbiAqIEBtZXRob2QgZnJlZUdKS19FUEFEeW5hbWljR2VvbWV0cnlcbiAqIEBwYXJhbSB7RHluYW1pY0dlb21ldHJ5fSBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBmcmVlR0pLX0VQQUR5bmFtaWNHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuICAgIHZhciBpO1xuICAgIGkgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgdiA9IHZlcnRpY2VzLnBvcCgpO1xuICAgICAgICBpZiAodiAhPT0gbnVsbCkgT01GcmVlR0pLX0VQQVN1cHBvcnRQb2ludCh2KTtcbiAgICB9XG4gICAgZ2VvbWV0cnkubnVtVmVydGljZXMgPSAwO1xuICAgIHZhciBmZWF0dXJlcyA9IGdlb21ldHJ5LmZlYXR1cmVzO1xuICAgIGkgPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgZiA9IGZlYXR1cmVzLnBvcCgpO1xuICAgICAgICBpZiAoZiAhPT0gbnVsbCkgT01GcmVlRHluYW1pY0dlb21ldHJ5RmVhdHVyZShmKTtcbiAgICB9XG4gICAgZ2VvbWV0cnkubnVtRmVhdHVyZXMgPSAwO1xuICAgIE9NRnJlZUR5bmFtaWNHZW9tZXRyeShnZW9tZXRyeSk7XG59XG5cbi8qKlxuICogRmluZCB0aGUgcG9pbnQgaW4gTWlua293c2tpIHNwYWNlIGZ1cnRoZXN0IGluIGEgZ2l2ZW4gZGlyZWN0aW9uIGZvciB0d28gY29udmV4IEJvZGllcy5cbiAqXG4gKiBAbWV0aG9kIG1pbmtvd3NraVN1cHBvcnRcbiAqIEBwYXJhbSB7Qm9keX0gYm9keTFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keTJcbiAqIEBwYXJhbSB7VmVjM30gZGlyZWN0aW9uXG4gKiBAcmV0dXJuIHtHSktfRVBBU3VwcG9ydFBvaW50fVxuICovXG5mdW5jdGlvbiBtaW5rb3dza2lTdXBwb3J0KGJvZHkxLCBib2R5MiwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIGludmVyc2VEaXJlY3Rpb24gPSBWZWMzLnNjYWxlKGRpcmVjdGlvbiwgLTEsIElOVkRJUkVDVElPTl9SRUdJU1RFUik7XG5cbiAgICB2YXIgZnVydGhlc3QxID0gYm9keTEuc3VwcG9ydChkaXJlY3Rpb24pO1xuICAgIHZhciBmdXJ0aGVzdDIgPSBib2R5Mi5zdXBwb3J0KGludmVyc2VEaXJlY3Rpb24pO1xuXG4gICAgdmFyIHcxID0gVmVjMy5hZGQoZnVydGhlc3QxLCBib2R5MS5wb3NpdGlvbiwgbmV3IFZlYzMoKSk7XG4gICAgdmFyIHcyID0gVmVjMy5hZGQoZnVydGhlc3QyLCBib2R5Mi5wb3NpdGlvbiwgbmV3IFZlYzMoKSk7XG5cbiAgICAvLyBUaGUgdmVydGV4IGluIE1pbmtvd3NraSBzcGFjZSBhcyB3ZWxsIGFzIHRoZSBvcmlnaW5hbCBwYWlyIGluIHdvcmxkIHNwYWNlXG4gICAgcmV0dXJuIE9NUmVxdWVzdEdKS19FUEFTdXBwb3J0UG9pbnQoKS5yZXNldChWZWMzLnN1YnRyYWN0KHcxLCB3MiwgbmV3IFZlYzMoKSksIHcxLCB3Mik7XG59XG5cbi8qKlxuICogR2lsYmVydC1Kb2huc29uLUtlZXJ0aGkgY29sbGlzaW9uIGRldGVjdGlvbi4gUmV0dXJucyBhIER5bmFtaWNHZW9tZXRyeSBzaW1wbGV4IGlmIHRoZSBib2RpZXMgYXJlIGZvdW5kXG4gKiB0byBoYXZlIGNvbGxpZGVkIG9yIGZhbHNlIGZvciBubyBjb2xsc2lvbi5cbiAqXG4gKiBAbWV0aG9kIEdKS1xuICogcGFyYW0ge0JvZHl9IGJvZHkxXG4gKiBwYXJhbSB7Qm9keX0gYm9keTJcbiAqIEByZXR1cm4ge0R5bmFtaWNHZW9tZXRyeSB8IEJvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIEdKSyhib2R5MSwgYm9keTIpIHtcbiAgICB2YXIgc3VwcG9ydCA9IG1pbmtvd3NraVN1cHBvcnQ7XG4gICAgLy8gVXNlIHAyIC0gcDEgdG8gc2VlZCB0aGUgaW5pdGlhbCBjaG9pY2Ugb2YgZGlyZWN0aW9uXG4gICAgdmFyIGRpcmVjdGlvbiA9IFZlYzMuc3VidHJhY3QoYm9keTIucG9zaXRpb24sIGJvZHkxLnBvc2l0aW9uLCBESVJFQ1RJT05fUkVHSVNURVIpLm5vcm1hbGl6ZSgpO1xuICAgIHZhciBzaW1wbGV4ID0gT01SZXF1ZXN0RHluYW1pY0dlb21ldHJ5KCk7XG4gICAgc2ltcGxleC5hZGRWZXJ0ZXgoc3VwcG9ydChib2R5MSwgYm9keTIsIGRpcmVjdGlvbikpO1xuICAgIGRpcmVjdGlvbi5pbnZlcnQoKTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IDFlMztcbiAgICB3aGlsZShpKysgPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24ueCA9PT0gMCAmJiBkaXJlY3Rpb24ueSA9PT0gMCAmJiBkaXJlY3Rpb24ueiA9PT0gMCkgYnJlYWs7XG4gICAgICAgIHNpbXBsZXguYWRkVmVydGV4KHN1cHBvcnQoYm9keTEsIGJvZHkyLCBkaXJlY3Rpb24pKTtcbiAgICAgICAgaWYgKFZlYzMuZG90KHNpbXBsZXguZ2V0TGFzdFZlcnRleCgpLnZlcnRleCwgZGlyZWN0aW9uKSA8IDApIGJyZWFrO1xuICAgICAgICAvLyBJZiBzaW1wbGV4IGNvbnRhaW5zIG9yaWdpbiwgcmV0dXJuIGZvciB1c2UgaW4gRVBBXG4gICAgICAgIGlmIChzaW1wbGV4LnNpbXBsZXhDb250YWluc09yaWdpbihkaXJlY3Rpb24sIE9NRnJlZUdKS19FUEFTdXBwb3J0UG9pbnQpKSByZXR1cm4gc2ltcGxleDtcbiAgICB9XG4gICAgZnJlZUdKS19FUEFEeW5hbWljR2VvbWV0cnkoc2ltcGxleCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEV4cGFuZGluZyBQb2x5dG9wZSBBbGdvcml0aG0tLXBlbmV0cmF0aW9uIGRlcHRoLCBjb2xsaXNpb24gbm9ybWFsLCBhbmQgY29udGFjdCBwb2ludHMuXG4gKiBSZXR1cm5zIGEgQ29sbGlzb25EYXRhIG9iamVjdC5cbiAqXG4gKiBAbWV0aG9kIEVQQVxuICogQHBhcmFtIHtCb2R5fSBib2R5MVxuICogQHBhcmFtIHtCb2R5fSBib2R5MlxuICogQHBhcmFtIHtEeW5hbWljR2VvbWV0cnl9IHBvbHl0b3BlXG4gKiBAcmV0dXJuIHtDb2xsaXNpb25EYXRhfVxuICovXG5mdW5jdGlvbiBFUEEoYm9keTEsIGJvZHkyLCBwb2x5dG9wZSkge1xuICAgIHZhciBzdXBwb3J0ID0gbWlua293c2tpU3VwcG9ydDtcbiAgICB2YXIgZGVwdGhFc3RpbWF0ZSA9IEluZmluaXR5O1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBtYXhJdGVyYXRpb25zID0gMWUzO1xuICAgIHdoaWxlKGkrKyA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgdmFyIGNsb3Nlc3QgPSBwb2x5dG9wZS5nZXRGZWF0dXJlQ2xvc2VzdFRvT3JpZ2luKCk7XG4gICAgICAgIGlmIChjbG9zZXN0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGNsb3Nlc3Qubm9ybWFsO1xuICAgICAgICB2YXIgcG9pbnQgPSBzdXBwb3J0KGJvZHkxLCBib2R5MiwgZGlyZWN0aW9uKTtcbiAgICAgICAgZGVwdGhFc3RpbWF0ZSA9IE1hdGgubWluKGRlcHRoRXN0aW1hdGUsIFZlYzMuZG90KHBvaW50LnZlcnRleCwgZGlyZWN0aW9uKSk7XG4gICAgICAgIGlmIChkZXB0aEVzdGltYXRlIC0gY2xvc2VzdC5kaXN0YW5jZSA8PSAwLjAxKSB7XG4gICAgICAgICAgICB2YXIgc3VwcG9ydEEgPSBwb2x5dG9wZS52ZXJ0aWNlc1tjbG9zZXN0LnZlcnRleEluZGljZXNbMF1dO1xuICAgICAgICAgICAgdmFyIHN1cHBvcnRCID0gcG9seXRvcGUudmVydGljZXNbY2xvc2VzdC52ZXJ0ZXhJbmRpY2VzWzFdXTtcbiAgICAgICAgICAgIHZhciBzdXBwb3J0QyA9IHBvbHl0b3BlLnZlcnRpY2VzW2Nsb3Nlc3QudmVydGV4SW5kaWNlc1syXV07XG5cbiAgICAgICAgICAgIHZhciBBID0gc3VwcG9ydEEudmVydGV4O1xuICAgICAgICAgICAgdmFyIEIgPSBzdXBwb3J0Qi52ZXJ0ZXg7XG4gICAgICAgICAgICB2YXIgQyA9IHN1cHBvcnRDLnZlcnRleDtcbiAgICAgICAgICAgIHZhciBQID0gVmVjMy5zY2FsZShkaXJlY3Rpb24sIGNsb3Nlc3QuZGlzdGFuY2UsIFBfUkVHSVNURVIpO1xuXG4gICAgICAgICAgICB2YXIgVjAgPSBWZWMzLnN1YnRyYWN0KEIsIEEsIFYwX1JFR0lTVEVSKTtcbiAgICAgICAgICAgIHZhciBWMSA9IFZlYzMuc3VidHJhY3QoQywgQSwgVjFfUkVHSVNURVIpO1xuICAgICAgICAgICAgdmFyIFYyID0gVmVjMy5zdWJ0cmFjdChQLCBBLCBWMl9SRUdJU1RFUik7XG5cbiAgICAgICAgICAgIHZhciBkMDAgPSBWZWMzLmRvdChWMCwgVjApO1xuICAgICAgICAgICAgdmFyIGQwMSA9IFZlYzMuZG90KFYwLCBWMSk7XG4gICAgICAgICAgICB2YXIgZDExID0gVmVjMy5kb3QoVjEsIFYxKTtcbiAgICAgICAgICAgIHZhciBkMjAgPSBWZWMzLmRvdChWMiwgVjApO1xuICAgICAgICAgICAgdmFyIGQyMSA9IFZlYzMuZG90KFYyLCBWMSk7XG4gICAgICAgICAgICB2YXIgZGVub20gPSBkMDAqZDExIC0gZDAxKmQwMTtcblxuICAgICAgICAgICAgdmFyIHYgPSAoZDExKmQyMCAtIGQwMSpkMjEpIC8gZGVub207XG4gICAgICAgICAgICB2YXIgdyA9IChkMDAqZDIxIC0gZDAxKmQyMCkgLyBkZW5vbTtcbiAgICAgICAgICAgIHZhciB1ID0gMS4wIC0gdiAtIHc7XG5cbiAgICAgICAgICAgIHZhciBib2R5MUNvbnRhY3QgPSAgICAgIHN1cHBvcnRBLndvcmxkVmVydGV4QS5zY2FsZSh1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGQoc3VwcG9ydEIud29ybGRWZXJ0ZXhBLnNjYWxlKHYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGQoc3VwcG9ydEMud29ybGRWZXJ0ZXhBLnNjYWxlKHcpKTtcblxuICAgICAgICAgICAgdmFyIGJvZHkyQ29udGFjdCA9ICAgICAgc3VwcG9ydEEud29ybGRWZXJ0ZXhCLnNjYWxlKHUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZChzdXBwb3J0Qi53b3JsZFZlcnRleEIuc2NhbGUodikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZChzdXBwb3J0Qy53b3JsZFZlcnRleEIuc2NhbGUodykpO1xuXG4gICAgICAgICAgICB2YXIgbG9jYWxCb2R5MUNvbnRhY3QgPSBWZWMzLnN1YnRyYWN0KGJvZHkxQ29udGFjdCwgYm9keTEucG9zaXRpb24sIG5ldyBWZWMzKCkpO1xuICAgICAgICAgICAgdmFyIGxvY2FsQm9keTJDb250YWN0ID0gVmVjMy5zdWJ0cmFjdChib2R5MkNvbnRhY3QsIGJvZHkyLnBvc2l0aW9uLCBuZXcgVmVjMygpKTtcblxuICAgICAgICAgICAgZnJlZUdKS19FUEFEeW5hbWljR2VvbWV0cnkocG9seXRvcGUpO1xuICAgICAgICAgICAgT01GcmVlR0pLX0VQQVN1cHBvcnRQb2ludChwb2ludCk7XG5cbiAgICAgICAgICAgIHJldHVybiBPYmplY3RNYW5hZ2VyLnJlcXVlc3RDb2xsaXNpb25EYXRhKCkucmVzZXQoY2xvc2VzdC5kaXN0YW5jZSwgZGlyZWN0aW9uLCBib2R5MUNvbnRhY3QsIGJvZHkyQ29udGFjdCwgbG9jYWxCb2R5MUNvbnRhY3QsIGxvY2FsQm9keTJDb250YWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvbHl0b3BlLmFkZFZlcnRleChwb2ludCk7XG4gICAgICAgICAgICBwb2x5dG9wZS5yZXNoYXBlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFUEEgZmFpbGVkIHRvIHRlcm1pbmF0ZSBpbiBhbGxvdHRlZCBpdGVyYXRpb25zLicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5HSksgPSBHSks7XG5tb2R1bGUuZXhwb3J0cy5FUEEgPSBFUEE7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBQUJCID0gcmVxdWlyZSgnLi9BQUJCJyk7XG5cbi8qKlxuICogQGNvbnN0IHtTdHJpbmdbXX0gQVhFUyB4LCB5LCBhbmQgeiBheGVzXG4gKi9cbnZhciBBWEVTID0gWyd4JywgJ3knLCAneiddO1xuXG4vKipcbiAqIFBlcnNpc3RhbnQgb2JqZWN0IG1haW50YWluaW5nIHNvcnRlZCBsaXN0cyBvZiBBQUJCIGVuZHBvaW50cyB1c2VkIGluIGEgc3dlZXAtYW5kLXBydW5lIGJyb2FkcGhhc2UuXG4gKiBVc2VkIHRvIGFjY2VsZXJhdGUgY29sbGlzaW9uIGRldGVjdGlvbi5cbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3dlZXBfYW5kX3BydW5lXG4gKlxuICogQGNsYXNzIFN3ZWVwQW5kUHJ1bmVcbiAqIEBwYXJhbSB7Qm9keVtdfSB0YXJnZXRzXG4gKi9cbmZ1bmN0aW9uIFN3ZWVwQW5kUHJ1bmUodGFyZ2V0cykge1xuICAgIHRoaXMuX3N3ZWVwVm9sdW1lcyA9IFtdO1xuICAgIHRoaXMuX2VudGl0eVJlZ2lzdHJ5ID0ge307XG4gICAgdGhpcy5fYm91bmRpbmdWb2x1bWVSZWdpc3RyeSA9IHt9O1xuICAgIHRoaXMuZW5kcG9pbnRzID0ge3g6IFtdLCB5OiBbXSwgejogW119O1xuXG4gICAgdGhpcy5vdmVybGFwcyA9IFtdO1xuICAgIHRoaXMub3ZlcmxhcHNNYXRyaXggPSB7fTtcbiAgICB0aGlzLl9JRFBvb2wgPSBbXTtcbiAgICB0YXJnZXRzID0gdGFyZ2V0cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGQodGFyZ2V0c1tpXSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFN0YXJ0IHRyYWNraW5nIGEgYm9keSBpbiB0aGUgYnJvYWQtcGhhc2UuXG4gKlxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5Td2VlcEFuZFBydW5lLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgdmFyIGJvdW5kaW5nVm9sdW1lID0gbmV3IEFBQkIoYm9keSk7XG4gICAgdmFyIHN3ZWVwVm9sdW1lID0gbmV3IFN3ZWVwVm9sdW1lKGJvdW5kaW5nVm9sdW1lKTtcblxuICAgIHRoaXMuX2VudGl0eVJlZ2lzdHJ5W2JvZHkuX0lEXSA9IGJvZHk7XG4gICAgdGhpcy5fYm91bmRpbmdWb2x1bWVSZWdpc3RyeVtib2R5Ll9JRF0gPSBib3VuZGluZ1ZvbHVtZTtcbiAgICB0aGlzLl9zd2VlcFZvbHVtZXMucHVzaChzd2VlcFZvbHVtZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgdmFyIGF4aXMgPSBBWEVTW2ldO1xuICAgICAgICB0aGlzLmVuZHBvaW50c1theGlzXS5wdXNoKHN3ZWVwVm9sdW1lLnBvaW50c1theGlzXVswXSk7XG4gICAgICAgIHRoaXMuZW5kcG9pbnRzW2F4aXNdLnB1c2goc3dlZXBWb2x1bWUucG9pbnRzW2F4aXNdWzFdKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFN0b3AgdHJhY2tpbmcgYSBib2R5IGluIHRoZSBicm9hZC1waGFzZS5cbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKi9cblN3ZWVwQW5kUHJ1bmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShib2R5KSB7XG4gICAgdGhpcy5fZW50aXR5UmVnaXN0cnlbYm9keS5fSURdID0gbnVsbDtcbiAgICB0aGlzLl9ib3VuZGluZ1ZvbHVtZVJlZ2lzdHJ5W2JvZHkuX0lEXSA9IG51bGw7XG4gICAgdmFyIGksIGxlbjtcbiAgICB2YXIgaW5kZXg7XG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5fc3dlZXBWb2x1bWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9zd2VlcFZvbHVtZXNbaV0uX0lEID09PSBib2R5Ll9JRCkge1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc3dlZXBWb2x1bWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgdmFyIGVuZHBvaW50cyA9IHRoaXMuZW5kcG9pbnRzO1xuICAgIHZhciBwb2ludDtcblxuICAgIHZhciB4cyA9IFtdO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGVuZHBvaW50cy54Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gZW5kcG9pbnRzLnhbaV07XG4gICAgICAgIGlmIChwb2ludC5fSUQgIT09IGJvZHkuX0lEKSB4cy5wdXNoKHBvaW50KTtcbiAgICB9XG4gICAgdmFyIHlzID0gW107XG4gICAgZm9yIChpID0gMCwgbGVuID0gZW5kcG9pbnRzLnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBlbmRwb2ludHMueVtpXTtcbiAgICAgICAgaWYgKHBvaW50Ll9JRCAhPT0gYm9keS5fSUQpIHlzLnB1c2gocG9pbnQpO1xuICAgIH1cbiAgICB2YXIgenMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBlbmRwb2ludHMuei5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludCA9IGVuZHBvaW50cy56W2ldO1xuICAgICAgICBpZiAocG9pbnQuX0lEICE9PSBib2R5Ll9JRCkgenMucHVzaChwb2ludCk7XG4gICAgfVxuICAgIGVuZHBvaW50cy54ID0geHM7XG4gICAgZW5kcG9pbnRzLnkgPSB5cztcbiAgICBlbmRwb2ludHMueiA9IHpzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGVuZHBvaW50cyBvZiB0aGUgdHJhY2tlZCBBQUJCJ3MgYW5kIHJlc29ydCB0aGUgZW5kcG9pbnQgbGlzdHMgYWNjb3JkaW5nbHkuIFVzZXMgYW4gaW5zZXJ0aW9uIHNvcnQsXG4gKiB3aGVyZSBzd2FwcyBkdXJpbmcgdGhlIHNvcnQgYXJlIHRha2VuIHRvIHNpZ25pZnkgYSBwb3RlbnRpYWwgY2hhbmdlIGluIG92ZXJsYXAgc3RhdHVzIGZvciB0aGUgdHdvXG4gKiByZWxldmFudCBBQUJCJ3MuIFJldHVybnMgcGFpcnMgb2Ygb3ZlcmxhcHBpbmcgQUFCQidzLlxuICpcbiAqIEBwYXJhbSB1cGRhdGVcbiAqIEByZXR1cm4ge1BhcnRpY2xlW11bXX1cbiAqL1xuU3dlZXBBbmRQcnVuZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9zd2VlcFZvbHVtZXMgPSB0aGlzLl9zd2VlcFZvbHVtZXM7XG4gICAgdmFyIF9lbnRpdHlSZWdpc3RyeSA9IHRoaXMuX2VudGl0eVJlZ2lzdHJ5O1xuICAgIHZhciBfYm91bmRpbmdWb2x1bWVSZWdpc3RyeSA9IHRoaXMuX2JvdW5kaW5nVm9sdW1lUmVnaXN0cnk7XG5cbiAgICB2YXIgaSwgaiwgaywgbGVuO1xuXG4gICAgZm9yIChqID0gMCwgbGVuID0gX3N3ZWVwVm9sdW1lcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBfc3dlZXBWb2x1bWVzW2pdLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBlbmRwb2ludHMgPSB0aGlzLmVuZHBvaW50cztcbiAgICB2YXIgb3ZlcmxhcHMgPSB0aGlzLm92ZXJsYXBzO1xuICAgIHZhciBvdmVybGFwc01hdHJpeCA9IHRoaXMub3ZlcmxhcHNNYXRyaXg7XG4gICAgdmFyIF9JRFBvb2wgPSB0aGlzLl9JRFBvb2w7XG5cbiAgICBmb3IgKGsgPSAwOyBrIDwgMzsgaysrKSB7XG4gICAgICAgIHZhciBheGlzID0gQVhFU1trXTtcbiAgICAgICAgLy8gSW5zZXJ0aW9uIHNvcnQ6XG4gICAgICAgIHZhciBlbmRwb2ludEF4aXMgPSBlbmRwb2ludHNbYXhpc107XG4gICAgICAgIGZvciAoaiA9IDEsIGxlbiA9IGVuZHBvaW50QXhpcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBlbmRwb2ludEF4aXNbal07XG4gICAgICAgICAgICB2YXIgdmFsID0gY3VycmVudC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBzd2FwO1xuICAgICAgICAgICAgdmFyIHJvdztcbiAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgIHZhciBsb3dJRDtcbiAgICAgICAgICAgIHZhciBoaWdoSUQ7XG4gICAgICAgICAgICB2YXIgY0lEO1xuICAgICAgICAgICAgdmFyIHNJRDtcblxuICAgICAgICAgICAgaSA9IGogLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiAoc3dhcCA9IGVuZHBvaW50QXhpc1tpXSkudmFsdWUgPiB2YWwpIHtcbiAgICAgICAgICAgICAgICAvLyBBIHN3YXAgb2NjdXJlbmNlIGluZGljYXRlcyB0aGF0IGN1cnJlbnQgYW5kIHN3YXAgZWl0aGVyIGp1c3Qgc3RhcnRlZCBvciBqdXN0IHN0b3BwZWQgb3ZlcmxhcHBpbmdcblxuICAgICAgICAgICAgICAgIGNJRCA9IGN1cnJlbnQuX0lEO1xuICAgICAgICAgICAgICAgIHNJRCA9IHN3YXAuX0lEO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNJRCA8IHNJRCkge1xuICAgICAgICAgICAgICAgICAgICBsb3dJRCA9IGNJRDtcbiAgICAgICAgICAgICAgICAgICAgaGlnaElEID0gc0lEO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd0lEID0gc0lEO1xuICAgICAgICAgICAgICAgICAgICBoaWdoSUQgPSBjSUQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYsIGZvciB0aGlzIGF4aXMsIG1pbiBwb2ludCBvZiBjdXJyZW50IGFuZCBtYXggcG9pbnQgb2Ygc3dhcFxuICAgICAgICAgICAgICAgIGlmICh+Y3VycmVudC5zaWRlICYgc3dhcC5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyBvdmVybGFwcGluZyBvbiB0aGlzIGF4aXMgLT4gcG9zc2libGUgb3ZlcmxhcCwgZG8gZnVsbCBBQUJCIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChBQUJCLmNoZWNrT3ZlcmxhcChfYm91bmRpbmdWb2x1bWVSZWdpc3RyeVtjSURdLCBfYm91bmRpbmdWb2x1bWVSZWdpc3RyeVtzSURdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gb3ZlcmxhcHNNYXRyaXhbbG93SURdID0gb3ZlcmxhcHNNYXRyaXhbbG93SURdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByb3dbaGlnaElEXSA9IF9JRFBvb2wubGVuZ3RoID8gX0lEUG9vbC5wb3AoKSA6IG92ZXJsYXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzW2luZGV4XSA9IFtfZW50aXR5UmVnaXN0cnlbbG93SURdLCBfZW50aXR5UmVnaXN0cnlbaGlnaElEXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAvLyBFbHNlIGlmLCBmb3IgdGhpcyBheGlzLCBtYXggcG9pbnQgb2YgY3VycmVudCBhbmQgbWluIHBvaW50IG9mIHN3YXBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQuc2lkZSAmIH5zd2FwLnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IG5vdCBvdmVybGFwcGluZyBvbiB0aGlzIGF4aXMgLT4gZGVmaW5pdGVseSBub3Qgb3ZlcmxhcHBpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKChyb3cgPSBvdmVybGFwc01hdHJpeFtsb3dJRF0pICYmIHJvd1toaWdoSURdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcm93W2hpZ2hJRF07XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93W2hpZ2hJRF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgX0lEUG9vbC5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbHNlIGlmIG1heCBvZiBib3RoIG9yIG1pbiBvZiBib3RoLCBzdGlsbCBvdmVybGFwcGluZ1xuXG4gICAgICAgICAgICAgICAgZW5kcG9pbnRBeGlzW2kgKyAxXSA9IHN3YXA7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kcG9pbnRBeGlzW2kgKyAxXSA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3ZlcmxhcHM7XG59O1xuXG4vKipcbiAqIE9iamVjdCB1c2VkIHRvIGFzc29jaWF0ZSBhbiBBQUJCIHdpdGggaXRzIGVuZHBvaW50cyBpbiB0aGUgc29ydGVkIGxpc3RzLlxuICpcbiAqIEBjbGFzcyBTd2VlcFZvbHVtZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FBQkJ9IGJvdW5kaW5nVm9sdW1lXG4gKi9cbmZ1bmN0aW9uIFN3ZWVwVm9sdW1lKGJvdW5kaW5nVm9sdW1lKSB7XG4gICAgdGhpcy5fYm91bmRpbmdWb2x1bWUgPSBib3VuZGluZ1ZvbHVtZTtcbiAgICB0aGlzLl9JRCA9IGJvdW5kaW5nVm9sdW1lLl9JRDtcbiAgICB0aGlzLnBvaW50cyA9IHtcbiAgICAgICAgeDogW3tfSUQ6IGJvdW5kaW5nVm9sdW1lLl9JRCwgc2lkZTogMCwgdmFsdWU6IG51bGx9LCB7X0lEOiBib3VuZGluZ1ZvbHVtZS5fSUQsIHNpZGU6IDEsIHZhbHVlOiBudWxsfV0sXG4gICAgICAgIHk6IFt7X0lEOiBib3VuZGluZ1ZvbHVtZS5fSUQsIHNpZGU6IDAsIHZhbHVlOiBudWxsfSwge19JRDogYm91bmRpbmdWb2x1bWUuX0lELCBzaWRlOiAxLCB2YWx1ZTogbnVsbH1dLFxuICAgICAgICB6OiBbe19JRDogYm91bmRpbmdWb2x1bWUuX0lELCBzaWRlOiAwLCB2YWx1ZTogbnVsbH0sIHtfSUQ6IGJvdW5kaW5nVm9sdW1lLl9JRCwgc2lkZTogMSwgdmFsdWU6IG51bGx9XVxuICAgIH07XG4gICAgdGhpcy51cGRhdGUoKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGVuZHBvaW50cyB0byByZWZsZWN0IHRoZSBjdXJyZW50IGxvY2F0aW9uIG9mIHRoZSBBQUJCLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cblN3ZWVwVm9sdW1lLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm91bmRpbmdWb2x1bWUgPSB0aGlzLl9ib3VuZGluZ1ZvbHVtZTtcbiAgICBib3VuZGluZ1ZvbHVtZS51cGRhdGUoKTtcblxuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHZhciBheGlzID0gQVhFU1tpXTtcbiAgICAgICAgcG9pbnRzW2F4aXNdWzBdLnZhbHVlID0gYm91bmRpbmdWb2x1bWUudmVydGljZXNbYXhpc11bMF07XG4gICAgICAgIHBvaW50c1theGlzXVsxXS52YWx1ZSA9IGJvdW5kaW5nVm9sdW1lLnZlcnRpY2VzW2F4aXNdWzFdO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3dlZXBBbmRQcnVuZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZvcmNlID0gcmVxdWlyZSgnLi9Gb3JjZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG5cbnZhciBGT1JDRV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogVXNlIGRyYWcgdG8gb3Bwb3NlIG1vbWVudHVtIG9mIGEgbW92aW5nIG9iamVjdFxuICpcbiAqIEBjbGFzcyBEcmFnXG4gKiBAZXh0ZW5kcyBGb3JjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gRHJhZyh0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgRm9yY2UuY2FsbCh0aGlzLCB0YXJnZXRzLCBvcHRpb25zKTtcbn1cblxuRHJhZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZvcmNlLnByb3RvdHlwZSk7XG5EcmFnLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyYWc7XG5cbi8qKlxuICogVXNlZCB0byBzY2FsZSB2ZWxvY2l0eSBpbiB0aGUgY29tcHV0YXRpb24gb2YgdGhlIGRyYWcgZm9yY2UuXG4gKlxuICogQGF0dHJpYnV0ZSBRVUFEUkFUSUNcbiAqIEB0eXBlIEZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gdlxuICogQHJldHVybiB7TnVtYmVyfSB1c2VkIHRvIHNxdWFyZSB0aGUgbWFnbml0dWRlIG9mIHRoZSB2ZWxvY2l0eVxuICovXG5EcmFnLlFVQURSQVRJQyA9IGZ1bmN0aW9uIFFVQURSQVRJQyh2KSB7XG4gICAgcmV0dXJuIHYqdjtcbn07XG5cbi8qKlxuICogVXNlZCB0byBzY2FsZSB2ZWxvY2l0eSBpbiB0aGUgY29tcHV0YXRpb24gb2YgdGhlIGRyYWcgZm9yY2UuXG4gKlxuICogQGF0dHJpYnV0ZSBMSU5FQVJcbiAqIEB0eXBlIEZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gdlxuICogQHJldHVybiB7TnVtYmVyfSBzdHJlbmd0aCAxLCB3aWxsIG5vdCBzY2FsZSB0aGUgdmVsb2NpdHlcbiAqL1xuRHJhZy5MSU5FQVIgPSBmdW5jdGlvbiBMSU5FQVIodikge1xuICAgIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBGb3JjZS4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5EcmFnLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tYXggPSB0aGlzLm1heCB8fCBJbmZpbml0eTtcbiAgICB0aGlzLnN0cmVuZ3RoID0gdGhpcy5zdHJlbmd0aCB8fCAxO1xuICAgIHRoaXMudHlwZSA9IHRoaXMudHlwZSB8fCBEcmFnLkxJTkVBUjtcbn07XG5cbi8qKlxuICogQXBwbHkgdGhlIGZvcmNlLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkRyYWcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgIHZhciBmb3JjZSA9IEZPUkNFX1JFR0lTVEVSO1xuXG4gICAgdmFyIG1heCA9IHRoaXMubWF4O1xuICAgIHZhciBzdHJlbmd0aCA9IHRoaXMuc3RyZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgIHZhciB2ZWxvY2l0eSA9IHRhcmdldC52ZWxvY2l0eTtcbiAgICAgICAgdmFyIHYgPSB2ZWxvY2l0eS5sZW5ndGgoKTtcbiAgICAgICAgdmFyIGludlYgPSB2ID8gMSAvIHYgOiAwO1xuICAgICAgICB2YXIgbWFnbml0dWRlID0gLXN0cmVuZ3RoICogdHlwZSh2KTtcbiAgICAgICAgVmVjMy5zY2FsZSh2ZWxvY2l0eSwgKG1hZ25pdHVkZSA8IC1tYXggPyAtbWF4IDogbWFnbml0dWRlKSAqIGludlYsIGZvcmNlKTtcbiAgICAgICAgdGFyZ2V0LmFwcGx5Rm9yY2UoZm9yY2UpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9JRCA9IDA7XG4vKipcbiAqIEFic3RyYWN0IGZvcmNlIG1hbmFnZXIgdG8gYXBwbHkgZm9yY2VzIHRvIHRhcmdldHMuXG4gKlxuICogQGNsYXNzIEZvcmNlXG4gKiBAdmlydHVhbFxuICogQHBhcmFtIHtQYXJ0aWNsZVtdfSB0YXJnZXRzIFRoZSB0YXJnZXRzIG9mIHRoZSBmb3JjZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGhhc2guXG4gKi9cbmZ1bmN0aW9uIEZvcmNlKHRhcmdldHMsIG9wdGlvbnMpIHtcbiAgICBpZiAodGFyZ2V0cykge1xuICAgICAgICBpZiAodGFyZ2V0cyBpbnN0YW5jZW9mIEFycmF5KSB0aGlzLnRhcmdldHMgPSB0YXJnZXRzO1xuICAgICAgICBlbHNlIHRoaXMudGFyZ2V0cyA9IFt0YXJnZXRzXTtcbiAgICB9XG4gICAgZWxzZSB0aGlzLnRhcmdldHMgPSBbXTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHRoaXMuX0lEID0gX0lEKys7XG59XG5cbi8qKlxuICogRGVjb3JhdGVzIHRoZSBGb3JjZSB3aXRoIHRoZSBvcHRpb25zIG9iamVjdC5cbiAqXG4gKiBAbWV0aG9kIHNldE9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGhhc2guXG4gKi9cbkZvcmNlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB0aGlzLmluaXQob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEFkZCBhIHRhcmdldCBvciB0YXJnZXRzIHRvIHRoZSBGb3JjZS5cbiAqXG4gKiBAbWV0aG9kIGFkZFRhcmdldFxuICogQHBhcmFtIHtQYXJ0aWNsZX0gdGFyZ2V0IFRoZSBib2R5IHRvIGJlZ2luIHRhcmdldHRpbmcuXG4gKi9cbkZvcmNlLnByb3RvdHlwZS5hZGRUYXJnZXQgPSBmdW5jdGlvbiBhZGRUYXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXRzLnB1c2godGFyZ2V0KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgdGFyZ2V0IG9yIHRhcmdldHMgZnJvbSB0aGUgRm9yY2UuXG4gKlxuICogQG1ldGhvZCBhZGRUYXJnZXRcbiAqIEBwYXJhbSB7UGFydGljbGV9IHRhcmdldCBUaGUgYm9keSB0byBzdG9wIHRhcmdldHRpbmcuXG4gKi9cbkZvcmNlLnByb3RvdHlwZS5yZW1vdmVUYXJnZXQgPSBmdW5jdGlvbiByZW1vdmVUYXJnZXQodGFyZ2V0KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy50YXJnZXRzLmluZGV4T2YodGFyZ2V0KTtcbiAgICBpZiAoaW5kZXggPCAwKSByZXR1cm47XG4gICAgdGhpcy50YXJnZXRzLnNwbGljZShpbmRleCwgMSk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCBpbnZva2VkIHVwb24gaW5zdGFudGlhdGlvbiBhbmQgdGhlIHNldHRpbmcgb2Ygb3B0aW9ucy5cbiAqXG4gKiBAbWV0aG9kIGluaXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGhhc2guXG4gKi9cbkZvcmNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7fTtcblxuLyoqXG4gKiBBcHBseSBmb3JjZXMgb24gZWFjaCB0YXJnZXQuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSBjdXJyZW50IHRpbWUgaW4gdGhlIHBoeXNpY3MgZW5naW5lLlxuICogQHBhcmFtIHtOdW1iZXJ9IGR0IFRoZSBwaHlzaWNzIGVuZ2luZSBmcmFtZSBkZWx0YS5cbiAqL1xuRm9yY2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh0aW1lLCBkdCkge307XG5cbm1vZHVsZS5leHBvcnRzID0gRm9yY2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGb3JjZSA9IHJlcXVpcmUoJy4vRm9yY2UnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xuXG52YXIgRk9SQ0VfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEZvcmNlIHRoYXQgcHVsbHMgYWxsIG9iamVjdHMgaW4gYSBkaXJlY3Rpb24gd2l0aCBjb25zdGFudCBhY2NlbGVyYXRpb25cbiAqXG4gKiBAY2xhc3MgR3Jhdml0eTFEXG4gKiBAZXh0ZW5kcyBGb3JjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gR3Jhdml0eTFEKHRhcmdldHMsIG9wdGlvbnMpIHtcbiAgICBGb3JjZS5jYWxsKHRoaXMsIHRhcmdldHMsIG9wdGlvbnMpO1xufVxuXG5HcmF2aXR5MUQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGb3JjZS5wcm90b3R5cGUpO1xuR3Jhdml0eTFELnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyYXZpdHkxRDtcblxuLyoqXG4gKiBAZW51bSBkaXJlY3Rpb25zXG4gKi9cbkdyYXZpdHkxRC5ET1dOICAgICA9IDA7XG5HcmF2aXR5MUQuVVAgICAgICAgPSAxO1xuR3Jhdml0eTFELkxFRlQgICAgID0gMjtcbkdyYXZpdHkxRC5SSUdIVCAgICA9IDM7XG5HcmF2aXR5MUQuRk9SV0FSRCAgPSA0O1xuR3Jhdml0eTFELkJBQ0tXQVJEID0gNTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBGb3JjZS4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5HcmF2aXR5MUQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5tYXggPSB0aGlzLm1heCB8fCBJbmZpbml0eTtcbiAgICBpZiAob3B0aW9ucy5hY2NlbGVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5zdHJlbmd0aCA9IHRoaXMuYWNjZWxlcmF0aW9uLmxlbmd0aCgpO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IC0xO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhY2NlbGVyYXRpb24gPSB0aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb24gfHwgR3Jhdml0eTFELkRPV047XG4gICAgdmFyIG1hZ25pdHVkZSA9IHRoaXMuc3RyZW5ndGggPSB0aGlzLnN0cmVuZ3RoIHx8IDIwMDtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICBjYXNlIEdyYXZpdHkxRC5ET1dOOlxuICAgICAgICAgICAgYWNjZWxlcmF0aW9uLnNldCgwLCBtYWduaXR1ZGUsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR3Jhdml0eTFELlVQOlxuICAgICAgICAgICAgYWNjZWxlcmF0aW9uLnNldCgwLCAtMSAqIG1hZ25pdHVkZSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHcmF2aXR5MUQuTEVGVDpcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvbi5zZXQoLTEgKiBtYWduaXR1ZGUsIDAsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR3Jhdml0eTFELlJJR0hUOlxuICAgICAgICAgICAgYWNjZWxlcmF0aW9uLnNldChtYWduaXR1ZGUsIDAsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR3Jhdml0eTFELkZPUldBUkQ6XG4gICAgICAgICAgICBhY2NlbGVyYXRpb24uc2V0KDAsIDAsIC0xICogbWFnbml0dWRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdyYXZpdHkxRC5CQUNLV0FSRDpcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvbi5zZXQoMCwgMCwgbWFnbml0dWRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBcHBseSB0aGUgZm9yY2UuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuR3Jhdml0eTFELnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcblxuICAgIHZhciBmb3JjZSA9IEZPUkNFX1JFR0lTVEVSO1xuXG4gICAgdmFyIG1heCA9IHRoaXMubWF4O1xuICAgIHZhciBhY2NlbGVyYXRpb24gPSB0aGlzLmFjY2VsZXJhdGlvbjtcbiAgICB2YXIgYSA9IGFjY2VsZXJhdGlvbi5sZW5ndGgoKTtcbiAgICB2YXIgaW52QSA9IGEgPyAxIC8gYSA6IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgIHZhciBtYWduaXR1ZGUgPSBhICogdGFyZ2V0Lm1hc3M7XG4gICAgICAgIFZlYzMuc2NhbGUoYWNjZWxlcmF0aW9uLCAobWFnbml0dWRlID4gbWF4ID8gbWF4IDogbWFnbml0dWRlKSAqIGludkEsIGZvcmNlKTtcbiAgICAgICAgdGFyZ2V0LmFwcGx5Rm9yY2UoZm9yY2UpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3Jhdml0eTFEO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRm9yY2UgPSByZXF1aXJlKCcuL0ZvcmNlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcblxudmFyIEZPUkNFX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBBbiBpbnZlcnNlIHNxdWFyZSBmb3JjZSBkZXBlbmRlbnQgb24gdGhlIG1hc3NlcyBvZiB0aGUgc291cmNlIGFuZCB0YXJnZXRzLlxuICpcbiAqIEBjbGFzcyBHcmF2aXR5M0RcbiAqIEBleHRlbmRzIEZvcmNlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBHcmF2aXR5M0Qoc291cmNlLCB0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2UgfHwgbnVsbDtcbiAgICBGb3JjZS5jYWxsKHRoaXMsIHRhcmdldHMsIG9wdGlvbnMpO1xufVxuXG5HcmF2aXR5M0QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGb3JjZS5wcm90b3R5cGUpO1xuR3Jhdml0eTNELnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyYXZpdHkzRDtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBGb3JjZS4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKi9cbkdyYXZpdHkzRC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubWF4ID0gdGhpcy5tYXggfHwgSW5maW5pdHk7XG4gICAgdGhpcy5zdHJlbmd0aCA9IHRoaXMuc3RyZW5ndGggfHwgMjAwO1xufTtcblxuLyoqXG4gKiBBcHBseSB0aGUgZm9yY2UuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuR3Jhdml0eTNELnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgdmFyIHRhcmdldHMgPSB0aGlzLnRhcmdldHM7XG5cbiAgICB2YXIgZm9yY2UgPSBGT1JDRV9SRUdJU1RFUjtcblxuICAgIHZhciBzdHJlbmd0aCA9IHRoaXMuc3RyZW5ndGg7XG4gICAgdmFyIG1heCA9IHRoaXMubWF4O1xuICAgIHZhciBhbmNob3IgPSB0aGlzLmFuY2hvciB8fCBzb3VyY2UucG9zaXRpb247XG4gICAgdmFyIHNvdXJjZU1hc3MgPSB0aGlzLmFuY2hvciA/IDEgOiBzb3VyY2UubWFzcztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgVmVjMy5zdWJ0cmFjdChhbmNob3IsIHRhcmdldC5wb3NpdGlvbiwgZm9yY2UpO1xuICAgICAgICB2YXIgZGlzdCA9IGZvcmNlLmxlbmd0aCgpO1xuICAgICAgICB2YXIgaW52RGlzdGFuY2UgPSBkaXN0ID8gMSAvIGRpc3QgOiAwO1xuICAgICAgICB2YXIgbWFnbml0dWRlID0gc3RyZW5ndGggKiBzb3VyY2VNYXNzICogdGFyZ2V0Lm1hc3MgKiBpbnZEaXN0YW5jZSAqIGludkRpc3RhbmNlO1xuICAgICAgICBpZiAobWFnbml0dWRlIDwgMCkge1xuICAgICAgICAgICAgbWFnbml0dWRlID0gbWFnbml0dWRlIDwgLW1heCA/IC1tYXggOiBtYWduaXR1ZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYWduaXR1ZGUgPSBtYWduaXR1ZGUgPiBtYXggPyBtYXggOiBtYWduaXR1ZGU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yY2Uuc2NhbGUobWFnbml0dWRlICogaW52RGlzdGFuY2UpO1xuICAgICAgICB0YXJnZXQuYXBwbHlGb3JjZShmb3JjZSk7XG4gICAgICAgIGlmIChzb3VyY2UpIHNvdXJjZS5hcHBseUZvcmNlKGZvcmNlLmludmVydCgpKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXZpdHkzRDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZvcmNlID0gcmVxdWlyZSgnLi9Gb3JjZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG5cbnZhciBUT1JRVUVfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEEgYmVoYXZpb3IgdGhhdCBzbG93cyBhbmd1bGFyIHZlbG9jaXR5IGJ5IGFwcGx5aW5nIHRvcnF1ZS5cbiAqXG4gKiBAY2xhc3MgUm90YXRpb25hbERyYWdcbiAqIEBleHRlbmRzIEZvcmNlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIHRvIHNldCBvbiBkcmFnXG4gKi9cbmZ1bmN0aW9uIFJvdGF0aW9uYWxEcmFnKHRhcmdldHMsIG9wdGlvbnMpIHtcbiAgICBGb3JjZS5jYWxsKHRoaXMsIHRhcmdldHMsIG9wdGlvbnMpO1xufVxuXG5Sb3RhdGlvbmFsRHJhZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZvcmNlLnByb3RvdHlwZSk7XG5Sb3RhdGlvbmFsRHJhZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbmFsRHJhZztcblxuLyoqXG4gKiBVc2VkIHRvIHNjYWxlIGFuZ3VsYXIgdmVsb2NpdHkgaW4gdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBkcmFnIHRvcnF1ZS5cbiAqXG4gKiBAYXR0cmlidXRlIFFVQURSQVRJQ1xuICogQHR5cGUgRnVuY3Rpb25cbiAqIEBwYXJhbSB7VmVjM30gb21lZ2FcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuUm90YXRpb25hbERyYWcuUVVBRFJBVElDID0gZnVuY3Rpb24gUVVBRFJBVElDKG9tZWdhKSB7XG4gICAgcmV0dXJuIG9tZWdhLmxlbmd0aCgpO1xufTtcblxuLyoqXG4gKiBVc2VkIHRvIHNjYWxlIGFuZ3VsYXIgdmVsb2NpdHkgaW4gdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBkcmFnIHRvcnF1ZS5cbiAqXG4gKiBAYXR0cmlidXRlIExJTkVBUlxuICogQHR5cGUgRnVuY3Rpb25cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuUm90YXRpb25hbERyYWcuTElORUFSID0gZnVuY3Rpb24gTElORUFSKCkge1xuICAgIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBGb3JjZS4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKi9cblJvdGF0aW9uYWxEcmFnLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLm1heCA9IHRoaXMubWF4IHx8IEluZmluaXR5O1xuICAgIHRoaXMuc3RyZW5ndGggPSB0aGlzLnN0cmVuZ3RoIHx8IDE7XG4gICAgdGhpcy50eXBlID0gdGhpcy50eXBlIHx8IFJvdGF0aW9uYWxEcmFnLkxJTkVBUjtcbn07XG5cbi8qKlxuICogQWRkcyBhIHJvdGF0aW9uYWwgZHJhZyBmb3JjZSB0byBhIHBoeXNpY3MgYm9keSdzIHRvcnF1ZSBhY2N1bXVsYXRvci5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5Sb3RhdGlvbmFsRHJhZy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciB0YXJnZXRzID0gdGhpcy50YXJnZXRzO1xuICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgdmFyIHRvcnF1ZSA9IFRPUlFVRV9SRUdJU1RFUjtcblxuICAgIHZhciBtYXggPSB0aGlzLm1heDtcbiAgICB2YXIgc3RyZW5ndGggPSB0aGlzLnN0cmVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICB2YXIgb21lZ2EgPSB0YXJnZXQuYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICB2YXIgbWFnbml0dWRlID0gLXN0cmVuZ3RoICogdHlwZShvbWVnYSk7XG4gICAgICAgIFZlYzMuc2NhbGUob21lZ2EsIG1hZ25pdHVkZSA8IC1tYXggPyAtbWF4IDogbWFnbml0dWRlLCB0b3JxdWUpO1xuICAgICAgICB0YXJnZXQuYXBwbHlUb3JxdWUodG9ycXVlKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxEcmFnO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRm9yY2UgPSByZXF1aXJlKCcuL0ZvcmNlJyk7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuUXVhdGVybmlvbjtcbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xudmFyIE1hdDMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5NYXQzMztcblxudmFyIFFfUkVHSVNURVIgPSBuZXcgUXVhdGVybmlvbigpO1xudmFyIERBTVBJTkdfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFhZWl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgTUFUX1JFR0lTVEVSID0gbmV3IE1hdDMzKCk7XG5cbi8qKiBAY29uc3QgUEkgKi9cbnZhciBQSSA9IE1hdGguUEk7XG5cbi8qKlxuICogQSBzcHJpbmctbGlrZSBiZWhhdmlvciB0aGF0IGF0dGVtcHRzIHRvIGVuZm9yY2UgYSBzcGVjZmljIG9yaWVudGF0aW9uIGJ5IGFwcGx5aW5nIHRvcnF1ZS5cbiAqXG4gKiBAY2xhc3MgUm90YXRpb25hbFNwcmluZ1xuICogQGV4dGVuZHMgRm9yY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJvdGF0aW9uYWxTcHJpbmcoc291cmNlLCB0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2UgfHwgbnVsbDtcbiAgICBGb3JjZS5jYWxsKHRoaXMsIHRhcmdldHMsIG9wdGlvbnMpO1xufVxuXG5Sb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRm9yY2UucHJvdG90eXBlKTtcblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbFNwcmluZztcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBGb3JjZS4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5Sb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZSkgdGhpcy5hbmNob3IgPSB0aGlzLmFuY2hvciA/IHRoaXMuYW5jaG9yLm5vcm1hbGl6ZSgpIDogbmV3IFF1YXRlcm5pb24oMSwwLDAsMCk7XG4gICAgaWYgKG9wdGlvbnMuc3RpZmZuZXNzIHx8IG9wdGlvbnMuZGFtcGluZykge1xuICAgICAgICB0aGlzLnN0aWZmbmVzcyA9IHRoaXMuc3RpZmZuZXNzIHx8IDEwMDtcbiAgICAgICAgdGhpcy5kYW1waW5nID0gdGhpcy5kYW1waW5nIHx8IDA7XG4gICAgICAgIHRoaXMucGVyaW9kID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYW1waW5nUmF0aW8gPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLnBlcmlvZCB8fCBvcHRpb25zLmRhbXBpbmdSYXRpbykge1xuICAgICAgICB0aGlzLnBlcmlvZCA9IHRoaXMucGVyaW9kIHx8IDE7XG4gICAgICAgIHRoaXMuZGFtcGluZ1JhdGlvID0gdGhpcy5kYW1waW5nUmF0aW8gfHwgMDtcblxuICAgICAgICB0aGlzLnN0aWZmbmVzcyA9IDIgKiBQSSAvIHRoaXMucGVyaW9kO1xuICAgICAgICB0aGlzLnN0aWZmbmVzcyAqPSB0aGlzLnN0aWZmbmVzcztcbiAgICAgICAgdGhpcy5kYW1waW5nID0gNCAqIFBJICogdGhpcy5kYW1waW5nUmF0aW8gLyB0aGlzLnBlcmlvZDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZHMgYSB0b3JxdWUgZm9yY2UgdG8gYSBwaHlzaWNzIGJvZHkncyB0b3JxdWUgYWNjdW11bGF0b3IuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuUm90YXRpb25hbFNwcmluZy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcblxuICAgIHZhciBkZWx0YVEgPSBRX1JFR0lTVEVSO1xuICAgIHZhciBkYW1waW5nVG9ycXVlID0gREFNUElOR19SRUdJU1RFUjtcbiAgICB2YXIgWFlaID0gWFlaX1JFR0lTVEVSO1xuICAgIHZhciBlZmZJbmVydGlhID0gTUFUX1JFR0lTVEVSO1xuXG4gICAgdmFyIG1heCA9IHRoaXMubWF4O1xuICAgIHZhciBzdGlmZm5lc3MgPSB0aGlzLnN0aWZmbmVzcztcbiAgICB2YXIgZGFtcGluZyA9IHRoaXMuZGFtcGluZztcbiAgICB2YXIgYW5jaG9yID0gdGhpcy5hbmNob3IgfHwgc291cmNlLm9yaWVudGF0aW9uO1xuICAgIHZhciBpbnZTb3VyY2VJbmVydGlhID0gdGhpcy5hbmNob3IgPyBudWxsIDogc291cmNlLmludmVyc2VJbmVydGlhO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICB2YXIgcSA9IHRhcmdldC5vcmllbnRhdGlvbjtcbiAgICAgICAgUXVhdGVybmlvbi5jb25qdWdhdGUocSwgZGVsdGFRKTtcbiAgICAgICAgZGVsdGFRLm11bHRpcGx5KGFuY2hvcik7XG5cbiAgICAgICAgaWYgKGRlbHRhUS53ID49IDEpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgaGFsZnRoZXRhID0gTWF0aC5hY29zKGRlbHRhUS53KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGguc3FydCgxIC0gZGVsdGFRLncgKiBkZWx0YVEudyk7XG5cbiAgICAgICAgdmFyIGRlbHRhT21lZ2EgPSBYWVouY29weShkZWx0YVEpLnNjYWxlKDIgKiBoYWxmdGhldGEgLyBsZW5ndGgpO1xuXG4gICAgICAgIGRlbHRhT21lZ2Euc2NhbGUoc3RpZmZuZXNzKTtcblxuICAgICAgICBpZiAoaW52U291cmNlSW5lcnRpYSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgTWF0MzMuYWRkKGludlNvdXJjZUluZXJ0aWEsIHRhcmdldC5pbnZlcnNlSW5lcnRpYSwgZWZmSW5lcnRpYSkuaW52ZXJzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTWF0MzMuaW52ZXJzZSh0YXJnZXQuaW52ZXJzZUluZXJ0aWEsIGVmZkluZXJ0aWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhbXBpbmcgIT09IDApIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBkZWx0YU9tZWdhLmFkZChWZWMzLnN1YnRyYWN0KHRhcmdldC5hbmd1bGFyVmVsb2NpdHksIHNvdXJjZS5hbmd1bGFyVmVsb2NpdHksIGRhbXBpbmdUb3JxdWUpLnNjYWxlKC1kYW1waW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWx0YU9tZWdhLmFkZChWZWMzLnNjYWxlKHRhcmdldC5hbmd1bGFyVmVsb2NpdHksIC1kYW1waW5nLCBkYW1waW5nVG9ycXVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9ycXVlID0gZGVsdGFPbWVnYS5hcHBseU1hdHJpeChlZmZJbmVydGlhKTtcbiAgICAgICAgdmFyIG1hZ25pdHVkZSA9IHRvcnF1ZS5sZW5ndGgoKTtcblxuICAgICAgICBpZiAobWFnbml0dWRlID4gbWF4KSB0b3JxdWUuc2NhbGUobWF4L21hZ25pdHVkZSk7XG5cbiAgICAgICAgdGFyZ2V0LmFwcGx5VG9ycXVlKHRvcnF1ZSk7XG4gICAgICAgIGlmIChzb3VyY2UpIHNvdXJjZS5hcHBseVRvcnF1ZSh0b3JxdWUuaW52ZXJ0KCkpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUm90YXRpb25hbFNwcmluZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZvcmNlID0gcmVxdWlyZSgnLi9Gb3JjZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG5cbnZhciBGT1JDRV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgREFNUElOR19SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQSBmb3JjZSB0aGF0IGFjY2VsZXJhdGVzIGEgUGFydGljbGUgdG93YXJkcyBhIHNwZWNpZmljIGFuY2hvciBwb2ludC4gQ2FuIGJlIGFuY2hvcmVkIHRvXG4gKiBhIFZlYzMgb3IgYW5vdGhlciBzb3VyY2UgUGFydGljbGUuXG4gKlxuICogIEBjbGFzcyBTcHJpbmdcbiAqICBAZXh0ZW5kcyBGb3JjZVxuICogIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgdG8gc2V0IG9uIGRyYWdcbiAqL1xuZnVuY3Rpb24gU3ByaW5nKHNvdXJjZSwgdGFyZ2V0cywgb3B0aW9ucykge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlIHx8IG51bGw7XG4gICAgRm9yY2UuY2FsbCh0aGlzLCB0YXJnZXRzLCBvcHRpb25zKTtcbn1cblxuU3ByaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRm9yY2UucHJvdG90eXBlKTtcblNwcmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcHJpbmc7XG5cbi8qKiBAY29uc3QgKi9cbnZhciBQSSA9IE1hdGguUEk7XG5cbi8qKlxuICogQSBGRU5FIChGaW5pdGVseSBFeHRlbnNpYmxlIE5vbmxpbmVhciBFbGFzdGljKSBzcHJpbmcgZm9yY2VcbiAqICAgICAgc2VlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZFTkVcbiAqIEBhdHRyaWJ1dGUgRkVORVxuICogQHR5cGUgRnVuY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0IGN1cnJlbnQgZGlzdGFuY2UgdGFyZ2V0IGlzIGZyb20gc291cmNlIGJvZHlcbiAqIEBwYXJhbSB7TnVtYmVyfSByTWF4IG1heGltdW0gcmFuZ2Ugb2YgaW5mbHVlbmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHVuc2NhbGVkIGZvcmNlXG4gKi9cblNwcmluZy5GRU5FID0gZnVuY3Rpb24oZGlzdCwgck1heCkge1xuICAgIHZhciByTWF4U21hbGwgPSByTWF4ICogMC45OTtcbiAgICB2YXIgciA9IE1hdGgubWF4KE1hdGgubWluKGRpc3QsIHJNYXhTbWFsbCksIC1yTWF4U21hbGwpO1xuICAgIHJldHVybiByIC8gKDEgLSByICogci8ock1heCAqIHJNYXgpKTtcbn07XG5cbi8qKlxuICogQSBIb29rZWFuIHNwcmluZyBmb3JjZSwgbGluZWFyIGluIHRoZSBkaXNwbGFjZW1lbnRcbiAqICAgICAgc2VlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hvb2tlJ3NfbGF3XG4gKiBAYXR0cmlidXRlIEhPT0tFXG4gKiBAdHlwZSBGdW5jdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGRpc3QgY3VycmVudCBkaXN0YW5jZSB0YXJnZXQgaXMgZnJvbSBzb3VyY2UgYm9keVxuICogQHJldHVybiB7TnVtYmVyfSB1bnNjYWxlZCBmb3JjZVxuICovXG5TcHJpbmcuSE9PS0UgPSBmdW5jdGlvbihkaXN0KSB7XG4gICAgcmV0dXJuIGRpc3Q7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIEZvcmNlLiBTZXRzIGRlZmF1bHRzIGlmIGEgcHJvcGVydHkgd2FzIG5vdCBhbHJlYWR5IHNldC5cbiAqXG4gKiBAbWV0aG9kIGluaXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGhhc2guXG4gKi9cblNwcmluZy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLm1heCA9IHRoaXMubWF4IHx8IEluZmluaXR5O1xuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICB0aGlzLnR5cGUgPSB0aGlzLnR5cGUgfHwgU3ByaW5nLkhPT0tFO1xuICAgIHRoaXMubWF4TGVuZ3RoID0gdGhpcy5tYXhMZW5ndGggfHwgSW5maW5pdHk7XG4gICAgaWYgKG9wdGlvbnMuc3RpZmZuZXNzIHx8IG9wdGlvbnMuZGFtcGluZykge1xuICAgICAgICB0aGlzLnN0aWZmbmVzcyA9IHRoaXMuc3RpZmZuZXNzIHx8IDEwMDtcbiAgICAgICAgdGhpcy5kYW1waW5nID0gdGhpcy5kYW1waW5nIHx8IDA7XG4gICAgICAgIHRoaXMucGVyaW9kID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYW1waW5nUmF0aW8gPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLnBlcmlvZCB8fCBvcHRpb25zLmRhbXBpbmdSYXRpbykge1xuICAgICAgICB0aGlzLnBlcmlvZCA9IHRoaXMucGVyaW9kIHx8IDE7XG4gICAgICAgIHRoaXMuZGFtcGluZ1JhdGlvID0gdGhpcy5kYW1waW5nUmF0aW8gfHwgMDtcblxuICAgICAgICB0aGlzLnN0aWZmbmVzcyA9IDIgKiBQSSAvIHRoaXMucGVyaW9kO1xuICAgICAgICB0aGlzLnN0aWZmbmVzcyAqPSB0aGlzLnN0aWZmbmVzcztcbiAgICAgICAgdGhpcy5kYW1waW5nID0gNCAqIFBJICogdGhpcy5kYW1waW5nUmF0aW8gLyB0aGlzLnBlcmlvZDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFwcGx5IHRoZSBmb3JjZS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5TcHJpbmcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcblxuICAgIHZhciBmb3JjZSA9IEZPUkNFX1JFR0lTVEVSO1xuICAgIHZhciBkYW1waW5nRm9yY2UgPSBEQU1QSU5HX1JFR0lTVEVSO1xuXG4gICAgdmFyIG1heCA9IHRoaXMubWF4O1xuICAgIHZhciBzdGlmZm5lc3MgPSB0aGlzLnN0aWZmbmVzcztcbiAgICB2YXIgZGFtcGluZyA9IHRoaXMuZGFtcGluZztcbiAgICB2YXIgcmVzdExlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHZhciBtYXhMZW5ndGggPSB0aGlzLm1heExlbmd0aDtcbiAgICB2YXIgYW5jaG9yID0gdGhpcy5hbmNob3IgfHwgc291cmNlLnBvc2l0aW9uO1xuICAgIHZhciBpbnZTb3VyY2VNYXNzID0gdGhpcy5hbmNob3IgPyAwIDogc291cmNlLmludmVyc2VNYXNzO1xuICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgIFZlYzMuc3VidHJhY3QoYW5jaG9yLCB0YXJnZXQucG9zaXRpb24sIGZvcmNlKTtcbiAgICAgICAgdmFyIGRpc3QgPSBmb3JjZS5sZW5ndGgoKTtcbiAgICAgICAgdmFyIHN0cmV0Y2ggPSBkaXN0IC0gcmVzdExlbmd0aDtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoc3RyZXRjaCkgPCAxZS02KSBjb250aW51ZTtcblxuICAgICAgICB2YXIgZWZmTWFzcyA9IDEgLyAodGFyZ2V0LmludmVyc2VNYXNzICsgaW52U291cmNlTWFzcyk7XG4gICAgICAgIGlmICh0aGlzLnBlcmlvZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RpZmZuZXNzICo9IGVmZk1hc3M7XG4gICAgICAgICAgICBkYW1waW5nICo9IGVmZk1hc3M7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JjZS5zY2FsZShzdGlmZm5lc3MgKiB0eXBlKHN0cmV0Y2gsIG1heExlbmd0aCkgLyBzdHJldGNoKTtcblxuICAgICAgICBpZiAoZGFtcGluZyAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGZvcmNlLmFkZChWZWMzLnN1YnRyYWN0KHRhcmdldC52ZWxvY2l0eSwgc291cmNlLnZlbG9jaXR5LCBkYW1waW5nRm9yY2UpLnNjYWxlKC1kYW1waW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JjZS5hZGQoVmVjMy5zY2FsZSh0YXJnZXQudmVsb2NpdHksIC1kYW1waW5nLCBkYW1waW5nRm9yY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYWduaXR1ZGUgPSBmb3JjZS5sZW5ndGgoKTtcbiAgICAgICAgdmFyIGludk1hZyA9IG1hZ25pdHVkZSA/IDEgLyBtYWduaXR1ZGUgOiAwO1xuXG4gICAgICAgIFZlYzMuc2NhbGUoZm9yY2UsIChtYWduaXR1ZGUgPiBtYXggPyBtYXggOiBtYWduaXR1ZGUpICogaW52TWFnLCBmb3JjZSk7XG5cbiAgICAgICAgdGFyZ2V0LmFwcGx5Rm9yY2UoZm9yY2UpO1xuICAgICAgICBpZiAoc291cmNlKSBzb3VyY2UuYXBwbHlGb3JjZShmb3JjZS5pbnZlcnQoKSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFBhcnRpY2xlOiByZXF1aXJlKCcuL2JvZGllcy9QYXJ0aWNsZScpLFxuICAgIENvbnZleEJvZHlGYWN0b3J5OiByZXF1aXJlKCcuL2JvZGllcy9Db252ZXhCb2R5RmFjdG9yeScpLFxuICAgIEJveDogcmVxdWlyZSgnLi9ib2RpZXMvQm94JyksXG4gICAgU3BoZXJlOiByZXF1aXJlKCcuL2JvZGllcy9TcGhlcmUnKSxcbiAgICBXYWxsOiByZXF1aXJlKCcuL2JvZGllcy9XYWxsJyksXG5cbiAgICBDb25zdHJhaW50OiByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKSxcbiAgICBBbmdsZTogcmVxdWlyZSgnLi9jb25zdHJhaW50cy9BbmdsZScpLFxuICAgIENvbGxpc2lvbjogcmVxdWlyZSgnLi9jb25zdHJhaW50cy9Db2xsaXNpb24nKSxcbiAgICBEaXJlY3Rpb246IHJlcXVpcmUoJy4vY29uc3RyYWludHMvRGlyZWN0aW9uJyksXG4gICAgRGlzdGFuY2U6IHJlcXVpcmUoJy4vY29uc3RyYWludHMvRGlzdGFuY2UnKSxcbiAgICBDdXJ2ZTogcmVxdWlyZSgnLi9jb25zdHJhaW50cy9DdXJ2ZScpLFxuICAgIEhpbmdlOiByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0hpbmdlJyksXG4gICAgUG9pbnQyUG9pbnQ6IHJlcXVpcmUoJy4vY29uc3RyYWludHMvUG9pbnQyUG9pbnQnKSxcblxuICAgIEZvcmNlOiByZXF1aXJlKCcuL2ZvcmNlcy9Gb3JjZScpLFxuICAgIERyYWc6IHJlcXVpcmUoJy4vZm9yY2VzL0RyYWcnKSxcbiAgICBSb3RhdGlvbmFsRHJhZzogcmVxdWlyZSgnLi9mb3JjZXMvUm90YXRpb25hbERyYWcnKSxcbiAgICBHcmF2aXR5MUQ6IHJlcXVpcmUoJy4vZm9yY2VzL0dyYXZpdHkxRCcpLFxuICAgIEdyYXZpdHkzRDogcmVxdWlyZSgnLi9mb3JjZXMvR3Jhdml0eTNEJyksXG4gICAgU3ByaW5nOiByZXF1aXJlKCcuL2ZvcmNlcy9TcHJpbmcnKSxcbiAgICBSb3RhdGlvbmFsU3ByaW5nOiByZXF1aXJlKCcuL2ZvcmNlcy9Sb3RhdGlvbmFsU3ByaW5nJyksXG5cbiAgICBQaHlzaWNzRW5naW5lOiByZXF1aXJlKCcuL1BoeXNpY3NFbmdpbmUnKSxcbiAgICBHZW9tZXRyeTogcmVxdWlyZSgnLi9HZW9tZXRyeScpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRWxlbWVudENhY2hlID0gcmVxdWlyZSgnLi9FbGVtZW50Q2FjaGUnKTtcblxuLy8gYW4gZW51bWVyYXRpb24gb2YgcG90ZW50aWFsIHZlbmRvciBwcmVmaXhlcy5cbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICctbXMtJywgJy13ZWJraXQtJywgJy1tb3otJywgJy1vLSddO1xuXG4vKipcbiAqIEEgcHJpdmF0ZSBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgaWYgYSBjc3MgcHJvcGVydHlcbiAqIGhhcyBhIHZlbmRvciBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIHZlbmRvclByZWZpeChwcm9wZXJ0eSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcmVmaXhlZCA9IFZFTkRPUl9QUkVGSVhFU1tpXSArIHByb3BlcnR5O1xuICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3ByZWZpeGVkXSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXhlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydHk7XG59XG5cbi8vIHRoZSBwcmVmaXhlZCB0cmFuc2Zvcm0gcHJvcGVydHkuXG52YXIgVFJBTlNGT1JNID0gdmVuZG9yUHJlZml4KCd0cmFuc2Zvcm0nKTtcblxuLyoqXG4gKiBET01SZW5kZXJlciBpcyBhIGNsYXNzIHJlc3BvbnNpYmxlIGZvciBhZGRpbmcgZWxlbWVudHNcbiAqIHRvIHRoZSBET00gYW5kIHdyaXRpbmcgdG8gdGhvc2UgZWxlbWVudHMuXG4gKiB0aGVyZSBpcyBhIERPTVJlbmRlcmVyIHBlciBjb250ZXh0LCByZXByZXNlbnRlZCBhcyBhblxuICogZWxlbWVudCBhbmQgYSBzZWxlY3Rvci4gSXQgaXMgaW5zdGFudGlhdGVkIGluIHRoZSBcbiAqIGNvbnRleHQgY2xhc3MuXG4gKlxuICogQGNsYXNzIERPTVJlbmRlcmVyXG4gKiBcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGhlIHNlbGVjdG9yIG9mIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtDb21wb3NpdG9yfVxuICovXG5mdW5jdGlvbiBET01SZW5kZXJlciAoZWxlbWVudCwgc2VsZWN0b3IsIGNvbXBvc2l0b3IpIHtcbiAgICB0aGlzLl9jb21wb3NpdG9yID0gY29tcG9zaXRvcjsgLy8gYSByZWZlcmVuY2UgdG8gdGhlIGNvbXBvc2l0b3JcblxuICAgIHRoaXMuX3RhcmdldCA9IG51bGw7IC8vIGEgcmVnaXN0ZXIgZm9yIGhvbGRpbmcgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHRoYXQgdGhlIFJlbmRlcmVyIGlzIG9wZXJhdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwb25cblxuICAgIHRoaXMuX3BhcmVudCA9IG51bGw7IC8vIGEgcmVnaXN0ZXIgZm9yIGhvbGRpbmcgdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSB0YXJnZXRcblxuICAgIHRoaXMuX3BhdGggPSBudWxsOyAvLyBhIHJlZ2lzdGVyIGZvciBob2xkaW5nIHRoZSBwYXRoIG9mIHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZWdpc3RlciBtdXN0IGJlIHNldCBmaXJzdCwgYW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hpbGRyZW4sIHRhcmdldCwgYW5kIHBhcmVudCBhcmUgYWxsIGxvb2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAvLyB1cCBmcm9tIHRoYXQuXG5cbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdOyAvLyBhIHJlZ2lzdGVyIGZvciBob2xkaW5nIHRoZSBjaGlsZHJlbiBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHRhcmdldC5cblxuICAgIHRoaXMuX3Jvb3QgPSBuZXcgRWxlbWVudENhY2hlKGVsZW1lbnQsIHNlbGVjdG9yKTsgLy8gdGhlIHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBkb20gdHJlZSB0aGF0IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlcmVyIGlzIHJlc3BvbnNpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3JcblxuICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgXG4gICAgdGhpcy5fZWxlbWVudHMgPSB7fTtcblxuICAgIHRoaXMuX2VsZW1lbnRzW3NlbGVjdG9yXSA9IHRoaXMuX3Jvb3Q7XG5cbiAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pO1xuICAgIHRoaXMuX1ZQdHJhbnNmb3JtID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pO1xuXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcbn1cblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHBhdGgsIHR5cGUsIHByb3BlcnRpZXMsIHByZXZlbnREZWZhdWx0KSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudExpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVyc1t0eXBlXSA9IHt9O1xuICAgICAgICB0aGlzLl9yb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLl90cmlnZ2VyRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbdHlwZV1bcGF0aF0gPSB7XG4gICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBwcmV2ZW50RGVmYXVsdFxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBfbWlycm9yKGl0ZW0sIHRhcmdldCwgcmVmZXJlbmNlKSB7XG4gICAgdmFyIGksIGxlbjtcbiAgICB2YXIga2V5LCBrZXlzO1xuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGl0ZW0gPT09ICdudW1iZXInKSB0YXJnZXRbaXRlbV0gPSByZWZlcmVuY2VbaXRlbV07XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBfbWlycm9yKGl0ZW1baV0sIHRhcmdldCwgcmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGl0ZW0pO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICBfbWlycm9yKGl0ZW1ba2V5XSwgdGFyZ2V0W2tleV0sIHJlZmVyZW5jZVtrZXldKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfbWFrZVRhcmdldCAoZXYpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHRhZ05hbWU6IHRhcmdldC50YWdOYW1lLFxuICAgICAgICBpZDogdGFyZ2V0LmdldEF0dHJpYnV0ZSgnaWQnKSxcbiAgICAgICAgY2xhc3NlczogW11cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0YXJnZXQuY2xhc3NMaXN0Lmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIHJlc3VsdC5jbGFzc2VzW2ldID0gdGFyZ2V0LmNsYXNzTGlzdFtpXTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBfc3RyaXBFdmVudCAoZXYsIHByb3BlcnRpZXMsIHBhdGgpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICB0YXJnZXQ6IF9tYWtlVGFyZ2V0KGV2KSxcbiAgICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gICAgdmFyIGksIGxlbjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm9wZXJ0aWVzID8gcHJvcGVydGllcy5sZW5ndGggOiAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICBfbWlycm9yKHByb3AsIHJlc3VsdCwgZXYpO1xuICAgIH1cbiAgICByZXN1bHQudGltZVN0YW1wID0gZXYudGltZVN0YW1wO1xuICAgIHJlc3VsdC50aW1lID0gZXYudGltZVN0YW1wO1xuICAgIHN3aXRjaCAoZXYudHlwZSkge1xuICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgICAgcmVzdWx0LnggPSBldi54O1xuICAgICAgICAgICAgcmVzdWx0LnkgPSBldi55O1xuICAgICAgICAgICAgcmVzdWx0LnRpbWVTdGFtcCA9IGV2LnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHJlc3VsdC5wYWdlWCA9IGV2LnBhZ2VYO1xuICAgICAgICAgICAgcmVzdWx0LnBhZ2VZID0gZXYucGFnZVk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnd2hlZWwnOlxuICAgICAgICAgICAgcmVzdWx0LmRlbHRhWCA9IGV2LmRlbHRhWDtcbiAgICAgICAgICAgIHJlc3VsdC5kZWx0YVkgPSBldi5kZWx0YVk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgICAgIGNhc2UgJ3RvdWNoZW5kJzpcbiAgICAgICAgICAgcmVzdWx0LnRhcmdldFRvdWNoZXMgPSBbXTtcbiAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZXYudGFyZ2V0VG91Y2hlcy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgICAgIHJlc3VsdC50YXJnZXRUb3VjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBldi50YXJnZXRUb3VjaGVzW2ldLnBhZ2VYLFxuICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBldi50YXJnZXRUb3VjaGVzW2ldLnBhZ2VZLFxuICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGV2LnRhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllclxuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLl90cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiBfdHJpZ2dlckV2ZW50KGV2KSB7XG4gICAgdmFyIGV2UGF0aCA9IGV2LnBhdGggPyBldi5wYXRoIDogX2dldFBhdGgoZXYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghZXZQYXRoW2ldLmRhdGFzZXQpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgcGF0aCA9IGV2UGF0aFtpXS5kYXRhc2V0LmZhUGF0aDtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2LnR5cGVdW3BhdGhdKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wb3NpdG9yLnNlbmRFdmVudChwYXRoLCBldi50eXBlLCBfc3RyaXBFdmVudChldiwgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXYudHlwZV1bcGF0aF0ucHJvcGVydGllcywgcGF0aCkpO1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXYudHlwZV1bcGF0aF0ucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiBfZ2V0UGF0aCAoZXYpIHtcbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIHZhciBub2RlID0gZXYudGFyZ2V0O1xuICAgIHdoaWxlIChub2RlICE9IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiBnZXRTaXplICgpIHtcbiAgICByZXR1cm4gW3RoaXMuX3Jvb3QuZWxlbWVudC5vZmZzZXRXaWR0aCwgdGhpcy5fcm9vdC5lbGVtZW50Lm9mZnNldEhlaWdodF07XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuX2dldFNpemUgPSBET01SZW5kZXJlci5wcm90b3R5cGUuZ2V0U2l6ZTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiBkcmF3IChyZW5kZXJTdGF0ZSkge1xuICAgIGlmIChyZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5KSB7XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVEaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVswXSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzBdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzFdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMV07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMl0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsyXTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVszXSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzNdO1xuXG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bNF0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs0XTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs1XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzVdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzZdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bNl07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bN10gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs3XTtcblxuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzhdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bOF07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bOV0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs5XTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMF0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMF07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTFdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTFdO1xuXG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTJdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTJdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzEzXSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzEzXTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxNF0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxNF07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTVdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTVdO1xuICAgIH1cblxuICAgIGlmIChyZW5kZXJTdGF0ZS52aWV3RGlydHkgfHwgcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVEaXJ0eSkge1xuICAgICAgICBtdWx0aXBseSh0aGlzLl9WUHRyYW5zZm9ybSwgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybSwgcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMuX3Jvb3QuZWxlbWVudC5zdHlsZVtUUkFOU0ZPUk1dID0gc3RyaW5naWZ5TWF0cml4KHRoaXMuX1ZQdHJhbnNmb3JtKTtcbiAgICB9XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuX2Fzc2VydFBhdGhMb2FkZWQgPSBmdW5jdGlvbiBfYXNzZXJQYXRoTG9hZGVkICgpIHtcbiAgICBpZiAoIXRoaXMuX3BhdGgpIHRocm93IG5ldyBFcnJvcigncGF0aCBub3QgbG9hZGVkJyk7XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuX2Fzc2VydFBhcmVudExvYWRlZCA9IGZ1bmN0aW9uIF9hc3NlcnRQYXJlbnRMb2FkZWQgKCkge1xuICAgIGlmICghdGhpcy5fcGFyZW50KSB0aHJvdyBuZXcgRXJyb3IoJ3BhcmVudCBub3QgbG9hZGVkJyk7XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuX2Fzc2VydENoaWxkcmVuTG9hZGVkID0gZnVuY3Rpb24gX2Fzc2VydENoaWxkcmVuTG9hZGVkICgpIHtcbiAgICBpZiAoIXRoaXMuX2NoaWxkcmVuKSB0aHJvdyBuZXcgRXJyb3IoJ2NoaWxkcmVuIG5vdCBsb2FkZWQnKTtcbn07XG5cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5maW5kUGFyZW50ID0gZnVuY3Rpb24gZmluZFBhcmVudCAoKSB7XG4gICAgdGhpcy5fYXNzZXJ0UGF0aExvYWRlZCgpO1xuXG4gICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhciBwYXJlbnQ7XG5cbiAgICB3aGlsZSAoIXBhcmVudCAmJiBwYXRoLmxlbmd0aCkge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgcGFyZW50ID0gdGhpcy5fZWxlbWVudHNbcGF0aF07XG4gICAgfVxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICByZXR1cm4gcGFyZW50O1xufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLmZpbmRDaGlsZHJlbiA9IGZ1bmN0aW9uIGZpbmRDaGlsZHJlbiAoYXJyYXkpIHtcbiAgICB0aGlzLl9hc3NlcnRQYXRoTG9hZGVkKCk7XG4gICAgXG4gICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5fZWxlbWVudHMpO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuO1xuICAgIGFycmF5ID0gYXJyYXkgPyBhcnJheSA6IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGtleXNbaV0uaW5kZXhPZihwYXRoKSA9PT0gLTEgfHwga2V5c1tpXSA9PT0gcGF0aCkga2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGVsc2UgaSsrO1xuICAgIH1cbiAgICB2YXIgY3VycmVudFBhdGg7XG4gICAgdmFyIGogPSAwO1xuICAgIGZvciAoaSA9IDAgOyBpIDwga2V5cy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgY3VycmVudFBhdGggPSBrZXlzW2ldO1xuICAgICAgICBmb3IgKGogPSAwIDsgaiA8IGtleXMubGVuZ3RoIDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gaiAmJiBrZXlzW2pdLmluZGV4T2YoY3VycmVudFBhdGgpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGtleXMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIGFycmF5W2ldID0gdGhpcy5fZWxlbWVudHNba2V5c1tpXV07XG5cbiAgICByZXR1cm4gYXJyYXk7XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuZmluZFRhcmdldCA9IGZ1bmN0aW9uIGZpbmRUYXJnZXQgKCkge1xuICAgIHRoaXMuX3RhcmdldCA9IHRoaXMuX2VsZW1lbnRzW3RoaXMuX3BhdGhdO1xuICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUubG9hZFBhdGggPSBmdW5jdGlvbiBsb2FkUGF0aCAocGF0aCkge1xuICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgIHJldHVybiB0aGlzLl9wYXRoO1xufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLmluc2VydEVsID0gZnVuY3Rpb24gaW5zZXJ0RWwgKHRhZ05hbWUpIHtcbiAgICBpZiAoIXRoaXMuX3RhcmdldCB8fFxuICAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZmluZFBhcmVudCgpO1xuICAgICAgICB0aGlzLmZpbmRDaGlsZHJlbigpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fYXNzZXJ0UGFyZW50TG9hZGVkKCk7XG4gICAgICAgIHRoaXMuX2Fzc2VydENoaWxkcmVuTG9hZGVkKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldCkgdGhpcy5fcGFyZW50LmVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5fdGFyZ2V0LmVsZW1lbnQpO1xuIFxuICAgICAgICB0aGlzLl90YXJnZXQgPSBuZXcgRWxlbWVudENhY2hlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSksIHRoaXMuX3BhdGgpO1xuICAgICAgICB0aGlzLl9wYXJlbnQuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl90YXJnZXQuZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzW3RoaXMuX3BhdGhdID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2NoaWxkcmVuW2ldLmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLl9hc3NlcnRUYXJnZXRMb2FkZWQgPSBmdW5jdGlvbiBfYXNzZXJ0VGFyZ2V0TG9hZGVkICgpIHtcbiAgICBpZiAoIXRoaXMuX3RhcmdldCkgdGhyb3cgbmV3IEVycm9yKCdObyB0YXJnZXQgbG9hZGVkJyk7XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eSAobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLl9hc3NlcnRUYXJnZXRMb2FkZWQoKTtcbiAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5zdHlsZVtuYW1lXSA9IHZhbHVlO1xufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiBzZXRTaXplICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuc3R5bGUud2lkdGggPSAod2lkdGggPT09IHRydWUpID8gJycgOiB3aWR0aCArICdweCc7XG4gICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKGhlaWdodCA9PT0gdHJ1ZSkgPyAnJyA6IGhlaWdodCArICdweCc7XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlIChuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuX2Fzc2VydFRhcmdldExvYWRlZCgpO1xuICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIHNldENvbnRlbnQgKGNvbnRlbnQpIHtcbiAgICB0aGlzLl9hc3NlcnRUYXJnZXRMb2FkZWQoKTtcbiAgICB0aGlzLmZpbmRDaGlsZHJlbih0aGlzLl9wYXRoKTtcblxuICAgIC8vIFRlbXBvcmFyeSBzb2x1dGlvblxuICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA7IGkrKykge1xuICAgICAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9jaGlsZHJlbltpXS5lbGVtZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5pbm5lckhUTUwgPSBjb250ZW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIDsgaSsrKVxuICAgICAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9jaGlsZHJlbltpXS5lbGVtZW50KTtcbn07XG5cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5zZXRNYXRyaXggPSBmdW5jdGlvbiBzZXRNYXRyaXggKHRyYW5zZm9ybSkgeyBcbiAgICB0aGlzLl9hc3NlcnRUYXJnZXRMb2FkZWQoKTtcbiAgICB0aGlzLmZpbmRQYXJlbnQoKTtcbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSB0aGlzLl90YXJnZXQud29ybGRUcmFuc2Zvcm07XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZVxuXG4gICAgaWYgKHRyYW5zZm9ybSlcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IDE2IDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgPyBjaGFuZ2VkIDogd29ybGRUcmFuc2Zvcm1baV0gPT09IHRyYW5zZm9ybVtpXTtcbiAgICAgICAgICAgIHdvcmxkVHJhbnNmb3JtW2ldID0gdHJhbnNmb3JtW2ldO1xuICAgICAgICB9XG4gICAgZWxzZSBjaGFuZ2VkID0gdHJ1ZTtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIGludmVydCh0aGlzLl90YXJnZXQuaW52ZXJ0ZWRQYXJlbnQsIHRoaXMuX3BhcmVudC53b3JsZFRyYW5zZm9ybSk7XG4gICAgICAgIG11bHRpcGx5KHRoaXMuX3RhcmdldC5maW5hbFRyYW5zZm9ybSwgdGhpcy5fdGFyZ2V0LmludmVydGVkUGFyZW50LCB3b3JsZFRyYW5zZm9ybSk7XG5cbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyBhIHRlbXBvcmFyeSBmaXggZm9yIGRyYXcgY29tbWFuZHNcbiAgICAgICAgLy8gY29taW5nIGluIG91dCBvZiBvcmRlclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmZpbmRDaGlsZHJlbihbXSk7XG4gICAgICAgIHZhciBwcmV2aW91c1BhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgICB2YXIgcHJldmlvdXNUYXJnZXQgPSB0aGlzLl90YXJnZXQ7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgdGhpcy5fcGF0aCA9IHRoaXMuX3RhcmdldC5wYXRoO1xuICAgICAgICAgICAgdGhpcy5zZXRNYXRyaXgoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXRoID0gcHJldmlvdXNQYXRoO1xuICAgICAgICB0aGlzLl90YXJnZXQgPSBwcmV2aW91c1RhcmdldDtcbiAgICB9XG5cbiAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5zdHlsZVtUUkFOU0ZPUk1dID0gc3RyaW5naWZ5TWF0cml4KHRoaXMuX3RhcmdldC5maW5hbFRyYW5zZm9ybSk7XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyAoZG9tQ2xhc3MpIHtcbiAgICB0aGlzLl9hc3NlcnRUYXJnZXRMb2FkZWQoKTtcbiAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5jbGFzc0xpc3QuYWRkKGRvbUNsYXNzKTtcbn07XG5cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzIChkb21DbGFzcykge1xuICAgIHRoaXMuX2Fzc2VydFRhcmdldExvYWRlZCgpO1xuICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoZG9tQ2xhc3MpO1xufTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5TWF0cml4KG0pIHtcbiAgICB2YXIgciA9ICdtYXRyaXgzZCgnO1xuXG4gICAgciArPSAobVswXSA8IDAuMDAwMDAxICYmIG1bMF0gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bMF0gKyAnLCc7XG4gICAgciArPSAobVsxXSA8IDAuMDAwMDAxICYmIG1bMV0gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bMV0gKyAnLCc7XG4gICAgciArPSAobVsyXSA8IDAuMDAwMDAxICYmIG1bMl0gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bMl0gKyAnLCc7XG4gICAgciArPSAobVszXSA8IDAuMDAwMDAxICYmIG1bM10gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bM10gKyAnLCc7XG4gICAgciArPSAobVs0XSA8IDAuMDAwMDAxICYmIG1bNF0gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bNF0gKyAnLCc7XG4gICAgciArPSAobVs1XSA8IDAuMDAwMDAxICYmIG1bNV0gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bNV0gKyAnLCc7XG4gICAgciArPSAobVs2XSA8IDAuMDAwMDAxICYmIG1bNl0gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bNl0gKyAnLCc7XG4gICAgciArPSAobVs3XSA8IDAuMDAwMDAxICYmIG1bN10gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bN10gKyAnLCc7XG4gICAgciArPSAobVs4XSA8IDAuMDAwMDAxICYmIG1bOF0gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bOF0gKyAnLCc7XG4gICAgciArPSAobVs5XSA8IDAuMDAwMDAxICYmIG1bOV0gPiAtMC4wMDAwMDEpID8gJzAsJyA6IG1bOV0gKyAnLCc7XG4gICAgciArPSAobVsxMF0gPCAwLjAwMDAwMSAmJiBtWzEwXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVsxMF0gKyAnLCc7XG4gICAgciArPSAobVsxMV0gPCAwLjAwMDAwMSAmJiBtWzExXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVsxMV0gKyAnLCc7XG4gICAgciArPSAobVsxMl0gPCAwLjAwMDAwMSAmJiBtWzEyXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVsxMl0gKyAnLCc7XG4gICAgciArPSAobVsxM10gPCAwLjAwMDAwMSAmJiBtWzEzXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVsxM10gKyAnLCc7XG4gICAgciArPSAobVsxNF0gPCAwLjAwMDAwMSAmJiBtWzE0XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVsxNF0gKyAnLCc7XG5cbiAgICByICs9IG1bMTVdICsgJyknO1xuICAgIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBpbnZlcnQgKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBtdWx0aXBseSAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLFxuICAgICAgICBiNCA9IGJbNF0sIGI1ID0gYls1XSwgYjYgPSBiWzZdLCBiNyA9IGJbN10sXG4gICAgICAgIGI4ID0gYls4XSwgYjkgPSBiWzldLCBiMTAgPSBiWzEwXSwgYjExID0gYlsxMV0sXG4gICAgICAgIGIxMiA9IGJbMTJdLCBiMTMgPSBiWzEzXSwgYjE0ID0gYlsxNF0sIGIxNSA9IGJbMTVdO1xuXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgb3V0MCwgb3V0MSwgb3V0Miwgb3V0MztcblxuICAgIG91dDAgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0MSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXQyID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dDMgPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/XG4gICAgICAgICAgICAgIGNoYW5nZWQgOiBvdXQwID09IG91dFswXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MSA9PSBvdXRbMV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDIgPT0gb3V0WzJdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQzID09IG91dFszXTtcblxuICAgIG91dFswXSA9IG91dDA7XG4gICAgb3V0WzFdID0gb3V0MTtcbiAgICBvdXRbMl0gPSBvdXQyO1xuICAgIG91dFszXSA9IG91dDM7XG5cbiAgICBiMCA9IGI0OyBiMSA9IGI1OyBiMiA9IGI2OyBiMyA9IGI3O1xuICAgIG91dDAgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0MSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXQyID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dDMgPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/XG4gICAgICAgICAgICAgIGNoYW5nZWQgOiBvdXQwID09IG91dFs0XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MSA9PSBvdXRbNV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDIgPT0gb3V0WzZdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQzID09IG91dFs3XTtcblxuICAgIG91dFs0XSA9IG91dDA7XG4gICAgb3V0WzVdID0gb3V0MTtcbiAgICBvdXRbNl0gPSBvdXQyO1xuICAgIG91dFs3XSA9IG91dDM7XG5cbiAgICBiMCA9IGI4OyBiMSA9IGI5OyBiMiA9IGIxMDsgYjMgPSBiMTE7XG4gICAgb3V0MCA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXQxID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dDIgPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0MyA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGNoYW5nZWQgPSBjaGFuZ2VkID9cbiAgICAgICAgICAgICAgY2hhbmdlZCA6IG91dDAgPT0gb3V0WzhdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQxID09IG91dFs5XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MiA9PSBvdXRbMTBdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQzID09IG91dFsxMV07XG5cbiAgICBvdXRbOF0gPSBvdXQwO1xuICAgIG91dFs5XSA9IG91dDE7XG4gICAgb3V0WzEwXSA9IG91dDI7XG4gICAgb3V0WzExXSA9IG91dDM7XG5cbiAgICBiMCA9IGIxMjsgYjEgPSBiMTM7IGIyID0gYjE0OyBiMyA9IGIxNTtcbiAgICBvdXQwID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dDEgPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0MiA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXQzID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgP1xuICAgICAgICAgICAgICBjaGFuZ2VkIDogb3V0MCA9PSBvdXRbMTJdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQxID09IG91dFsxM10gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDIgPT0gb3V0WzE0XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MyA9PSBvdXRbMTVdO1xuXG4gICAgb3V0WzEyXSA9IG91dDA7XG4gICAgb3V0WzEzXSA9IG91dDE7XG4gICAgb3V0WzE0XSA9IG91dDI7XG4gICAgb3V0WzE1XSA9IG91dDM7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVJlbmRlcmVyO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudCA9IFtcbiAgICAxLCAwLCAwLCAwLFxuICAgIDAsIDEsIDAsIDAsXG4gICAgMCwgMCwgMSwgMCxcbiAgICAwLCAwLCAwLCAxXG5dO1xuXG5mdW5jdGlvbiBFbGVtZW50Q2FjaGUgKGVsZW1lbnQsIHBhdGgpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG5ldyBGbG9hdDMyQXJyYXkoaWRlbnQpO1xuICAgIHRoaXMuaW52ZXJ0ZWRQYXJlbnQgPSBuZXcgRmxvYXQzMkFycmF5KGlkZW50KTtcbiAgICB0aGlzLmZpbmFsVHJhbnNmb3JtID0gbmV3IEZsb2F0MzJBcnJheShpZGVudCk7XG4gICAgdGhpcy5wb3N0UmVuZGVyU2l6ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnRDYWNoZTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBET01SZW5kZXJlcjogcmVxdWlyZSgnLi9ET01SZW5kZXJlcicpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuL0dlb21ldHJ5Jyk7XG5cbi8qKlxuICogRHluYW1pY0dlb21ldHJ5IGlzIGEgY29tcG9uZW50IHRoYXQgZGVmaW5lcyB0aGUgZGF0YSB0aGF0IHNob3VsZFxuICogICBiZSBkcmF3biB0byB0aGUgd2ViR0wgY2FudmFzLiBNYW5hZ2VzIHZlcnRleCBkYXRhIGFuZCBhdHRyaWJ1dGVzLlxuICpcbiAqIEBjbGFzcyBEeW5hbWljR2VvbWV0cnlcbiAqIEBjb25zdHJ1Y3RvclxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBpbnN0YW50aWF0aW9uIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gRHluYW1pY0dlb21ldHJ5KG9wdGlvbnMpIHtcbiAgICBHZW9tZXRyeS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5zcGVjLmR5bmFtaWMgPSB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBhdHRyaWJ1dGUgdmFsdWVzIHVzZWQgdG8gZHJhdyB0aGUgRHluYW1pY0dlb21ldHJ5LlxuICpcbiAqIEBjbGFzcyBEeW5hbWljR2VvbWV0cnlcbiAqIEBjb25zdHJ1Y3RvclxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9IGZsYXR0ZW5lZCBsZW5ndGggb2YgdGhlIHZlcnRleCBwb3NpdGlvbnMgYXR0cmlidXRlXG4gKiBpbiB0aGUgZ2VvbWV0cnkuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmdldFZlcnRleFBvc2l0aW9ucygpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgYnVmZmVyIG9iamVjdCBiYXNlZCBvbiBidWZmZXIgbmFtZS4gVGhyb3dzIGVycm9yXG4gKiBpZiBidWZmZXJOYW1lIGlzIG5vdCBwcm92aWRlZC5cbiAqXG4gKiBAbWV0aG9kIGdldFZlcnRleEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBidWZmZXJOYW1lIE5hbWUgb2YgdmVydGV4QnVmZmVyIHRvIGJlIHJldHJpZXZlZC5cbiAqIEByZXR1cm4ge09iamVjdH0gdmFsdWUgb2YgYnVmZmVyIHdpdGggY29ycmVzcG9uZGluZyBidWZmZXJOYW1lLlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLmdldFZlcnRleEJ1ZmZlciA9IGZ1bmN0aW9uIGdldFZlcnRleEJ1ZmZlcihidWZmZXJOYW1lKSB7XG4gICAgaWYgKCEgYnVmZmVyTmFtZSkgdGhyb3cgJ2dldFZlcnRleEJ1ZmZlciByZXF1aXJlcyBhIG5hbWUnO1xuXG4gICAgdmFyIGlkeCA9IHRoaXMuc3BlYy5idWZmZXJOYW1lcy5pbmRleE9mKGJ1ZmZlck5hbWUpO1xuICAgIGlmIChpZHggPT09IC0xKSB0aHJvdyAnYnVmZmVyIGRvZXMgbm90IGV4aXN0JztcbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5idWZmZXJWYWx1ZXNbaWR4XTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldHMgYSB2ZXJ0ZXggYnVmZmVyIHdpdGggZ2l2ZW4gbmFtZSB0byBpbnB1dCB2YWx1ZS4gUmVnaXN0ZXJzIGEgbmV3IFxuICogYnVmZmVyIGlmIG9uZSBkb2VzIG5vdCBleGlzdCB3aXRoIGdpdmVuIG5hbWUuXG4gKiBcbiAqIEBtZXRob2Qgc2V0VmVydGV4QnVmZmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gYnVmZmVyTmFtZSBOYW1lIG9mIHZlcnRleEJ1ZmZlciB0byBiZSBzZXQuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBJbnB1dCBkYXRhIHRvIGZpbGwgdGFyZ2V0IGJ1ZmZlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIFZlY3RvciBzaXplIG9mIGlucHV0IGJ1ZmZlciBkYXRhLlxuICogQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IGdlb21ldHJ5LlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnNldFZlcnRleEJ1ZmZlciA9IGZ1bmN0aW9uIHNldFZlcnRleEJ1ZmZlcihidWZmZXJOYW1lLCB2YWx1ZSwgc2l6ZSkge1xuICAgIHZhciBpZHggPSB0aGlzLnNwZWMuYnVmZmVyTmFtZXMuaW5kZXhPZihidWZmZXJOYW1lKTtcblxuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgIGlkeCA9IHRoaXMuc3BlYy5idWZmZXJOYW1lcy5wdXNoKGJ1ZmZlck5hbWUpIC0gMTtcbiAgICB9XG5cbiAgICB0aGlzLnNwZWMuYnVmZmVyVmFsdWVzW2lkeF0gPSB2YWx1ZSB8fCBbXTtcbiAgICB0aGlzLnNwZWMuYnVmZmVyU3BhY2luZ3NbaWR4XSA9IHNpemUgfHwgdGhpcy5ERUZBVUxUX0JVRkZFUl9TSVpFO1xuXG4gICAgaWYgKHRoaXMuc3BlYy5pbnZhbGlkYXRpb25zLmluZGV4T2YoaWR4KSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5zcGVjLmludmFsaWRhdGlvbnMucHVzaChpZHgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb3BpZXMgYW5kIHNldHMgYWxsIGJ1ZmZlcnMgZnJvbSBhbm90aGVyIGdlb21ldHJ5IGluc3RhbmNlLlxuICpcbiAqIEBtZXRob2QgZnJvbUdlb21ldHJ5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGdlb21ldHJ5IEdlb21ldHJ5IGluc3RhbmNlIHRvIGNvcHkgYnVmZmVycyBmcm9tLlxuICogQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IGdlb21ldHJ5LlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLmZyb21HZW9tZXRyeSA9IGZ1bmN0aW9uIGZyb21HZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIHZhciBsZW4gPSBnZW9tZXRyeS5zcGVjLmJ1ZmZlck5hbWVzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuc2V0VmVydGV4QnVmZmVyKFxuICAgICAgICAgICAgZ2VvbWV0cnkuc3BlYy5idWZmZXJOYW1lc1tpXSxcbiAgICAgICAgICAgIGdlb21ldHJ5LnNwZWMuYnVmZmVyVmFsdWVzW2ldLFxuICAgICAgICAgICAgZ2VvbWV0cnkuc3BlYy5idWZmZXJTcGFjaW5nc1tpXVxuICAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogIFNldCB0aGUgcG9zaXRpb25zIG9mIHRoZSB2ZXJ0aWNlcyBpbiB0aGlzIGdlb21ldHJ5LlxuICogXG4gKiAgQG1ldGhvZCBzZXRWZXJ0ZXhQb3NpdGlvbnNcbiAqICBAcGFyYW0ge0FycmF5fSB2YWx1ZSBOZXcgdmFsdWUgZm9yIHZlcnRleCBwb3NpdGlvbiBidWZmZXJcbiAqICBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgZ2VvbWV0cnkuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuc2V0VmVydGV4UG9zaXRpb25zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VmVydGV4QnVmZmVyKCdwb3MnLCB2YWx1ZSwgMyk7XG59O1xuXG4vKipcbiAqICBTZXQgdGhlIG5vcm1hbHMgb24gdGhpcyBnZW9tZXRyeS5cbiAqIFxuICogIEBtZXRob2Qgc2V0Tm9ybWFsc1xuICogIEBwYXJhbSB7QXJyYXl9IHZhbHVlIFZhbHVlIHRvIHNldCBub3JtYWwgYnVmZmVyIHRvLlxuICogIEByZXR1cm4ge09iamVjdH0gY3VycmVudCBnZW9tZXRyeS5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5zZXROb3JtYWxzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VmVydGV4QnVmZmVyKCdub3JtYWxzJywgdmFsdWUsIDMpO1xufTtcblxuLyoqXG4gKiAgU2V0IHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIG9uIHRoaXMgZ2VvbWV0cnkuXG4gKiBcbiAqICBAbWV0aG9kIHNldFRleHR1cmVDb29yZHNcbiAqICBAcGFyYW0ge0FycmF5fSB2YWx1ZSBOZXcgdmFsdWUgZm9yIHRleHR1cmUgY29vcmRpbmF0ZXMgYnVmZmVyLlxuICogIEByZXR1cm4ge09iamVjdH0gY3VycmVudCBnZW9tZXRyeS5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5zZXRUZXh0dXJlQ29vcmRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VmVydGV4QnVmZmVyKCd0ZXhDb29yZCcsIHZhbHVlLCAyKTtcbn07XG5cbi8qKlxuICogIFNldCB0aGUgdGV4dHVyZSBjb29yZGluYXRlcyBvbiB0aGlzIGdlb21ldHJ5LlxuICogIEBtZXRob2Qgc2V0VGV4dHVyZUNvb3Jkc1xuICogIEBwYXJhbSB7QXJyYXl9IHZhbHVlIE5ldyB2YWx1ZSBmb3IgaW5kZXggYnVmZmVyXG4gKiAgQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IGdlb21ldHJ5LlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnNldEluZGljZXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRWZXJ0ZXhCdWZmZXIoJ2luZGljZXMnLCB2YWx1ZSwgMSk7XG59O1xuXG4vKipcbiAqICBTZXQgdGhlIFdlYkdMIGRyYXdpbmcgcHJpbWl0aXZlIGZvciB0aGlzIGdlb21ldHJ5LlxuICogIEBtZXRob2Qgc2V0RHJhd1R5cGVcbiAqICBAcGFyYW0ge1N0cmluZ30gdHlwZSBOZXcgZHJhd2luZyBwcmltaXRpdmUgZm9yIGdlb21ldHJ5XG4gKiAgQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IGdlb21ldHJ5LlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnNldERyYXdUeXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5zcGVjLnR5cGUgPSB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSAncG9zJyB2ZXJ0ZXggYnVmZmVyIG9mIHRoZSBnZW9tZXRyeS5cbiAqIEBtZXRob2QgZ2V0VmVydGV4UG9zaXRpb25zXG4gKiBAcmV0dXJuIHtBcnJheX0gVmVydGV4IGJ1ZmZlci5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5nZXRWZXJ0ZXhQb3NpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmVydGV4QnVmZmVyKCdwb3MnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgJ25vcm1hbCcgdmVydGV4IGJ1ZmZlciBvZiB0aGUgZ2VvbWV0cnkuXG4gKiBAbWV0aG9kIGdldE5vcm1hbHNcbiAqIEByZXR1cm4ge0FycmF5fSBWZXJ0ZXggQnVmZmVyLlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLmdldE5vcm1hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmVydGV4QnVmZmVyKCdub3JtYWxzJyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlICd0ZXh0dXJlQ29vcmQnIHZlcnRleCBidWZmZXIgb2YgdGhlIGdlb21ldHJ5LlxuICogQG1ldGhvZCBnZXRUZXh0dXJlQ29vcmRzXG4gKiBAcmV0dXJuIHtBcnJheX0gVmVydGV4IEJ1ZmZlci5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5nZXRUZXh0dXJlQ29vcmRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFZlcnRleEJ1ZmZlcigndGV4Q29vcmQnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHluYW1pY0dlb21ldHJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VvbWV0cnlJZHMgPSAwO1xuXG4vLyBXZWJHTCBkcmF3aW5nIHByaW1pdGl2ZXMgbWFwLiBUaGlzIGlzIGdlbmVyYXRlZCBpbiBnZW9tZXRyeSB0byBcbi8vIGF2b2lkIGNocm9tZSBkZW9wdGltaXphdGlvbnMgaW4gV2ViR0xSZW5kZXJlciBkcmF3IGZ1bmN0aW9uLlxuLy8gVE9ETzogcmV0dXJuIGRyYXcgdHlwZSBkYXRhIHJldHJlaXZhbCB0byBXZWJHTFJlbmRlcmVyLlxuXG52YXIgRFJBV19UWVBFUyA9IHtcbiAgICBQT0lOVFM6IDAsXG4gICAgTElORVM6IDEsXG4gICAgTElORV9MT09QOiAyLFxuICAgIExJTkVfU1RSSVA6IDMsXG4gICAgVFJJQU5HTEVTOiA0LFxuICAgIFRSSUFOR0xFX1NUUklQOiA1LFxuICAgIFRSSUFOR0xFX0ZBTjogNlxufTtcblxuLyoqXG4gKiBHZW9tZXRyeSBpcyBhIGNvbXBvbmVudCB0aGF0IGRlZmluZXMgdGhlIGRhdGEgdGhhdCBzaG91bGRcbiAqIGJlIGRyYXduIHRvIHRoZSB3ZWJHTCBjYW52YXMuIE1hbmFnZXMgdmVydGV4IGRhdGEgYW5kIGF0dHJpYnV0ZXMuXG4gKlxuICogQGNsYXNzIEdlb21ldHJ5XG4gKiBAY29uc3RydWN0b3JcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgSW5zdGFudGlhdGlvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBHZW9tZXRyeShvcHRpb25zKSB7XG4gICAgdGhpcy5pZCA9IEdlb21ldHJ5SWRzKys7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLkRFRkFVTFRfQlVGRkVSX1NJWkUgPSAzO1xuXG4gICAgdGhpcy5zcGVjID0ge1xuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgIHR5cGU6IERSQVdfVFlQRVNbKHRoaXMub3B0aW9ucy50eXBlID8gdGhpcy5vcHRpb25zLnR5cGUudG9VcHBlckNhc2UoKSA6ICdUUklBTkdMRVMnKV0sXG4gICAgICAgIGJ1ZmZlck5hbWVzOiBbXSxcbiAgICAgICAgYnVmZmVyVmFsdWVzOiBbXSxcbiAgICAgICAgYnVmZmVyU3BhY2luZ3M6IFtdLFxuICAgICAgICBpbnZhbGlkYXRpb25zOiBbXVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJ1ZmZlcnMpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMub3B0aW9ucy5idWZmZXJzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICB0aGlzLnNwZWMuYnVmZmVyTmFtZXMucHVzaCh0aGlzLm9wdGlvbnMuYnVmZmVyc1tpXS5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuc3BlYy5idWZmZXJWYWx1ZXMucHVzaCh0aGlzLm9wdGlvbnMuYnVmZmVyc1tpXS5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuc3BlYy5idWZmZXJTcGFjaW5ncy5wdXNoKHRoaXMub3B0aW9ucy5idWZmZXJzW2ldLnNpemUgfHwgdGhpcy5ERUZBVUxUX0JVRkZFUl9TSVpFKTtcbiAgICAgICAgICAgIHRoaXMuc3BlYy5pbnZhbGlkYXRpb25zLnB1c2goaSsrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHZW9tZXRyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG52YXIgVmVjMiA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMjtcblxudmFyIG91dHB1dHMgPSBbXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzIoKSxcbiAgICBuZXcgVmVjMigpXG5dO1xuXG4vKipcbiAqIEEgaGVscGVyIG9iamVjdCB1c2VkIHRvIGNhbGN1bGF0ZSBidWZmZXJzIGZvciBjb21wbGljYXRlZCBnZW9tZXRyaWVzLlxuICogVGFpbG9yZWQgZm9yIHRoZSBXZWJHTFJlbmRlcmVyLCB1c2VkIGJ5IG1vc3QgcHJpbWl0aXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY2xhc3MgR2VvbWV0cnlIZWxwZXJcbiAqL1xudmFyIEdlb21ldHJ5SGVscGVyID0ge307XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGl0ZXJhdGVzIHRocm91Z2ggdmVydGljYWwgYW5kIGhvcml6b250YWwgc2xpY2VzXG4gKiBiYXNlZCBvbiBpbnB1dCBkZXRhaWwsIGFuZCBnZW5lcmF0ZXMgdmVydGljZXMgYW5kIGluZGljZXMgZm9yIGVhY2hcbiAqIHN1YmRpdmlzaW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2VuZXJhdGVQYXJhbWV0cmljXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRldGFpbFggQW1vdW50IG9mIHNsaWNlcyB0byBpdGVyYXRlIHRocm91Z2guXG4gKiBAcGFyYW0ge051bWJlcn0gZGV0YWlsWSBBbW91bnQgb2Ygc3RhY2tzIHRvIGl0ZXJhdGUgdGhyb3VnaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB2ZXJ0ZXggcG9zaXRpb25zIGF0IGVhY2ggcG9pbnQuXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgZ2VuZXJhdGVkIHZlcnRpY2VzIGFuZCBpbmRpY2VzLlxuICovXG5HZW9tZXRyeUhlbHBlci5nZW5lcmF0ZVBhcmFtZXRyaWMgPSBmdW5jdGlvbiBnZW5lcmF0ZVBhcmFtZXRyaWMoZGV0YWlsWCwgZGV0YWlsWSwgZnVuYykge1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdLFxuICAgICAgICBpLCB0aGV0YSwgcGhpLCByZXN1bHQsIGo7XG5cbiAgICAvLyBXZSBtdXN0IHdyYXAgYXJvdW5kIHNsaWdodGx5IG1vcmUgdGhhbiBvbmNlIGZvciB1diBjb29yZGluYXRlcyB0byBsb29rIGNvcnJlY3QuXG5cbiAgICB2YXIgWHJhbmdlID0gTWF0aC5QSSArIChNYXRoLlBJIC8gKGRldGFpbFggLSAxKSk7XG4gICAgdmFyIG91dCA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGRldGFpbFggKyAxOyBpKyspIHtcbiAgICAgICAgdGhldGEgPSBpICogWHJhbmdlIC8gZGV0YWlsWDtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGRldGFpbFk7IGorKykge1xuICAgICAgICAgICAgcGhpID0gaiAqIDIuMCAqIFhyYW5nZSAvIGRldGFpbFk7XG4gICAgICAgICAgICBmdW5jKHRoZXRhLCBwaGksIG91dCk7XG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKG91dFswXSwgb3V0WzFdLCBvdXRbMl0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGluZGljZXMgPSBbXSxcbiAgICAgICAgdiA9IDAsXG4gICAgICAgIG5leHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IGRldGFpbFg7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgZGV0YWlsWTsgaisrKSB7XG4gICAgICAgICAgICBuZXh0ID0gKGogKyAxKSAlIGRldGFpbFk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godiArIGosIHYgKyBqICsgZGV0YWlsWSwgdiArIG5leHQpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHYgKyBuZXh0LCB2ICsgaiArIGRldGFpbFksIHYgKyBuZXh0ICsgZGV0YWlsWSk7XG4gICAgICAgIH1cbiAgICAgICAgdiArPSBkZXRhaWxZO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRpY2VzOiB2ZXJ0aWNlcyxcbiAgICAgICAgaW5kaWNlczogaW5kaWNlc1xuICAgIH07XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBub3JtYWxzIGJlbG9uZ2luZyB0byBlYWNoIGZhY2Ugb2YgYSBnZW9tZXRyeS4gIFxuICogQXNzdW1lcyBjbG9ja3dpc2UgZGVjbGFyYXRpb24gb2YgdmVydGljZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjb21wdXRlTm9ybWFsc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIFZlcnRpY2VzIG9mIGFsbCBwb2ludHMgb24gdGhlIGdlb21ldHJ5LlxuICogQHBhcmFtIHtBcnJheX0gaW5kaWNlcyBJbmRpY2VzIGRlY2xhcmluZyBmYWNlcyBvZiBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IG91dCBBcnJheSB0byBiZSBmaWxsZWQgYW5kIHJldHVybmVkLlxuICogXG4gKiBAcmV0dXJuIHtBcnJheX0gQ2FsY3VsYXRlZCBmYWNlIG5vcm1hbHMuXG4gKi9cbkdlb21ldHJ5SGVscGVyLmNvbXB1dGVOb3JtYWxzID0gZnVuY3Rpb24gY29tcHV0ZU5vcm1hbHModmVydGljZXMsIGluZGljZXMsIG91dCkge1xuICAgIHZhciBub3JtYWxzID0gb3V0IHx8IFtdO1xuICAgIHZhciB2ZXJ0ZXhUaHJlZTtcbiAgICB2YXIgdmVydGV4VHdvO1xuICAgIHZhciB2ZXJ0ZXhPbmU7XG4gICAgdmFyIGluZGV4T25lO1xuICAgIHZhciBpbmRleFR3bztcbiAgICB2YXIgaW5kZXhUaHJlZTtcbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIGVuZDtcbiAgICB2YXIgbm9ybWFsO1xuICAgIHZhciBqO1xuICAgIHZhciBsZW4gPSBpbmRpY2VzLmxlbmd0aCAvIDM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGogPSBpICogMztcbiAgICAgICAgaW5kZXhUd28gPSBpbmRpY2VzW2ogKyAwXSAqIDM7XG4gICAgICAgIGluZGV4T25lID0gaW5kaWNlc1tqICsgMV0gKiAzO1xuICAgICAgICBpbmRleFRocmVlID0gaW5kaWNlc1tqICsgMl0gKiAzO1xuXG4gICAgICAgIG91dHB1dHNbMF0uc2V0KHZlcnRpY2VzW2luZGV4T25lXSwgdmVydGljZXNbaW5kZXhPbmUgKyAxXSwgdmVydGljZXNbaW5kZXhPbmUgKyAyXSk7XG4gICAgICAgIG91dHB1dHNbMV0uc2V0KHZlcnRpY2VzW2luZGV4VHdvXSwgdmVydGljZXNbaW5kZXhUd28gKyAxXSwgdmVydGljZXNbaW5kZXhUd28gKyAyXSk7XG4gICAgICAgIG91dHB1dHNbMl0uc2V0KHZlcnRpY2VzW2luZGV4VGhyZWVdLCB2ZXJ0aWNlc1tpbmRleFRocmVlICsgMV0sIHZlcnRpY2VzW2luZGV4VGhyZWUgKyAyXSk7XG5cbiAgICAgICAgbm9ybWFsID0gb3V0cHV0c1syXS5zdWJ0cmFjdChvdXRwdXRzWzBdKS5jcm9zcyhvdXRwdXRzWzFdLnN1YnRyYWN0KG91dHB1dHNbMF0pKTtcbiAgICAgICAgbm9ybWFsID0gbm9ybWFsLm5vcm1hbGl6ZSgpLnRvQXJyYXkoKTtcblxuICAgICAgICBub3JtYWxzW2luZGV4T25lICsgMF0gPSBub3JtYWxbMF07XG4gICAgICAgIG5vcm1hbHNbaW5kZXhPbmUgKyAxXSA9IG5vcm1hbFsxXTtcbiAgICAgICAgbm9ybWFsc1tpbmRleE9uZSArIDJdID0gbm9ybWFsWzJdO1xuXG4gICAgICAgIG5vcm1hbHNbaW5kZXhUd28gKyAwXSA9IG5vcm1hbFswXTtcbiAgICAgICAgbm9ybWFsc1tpbmRleFR3byArIDFdID0gbm9ybWFsWzFdO1xuICAgICAgICBub3JtYWxzW2luZGV4VHdvICsgMl0gPSBub3JtYWxbMl07XG5cbiAgICAgICAgbm9ybWFsc1tpbmRleFRocmVlICsgMF0gPSBub3JtYWxbMF07XG4gICAgICAgIG5vcm1hbHNbaW5kZXhUaHJlZSArIDFdID0gbm9ybWFsWzFdO1xuICAgICAgICBub3JtYWxzW2luZGV4VGhyZWUgKyAyXSA9IG5vcm1hbFsyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFscztcbn07XG5cbi8qKlxuICogRGl2aWRlcyBhbGwgaW5zZXJ0ZWQgdHJpYW5nbGVzIGludG8gZm91ciBzdWItdHJpYW5nbGVzLiBBbHRlcnMgdGhlXG4gKiBwYXNzZWQgaW4gYXJyYXlzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3ViZGl2aWRlXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaW5kaWNlcyBJbmRpY2VzIGRlY2xhcmluZyBmYWNlcyBvZiBnZW9tZXRyeVxuICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgVmVydGljZXMgb2YgYWxsIHBvaW50cyBvbiB0aGUgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7QXJyYXl9IHRleHV0dXJlQ29vcmRzIFRleHR1cmUgY29vcmRpbmF0ZXMgb2YgYWxsIHBvaW50cyBvbiB0aGUgZ2VvbWV0cnlcbiAqIFxuICovXG5HZW9tZXRyeUhlbHBlci5zdWJkaXZpZGUgPSBmdW5jdGlvbiBzdWJkaXZpZGUoaW5kaWNlcywgdmVydGljZXMsIHRleHR1cmVDb29yZHMpIHtcbiAgICB2YXIgdHJpYW5nbGVJbmRleCA9IGluZGljZXMubGVuZ3RoIC8gMyxcbiAgICAgICAgYWJjLFxuICAgICAgICBmYWNlLFxuICAgICAgICBpLCBqLCBrLCBwb3MsIHRleDtcblxuICAgIHdoaWxlICh0cmlhbmdsZUluZGV4LS0pIHtcbiAgICAgICAgZmFjZSA9IGluZGljZXMuc2xpY2UodHJpYW5nbGVJbmRleCAqIDMsIHRyaWFuZ2xlSW5kZXggKiAzICsgMyk7XG5cbiAgICAgICAgcG9zID0gZmFjZS5tYXAoZnVuY3Rpb24odmVydEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModmVydGljZXNbdmVydEluZGV4ICogM10sIHZlcnRpY2VzW3ZlcnRJbmRleCAqIDMgKyAxXSwgdmVydGljZXNbdmVydEluZGV4ICogMyArIDJdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZlcnRpY2VzLnB1c2guYXBwbHkodmVydGljZXMsIFZlYzMuc2NhbGUoVmVjMy5hZGQocG9zWzBdLCBwb3NbMV0sIG91dHB1dHNbMF0pLCAwLjUsIG91dHB1dHNbMV0pLnRvQXJyYXkoKSk7XG4gICAgICAgIHZlcnRpY2VzLnB1c2guYXBwbHkodmVydGljZXMsIFZlYzMuc2NhbGUoVmVjMy5hZGQocG9zWzFdLCBwb3NbMl0sIG91dHB1dHNbMF0pLCAwLjUsIG91dHB1dHNbMV0pLnRvQXJyYXkoKSk7XG4gICAgICAgIHZlcnRpY2VzLnB1c2guYXBwbHkodmVydGljZXMsIFZlYzMuc2NhbGUoVmVjMy5hZGQocG9zWzBdLCBwb3NbMl0sIG91dHB1dHNbMF0pLCAwLjUsIG91dHB1dHNbMV0pLnRvQXJyYXkoKSk7XG5cbiAgICAgICAgaWYgKHRleHR1cmVDb29yZHMpIHtcbiAgICAgICAgICAgIHRleCA9IGZhY2UubWFwKGZ1bmN0aW9uKHZlcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih0ZXh0dXJlQ29vcmRzW3ZlcnRJbmRleCAqIDJdLCB0ZXh0dXJlQ29vcmRzW3ZlcnRJbmRleCAqIDIgKyAxXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRleHR1cmVDb29yZHMucHVzaC5hcHBseSh0ZXh0dXJlQ29vcmRzLCBWZWMyLnNjYWxlKFZlYzIuYWRkKHRleFswXSwgdGV4WzFdLCBvdXRwdXRzWzNdKSwgMC41LCBvdXRwdXRzWzRdKS50b0FycmF5KCkpO1xuICAgICAgICAgICAgdGV4dHVyZUNvb3Jkcy5wdXNoLmFwcGx5KHRleHR1cmVDb29yZHMsIFZlYzIuc2NhbGUoVmVjMi5hZGQodGV4WzFdLCB0ZXhbMl0sIG91dHB1dHNbM10pLCAwLjUsIG91dHB1dHNbNF0pLnRvQXJyYXkoKSk7XG4gICAgICAgICAgICB0ZXh0dXJlQ29vcmRzLnB1c2guYXBwbHkodGV4dHVyZUNvb3JkcywgVmVjMi5zY2FsZShWZWMyLmFkZCh0ZXhbMF0sIHRleFsyXSwgb3V0cHV0c1szXSksIDAuNSwgb3V0cHV0c1s0XSkudG9BcnJheSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgPSB2ZXJ0aWNlcy5sZW5ndGggLSAzLCBqID0gaSArIDEsIGsgPSBpICsgMjtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGksIGosIGspO1xuICAgICAgICBpbmRpY2VzLnB1c2goZmFjZVswXSwgaSwgayk7XG4gICAgICAgIGluZGljZXMucHVzaChpLCBmYWNlWzFdLCBqKTtcbiAgICAgICAgaW5kaWNlc1t0cmlhbmdsZUluZGV4XSA9IGs7XG4gICAgICAgIGluZGljZXNbdHJpYW5nbGVJbmRleCArIDFdID0gajtcbiAgICAgICAgaW5kaWNlc1t0cmlhbmdsZUluZGV4ICsgMl0gPSBmYWNlWzJdO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBkdXBsaWNhdGUgb2YgdmVydGljZXMgdGhhdCBhcmUgc2hhcmVkIGJldHdlZW4gZmFjZXMuXG4gKiBBbHRlcnMgdGhlIGlucHV0IHZlcnRleCBhbmQgaW5kZXggYXJyYXlzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2V0VW5pcXVlRmFjZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2ZXJ0aWNlcyBWZXJ0aWNlcyBvZiBhbGwgcG9pbnRzIG9uIHRoZSBnZW9tZXRyeVxuICogQHBhcmFtIHtBcnJheX0gaW5kaWNlcyBJbmRpY2VzIGRlY2xhcmluZyBmYWNlcyBvZiBnZW9tZXRyeVxuICogXG4gKi9cbkdlb21ldHJ5SGVscGVyLmdldFVuaXF1ZUZhY2VzID0gZnVuY3Rpb24gZ2V0VW5pcXVlRmFjZXModmVydGljZXMsIGluZGljZXMpIHtcbiAgICB2YXIgdHJpYW5nbGVJbmRleCA9IGluZGljZXMubGVuZ3RoIC8gMyxcbiAgICAgICAgcmVnaXN0ZXJlZCA9IFtdLFxuICAgICAgICBpbmRleDtcblxuICAgIHdoaWxlICh0cmlhbmdsZUluZGV4LS0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblxuICAgICAgICAgICAgaW5kZXggPSBpbmRpY2VzW3RyaWFuZ2xlSW5kZXggKiAzICsgaV07XG5cbiAgICAgICAgICAgIGlmIChyZWdpc3RlcmVkW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2godmVydGljZXNbaW5kZXggKiAzXSwgdmVydGljZXNbaW5kZXggKiAzICsgMV0sIHZlcnRpY2VzW2luZGV4ICogMyArIDJdKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzW3RyaWFuZ2xlSW5kZXggKiAzICsgaV0gPSB2ZXJ0aWNlcy5sZW5ndGggLyAzIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZFtpbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBEaXZpZGVzIGFsbCBpbnNlcnRlZCB0cmlhbmdsZXMgaW50byBmb3VyIHN1Yi10cmlhbmdsZXMgd2hpbGUgbWFpbnRhaW5pbmdcbiAqIGEgcmFkaXVzIG9mIG9uZS4gQWx0ZXJzIHRoZSBwYXNzZWQgaW4gYXJyYXlzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3ViZGl2aWRlXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgVmVydGljZXMgb2YgYWxsIHBvaW50cyBvbiB0aGUgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7QXJyYXl9IGluZGljZXMgSW5kaWNlcyBkZWNsYXJpbmcgZmFjZXMgb2YgZ2VvbWV0cnlcbiAqIFxuICovXG5HZW9tZXRyeUhlbHBlci5zdWJkaXZpZGVTcGhlcm9pZCA9IGZ1bmN0aW9uIHN1YmRpdmlkZVNwaGVyb2lkKHZlcnRpY2VzLCBpbmRpY2VzKSB7XG4gICAgdmFyIHRyaWFuZ2xlSW5kZXggPSBpbmRpY2VzLmxlbmd0aCAvIDMsXG4gICAgICAgIGFiYyxcbiAgICAgICAgZmFjZSxcbiAgICAgICAgaSwgaiwgaztcblxuICAgIHdoaWxlICh0cmlhbmdsZUluZGV4LS0pIHtcbiAgICAgICAgZmFjZSA9IGluZGljZXMuc2xpY2UodHJpYW5nbGVJbmRleCAqIDMsIHRyaWFuZ2xlSW5kZXggKiAzICsgMyk7XG4gICAgICAgIGFiYyA9IGZhY2UubWFwKGZ1bmN0aW9uKHZlcnRJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHZlcnRpY2VzW3ZlcnRJbmRleCAqIDNdLCB2ZXJ0aWNlc1t2ZXJ0SW5kZXggKiAzICsgMV0sIHZlcnRpY2VzW3ZlcnRJbmRleCAqIDMgKyAyXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZlcnRpY2VzLnB1c2guYXBwbHkodmVydGljZXMsIFZlYzMubm9ybWFsaXplKFZlYzMuYWRkKGFiY1swXSwgYWJjWzFdLCBvdXRwdXRzWzBdKSwgb3V0cHV0c1sxXSkudG9BcnJheSgpKTtcbiAgICAgICAgdmVydGljZXMucHVzaC5hcHBseSh2ZXJ0aWNlcywgVmVjMy5ub3JtYWxpemUoVmVjMy5hZGQoYWJjWzFdLCBhYmNbMl0sIG91dHB1dHNbMF0pLCBvdXRwdXRzWzFdKS50b0FycmF5KCkpO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoLmFwcGx5KHZlcnRpY2VzLCBWZWMzLm5vcm1hbGl6ZShWZWMzLmFkZChhYmNbMF0sIGFiY1syXSwgb3V0cHV0c1swXSksIG91dHB1dHNbMV0pLnRvQXJyYXkoKSk7XG5cbiAgICAgICAgaSA9IHZlcnRpY2VzLmxlbmd0aCAvIDMgLSAzLCBqID0gaSArIDEsIGsgPSBpICsgMjtcblxuICAgICAgICBpbmRpY2VzLnB1c2goaSwgaiwgayk7XG4gICAgICAgIGluZGljZXMucHVzaChmYWNlWzBdLCBpLCBrKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGksIGZhY2VbMV0sIGopO1xuICAgICAgICBpbmRpY2VzW3RyaWFuZ2xlSW5kZXggKiAzXSA9IGs7XG4gICAgICAgIGluZGljZXNbdHJpYW5nbGVJbmRleCAqIDMgKyAxXSA9IGo7XG4gICAgICAgIGluZGljZXNbdHJpYW5nbGVJbmRleCAqIDMgKyAyXSA9IGZhY2VbMl07XG4gICAgfVxufTtcblxuLyoqXG4gKiBEaXZpZGVzIGFsbCBpbnNlcnRlZCB0cmlhbmdsZXMgaW50byBmb3VyIHN1Yi10cmlhbmdsZXMgd2hpbGUgbWFpbnRhaW5pbmdcbiAqIGEgcmFkaXVzIG9mIG9uZS4gQWx0ZXJzIHRoZSBwYXNzZWQgaW4gYXJyYXlzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2V0U3BoZXJvaWROb3JtYWxzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgVmVydGljZXMgb2YgYWxsIHBvaW50cyBvbiB0aGUgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCBPcHRpb25hbCBhcnJheSB0byBiZSBmaWxsZWQgd2l0aCByZXN1bHRpbmcgbm9ybWFscy5cbiAqIFxuICogQHJldHVybiB7QXJyYXl9IG5ldyBsaXN0IG9mIGNhbGN1bGF0ZWQgbm9ybWFscy5cbiAqL1xuR2VvbWV0cnlIZWxwZXIuZ2V0U3BoZXJvaWROb3JtYWxzID0gZnVuY3Rpb24gZ2V0U3BoZXJvaWROb3JtYWxzKHZlcnRpY2VzLCBvdXQpIHtcbiAgICB2YXIgb3V0ID0gb3V0IHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xuICAgIHZhciBub3JtYWxpemVkO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQgPSBuZXcgVmVjMyhcbiAgICAgICAgICAgIHZlcnRpY2VzW2kgKiAzICsgMF0sXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpICogMyArIDFdLFxuICAgICAgICAgICAgdmVydGljZXNbaSAqIDMgKyAyXVxuICAgICAgICApLm5vcm1hbGl6ZSgpLnRvQXJyYXkoKTtcblxuICAgICAgICBvdXRbaSAqIDMgKyAwXSA9IG5vcm1hbGl6ZWRbMF07XG4gICAgICAgIG91dFtpICogMyArIDFdID0gbm9ybWFsaXplZFsxXTtcbiAgICAgICAgb3V0W2kgKiAzICsgMl0gPSBub3JtYWxpemVkWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGV4dHVyZSBjb29yZGluYXRlcyBmb3Igc3BoZXJvaWQgcHJpbWl0aXZlcyBiYXNlZCBvblxuICogaW5wdXQgdmVydGljZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRTcGhlcm9pZFVWXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgVmVydGljZXMgb2YgYWxsIHBvaW50cyBvbiB0aGUgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCBPcHRpb25hbCBhcnJheSB0byBiZSBmaWxsZWQgd2l0aCByZXN1bHRpbmcgdGV4dHVyZSBjb29yZGluYXRlcy5cbiAqIFxuICogQHJldHVybiB7QXJyYXl9IG5ldyBsaXN0IG9mIGNhbGN1bGF0ZWQgdGV4dHVyZSBjb29yZGluYXRlc1xuICovXG5HZW9tZXRyeUhlbHBlci5nZXRTcGhlcm9pZFVWID0gZnVuY3Rpb24gZ2V0U3BoZXJvaWRVVih2ZXJ0aWNlcywgb3V0KSB7XG4gICAgdmFyIG91dCA9IG91dCB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gdmVydGljZXMubGVuZ3RoIC8gMztcbiAgICB2YXIgdmVydGV4O1xuXG4gICAgdmFyIHV2ID0gW107XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmVydGV4ID0gb3V0cHV0c1swXS5zZXQoXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpICogM10sXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpICogMyArIDFdLFxuICAgICAgICAgICAgdmVydGljZXNbaSAqIDMgKyAyXVxuICAgICAgICApXG4gICAgICAgIC5ub3JtYWxpemUoKVxuICAgICAgICAudG9BcnJheSgpO1xuXG4gICAgICAgIHV2WzBdID0gdGhpcy5nZXRBemltdXRoKHZlcnRleCkgKiAwLjUgLyBNYXRoLlBJICsgMC41O1xuICAgICAgICB1dlsxXSA9IHRoaXMuZ2V0QWx0aXR1ZGUodmVydGV4KSAvIE1hdGguUEkgKyAwLjU7XG5cbiAgICAgICAgb3V0LnB1c2guYXBwbHkob3V0LCB1dik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBhbmQgbm9ybWFsaXplcyBhIGxpc3Qgb2YgdmVydGljZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBub3JtYWxpemVBbGxcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2ZXJ0aWNlcyBWZXJ0aWNlcyBvZiBhbGwgcG9pbnRzIG9uIHRoZSBnZW9tZXRyeVxuICogQHBhcmFtIHtBcnJheX0gb3V0IE9wdGlvbmFsIGFycmF5IHRvIGJlIGZpbGxlZCB3aXRoIHJlc3VsdGluZyBub3JtYWxpemVkIHZlY3RvcnMuXG4gKiBcbiAqIEByZXR1cm4ge0FycmF5fSBuZXcgbGlzdCBvZiBub3JtYWxpemVkIHZlcnRpY2VzXG4gKi9cbkdlb21ldHJ5SGVscGVyLm5vcm1hbGl6ZUFsbCA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUFsbCh2ZXJ0aWNlcywgb3V0KSB7XG4gICAgdmFyIG91dCA9IG91dCB8fCBbXTtcbiAgICB2YXIgdmVydGV4O1xuICAgIHZhciBsZW4gPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvdXQsIG5ldyBWZWMzKHZlcnRpY2VzW2kgKiAzXSwgdmVydGljZXNbaSAqIDMgKyAxXSwgdmVydGljZXNbaSAqIDMgKyAyXSkubm9ybWFsaXplKCkudG9BcnJheSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgc2V0IG9mIHZlcnRpY2VzIHRvIG1vZGVsIHNwYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgbm9ybWFsaXplVmVydGljZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2ZXJ0aWNlcyBWZXJ0aWNlcyBvZiBhbGwgcG9pbnRzIG9uIHRoZSBnZW9tZXRyeVxuICogQHBhcmFtIHtBcnJheX0gb3V0IE9wdGlvbmFsIGFycmF5IHRvIGJlIGZpbGxlZCB3aXRoIG1vZGVsIHNwYWNlIHBvc2l0aW9uIHZlY3RvcnMuXG4gKiBcbiAqIEByZXR1cm4ge0FycmF5fSBPdXRwdXQgdmVydGljZXMuXG4gKi9cbkdlb21ldHJ5SGVscGVyLm5vcm1hbGl6ZVZlcnRpY2VzID0gZnVuY3Rpb24gbm9ybWFsaXplVmVydGljZXModmVydGljZXMsIG91dCkge1xuICAgIHZhciBvdXQgPSBvdXQgfHwgW107XG4gICAgdmFyIGxlbiA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XG4gICAgdmFyIHZlY3RvcnMgPSBbXTtcbiAgICB2YXIgbWluWDtcbiAgICB2YXIgbWF4WDtcbiAgICB2YXIgbWluWTtcbiAgICB2YXIgbWF4WTtcbiAgICB2YXIgbWluWjtcbiAgICB2YXIgbWF4WjtcbiAgICB2YXIgdjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdiA9IHZlY3RvcnNbaV0gPSBuZXcgVmVjMyhcbiAgICAgICAgICAgIHZlcnRpY2VzW2kgKiAzXSxcbiAgICAgICAgICAgIHZlcnRpY2VzW2kgKiAzICsgMV0sXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpICogMyArIDJdXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG1pblggPT0gbnVsbCB8fCB2LnggPCBtaW5YKSBtaW5YID0gdi54O1xuICAgICAgICBpZiAobWF4WCA9PSBudWxsIHx8IHYueCA+IG1heFgpIG1heFggPSB2Lng7XG5cbiAgICAgICAgaWYgKG1pblkgPT0gbnVsbCB8fCB2LnkgPCBtaW5ZKSBtaW5ZID0gdi55O1xuICAgICAgICBpZiAobWF4WSA9PSBudWxsIHx8IHYueSA+IG1heFkpIG1heFkgPSB2Lnk7XG5cbiAgICAgICAgaWYgKG1pblogPT0gbnVsbCB8fCB2LnogPCBtaW5aKSBtaW5aID0gdi56O1xuICAgICAgICBpZiAobWF4WiA9PSBudWxsIHx8IHYueiA+IG1heFopIG1heFogPSB2Lno7XG4gICAgfTtcblxuICAgIHZhciB0cmFuc2xhdGlvbiA9IG5ldyBWZWMzKFxuICAgICAgICBnZXRUcmFuc2xhdGlvbkZhY3RvcihtYXhYLCBtaW5YKSxcbiAgICAgICAgZ2V0VHJhbnNsYXRpb25GYWN0b3IobWF4WSwgbWluWSksXG4gICAgICAgIGdldFRyYW5zbGF0aW9uRmFjdG9yKG1heFosIG1pblopXG4gICAgKTtcblxuICAgIHZhciBzY2FsZSA9IE1hdGgubWluKFxuICAgICAgICBnZXRTY2FsZUZhY3RvcihtYXhYICsgdHJhbnNsYXRpb24ueCwgbWluWCArIHRyYW5zbGF0aW9uLngpLFxuICAgICAgICBnZXRTY2FsZUZhY3RvcihtYXhZICsgdHJhbnNsYXRpb24ueSwgbWluWSArIHRyYW5zbGF0aW9uLnkpLFxuICAgICAgICBnZXRTY2FsZUZhY3RvcihtYXhaICsgdHJhbnNsYXRpb24ueiwgbWluWiArIHRyYW5zbGF0aW9uLnopXG4gICAgKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXQucHVzaC5hcHBseShvdXQsIHZlY3RvcnNbaV0uYWRkKHRyYW5zbGF0aW9uKS5zY2FsZShzY2FsZSkudG9BcnJheSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRyYW5zbGF0aW9uIGFtb3VudCBmb3IgYSBnaXZlbiBheGlzIHRvIG5vcm1hbGl6ZSBtb2RlbCBjb29yZGluYXRlcy5cbiAqXG4gKiBAbWV0aG9kIGdldFRyYW5zbGF0aW9uRmFjdG9yXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggTWF4aW11bSBwb3NpdGlvbiB2YWx1ZSBvZiBnaXZlbiBheGlzIG9uIHRoZSBtb2RlbC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gTWluaW11bSBwb3NpdGlvbiB2YWx1ZSBvZiBnaXZlbiBheGlzIG9uIHRoZSBtb2RlbC5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IE51bWJlciBieSB3aGljaCB0aGUgZ2l2ZW4gYXhpcyBzaG91bGQgYmUgdHJhbnNsYXRlZCBmb3IgYWxsIHZlcnRpY2VzLlxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGlvbkZhY3RvcihtYXgsIG1pbikge1xuICAgIHJldHVybiAtKG1pbiArIChtYXggLSBtaW4pIC8gMik7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBzY2FsZSBhbW91bnQgZm9yIGEgZ2l2ZW4gYXhpcyB0byBub3JtYWxpemUgbW9kZWwgY29vcmRpbmF0ZXMuXG4gKlxuICogQG1ldGhvZCBnZXRTY2FsZUZhY3RvclxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IE1heGltdW0gc2NhbGUgdmFsdWUgb2YgZ2l2ZW4gYXhpcyBvbiB0aGUgbW9kZWwuXG4gKiBAcGFyYW0ge051bWJlcn0gbWluIE1pbmltdW0gc2NhbGUgdmFsdWUgb2YgZ2l2ZW4gYXhpcyBvbiB0aGUgbW9kZWwuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBOdW1iZXIgYnkgd2hpY2ggdGhlIGdpdmVuIGF4aXMgc2hvdWxkIGJlIHNjYWxlZCBmb3IgYWxsIHZlcnRpY2VzLlxuICovXG5mdW5jdGlvbiBnZXRTY2FsZUZhY3RvcihtYXgsIG1pbikge1xuICAgIHJldHVybiAxIC8gKChtYXggLSBtaW4pIC8gMik7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGF6aW11dGgsIG9yIGFuZ2xlIGFib3ZlIHRoZSBYWSBwbGFuZSwgb2YgYSBnaXZlbiB2ZWN0b3IuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRBemltdXRoXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdiBWZXJ0ZXggdG8gcmV0cmVpdmUgYXppbXV0aCBmcm9tLlxuICogXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEF6aW11dGggdmFsdWUgaW4gcmFkaWFucy4gXG4gKi9cbkdlb21ldHJ5SGVscGVyLmdldEF6aW11dGggPSBmdW5jdGlvbiBhemltdXRoKHYpIHtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih2WzJdLCAtdlswXSk7XG59O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBhbHRpdHVkZSwgb3IgYW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLCBvZiBhIGdpdmVuIHZlY3Rvci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdldEFsdGl0dWRlXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdiBWZXJ0ZXggdG8gcmV0cmVpdmUgYWx0aXR1ZGUgZnJvbS5cbiAqIFxuICogQHJldHVybiB7TnVtYmVyfSBBbHRpdHVkZSB2YWx1ZSBpbiByYWRpYW5zLiBcbiAqL1xuR2VvbWV0cnlIZWxwZXIuZ2V0QWx0aXR1ZGUgPSBmdW5jdGlvbiBhbHRpdHVkZSh2KSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoLXZbMV0sIE1hdGguc3FydCgodlswXSAqIHZbMF0pICsgKHZbMl0gKiB2WzJdKSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGxpc3Qgb2YgaW5kaWNlcyBmcm9tICd0cmlhbmdsZScgdG8gJ2xpbmUnIGZvcm1hdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHRyaWFuZ2xlc1RvTGluZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpbmRpY2VzIEluZGljZXMgb2YgYWxsIGZhY2VzIG9uIHRoZSBnZW9tZXRyeVxuICogXG4gKiBAcmV0dXJuIHtBcnJheX0gbmV3IGxpc3Qgb2YgbGluZS1mb3JtYXR0ZWQgaW5kaWNlc1xuICovXG5HZW9tZXRyeUhlbHBlci50cmlhbmdsZXNUb0xpbmVzID0gZnVuY3Rpb24gdHJpYW5nbGVUb0xpbmVzKGluZGljZXMsIG91dCkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgZmFjZTtcbiAgICB2YXIgajtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoKGluZGljZXNbaV1bMF0sIGluZGljZXNbaV1bMV0pO1xuICAgICAgICBvdXQucHVzaChpbmRpY2VzW2ldWzFdLCBpbmRpY2VzW2ldWzJdKTtcbiAgICAgICAgb3V0LnB1c2goaW5kaWNlc1tpXVsyXSwgaW5kaWNlc1tpXVswXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvbWV0cnlIZWxwZXI7XG4iLCJ2YXIgbG9hZFVSTCAgICAgICAgPSByZXF1aXJlKCdmYW1vdXMtdXRpbGl0aWVzJykubG9hZFVSTDtcbnZhciBHZW9tZXRyeUhlbHBlciA9IHJlcXVpcmUoJy4vR2VvbWV0cnlIZWxwZXInKTtcblxuLypcbiAqIEEgc2luZ2xldG9uIG9iamVjdCB0aGF0IHRha2VzIHRoYXQgbWFrZXMgcmVxdWVzdHNcbiAqIGZvciBPQkogZmlsZXMgYW5kIHJldHVybnMgdGhlIGZvcm1hdHRlZCBkYXRhIGFzXG4gKiBhbiBhcmd1bWVudCB0byBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjbGFzcyBPQkpMb2FkZXJcbiAqL1xuXG52YXIgT0JKTG9hZGVyID0ge1xuICAgIGNhY2hlZDoge30sXG4gICAgcmVxdWVzdHM6IHt9XG59O1xuXG4vKlxuICogVGFrZXMgYSBwYXRoIHRvIGRlc2lyZWQgb2JqIGZpbGUgYW5kIG1ha2VzIGFuIFhNTEh0dHAgcmVxdWVzdFxuICogaWYgdGhlIHJlc291cmNlIGlzIG5vdCBjYWNoZWQuIFNldHMgdXAgdGhlICdvbnJlc3BvbnNlJyBmdW5jdGlvblxuICogYXMgYSBjYWxsYmFjayBmb3IgZm9ybWF0dGluZyBhbmQgY2FsbGJhY2sgaW52b2NhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGxvYWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCBvZiBkZXNpcmVkIG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgRnVuY3Rpb24gdG8gYmUgZmlyZWQgdXBvbiBzdWNjZXNzZnVsIGZvcm1hdHRpbmcgb2Ygb2JqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIGhhc2ggdG8gdGhhdCBjYW4gYWZmZWN0IHRoZSBvdXRwdXQgb2YgdGhlIE9CSlxuICogdmVydGljZXMuXG4gKi9cbk9CSkxvYWRlci5sb2FkID0gZnVuY3Rpb24gbG9hZCh1cmwsIGNiLCBvcHRpb25zKSB7XG4gICAgaWYgKCEgdGhpcy5jYWNoZWRbdXJsXSkge1xuICAgICAgICBpZighIHRoaXMucmVxdWVzdHNbdXJsXSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0c1t1cmxdID0gW2NiXTtcbiAgICAgICAgICAgIGxvYWRVUkwoXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHRoaXMuX29uc3VjY2Vzcy5iaW5kKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0c1t1cmxdLnB1c2goY2IpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2IodGhpcy5jYWNoZWRbdXJsXSk7XG4gICAgfVxufTtcblxuLypcbiAqIEZpcmVkIG9uIHJlc3BvbnNlIGZyb20gc2VydmVyIGZvciBPQkogYXNzZXQuICBGb3JtYXRzIHRoZVxuICogcmV0dXJuZWQgc3RyaW5nIGFuZCBzdG9yZXMgdGhlIGJ1ZmZlciBkYXRhIGluIGNhY2hlLlxuICogSW52b2tlcyBhbGwgcXVldWVkIGNhbGxiYWNrcyBiZWZvcmUgY2xlYXJpbmcgdGhlbS5cbiAqXG4gKiBAbWV0aG9kIF9vbnN1Y2Nlc3NcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFVSTCBvZiByZXF1ZXN0ZWQgb2JqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIGRldGVybWluaW5nIHdoZXRoZXIgb3Igbm90IHRvIG1hbnVhbGx5IGNhbGN1bGF0ZSBub3JtYWxzXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGVudCBvZiB0aGUgc2VydmVyIHJlc3BvbnNlXG4gKi9cbk9CSkxvYWRlci5fb25zdWNjZXNzID0gZnVuY3Rpb24gX29uc3VjY2Vzcyh1cmwsIG9wdGlvbnMsIHRleHQpIHtcbiAgICB2YXIgYnVmZmVycyA9IGZvcm1hdC5jYWxsKHRoaXMsIHRleHQsIG9wdGlvbnMgfHwge30pO1xuICAgIHRoaXMuY2FjaGVkW3VybF0gPSBidWZmZXJzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlcXVlc3RzW3VybF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0c1t1cmxdW2ldKGJ1ZmZlcnMpO1xuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdHNbdXJsXSA9IG51bGw7XG59O1xuXG4vKlxuICogVGFrZXMgcmF3IHN0cmluZyBmb3JtYXQgb2Ygb2JqIGFuZCBjb252ZXJ0cyBpdCB0byBhIGphdmFzY3JpcHRcbiAqIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJ1ZmZlcnMgbmVlZGVkIHRvIGRyYXcgdGhlIGdlb21ldHJ5LlxuICpcbiAqIEBtZXRob2QgZm9ybWF0XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXcgb2JqIGRhdGEgaW4gdGV4dCBmb3JtYXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgZGV0ZXJtaW5pbmcgd2hldGhlciBvciBub3QgdG8gbWFudWFsbHkgY2FsY3VsYXRlIG5vcm1hbHNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlcnRleCBidWZmZXIgZGF0YVxuICovXG5mdW5jdGlvbiBmb3JtYXQodGV4dCwgb3B0aW9ucykge1xuICAgIHZhciB0ZXh0ID0gc2FuaXRpemUodGV4dCk7XG5cbiAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcblxuICAgIHZhciBmYWNlVGV4Q29vcmRzID0gW107XG4gICAgdmFyIGZhY2VWZXJ0aWNlcyA9IFtdO1xuICAgIHZhciBmYWNlTm9ybWFscyA9IFtdO1xuXG4gICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICB2YXIgdGV4Q29vcmRzID0gW107XG4gICAgdmFyIHZlcnRpY2VzID0gW107XG5cbiAgICB2YXIgaTEsIGkyLCBpMywgaTQ7XG4gICAgdmFyIHNwbGl0O1xuICAgIHZhciBsaW5lO1xuXG4gICAgdmFyIGxlbmd0aCA9IGxpbmVzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBzcGxpdCA9IGxpbmVzW2ldLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgLy8gSGFuZGxlIHZlcnRleCBwb3NpdGlvbnNcblxuICAgICAgICBpZiAobGluZS5pbmRleE9mKCd2ICcpICE9PSAtMSkge1xuICAgICAgICAgICAgdmVydGljZXMucHVzaChbXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsxXSksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsyXSksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFszXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHRleHR1cmUgY29vcmRpbmF0ZXNcblxuICAgICAgICBlbHNlIGlmKGxpbmUuaW5kZXhPZigndnQgJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0ZXhDb29yZHMucHVzaChbXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsxXSksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsyXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHZlcnRleCBub3JtYWxzXG5cbiAgICAgICAgZWxzZSBpZiAobGluZS5pbmRleE9mKCd2biAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIG5vcm1hbHMucHVzaChbXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsxXSksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsyXSksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFszXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGZhY2VcblxuICAgICAgICBlbHNlIGlmIChsaW5lLmluZGV4T2YoJ2YgJykgIT09IC0xKSB7XG5cbiAgICAgICAgICAgIC8vIFZlcnRleCwgTm9ybWFsXG5cbiAgICAgICAgICAgIGlmIChzcGxpdFsxXS5pbmRleE9mKCcvLycpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGkxID0gc3BsaXRbMV0uc3BsaXQoJy8vJyk7XG4gICAgICAgICAgICAgICAgaTIgPSBzcGxpdFsyXS5zcGxpdCgnLy8nKTtcbiAgICAgICAgICAgICAgICBpMyA9IHNwbGl0WzNdLnNwbGl0KCcvLycpO1xuXG4gICAgICAgICAgICAgICAgZmFjZVZlcnRpY2VzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkxWzBdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTJbMF0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpM1swXSkgLSAxXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgZmFjZU5vcm1hbHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTFbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpMlsxXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkzWzFdKSAtIDFcbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBxdWFkXG5cbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRbNF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaTQgPSBzcGxpdFs0XS5zcGxpdCgnLy8nKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZVZlcnRpY2VzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpMVswXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpM1swXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpNFswXSkgLSAxXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBmYWNlTm9ybWFscy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTFbMl0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTNbMl0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTRbMl0pIC0gMVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFZlcnRleCwgVGV4Q29vcmQsIE5vcm1hbFxuXG4gICAgICAgICAgICBlbHNlIGlmIChzcGxpdFsxXS5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaTEgPSBzcGxpdFsxXS5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgIGkyID0gc3BsaXRbMl0uc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICBpMyA9IHNwbGl0WzNdLnNwbGl0KCcvJyk7XG5cbiAgICAgICAgICAgICAgICBmYWNlVmVydGljZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTFbMF0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpMlswXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkzWzBdKSAtIDFcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBmYWNlVGV4Q29vcmRzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkxWzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTJbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpM1sxXSkgLSAxXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgZmFjZU5vcm1hbHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTFbMl0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpMlsyXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkzWzJdKSAtIDFcbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBRdWFkXG5cbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRbNF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaTQgPSBzcGxpdFs0XS5zcGxpdCgnLycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZhY2VWZXJ0aWNlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTFbMF0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTNbMF0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTRbMF0pIC0gMVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZVRleENvb3Jkcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTFbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTNbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTRbMV0pIC0gMVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZU5vcm1hbHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkxWzJdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkzWzJdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGk0WzJdKSAtIDFcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBWZXJ0ZXhcblxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFjZVZlcnRpY2VzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMl0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFszXSkgLSAxXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgZmFjZVRleENvb3Jkcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsxXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzJdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbM10pIC0gMVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGZhY2VOb3JtYWxzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMl0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFszXSkgLSAxXG4gICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgUXVhZFxuXG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0WzRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VWZXJ0aWNlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbM10pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbNF0pIC0gMVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZVRleENvb3Jkcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbM10pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbNF0pIC0gMVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZU5vcm1hbHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzNdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzRdKSAtIDFcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNhY2hlZCA9IGNhY2hlVmVydGljZXMoXG4gICAgICAgIHZlcnRpY2VzLFxuICAgICAgICBub3JtYWxzLFxuICAgICAgICB0ZXhDb29yZHMsXG4gICAgICAgIGZhY2VWZXJ0aWNlcyxcbiAgICAgICAgZmFjZU5vcm1hbHMsXG4gICAgICAgIGZhY2VUZXhDb29yZHNcbiAgICApO1xuXG5cbiAgICBjYWNoZWQudmVydGljZXMgPSBmbGF0dGVuKGNhY2hlZC52ZXJ0aWNlcyk7XG4gICAgY2FjaGVkLm5vcm1hbHMgPSBmbGF0dGVuKGNhY2hlZC5ub3JtYWxzKTtcbiAgICBjYWNoZWQudGV4Q29vcmRzID0gZmxhdHRlbihjYWNoZWQudGV4Q29vcmRzKTtcbiAgICBjYWNoZWQuaW5kaWNlcyA9IGZsYXR0ZW4oY2FjaGVkLmluZGljZXMpO1xuXG4gICAgaWYgKG9wdGlvbnMubm9ybWFsaXplKSB7XG4gICAgICAgIGNhY2hlZC52ZXJ0aWNlcyA9IEdlb21ldHJ5SGVscGVyLm5vcm1hbGl6ZVZlcnRpY2VzKFxuICAgICAgICAgICAgY2FjaGVkLnZlcnRpY2VzXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY29tcHV0ZU5vcm1hbHMpIHtcbiAgICAgICAgY2FjaGVkLm5vcm1hbHMgPSBHZW9tZXRyeUhlbHBlci5jb21wdXRlTm9ybWFscyhcbiAgICAgICAgICAgIGNhY2hlZC52ZXJ0aWNlcyxcbiAgICAgICAgICAgIGNhY2hlZC5pbmRpY2VzXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGljZXM6IGNhY2hlZC52ZXJ0aWNlcyxcbiAgICAgICAgbm9ybWFsczogY2FjaGVkLm5vcm1hbHMsXG4gICAgICAgIHRleHR1cmVDb29yZHM6IGNhY2hlZC50ZXhDb29yZHMsXG4gICAgICAgIGluZGljZXM6IGNhY2hlZC5pbmRpY2VzXG4gICAgfTtcbn07XG5cbi8qXG4gKiBSZXBsYWNlcyBhbGwgZG91YmxlIHNwYWNlcyB3aXRoIHNpbmdsZSBzcGFjZXMgYW5kIHJlbW92ZXNcbiAqIGFsbCB0cmFpbGluZyBzcGFjZXMgZnJvbSBsaW5lcyBvZiBhIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAbWV0aG9kIHNhbml0aXplXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFN0cmluZyB0byBiZSBzYW5pdGl6ZWQuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBzYW5pdGl6ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzYW5pdGl6ZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvICsoPz0gKS9nLCcnKS5yZXBsYWNlKC9cXHMrJC9nLCAnJyk7XG59XG5cbi8qXG4gKiBUYWtlcyBhIGdpdmVuIHBvb2wgb2YgYXR0cmlidXRlcyBhbmQgZmFjZSBkZWZpbml0aW9uc1xuICogYW5kIHJlbW92ZXMgYWxsIGR1cGxpY2F0ZSB2ZXJ0aWNlcy5cbiAqXG4gKiBAbWV0aG9kIGNhY2hlVmVydGljZXNcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdiBQb29sIG9mIHZlcnRpY2VzIHVzZWQgaW4gZmFjZSBkZWNsYXJhdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBuIFBvb2wgb2Ygbm9ybWFscyB1c2VkIGluIGZhY2UgZGVjbGFyYXRpb25zLlxuICogQHBhcmFtIHtBcnJheX0gdCBQb29sIG9mIHRleHR1cmVDb29yZHMgdXNlZCBpbiBmYWNlIGRlY2xhcmF0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IGZ2IFZlcnRleCBwb3NpdGlvbnMgYXQgZWFjaCBmYWNlIGluIHRoZSBPQkouXG4gKiBAcGFyYW0ge0FycmF5fSBmbiBOb3JtYWxzIGF0IGVhY2ggZmFjZSBpbiB0aGUgT0JKLlxuICogQHBhcmFtIHtBcnJheX0gZnQgVGV4dHVyZSBjb29yZGluYXRlcyBhdCBlYWNoIGZhY2UgaW4gdGhlIE9CSi5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSB2ZXJ0aWNlcywgdGV4dHVyZUNvb3JkaW5hdGVzIGFuZFxuICogbm9ybWFscyBvZiB0aGUgT0JKLlxuICovXG5mdW5jdGlvbiBjYWNoZVZlcnRpY2VzKHYsIG4sIHQsIGZ2LCBmbiwgZnQpIHtcbiAgICB2YXIgb3V0Tm9ybWFscyA9IFtdO1xuICAgIHZhciBvdXRQb3MgPSBbXTtcbiAgICB2YXIgb3V0VGV4Q29vcmQgPSBbXTtcbiAgICB2YXIgb3V0SW5kaWNlcyA9IFtdO1xuXG4gICAgdmFyIHZlcnRleENhY2hlID0ge307XG5cbiAgICB2YXIgcG9zaXRpb25JbmRleDtcbiAgICB2YXIgbm9ybWFsSW5kZXg7XG4gICAgdmFyIHRleENvb3JkSW5kZXg7XG5cbiAgICB2YXIgY3VycmVudEluZGV4ID0gMDtcbiAgICB2YXIgZnZMZW5ndGggPSBmdi5sZW5ndGg7XG4gICAgdmFyIGZuTGVuZ3RoID0gZm4ubGVuZ3RoO1xuICAgIHZhciBmdExlbmd0aCA9IGZ0Lmxlbmd0aDtcbiAgICB2YXIgZmFjZUxlbmd0aDtcbiAgICB2YXIgaW5kZXg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ2TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0SW5kaWNlc1tpXSA9IFtdO1xuICAgICAgICBmYWNlTGVuZ3RoID0gZnZbaV0ubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmFjZUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZnRMZW5ndGgpIHRleENvb3JkSW5kZXggPSBmdFtpXVtqXTtcbiAgICAgICAgICAgIGlmIChmbkxlbmd0aCkgbm9ybWFsSW5kZXggICA9IGZuW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkluZGV4ID0gZnZbaV1bal07XG5cbiAgICAgICAgICAgIGluZGV4ID0gdmVydGV4Q2FjaGVbcG9zaXRpb25JbmRleCArICcsJyArIG5vcm1hbEluZGV4ICsgJywnICsgdGV4Q29vcmRJbmRleF07XG5cbiAgICAgICAgICAgIGlmKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGN1cnJlbnRJbmRleCsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRQb3MucHVzaCh2W3Bvc2l0aW9uSW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAoZm5MZW5ndGgpIG91dE5vcm1hbHMucHVzaChuW25vcm1hbEluZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKGZ0TGVuZ3RoKSBvdXRUZXhDb29yZC5wdXNoKHRbdGV4Q29vcmRJbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgdmVydGV4Q2FjaGVbcG9zaXRpb25JbmRleCArICcsJyArIG5vcm1hbEluZGV4ICsgJywnICsgdGV4Q29vcmRJbmRleF0gPSBpbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0SW5kaWNlc1tpXS5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRpY2VzOiBvdXRQb3MsXG4gICAgICAgIG5vcm1hbHM6IG91dE5vcm1hbHMsXG4gICAgICAgIHRleENvb3Jkczogb3V0VGV4Q29vcmQsXG4gICAgICAgIGluZGljZXM6IG91dEluZGljZXNcbiAgICB9XG59XG5cbi8qXG4gKiBGbGF0dGVucyBhbiBhcnJheSBvZiBhcnJheXMuIE5vdCByZWN1cnNpdmUuIEFzc3VtZXNcbiAqIGFsbCBjaGlsZHJlbiBhcmUgYXJyYXlzLlxuICpcbiAqIEBtZXRob2QgZmxhdHRlblxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgSW5wdXQgYXJyYXkgdG8gYmUgZmxhdHRlbmVkLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBGbGF0dGVuZWQgdmVyc2lvbiBvZiBpbnB1dCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnIpIHtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICB2YXIgb3V0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoLmFwcGx5KG91dCwgYXJyW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9CSkxvYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQm94OiByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvQm94JyksXG4gICAgQ2lyY2xlOiByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvQ2lyY2xlJyksXG4gICAgQ3lsaW5kZXI6IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9DeWxpbmRlcicpLFxuICAgIEdlb2Rlc2ljU3BoZXJlOiByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvR2VvZGVzaWNTcGhlcmUnKSxcbiAgICBJY29zYWhlZHJvbjogcmVxdWlyZSgnLi9wcmltaXRpdmVzL0ljb3NhaGVkcm9uJyksXG4gICAgUGFyYW1ldHJpY0NvbmU6IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9QYXJhbWV0cmljQ29uZScpLFxuICAgIFBsYW5lOiByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvUGxhbmUnKSxcbiAgICBTcGhlcmU6IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9TcGhlcmUnKSxcbiAgICBUZXRyYWhlZHJvbjogcmVxdWlyZSgnLi9wcmltaXRpdmVzL1RldHJhaGVkcm9uJyksXG4gICAgVG9ydXM6IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9Ub3J1cycpLFxuICAgIFRyaWFuZ2xlOiByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvVHJpYW5nbGUnKSxcbiAgICBHZW9tZXRyeUhlbHBlcjogcmVxdWlyZSgnLi9HZW9tZXRyeUhlbHBlcicpLFxuICAgIER5bmFtaWNHZW9tZXRyeTogcmVxdWlyZSgnLi9EeW5hbWljR2VvbWV0cnknKSxcbiAgICBHZW9tZXRyeTogcmVxdWlyZSgnLi9HZW9tZXRyeScpLFxuICAgIE9CSkxvYWRlcjogcmVxdWlyZSgnLi9PQkpMb2FkZXInKSxcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9HZW9tZXRyeScpO1xuXG5mdW5jdGlvbiBwaWNrT2N0YW50KGkpIHtcbiAgICByZXR1cm4gWyhpICYgMSkgKiAyIC0gMSwgKGkgJiAyKSAtIDEsIChpICYgNCkgLyAyIC0gMV07XG59XG5cbnZhciBib3hEYXRhID0gW1xuICAgIFswLCA0LCAyLCA2LCAtMSwgMCwgMF0sIFxuICAgIFsxLCAzLCA1LCA3LCArMSwgMCwgMF0sXG4gICAgWzAsIDEsIDQsIDUsIDAsIC0xLCAwXSxcbiAgICBbMiwgNiwgMywgNywgMCwgKzEsIDBdLFxuICAgIFswLCAyLCAxLCAzLCAwLCAwLCAtMV0sXG4gICAgWzQsIDUsIDYsIDcsIDAsIDAsICsxXVxuXTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBuZXcgc3RhdGljIGdlb21ldHJ5LCB3aGljaCBpcyBwYXNzZWRcbiAqIGN1c3RvbSBidWZmZXIgZGF0YS5cbiAqXG4gKiBAY2xhc3MgQm94R2VvbWV0cnlcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBhcmFtZXRlcnMgdGhhdCBhbHRlciB0aGVcbiAqIHZlcnRleCBidWZmZXJzIG9mIHRoZSBnZW5lcmF0ZWQgZ2VvbWV0cnkuXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gY29uc3RydWN0ZWQgZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gQm94R2VvbWV0cnkob3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciB2ZXJ0aWNlcyAgICAgID0gW107XG4gICAgdmFyIHRleHR1cmVDb29yZHMgPSBbXTtcbiAgICB2YXIgbm9ybWFscyAgICAgICA9IFtdO1xuICAgIHZhciBpbmRpY2VzICAgICAgID0gW107XG5cbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgZDtcbiAgICB2YXIgdjtcbiAgICB2YXIgaTtcbiAgICB2YXIgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBib3hEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGEgPSBib3hEYXRhW2ldLCB2ID0gaSAqIDQ7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgIGQgPSBkYXRhW2pdO1xuICAgICAgICAgICAgdmFyIG9jdGFudCA9IHBpY2tPY3RhbnQoZCk7XG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKG9jdGFudFswXSwgb2N0YW50WzFdLCBvY3RhbnRbMl0pO1xuICAgICAgICAgICAgdGV4dHVyZUNvb3Jkcy5wdXNoKGogJiAxLCAoaiAmIDIpIC8gMik7XG4gICAgICAgICAgICBub3JtYWxzLnB1c2goZGF0YVs0XSwgZGF0YVs1XSwgZGF0YVs2XSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kaWNlcy5wdXNoKHYsIHYgKyAxLCB2ICsgMik7XG4gICAgICAgIGluZGljZXMucHVzaCh2ICsgMiwgdiArIDEsIHYgKyAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgYnVmZmVyczogW1xuICAgICAgICAgICAgeyBuYW1lOiAncG9zJywgZGF0YTogdmVydGljZXMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3RleENvb3JkJywgZGF0YTogdGV4dHVyZUNvb3Jkcywgc2l6ZTogMiB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbm9ybWFscycsIGRhdGE6IG5vcm1hbHMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2luZGljZXMnLCBkYXRhOiBpbmRpY2VzLCBzaXplOiAxIH1cbiAgICAgICAgXVxuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3hHZW9tZXRyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlb21ldHJ5ICAgICAgID0gcmVxdWlyZSgnLi4vR2VvbWV0cnknKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBuZXcgc3RhdGljIGdlb21ldHJ5LCB3aGljaCBpcyBwYXNzZWRcbiAqIGN1c3RvbSBidWZmZXIgZGF0YS5cbiAqXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQYXJhbWV0ZXJzIHRoYXQgYWx0ZXIgdGhlXG4gKiB2ZXJ0ZXggYnVmZmVycyBvZiB0aGUgZ2VuZXJhdGVkIGdlb21ldHJ5LlxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbnN0cnVjdGVkIGdlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIENpcmNsZSAob3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zICA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGRldGFpbCAgID0gb3B0aW9ucy5kZXRhaWwgfHwgMzA7XG4gICAgdmFyIGJ1ZmZlcnMgID0gZ2V0QnVmZmVycyhkZXRhaWwpO1xuXG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIHR5cGU6ICdUUklBTkdMRV9GQU4nLFxuICAgICAgICBidWZmZXJzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdwb3MnLCBkYXRhOiBidWZmZXJzLnZlcnRpY2VzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICd0ZXhDb29yZCcsIGRhdGE6IGJ1ZmZlcnMudGV4dHVyZUNvb3Jkcywgc2l6ZTogMiB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbm9ybWFscycsIGRhdGE6IGJ1ZmZlcnMubm9ybWFscyB9XG4gICAgICAgIF1cbiAgICB9KTtcbn1cbiAgICBcbi8qKlxuICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyBhbGwgdmVydGV4IHBvc2l0aW9ucywgdGV4dHVyZVxuICogY29vcmRpbmF0ZXMgYW5kIG5vcm1hbHMgb2YgdGhlIGNpcmNsZSBwcmltaXRpdmUuXG4gKlxuICogQG1ldGhvZCBnZXRCdWZmZXJzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRldGFpbCBBbW91bnQgb2YgZGV0YWlsIHRoYXQgZGV0ZXJtaW5lcyBob3cgbWFueVxuICogdmVydGljZXMgYXJlIGNyZWF0ZWQgYW5kIHdoZXJlIHRoZXkgYXJlIHBsYWNlZFxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbnN0cnVjdGVkIGdlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIGdldEJ1ZmZlcnMoZGV0YWlsKSB7XG4gICAgdmFyIHRoZXRhID0gMDtcbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcbiAgICB2YXIgaW5kZXggPSBkZXRhaWwgKyAxO1xuICAgIHZhciBuZXh0VGhldGE7XG4gICAgdmFyIHZlcnRpY2VzICAgICAgPSBbMCwgMCwgMF07XG4gICAgdmFyIG5vcm1hbHMgICAgICAgPSBbMCwgMCwgMV07XG4gICAgdmFyIHRleHR1cmVDb29yZHMgPSBbMC41LCAwLjVdO1xuXG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdGhldGEgPSBpbmRleCAvIGRldGFpbCAqIE1hdGguUEkgKiAyO1xuXG4gICAgICAgIHggPSBNYXRoLmNvcyh0aGV0YSksIHkgPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgIHZlcnRpY2VzLnVuc2hpZnQoeCwgeSwgMCk7XG4gICAgICAgIG5vcm1hbHMudW5zaGlmdCgwLCAwLCAxKTtcbiAgICAgICAgdGV4dHVyZUNvb3Jkcy51bnNoaWZ0KDAuNSArIHggKiAwLjUsIDAuNSArIC15ICogMC41KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0aWNlczogdmVydGljZXMsXG4gICAgICAgIG5vcm1hbHM6IG5vcm1hbHMsXG4gICAgICAgIHRleHR1cmVDb29yZHM6IHRleHR1cmVDb29yZHNcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlb21ldHJ5ICAgICAgID0gcmVxdWlyZSgnLi4vR2VvbWV0cnknKTtcbnZhciBHZW9tZXRyeUhlbHBlciA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5SGVscGVyJyk7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBjcmVhdGVzIGEgbmV3IGdlb21ldHJ5IGluc3RhbmNlIGFuZCBzZXRzXG4gKiBpdHMgdmVydGV4IHBvc2l0aW9ucywgdGV4dHVyZSBjb29yZGluYXRlcywgbm9ybWFscyxcbiAqIGFuZCBpbmRpY2VzIHRvIGJhc2VkIG9uIHRoZSBwcmltaXRpdmUuXG4gKlxuICogQGNsYXNzIEN5bGluZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUGFyYW1ldGVycyB0aGF0IGFsdGVyIHRoZVxuICogdmVydGV4IGJ1ZmZlcnMgb2YgdGhlIGdlbmVyYXRlZCBnZW9tZXRyeS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbnN0cnVjdGVkIGdlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIEN5bGluZGVyIChvcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcmFkaXVzICAgPSBvcHRpb25zLnJhZGl1cyB8fCAxO1xuICAgIHZhciBkZXRhaWwgICA9IG9wdGlvbnMuZGV0YWlsIHx8IDE1O1xuICAgIHZhciBidWZmZXJzO1xuXG4gICAgYnVmZmVycyA9IEdlb21ldHJ5SGVscGVyLmdlbmVyYXRlUGFyYW1ldHJpYyhcbiAgICAgICAgMSxcbiAgICAgICAgZGV0YWlsLFxuICAgICAgICBDeWxpbmRlci5nZW5lcmF0b3IuYmluZChudWxsLCByYWRpdXMpXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBidWZmZXJzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdwb3MnLCBkYXRhOiBidWZmZXJzLnZlcnRpY2VzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICd0ZXhDb29yZCcsIGRhdGE6IEdlb21ldHJ5SGVscGVyLmdldFNwaGVyb2lkVVYoYnVmZmVycy52ZXJ0aWNlcyksIHNpemU6IDIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ25vcm1hbHMnLCBkYXRhOiBHZW9tZXRyeUhlbHBlci5jb21wdXRlTm9ybWFscyhidWZmZXJzLnZlcnRpY2VzLCBidWZmZXJzLmluZGljZXMpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogYnVmZmVycy5pbmRpY2VzLCBzaXplOiAxIH1cbiAgICAgICAgXVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgaW4gaXRlcmF0aXZlIGNvbnN0cnVjdGlvbiBvZiBwYXJhbWV0cmljIHByaW1pdGl2ZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdlbmVyYXRvclxuICogQHBhcmFtIHtOdW1iZXJ9IHIgQ3lsaW5kZXIgcmFkaXVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IHUgTG9uZ2l0dWRhbCBwcm9ncmVzcyBmcm9tIDAgdG8gUEkuXG4gKiBAcGFyYW0ge051bWJlcn0gdiBMYXRpdHVkYWwgcHJvZ3Jlc3MgZnJvbSAwIHRvIFBJLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSB4LCB5IGFuZCB6IGNvb3JkaW5hdGUgb2YgZ2VvbWV0cnkuXG4gKi9cbkN5bGluZGVyLmdlbmVyYXRvciA9IGZ1bmN0aW9uIGdlbmVyYXRvcihyLCB1LCB2LCBwb3MpIHtcbiAgICBwb3NbMF0gPSByICogTWF0aC5jb3Modik7XG4gICAgcG9zWzFdID0gciAqICgtMSArIHUgLyBNYXRoLlBJICogMik7XG4gICAgcG9zWzJdID0gciAqIE1hdGguc2luKHYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEN5bGluZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VvbWV0cnkgICAgICAgPSByZXF1aXJlKCcuLi9HZW9tZXRyeScpO1xudmFyIEdlb21ldHJ5SGVscGVyID0gcmVxdWlyZSgnLi4vR2VvbWV0cnlIZWxwZXInKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBuZXcgc3RhdGljIGdlb21ldHJ5LCB3aGljaCBpcyBwYXNzZWRcbiAqIGN1c3RvbSBidWZmZXIgZGF0YS5cbiAqXG4gKiBAY2xhc3MgR2VvZGVzaWNTcGhlcmVcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBhcmFtZXRlcnMgdGhhdCBhbHRlciB0aGVcbiAqIHZlcnRleCBidWZmZXJzIG9mIHRoZSBnZW5lcmF0ZWQgZ2VvbWV0cnkuXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gY29uc3RydWN0ZWQgZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gR2VvZGVzaWNTcGhlcmUgKG9wdGlvbnMpIHtcbiAgICB2YXIgdCA9ICgxICsgTWF0aC5zcXJ0KDUpKSAqIDAuNTtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAgICAgLSAxLCAgdCwgIDAsICAgIDEsICB0LCAgMCwgICAtIDEsIC0gdCwgIDAsICAgIDEsIC0gdCwgIDAsXG4gICAgICAgICAwLCAtIDEsIC10LCAgICAwLCAgMSwgLXQsICAgIDAsIC0gMSwgICB0LCAgICAwLCAgMSwgICB0LFxuICAgICAgICAgdCwgIDAsICAgMSwgICAgdCwgIDAsIC0xLCAgIC0gdCwgIDAsICAgMSwgICAtIHQsICAwLCAtMVxuICAgIF07XG4gICAgdmFyIGluZGljZXMgPSBbXG4gICAgICAgIDAsICA1LCAxMSwgICAgMCwgIDEsICA1LCAgICAwLCAgNywgIDEsICAgIDAsIDEwLCAgNywgICAgMCwgMTEsIDEwLFxuICAgICAgICAxLCAgOSwgIDUsICAgIDUsICA0LCAxMSwgICAgMTEsIDIsIDEwLCAgIDEwLCAgNiwgIDcsICAgIDcsICA4LCAgMSxcbiAgICAgICAgMywgIDQsICA5LCAgICAzLCAgMiwgIDQsICAgIDMsICA2LCAgMiwgICAgMywgIDgsICA2LCAgICAzLCAgOSwgIDgsXG4gICAgICAgIDQsICA1LCAgOSwgICAgMiwgMTEsICA0LCAgICA2LCAxMCwgIDIsICAgIDgsICA3LCAgNiwgICAgOSwgIDEsICA4XG4gICAgXTtcblxuICAgIHZlcnRpY2VzID0gR2VvbWV0cnlIZWxwZXIubm9ybWFsaXplQWxsKHZlcnRpY2VzKTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZGV0YWlsICA9IG9wdGlvbnMuZGV0YWlsIHx8IDM7XG5cbiAgICB3aGlsZSgtLWRldGFpbCkgR2VvbWV0cnlIZWxwZXIuc3ViZGl2aWRlU3BoZXJvaWQodmVydGljZXMsIGluZGljZXMpO1xuICAgIEdlb21ldHJ5SGVscGVyLmdldFVuaXF1ZUZhY2VzKHZlcnRpY2VzLCBpbmRpY2VzKTtcblxuICAgIHZhciBub3JtYWxzICAgICAgID0gR2VvbWV0cnlIZWxwZXIuY29tcHV0ZU5vcm1hbHModmVydGljZXMsIGluZGljZXMpO1xuICAgIHZhciB0ZXh0dXJlQ29vcmRzID0gR2VvbWV0cnlIZWxwZXIuZ2V0U3BoZXJvaWRVVih2ZXJ0aWNlcyk7XG5cbiAgICByZXR1cm4gbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgYnVmZmVyczogW1xuICAgICAgICAgICAgeyBuYW1lOiAncG9zJywgZGF0YTogdmVydGljZXMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3RleENvb3JkJywgZGF0YTogdGV4dHVyZUNvb3Jkcywgc2l6ZTogMiB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbm9ybWFscycsIGRhdGE6IG5vcm1hbHMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2luZGljZXMnLCBkYXRhOiBpbmRpY2VzLCBzaXplOiAxIH1cbiAgICAgICAgXVxuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb2Rlc2ljU3BoZXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9HZW9tZXRyeScpO1xudmFyIEdlb21ldHJ5SGVscGVyID0gcmVxdWlyZSgnLi4vR2VvbWV0cnlIZWxwZXInKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBuZXcgc3RhdGljIGdlb21ldHJ5LCB3aGljaCBpcyBwYXNzZWRcbiAqIGN1c3RvbSBidWZmZXIgZGF0YS5cbiAqXG4gKiBAY2xhc3MgSWNvc2FoZWRyb25cbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBhcmFtZXRlcnMgdGhhdCBhbHRlciB0aGVcbiAqIHZlcnRleCBidWZmZXJzIG9mIHRoZSBnZW5lcmF0ZWQgZ2VvbWV0cnkuXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gY29uc3RydWN0ZWQgZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gSWNvc2FoZWRyb24oKSB7XG4gICAgdmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcblxuICAgIHZhciBnZW9tZXRyeTtcbiAgICB2YXIgZGV0YWlsO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAgICAgLSAxLCAgIHQsICAwLCAgICAxLCAgdCwgIDAsICAgLSAxLCAtIHQsICAwLCAgICAxLCAtIHQsICAwLFxuICAgICAgICAgIDAsIC0gMSwgLXQsICAgIDAsICAxLCAtdCwgICAgIDAsIC0gMSwgIHQsICAgIDAsICAgMSwgIHQsXG4gICAgICAgICAgdCwgICAwLCAgMSwgICAgdCwgIDAsIC0xLCAgIC0gdCwgICAwLCAgMSwgIC0gdCwgICAwLCAtMVxuICAgIF07XG4gICAgdmFyIGluZGljZXMgPSBbXG4gICAgICAgIDAsICA1LCAxMSwgICAgMCwgIDEsICA1LCAgICAwLCAgNywgIDEsICAgIDAsIDEwLCAgNywgICAgMCwgMTEsIDEwLFxuICAgICAgICAxLCAgOSwgIDUsICAgIDUsICA0LCAxMSwgICAgMTEsIDIsIDEwLCAgIDEwLCAgNiwgIDcsICAgIDcsICA4LCAgMSxcbiAgICAgICAgMywgIDQsICA5LCAgICAzLCAgMiwgIDQsICAgIDMsICA2LCAgMiwgICAgMywgIDgsICA2LCAgICAzLCAgOSwgIDgsXG4gICAgICAgIDQsICA1LCAgOSwgICAgMiwgMTEsICA0LCAgICA2LCAxMCwgIDIsICAgIDgsICA3LCAgNiwgICAgOSwgIDEsICA4XG4gICAgXTtcblxuICAgIEdlb21ldHJ5SGVscGVyLmdldFVuaXF1ZUZhY2VzKHZlcnRpY2VzLCBpbmRpY2VzKTtcblxuICAgIHZhciBub3JtYWxzICAgICAgID0gR2VvbWV0cnlIZWxwZXIuY29tcHV0ZU5vcm1hbHModmVydGljZXMsIGluZGljZXMpO1xuICAgIHZhciB0ZXh0dXJlQ29vcmRzID0gR2VvbWV0cnlIZWxwZXIuZ2V0U3BoZXJvaWRVVih2ZXJ0aWNlcyk7XG5cbiAgICB2ZXJ0aWNlcyAgICAgID0gR2VvbWV0cnlIZWxwZXIubm9ybWFsaXplQWxsKHZlcnRpY2VzKTtcblxuICAgIHJldHVybiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBidWZmZXJzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdwb3MnLCBkYXRhOiB2ZXJ0aWNlcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAndGV4Q29vcmQnLCBkYXRhOiB0ZXh0dXJlQ29vcmRzLCBzaXplOiAyIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdub3JtYWxzJywgZGF0YTogbm9ybWFscyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnaW5kaWNlcycsIGRhdGE6IGluZGljZXMsIHNpemU6IDEgfVxuICAgICAgICBdXG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSWNvc2FoZWRyb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG52YXIgR2VvbWV0cnlIZWxwZXIgPSByZXF1aXJlKCcuLi9HZW9tZXRyeUhlbHBlcicpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBzdGF0aWMgZ2VvbWV0cnksIHdoaWNoIGlzIHBhc3NlZFxuICogY3VzdG9tIGJ1ZmZlciBkYXRhLlxuICpcbiAqIEBjbGFzcyBQYXJhbWV0cmljQ29uZVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUGFyYW1ldGVycyB0aGF0IGFsdGVyIHRoZVxuICogdmVydGV4IGJ1ZmZlcnMgb2YgdGhlIGdlbmVyYXRlZCBnZW9tZXRyeS5cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBQYXJhbWV0cmljQ29uZSAob3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zICA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGRldGFpbCAgID0gb3B0aW9ucy5kZXRhaWwgfHwgMTU7XG4gICAgdmFyIHJhZGl1cyAgID0gb3B0aW9ucy5yYWRpdXMgfHwgMSAvIE1hdGguUEk7XG5cbiAgICB2YXIgYnVmZmVycyA9IEdlb21ldHJ5SGVscGVyLmdlbmVyYXRlUGFyYW1ldHJpYyhcbiAgICAgICAgZGV0YWlsLFxuICAgICAgICBkZXRhaWwsXG4gICAgICAgIFBhcmFtZXRyaWNDb25lLmdlbmVyYXRvci5iaW5kKG51bGwsIHJhZGl1cylcbiAgICApO1xuXG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ3BvcycsIGRhdGE6IGJ1ZmZlcnMudmVydGljZXMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3RleENvb3JkJywgZGF0YTogR2VvbWV0cnlIZWxwZXIuZ2V0U3BoZXJvaWRVVihidWZmZXJzLnZlcnRpY2VzKSwgc2l6ZTogMiB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbm9ybWFscycsIGRhdGE6IEdlb21ldHJ5SGVscGVyLmNvbXB1dGVOb3JtYWxzKGJ1ZmZlcnMudmVydGljZXMsIGJ1ZmZlcnMuaW5kaWNlcykgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2luZGljZXMnLCBkYXRhOiBidWZmZXJzLmluZGljZXMsIHNpemU6IDEgfVxuICAgICAgICBdXG4gICAgfSk7XG59XG5cbi8qKlxuICogZnVuY3Rpb24gdXNlZCBpbiBpdGVyYXRpdmUgY29uc3RydWN0aW9uIG9mIHBhcmFtZXRyaWMgcHJpbWl0aXZlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2VuZXJhdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gciBDb25lIFJhZGl1cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSB1IExvbmdpdHVkYWwgcHJvZ3Jlc3MgZnJvbSAwIHRvIFBJLlxuICogQHBhcmFtIHtOdW1iZXJ9IHYgTGF0aXR1ZGFsIHByb2dyZXNzIGZyb20gMCB0byBQSS5cbiAqIEByZXR1cm4ge0FycmF5fSB4LCB5IGFuZCB6IGNvb3JkaW5hdGUgb2YgZ2VvbWV0cnkuXG4gKi9cblxuUGFyYW1ldHJpY0NvbmUuZ2VuZXJhdG9yID0gZnVuY3Rpb24gZ2VuZXJhdG9yKHIsIHUsIHYsIHBvcykge1xuICAgIHBvc1swXSA9IHIgKiB1ICogTWF0aC5zaW4odik7XG4gICAgcG9zWzFdID0gLXIgKiB1ICogTWF0aC5jb3Modik7XG4gICAgcG9zWzJdID0gLXU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyYW1ldHJpY0NvbmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbmV3IHN0YXRpYyBnZW9tZXRyeSwgd2hpY2ggaXMgcGFzc2VkXG4gKiBjdXN0b20gYnVmZmVyIGRhdGEuXG4gKlxuICogQGNsYXNzIFBsYW5lXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQYXJhbWV0ZXJzIHRoYXQgYWx0ZXIgdGhlXG4gKiB2ZXJ0ZXggYnVmZmVycyBvZiB0aGUgZ2VuZXJhdGVkIGdlb21ldHJ5LlxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbnN0cnVjdGVkIGdlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIFBsYW5lKG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGRldGFpbFggPSBvcHRpb25zLmRldGFpbFggfHwgb3B0aW9ucy5kZXRhaWwgfHwgMTtcbiAgICB2YXIgZGV0YWlsWSA9IG9wdGlvbnMuZGV0YWlsWSB8fCBvcHRpb25zLmRldGFpbCB8fCAxO1xuXG4gICAgdmFyIHZlcnRpY2VzICAgICAgPSBbXTtcbiAgICB2YXIgdGV4dHVyZUNvb3JkcyA9IFtdO1xuICAgIHZhciBub3JtYWxzICAgICAgID0gW107XG4gICAgdmFyIGluZGljZXMgICAgICAgPSBbXTtcblxuICAgIGZvciAodmFyIHkgPSAwOyB5IDw9IGRldGFpbFk7IHkrKykge1xuICAgICAgICB2YXIgdCA9IHkgLyBkZXRhaWxZO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8PSBkZXRhaWxYOyB4KyspIHtcbiAgICAgICAgICAgIHZhciBzID0geCAvIGRldGFpbFg7XG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKDIuICogKHMgLSAuNSksIDIgKiAodCAtIC41KSwgMCk7XG4gICAgICAgICAgICB0ZXh0dXJlQ29vcmRzLnB1c2gocywgMSAtIHQpO1xuICAgICAgICAgICAgbm9ybWFscy5wdXNoKDAsIDAsIDEpO1xuICAgICAgICAgICAgaWYgKHggPCBkZXRhaWxYICYmIHkgPCBkZXRhaWxZKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB4ICsgeSAqIChkZXRhaWxYICsgMSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGksIGkgKyAxLCBpICsgZGV0YWlsWCArIDEpO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpICsgZGV0YWlsWCArIDEsIGkgKyAxLCBpICsgZGV0YWlsWCArIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBidWZmZXJzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdwb3MnLCBkYXRhOiB2ZXJ0aWNlcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAndGV4Q29vcmQnLCBkYXRhOiB0ZXh0dXJlQ29vcmRzLCBzaXplOiAyIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdub3JtYWxzJywgZGF0YTogbm9ybWFscyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnaW5kaWNlcycsIGRhdGE6IGluZGljZXMsIHNpemU6IDEgfVxuICAgICAgICBdXG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsYW5lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9HZW9tZXRyeScpO1xudmFyIEdlb21ldHJ5SGVscGVyID0gcmVxdWlyZSgnLi4vR2VvbWV0cnlIZWxwZXInKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBuZXcgc3RhdGljIGdlb21ldHJ5LCB3aGljaCBpcyBwYXNzZWRcbiAqIGN1c3RvbSBidWZmZXIgZGF0YS5cbiAqXG4gKiBAY2xhc3MgUGFyYW1ldHJpY1NwaGVyZVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUGFyYW1ldGVycyB0aGF0IGFsdGVyIHRoZVxuICogdmVydGV4IGJ1ZmZlcnMgb2YgdGhlIGdlbmVyYXRlZCBnZW9tZXRyeS5cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBQYXJhbWV0cmljU3BoZXJlIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGRldGFpbCA9IG9wdGlvbnMuZGV0YWlsIHx8IDEwO1xuICAgIHZhciBkZXRhaWxYID0gb3B0aW9ucy5kZXRhaWxYIHx8IGRldGFpbDsgICAgXG4gICAgdmFyIGRldGFpbFkgPSBvcHRpb25zLmRldGFpbFkgfHwgZGV0YWlsO1xuXG4gICAgdmFyIGJ1ZmZlcnMgPSBHZW9tZXRyeUhlbHBlci5nZW5lcmF0ZVBhcmFtZXRyaWMoXG4gICAgICAgICAgZGV0YWlsWCxcbiAgICAgICAgICBkZXRhaWxZLFxuICAgICAgICAgIFBhcmFtZXRyaWNTcGhlcmUuZ2VuZXJhdG9yXG4gICAgKTtcblxuICAgIEdlb21ldHJ5SGVscGVyLmdldFVuaXF1ZUZhY2VzKGJ1ZmZlcnMudmVydGljZXMsIGJ1ZmZlcnMuaW5kaWNlcyk7XG5cbiAgICByZXR1cm4gbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgYnVmZmVyczogW1xuICAgICAgICAgICAgeyBuYW1lOiAncG9zJywgZGF0YTogYnVmZmVycy52ZXJ0aWNlcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAndGV4Q29vcmQnLCBkYXRhOiBHZW9tZXRyeUhlbHBlci5nZXRTcGhlcm9pZFVWKGJ1ZmZlcnMudmVydGljZXMpLCBzaXplOiAyIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdub3JtYWxzJywgZGF0YTogR2VvbWV0cnlIZWxwZXIuZ2V0U3BoZXJvaWROb3JtYWxzKGJ1ZmZlcnMudmVydGljZXMpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogYnVmZmVycy5pbmRpY2VzLCBzaXplOiAxIH1cbiAgICAgICAgXVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgaW4gaXRlcmF0aXZlIGNvbnN0cnVjdGlvbiBvZiBwYXJhbWV0cmljIHByaW1pdGl2ZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdlbmVyYXRvclxuICogQHBhcmFtIHtOdW1iZXJ9IHUgTG9uZ2l0dWRhbCBwcm9ncmVzcyBmcm9tIDAgdG8gUEkuXG4gKiBAcGFyYW0ge051bWJlcn0gdiBMYXRpdHVkYWwgcHJvZ3Jlc3MgZnJvbSAwIHRvIFBJLlxuICogQHJldHVybiB7QXJyYXl9IHgsIHkgYW5kIHogY29vcmRpbmF0ZXMgb2YgZ2VvbWV0cnlcbiAqL1xuUGFyYW1ldHJpY1NwaGVyZS5nZW5lcmF0b3IgPSBmdW5jdGlvbiBnZW5lcmF0b3IodSwgdiwgcG9zKSB7XG4gICAgdmFyIHggPSBNYXRoLnNpbih1KSAqIE1hdGguY29zKHYpO1xuICAgIHZhciB5ID0gTWF0aC5jb3ModSk7XG4gICAgdmFyIHogPSAtTWF0aC5zaW4odSkgKiBNYXRoLnNpbih2KTtcblxuICAgIHBvc1swXSA9IHg7XG4gICAgcG9zWzFdID0geTtcbiAgICBwb3NbMl0gPSB6O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbWV0cmljU3BoZXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9HZW9tZXRyeScpO1xudmFyIEdlb21ldHJ5SGVscGVyID0gcmVxdWlyZSgnLi4vR2VvbWV0cnlIZWxwZXInKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyBjdXN0b20gYnVmZmVycyBhbmQgcGFzc2VzIHRoZW0gdG9cbiAqIGEgbmV3IHN0YXRpYyBnZW9tZXRyeSwgd2hpY2ggaXMgcmV0dXJuZWQgdG8gdGhlIHVzZXIuXG4gKlxuICogQGNsYXNzIFRldHJhaGVkcm9uXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQYXJhbWV0ZXJzIHRoYXQgYWx0ZXIgdGhlXG4gKiB2ZXJ0ZXggYnVmZmVycyBvZiB0aGUgZ2VuZXJhdGVkIGdlb21ldHJ5LlxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbnN0cnVjdGVkIGdlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIFRldHJhaGVkcm9uKG9wdGlvbnMpIHtcbiAgICB2YXIgdGV4dHVyZUNvb3JkcyA9IFtdO1xuICAgIHZhciBub3JtYWxzID0gW107XG4gICAgdmFyIGdlb21ldHJ5O1xuICAgIHZhciBkZXRhaWw7XG4gICAgdmFyIGk7XG4gICAgdmFyIHQgPSBNYXRoLnNxcnQoMyk7XG4gICAgXG4gICAgdmFyIHZlcnRpY2VzID0gW1xuICAgICAgICAvLyBCYWNrIFxuICAgICAgICAgMSwgLTEsIC0xIC8gdCxcbiAgICAgICAgLTEsIC0xLCAtMSAvIHQsXG4gICAgICAgICAwLCAgMSwgIDAsXG4gICAgICAgIFxuICAgICAgICAvLyBSaWdodFxuICAgICAgICAgMCwgIDEsICAwLFxuICAgICAgICAgMCwgLTEsIHQgLSAxIC8gdCxcbiAgICAgICAgIDEsIC0xLCAtMSAvIHQsXG5cbiAgICAgICAgLy8gTGVmdFxuICAgICAgICAgMCwgIDEsICAwLFxuICAgICAgICAtMSwgLTEsIC0xIC8gdCxcbiAgICAgICAgIDAsIC0xLCAgdCAtIDEgLyB0LFxuXG4gICAgICAgIC8vIEJvdHRvbVxuICAgICAgICAgMCwgLTEsICB0IC0gMSAvIHQsXG4gICAgICAgIC0xLCAtMSwgLTEgLyB0LFxuICAgICAgICAgMSwgLTEsIC0xIC8gdCxcbiAgICBdO1xuXG4gICAgdmFyIGluZGljZXMgPSBbXG4gICAgICAgIDAsIDEsIDIsXG4gICAgICAgIDMsIDQsIDUsXG4gICAgICAgIDYsIDcsIDgsXG4gICAgICAgIDksIDEwLCAxMSxcbiAgICBdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICB0ZXh0dXJlQ29vcmRzLnB1c2goXG4gICAgICAgICAgICAwLjAsIDAuMCxcbiAgICAgICAgICAgIDAuNSwgMS4wLFxuICAgICAgICAgICAgMS4wLCAwLjBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBvcHRpb25zICAgICAgID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHdoaWxlKC0tZGV0YWlsKSBHZW9tZXRyeUhlbHBlci5zdWJkaXZpZGUoaW5kaWNlcywgdmVydGljZXMsIHRleHR1cmVDb29yZHMpO1xuICAgIG5vcm1hbHMgICAgICAgPSBHZW9tZXRyeUhlbHBlci5jb21wdXRlTm9ybWFscyh2ZXJ0aWNlcywgaW5kaWNlcyk7XG5cbiAgICByZXR1cm4gbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgYnVmZmVyczogW1xuICAgICAgICAgICAgeyBuYW1lOiAncG9zJywgZGF0YTogdmVydGljZXMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3RleENvb3JkJywgZGF0YTogdGV4dHVyZUNvb3Jkcywgc2l6ZTogMiB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbm9ybWFscycsIGRhdGE6IG5vcm1hbHMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2luZGljZXMnLCBkYXRhOiBpbmRpY2VzLCBzaXplOiAxIH1cbiAgICAgICAgXVxuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRldHJhaGVkcm9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9HZW9tZXRyeScpO1xudmFyIEdlb21ldHJ5SGVscGVyID0gcmVxdWlyZSgnLi4vR2VvbWV0cnlIZWxwZXInKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBuZXcgc3RhdGljIGdlb21ldHJ5LCB3aGljaCBpcyBwYXNzZWRcbiAqIGN1c3RvbSBidWZmZXIgZGF0YS5cbiAqXG4gKiBAY2xhc3MgVG9ydXNcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBhcmFtZXRlcnMgdGhhdCBhbHRlciB0aGVcbiAqIHZlcnRleCBidWZmZXJzIG9mIHRoZSBnZW5lcmF0ZWQgZ2VvbWV0cnkuXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gY29uc3RydWN0ZWQgZ2VvbWV0cnlcbiAqL1xuXG5mdW5jdGlvbiBUb3J1cyhvcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZGV0YWlsICAgPSBvcHRpb25zLmRldGFpbCB8fCAzMDtcbiAgICB2YXIgaG9sZVJhZGl1cyA9IG9wdGlvbnMuaG9sZVJhZGl1cyB8fCAwLjgwO1xuICAgIHZhciB0dWJlUmFkaXVzID0gb3B0aW9ucy50dWJlUmFkaXVzIHx8IDAuMjA7XG5cbiAgICB2YXIgYnVmZmVycyA9IEdlb21ldHJ5SGVscGVyLmdlbmVyYXRlUGFyYW1ldHJpYyhcbiAgICAgICAgZGV0YWlsLFxuICAgICAgICBkZXRhaWwsXG4gICAgICAgIFRvcnVzLmdlbmVyYXRvci5iaW5kKG51bGwsIGhvbGVSYWRpdXMsIHR1YmVSYWRpdXMpXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBidWZmZXJzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdwb3MnLCBkYXRhOiBidWZmZXJzLnZlcnRpY2VzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICd0ZXhDb29yZCcsIGRhdGE6IEdlb21ldHJ5SGVscGVyLmdldFNwaGVyb2lkVVYoYnVmZmVycy52ZXJ0aWNlcyksIHNpemU6IDIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ25vcm1hbHMnLCBkYXRhOiBHZW9tZXRyeUhlbHBlci5jb21wdXRlTm9ybWFscyhidWZmZXJzLnZlcnRpY2VzLCBidWZmZXJzLmluZGljZXMpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogYnVmZmVycy5pbmRpY2VzLCBzaXplOiAxIH1cbiAgICAgICAgXVxuICAgIH0pO1xufVxuXG4vKipcbiAqIGZ1bmN0aW9uIHVzZWQgaW4gaXRlcmF0aXZlIGNvbnN0cnVjdGlvbiBvZiBwYXJhbWV0cmljIHByaW1pdGl2ZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdlbmVyYXRvclxuICogQHBhcmFtIHtOdW1iZXJ9IGMgUmFkaXVzIG9mIGlubmVyIGhvbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gYSBSYWRpdXMgb2YgdHViZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB1IExvbmdpdHVkYWwgcHJvZ3Jlc3MgZnJvbSAwIHRvIFBJLlxuICogQHBhcmFtIHtOdW1iZXJ9IHYgTGF0aXR1ZGFsIHByb2dyZXNzIGZyb20gMCB0byBQSS5cbiAqIEByZXR1cm4ge0FycmF5fSB4LCB5IGFuZCB6IGNvb3JkaW5hdGUgb2YgdGhlIHZlcnRleC5cbiAqL1xuVG9ydXMuZ2VuZXJhdG9yID0gZnVuY3Rpb24gZ2VuZXJhdG9yKGMsIGEsIHUsIHYsIHBvcykge1xuICAgIHBvc1swXSA9IChjICsgYSAqIE1hdGguY29zKDIgKiB2KSkgKiBNYXRoLnNpbigyICogdSk7XG4gICAgcG9zWzFdID0gLShjICsgYSAqIE1hdGguY29zKDIgKiB2KSkgKiBNYXRoLmNvcygyICogdSk7XG4gICAgcG9zWzJdID0gYSAqIE1hdGguc2luKDIgKiB2KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUb3J1cztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlb21ldHJ5ICAgICAgID0gcmVxdWlyZSgnLi4vR2VvbWV0cnknKTtcbnZhciBHZW9tZXRyeUhlbHBlciA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5SGVscGVyJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbmV3IHN0YXRpYyBnZW9tZXRyeSwgd2hpY2ggaXMgcGFzc2VkXG4gKiBjdXN0b20gYnVmZmVyIGRhdGEuXG4gKlxuICogQGNsYXNzIFRyaWFuZ2xlXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQYXJhbWV0ZXJzIHRoYXQgYWx0ZXIgdGhlXG4gKiB2ZXJ0ZXggYnVmZmVycyBvZiB0aGUgZ2VuZXJhdGVkIGdlb21ldHJ5LlxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbnN0cnVjdGVkIGdlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIFRyaWFuZ2xlIChvcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZGV0YWlsICAgPSBvcHRpb25zLmRldGFpbCB8fCAxO1xuICAgIHZhciBub3JtYWxzICA9IFtdO1xuICAgIHZhciB0ZXh0dXJlQ29vcmRzID0gW1xuICAgICAgICAwLjAsIDAuMCxcbiAgICAgICAgMC41LCAxLjAsXG4gICAgICAgIDEuMCwgMC4wXG4gICAgXTtcbiAgICB2YXIgaW5kaWNlcyAgPSBbXG4gICAgICAgIDAsIDEsIDJcbiAgICBdO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAgICAgLTEsICAxLCAwLFxuICAgICAgICAgMCwgLTEsIDAsXG4gICAgICAgICAxLCAgMSwgMFxuICAgIF07XG5cbiAgICB3aGlsZSgtLWRldGFpbCkgR2VvbWV0cnlIZWxwZXIuc3ViZGl2aWRlKGluZGljZXMsIHZlcnRpY2VzLCB0ZXh0dXJlQ29vcmRzKTtcbiAgICBub3JtYWxzICAgICAgID0gR2VvbWV0cnlIZWxwZXIuY29tcHV0ZU5vcm1hbHModmVydGljZXMsIGluZGljZXMpO1xuXG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ3BvcycsIGRhdGE6IHZlcnRpY2VzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICd0ZXhDb29yZCcsIGRhdGE6IHRleHR1cmVDb29yZHMsIHNpemU6IDIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ25vcm1hbHMnLCBkYXRhOiBub3JtYWxzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogaW5kaWNlcywgc2l6ZTogMSB9XG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmlhbmdsZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gbm9vcFxuXG5mdW5jdGlvbiBub29wKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnWW91IHNob3VsZCBidW5kbGUgeW91ciBjb2RlICcgK1xuICAgICAgJ3VzaW5nIGBnbHNsaWZ5YCBhcyBhIHRyYW5zZm9ybS4nXG4gIClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcHJvZ3JhbWlmeVxuXG5mdW5jdGlvbiBwcm9ncmFtaWZ5KHZlcnRleCwgZnJhZ21lbnQsIHVuaWZvcm1zLCBhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiB7XG4gICAgdmVydGV4OiB2ZXJ0ZXgsIFxuICAgIGZyYWdtZW50OiBmcmFnbWVudCxcbiAgICB1bmlmb3JtczogdW5pZm9ybXMsIFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNcbiAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGdsc2xpZnkgPSByZXF1aXJlKFwiZ2xzbGlmeVwiKTtcbnZhciBzaGFkZXJzID0gcmVxdWlyZShcImdsc2xpZnkvc2ltcGxlLWFkYXB0ZXIuanNcIikoXCJcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbm1hdDMgYV94X2dldE5vcm1hbE1hdHJpeChpbiBtYXQ0IHQpIHtcXG4gIG1hdDMgbWF0Tm9ybTtcXG4gIG1hdDQgYSA9IHQ7XFxuICBmbG9hdCBhMDAgPSBhWzBdWzBdLCBhMDEgPSBhWzBdWzFdLCBhMDIgPSBhWzBdWzJdLCBhMDMgPSBhWzBdWzNdLCBhMTAgPSBhWzFdWzBdLCBhMTEgPSBhWzFdWzFdLCBhMTIgPSBhWzFdWzJdLCBhMTMgPSBhWzFdWzNdLCBhMjAgPSBhWzJdWzBdLCBhMjEgPSBhWzJdWzFdLCBhMjIgPSBhWzJdWzJdLCBhMjMgPSBhWzJdWzNdLCBhMzAgPSBhWzNdWzBdLCBhMzEgPSBhWzNdWzFdLCBhMzIgPSBhWzNdWzJdLCBhMzMgPSBhWzNdWzNdLCBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCwgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLCBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSwgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLCBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCwgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLCBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSwgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLCBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XFxuICBkZXQgPSAxLjAgLyBkZXQ7XFxuICBtYXROb3JtWzBdWzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XFxuICBtYXROb3JtWzBdWzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XFxuICBtYXROb3JtWzBdWzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XFxuICBtYXROb3JtWzFdWzBdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XFxuICBtYXROb3JtWzFdWzFdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XFxuICBtYXROb3JtWzFdWzJdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XFxuICBtYXROb3JtWzJdWzBdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XFxuICBtYXROb3JtWzJdWzFdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XFxuICBtYXROb3JtWzJdWzJdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XFxuICByZXR1cm4gbWF0Tm9ybTtcXG59XFxuZmxvYXQgYl94X2ludmVyc2UoZmxvYXQgbSkge1xcbiAgcmV0dXJuIDEuMCAvIG07XFxufVxcbm1hdDIgYl94X2ludmVyc2UobWF0MiBtKSB7XFxuICByZXR1cm4gbWF0MihtWzFdWzFdLCAtbVswXVsxXSwgLW1bMV1bMF0sIG1bMF1bMF0pIC8gKG1bMF1bMF0gKiBtWzFdWzFdIC0gbVswXVsxXSAqIG1bMV1bMF0pO1xcbn1cXG5tYXQzIGJfeF9pbnZlcnNlKG1hdDMgbSkge1xcbiAgZmxvYXQgYTAwID0gbVswXVswXSwgYTAxID0gbVswXVsxXSwgYTAyID0gbVswXVsyXTtcXG4gIGZsb2F0IGExMCA9IG1bMV1bMF0sIGExMSA9IG1bMV1bMV0sIGExMiA9IG1bMV1bMl07XFxuICBmbG9hdCBhMjAgPSBtWzJdWzBdLCBhMjEgPSBtWzJdWzFdLCBhMjIgPSBtWzJdWzJdO1xcbiAgZmxvYXQgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxO1xcbiAgZmxvYXQgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMDtcXG4gIGZsb2F0IGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMDtcXG4gIGZsb2F0IGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcXG4gIHJldHVybiBtYXQzKGIwMSwgKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpLCAoYTEyICogYTAxIC0gYTAyICogYTExKSwgYjExLCAoYTIyICogYTAwIC0gYTAyICogYTIwKSwgKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApLCBiMjEsICgtYTIxICogYTAwICsgYTAxICogYTIwKSwgKGExMSAqIGEwMCAtIGEwMSAqIGExMCkpIC8gZGV0O1xcbn1cXG5tYXQ0IGJfeF9pbnZlcnNlKG1hdDQgbSkge1xcbiAgZmxvYXQgYTAwID0gbVswXVswXSwgYTAxID0gbVswXVsxXSwgYTAyID0gbVswXVsyXSwgYTAzID0gbVswXVszXSwgYTEwID0gbVsxXVswXSwgYTExID0gbVsxXVsxXSwgYTEyID0gbVsxXVsyXSwgYTEzID0gbVsxXVszXSwgYTIwID0gbVsyXVswXSwgYTIxID0gbVsyXVsxXSwgYTIyID0gbVsyXVsyXSwgYTIzID0gbVsyXVszXSwgYTMwID0gbVszXVswXSwgYTMxID0gbVszXVsxXSwgYTMyID0gbVszXVsyXSwgYTMzID0gbVszXVszXSwgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCwgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMiwgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCwgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMiwgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xcbiAgcmV0dXJuIG1hdDQoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5LCBhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDksIGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMywgYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzLCBhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcsIGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNywgYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxLCBhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEsIGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNiwgYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2LCBhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDAsIGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCwgYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2LCBhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYsIGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCwgYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAvIGRldDtcXG59XFxuZmxvYXQgY194X3RyYW5zcG9zZShmbG9hdCBtKSB7XFxuICByZXR1cm4gbTtcXG59XFxubWF0MiBjX3hfdHJhbnNwb3NlKG1hdDIgbSkge1xcbiAgcmV0dXJuIG1hdDIobVswXVswXSwgbVsxXVswXSwgbVswXVsxXSwgbVsxXVsxXSk7XFxufVxcbm1hdDMgY194X3RyYW5zcG9zZShtYXQzIG0pIHtcXG4gIHJldHVybiBtYXQzKG1bMF1bMF0sIG1bMV1bMF0sIG1bMl1bMF0sIG1bMF1bMV0sIG1bMV1bMV0sIG1bMl1bMV0sIG1bMF1bMl0sIG1bMV1bMl0sIG1bMl1bMl0pO1xcbn1cXG5tYXQ0IGNfeF90cmFuc3Bvc2UobWF0NCBtKSB7XFxuICByZXR1cm4gbWF0NChtWzBdWzBdLCBtWzFdWzBdLCBtWzJdWzBdLCBtWzNdWzBdLCBtWzBdWzFdLCBtWzFdWzFdLCBtWzJdWzFdLCBtWzNdWzFdLCBtWzBdWzJdLCBtWzFdWzJdLCBtWzJdWzJdLCBtWzNdWzJdLCBtWzBdWzNdLCBtWzFdWzNdLCBtWzJdWzNdLCBtWzNdWzNdKTtcXG59XFxudmVjNCBhcHBseVRyYW5zZm9ybSh2ZWM0IHBvcykge1xcbiAgbWF0NCBNVk1hdHJpeCA9IHZpZXcgKiB0cmFuc2Zvcm07XFxuICBwb3MueCArPSAxLjA7XFxuICBwb3MueSAtPSAxLjA7XFxuICBwb3MueHl6ICo9IHNpemUgKiAwLjU7XFxuICBwb3MueSAqPSAtMS4wO1xcbiAgdl9Qb3NpdGlvbiA9IChNVk1hdHJpeCAqIHBvcykueHl6O1xcbiAgTVZNYXRyaXhbMF1bMV0gKj0gLTEuMDtcXG4gIE1WTWF0cml4WzFdWzFdICo9IC0xLjA7XFxuICBNVk1hdHJpeFsyXVsxXSAqPSAtMS4wO1xcbiAgTVZNYXRyaXhbM11bMV0gKj0gLTEuMDtcXG4gIG1hdDQgTVZQTWF0cml4ID0gcGVyc3BlY3RpdmUgKiBNVk1hdHJpeDtcXG4gIHBvcyA9IE1WUE1hdHJpeCAqIHBvcztcXG4gIHBvcy54IC89IChyZXNvbHV0aW9uLnggKiAwLjUpO1xcbiAgcG9zLnkgLz0gKHJlc29sdXRpb24ueSAqIDAuNSk7XFxuICBwb3MueCAtPSAxLjA7XFxuICBwb3MueSArPSAxLjA7XFxuICBwb3MueiAqPSAtMC4wMDAwMTtcXG4gIHJldHVybiBwb3M7XFxufVxcbiN2ZXJ0X2RlZmluaXRpb25zXFxuXFxudmVjMyBjYWxjdWxhdGVPZmZzZXQodmVjMyBJRCkge1xcbiAgXFxuICAjdmVydF9hcHBsaWNhdGlvbnNcXG4gIHJldHVybiB2ZWMzKDAuMCk7XFxufVxcbnZvaWQgbWFpbigpIHtcXG4gIGdsX1BvaW50U2l6ZSA9IDEwLjA7XFxuICB2ZWMzIGludmVydGVkTm9ybWFscyA9IG5vcm1hbHM7XFxuICBpbnZlcnRlZE5vcm1hbHMueSAqPSAtMS4wO1xcbiAgdl9Ob3JtYWwgPSBjX3hfdHJhbnNwb3NlKG1hdDMoYl94X2ludmVyc2UodHJhbnNmb3JtKSkpICogaW52ZXJ0ZWROb3JtYWxzO1xcbiAgdl9UZXh0dXJlQ29vcmRpbmF0ZSA9IHRleENvb3JkO1xcbiAgdmVjMyBvZmZzZXRQb3MgPSBwb3MgKyBjYWxjdWxhdGVPZmZzZXQocG9zaXRpb25PZmZzZXQpO1xcbiAgZ2xfUG9zaXRpb24gPSBhcHBseVRyYW5zZm9ybSh2ZWM0KG9mZnNldFBvcywgMS4wKSk7XFxufVwiLCBcIlxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuI2Zsb2F0X2RlZmluaXRpb25zXFxuXFxuZmxvYXQgYV94X2FwcGx5TWF0ZXJpYWwoZmxvYXQgSUQpIHtcXG4gIFxcbiAgI2Zsb2F0X2FwcGxpY2F0aW9uc1xcbiAgcmV0dXJuIDEuO1xcbn1cXG4jdmVjX2RlZmluaXRpb25zXFxuXFxudmVjMyBhX3hfYXBwbHlNYXRlcmlhbCh2ZWMzIElEKSB7XFxuICBcXG4gICN2ZWNfYXBwbGljYXRpb25zXFxuICByZXR1cm4gdmVjMyguNSk7XFxufVxcbnZlYzMgYl94X2FwcGx5TGlnaHQoaW4gdmVjMyBtYXRlcmlhbCkge1xcbiAgaW50IG51bUxpZ2h0cyA9IGludCh1X051bUxpZ2h0cyk7XFxuICBmbG9hdCBsYW1iZXJ0aWFuVGVybTtcXG4gIHZlYzMgZmluYWxDb2xvciA9IHZlYzMoMC4wKTtcXG4gIHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKHZfTm9ybWFsKTtcXG4gIHZlYzMgYW1iaWVudExpZ2h0ID0gdV9BbWJpZW50TGlnaHQgKiBtYXRlcmlhbDtcXG4gIHZlYzMgZXllVmVjdG9yID0gdmVjMygtdl9Qb3NpdGlvbik7XFxuICB2ZWMzIGRpZmZ1c2UsIHNwZWN1bGFyLCBsaWdodERpcmVjdGlvbjtcXG4gIGZvcihpbnQgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG4gICAgaWYoaSA+PSBudW1MaWdodHMpXFxuICAgICAgYnJlYWs7XFxuICAgIGRpZmZ1c2UgPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcbiAgICBzcGVjdWxhciA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuICAgIGxpZ2h0RGlyZWN0aW9uID0gbm9ybWFsaXplKHVfTGlnaHRQb3NpdGlvbltpXS54eXogLSB2X1Bvc2l0aW9uKTtcXG4gICAgbGFtYmVydGlhblRlcm0gPSBkb3QobGlnaHREaXJlY3Rpb24sIG5vcm1hbCk7XFxuICAgIGlmKGxhbWJlcnRpYW5UZXJtID4gMC4wICYmIGdsb3NzaW5lc3MgPiAwLjApIHtcXG4gICAgICBkaWZmdXNlID0gbWF0ZXJpYWwgKiBsYW1iZXJ0aWFuVGVybTtcXG4gICAgICB2ZWMzIEUgPSBub3JtYWxpemUoZXllVmVjdG9yKTtcXG4gICAgICB2ZWMzIFIgPSByZWZsZWN0KGxpZ2h0RGlyZWN0aW9uLCBub3JtYWwpO1xcbiAgICAgIGZsb2F0IHNwZWN1bGFyV2VpZ2h0ID0gcG93KG1heChkb3QoUiwgRSksIDAuMCksIGdsb3NzaW5lc3MpO1xcbiAgICAgIHNwZWN1bGFyID0gdV9MaWdodENvbG9yW2ldLnJnYiAqIHNwZWN1bGFyV2VpZ2h0O1xcbiAgICAgIGZpbmFsQ29sb3IgKz0gZGlmZnVzZSArIHNwZWN1bGFyO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGxhbWJlcnRpYW5UZXJtID0gbWF4KGxhbWJlcnRpYW5UZXJtLCAwLjApO1xcbiAgICAgIGZpbmFsQ29sb3IgKz0gdV9MaWdodENvbG9yW2ldLnJnYiAqIG1hdGVyaWFsICogbGFtYmVydGlhblRlcm07XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBhbWJpZW50TGlnaHQgKyBmaW5hbENvbG9yO1xcbn1cXG52b2lkIG1haW4oKSB7XFxuICB2ZWMzIG1hdGVyaWFsID0gYmFzZUNvbG9yLnIgPj0gMC4wID8gYmFzZUNvbG9yIDogYV94X2FwcGx5TWF0ZXJpYWwoYmFzZUNvbG9yKTtcXG4gIGJvb2wgbGlnaHRzRW5hYmxlZCA9ICh1X0ZsYXRTaGFkaW5nID09IDAuMCkgJiYgKHVfTnVtTGlnaHRzID4gMC4wIHx8IGxlbmd0aCh1X0FtYmllbnRMaWdodCkgPiAwLjApO1xcbiAgdmVjMyBjb2xvciA9IGxpZ2h0c0VuYWJsZWQgPyBiX3hfYXBwbHlMaWdodChtYXRlcmlhbCkgOiBtYXRlcmlhbDtcXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xcbiAgaWYoaW50KGJhc2VDb2xvci5yKSA9PSAtMSlcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKGltYWdlLCB2X1RleHR1cmVDb29yZGluYXRlKTtcXG4gIFxcbn1cIiwgW10sIFtdKTtcbm1vZHVsZS5leHBvcnRzID0gc2hhZGVyczsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQnVmZmVyIGlzIGEgcHJpdmF0ZSBjbGFzcyB0aGF0IHdyYXBzIHRoZSB2ZXJ0ZXggZGF0YSB0aGF0IGRlZmluZXNcbiAqIHRoZSB0aGUgcG9pbnRzIG9mIHRoZSB0cmlhbmdsZXMgdGhhdCB3ZWJnbCBkcmF3cy4gRWFjaCBidWZmZXIgXG4gKiBtYXBzIHRvIG9uZSBhdHRyaWJ1dGUgb2YgYSBtZXNoLlxuICogXG4gKiBAY2xhc3MgQnVmZmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIFxuICogQHBhcmFtIHtOdW1iZXJ9IHRhcmdldCBUaGUgYmluZCB0YXJnZXQgb2YgdGhlIGJ1ZmZlciB0byB1cGRhdGU6IEFSUkFZX0JVRkZFUiBvciBFTEVNRU5UX0FSUkFZX0JVRkZFUlxuICogQHBhcmFtIHtPYmplY3R9IHR5cGUgQXJyYXkgdHlwZSB0byBiZSB1c2VkIGluIGNhbGxzIHRvIGdsLmJ1ZmZlckRhdGEuXG4gKiBAcGFyYW0ge1dlYkdMQ29udGV4dH0gZ2wgVGhlIFdlYkdMIGNvbnRleHQgdGhhdCB0aGUgYnVmZmVyIGlzIGhvc3RlZCBieS5cbiAqIFxuICovXG5mdW5jdGlvbiBCdWZmZXIodGFyZ2V0LCB0eXBlLCBnbCkge1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuZ2wgPSBnbDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgV2ViR0wgYnVmZmVyIGlmIG9uZSBkb2VzIG5vdCB5ZXQgZXhpc3QgYW5kIGJpbmRzIHRoZSBidWZmZXIgdG9cbiAqIHRvIHRoZSBjb250ZXh0LiAgUnVucyBidWZmZXJEYXRhIHdpdGggYXBwcm9wcmlhdGUgZGF0YS5cbiAqIFxuICogQG1ldGhvZCBzdWJEYXRhXG4gKiBcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5zdWJEYXRhID0gZnVuY3Rpb24gc3ViRGF0YSgpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBkYXRhID0gW107XG5cbiAgICAvLyB0byBwcmV2ZW50IGFnYWluc3QgbWF4aW11bSBjYWxsLXN0YWNrIGlzc3VlLlxuICAgIGZvciAodmFyIGkgPSAwLCBjaHVuayA9IDEwMDAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSBjaHVuaylcbiAgICAgICAgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoZGF0YSwgdGhpcy5kYXRhLnNsaWNlKGksIGkgKyBjaHVuaykpO1xuXG4gICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlciB8fCBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKHRoaXMudGFyZ2V0LCB0aGlzLmJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YSh0aGlzLnRhcmdldCwgbmV3IHRoaXMudHlwZShkYXRhKSwgZ2wuU1RBVElDX0RSQVcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBJTkRJQ0VTID0gJ2luZGljZXMnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9CdWZmZXInKTtcblxuLyoqXG4gKiBCdWZmZXJSZWdpc3RyeSBpcyBhIGNsYXNzIHRoYXQgbWFuYWdlcyBhbGxvY2F0aW9uIG9mIGJ1ZmZlcnMgdG9cbiAqIGlucHV0IGdlb21ldHJpZXMuXG4gKiBcbiAqIEBjbGFzcyBCdWZmZXJSZWdpc3RyeVxuICogQGNvbnN0cnVjdG9yXG4gKiBcbiAqIEBwYXJhbSB7V2ViR0xDb250ZXh0fSBjb250ZXh0IFdlYkdMIGRyYXdpbmcgY29udGV4dCB0byBiZSBwYXNzZWQgdG8gYnVmZmVycy5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyUmVnaXN0cnkoY29udGV4dCkge1xuICAgIHRoaXMuZ2wgPSBjb250ZXh0O1xuXG4gICAgdGhpcy5yZWdpc3RyeSA9IHt9O1xuICAgIHRoaXMuX2R5bmFtaWNCdWZmZXJzID0gW107XG4gICAgdGhpcy5fc3RhdGljQnVmZmVycyA9IFtdO1xuICAgIFxuICAgIHRoaXMuX2FycmF5QnVmZmVyTWF4ID0gMzAwMDA7XG4gICAgdGhpcy5fZWxlbWVudEJ1ZmZlck1heCA9IDMwMDAwO1xufVxuXG4vKipcbiAqIEJpbmRzIGFuZCBmaWxscyBhbGwgdGhlIHZlcnRleCBkYXRhIGludG8gd2ViZ2wgYnVmZmVycy4gIFdpbGwgcmV1c2UgYnVmZmVycyBpZlxuICogcG9zc2libGUuICBQb3B1bGF0ZXMgcmVnaXN0cnkgd2l0aCB0aGUgbmFtZSBvZiB0aGUgYnVmZmVyLCB0aGUgV2ViR0wgYnVmZmVyXG4gKiBvYmplY3QsIHNwYWNpbmcgb2YgdGhlIGF0dHJpYnV0ZSwgdGhlIGF0dHJpYnV0ZSdzIG9mZnNldCB3aXRoaW4gdGhlIGJ1ZmZlciwgXG4gKiBhbmQgZmluYWxseSB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIuICBUaGlzIGluZm9ybWF0aW9uIGlzIGxhdGVyIGFjY2Vzc2VkIGJ5XG4gKiB0aGUgcm9vdCB0byBkcmF3IHRoZSBidWZmZXJzLlxuICpcbiAqIEBtZXRob2QgYWxsb2NhdGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZ2VvbWV0cnlJZCBJZCBvZiB0aGUgZ2VvbWV0cnkgaW5zdGFuY2UgdGhhdCBob2xkcyB0aGUgYnVmZmVycy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEtleSBvZiB0aGUgaW5wdXQgYnVmZmVyIGluIHRoZSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIEZsYXQgYXJyYXkgY29udGFpbmluZyBpbnB1dCBkYXRhIGZvciBidWZmZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhY2luZyBUaGUgc3BhY2luZywgb3IgaXRlbVNpemUsIG9mIHRoZSBpbnB1dCBidWZmZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGR5bmFtaWMgQm9vbGVhbiBkZW5vdGluZyB3aGV0aGVyIGEgZ2VvbWV0cnkgaXMgZHluYW1pYyBvciBzdGF0aWMuXG4gKi9cbkJ1ZmZlclJlZ2lzdHJ5LnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uIGFsbG9jYXRlKGdlb21ldHJ5SWQsIG5hbWUsIHZhbHVlLCBzcGFjaW5nLCBkeW5hbWljKSB7XG4gICAgdmFyIHZlcnRleEJ1ZmZlcnMgPSB0aGlzLnJlZ2lzdHJ5W2dlb21ldHJ5SWRdIHx8ICh0aGlzLnJlZ2lzdHJ5W2dlb21ldHJ5SWRdID0geyBrZXlzOiBbXSwgdmFsdWVzOiBbXSwgc3BhY2luZzogW10sIG9mZnNldDogW10sIGxlbmd0aDogW10gfSk7XG5cbiAgICB2YXIgaiA9IHZlcnRleEJ1ZmZlcnMua2V5cy5pbmRleE9mKG5hbWUpO1xuICAgIHZhciBpc0luZGV4ID0gbmFtZSA9PT0gSU5ESUNFUztcbiAgICB2YXIgYnVmZmVyRm91bmQgPSBmYWxzZTtcbiAgICB2YXIgbmV3T2Zmc2V0O1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBsZW5ndGg7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICB2YXIgaztcblxuICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICBqID0gdmVydGV4QnVmZmVycy5rZXlzLmxlbmd0aDtcbiAgICAgICAgbGVuZ3RoID0gaXNJbmRleCA/IHZhbHVlLmxlbmd0aCA6IE1hdGguZmxvb3IodmFsdWUubGVuZ3RoIC8gc3BhY2luZyk7XG5cbiAgICAgICAgaWYgKGR5bmFtaWMpIHtcblxuICAgICAgICAgICAgLy8gVXNlIGEgcHJldmlvdXNseSBjcmVhdGVkIGJ1ZmZlciBpZiBhdmFpbGFibGUuXG5cbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCB0aGlzLl9zdGF0aWNCdWZmZXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5kZXggPT09IHRoaXMuX3N0YXRpY0J1ZmZlcnNba10uaXNJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPZmZzZXQgPSB0aGlzLl9zdGF0aWNCdWZmZXJzW2tdLm9mZnNldCArIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghaXNJbmRleCAmJiBuZXdPZmZzZXQgPCB0aGlzLl9hcnJheUJ1ZmZlck1heCkgfHwgKGlzSW5kZXggJiYgbmV3T2Zmc2V0IDwgdGhpcy5fZWxlbWVudEJ1ZmZlck1heCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuX3N0YXRpY0J1ZmZlcnNba10uYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fc3RhdGljQnVmZmVyc1trXS5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0aWNCdWZmZXJzW2tdLm9mZnNldCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHN0YXRpYyBidWZmZXIgaW4gbm9uZSB3ZXJlIGZvdW5kLlxuXG4gICAgICAgICAgICBpZiAoIWJ1ZmZlckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IEJ1ZmZlcihcbiAgICAgICAgICAgICAgICAgICAgaXNJbmRleCA/IHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgOiB0aGlzLmdsLkFSUkFZX0JVRkZFUixcbiAgICAgICAgICAgICAgICAgICAgaXNJbmRleCA/IFVpbnQxNkFycmF5IDogRmxvYXQzMkFycmF5LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRpY0J1ZmZlcnMucHVzaCh7IGJ1ZmZlcjogYnVmZmVyLCBvZmZzZXQ6IHZhbHVlLmxlbmd0aCwgaXNJbmRleDogaXNJbmRleCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gRm9yIGR5bmFtaWMgZ2VvbWV0cmllcywgYWx3YXlzIGNyZWF0ZSBuZXcgYnVmZmVyLlxuXG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgQnVmZmVyKFxuICAgICAgICAgICAgICAgIGlzSW5kZXggPyB0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSIDogdGhpcy5nbC5BUlJBWV9CVUZGRVIsXG4gICAgICAgICAgICAgICAgaXNJbmRleCA/IFVpbnQxNkFycmF5IDogRmxvYXQzMkFycmF5LFxuICAgICAgICAgICAgICAgIHRoaXMuZ2xcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNCdWZmZXJzLnB1c2goeyBidWZmZXI6IGJ1ZmZlciwgb2Zmc2V0OiB2YWx1ZS5sZW5ndGggfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlZ2lzdHJ5IGZvciB0aGUgc3BlYyB3aXRoIGJ1ZmZlciBpbmZvcm1hdGlvbi5cblxuICAgICAgICB2ZXJ0ZXhCdWZmZXJzLmtleXMucHVzaChuYW1lKTtcbiAgICAgICAgdmVydGV4QnVmZmVycy52YWx1ZXMucHVzaChidWZmZXIpO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJzLnNwYWNpbmcucHVzaChzcGFjaW5nKTtcbiAgICAgICAgdmVydGV4QnVmZmVycy5vZmZzZXQucHVzaChvZmZzZXQpO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJzLmxlbmd0aC5wdXNoKGxlbmd0aCk7XG4gICAgfVxuICAgIFxuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBsZW47IGsrKykge1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJzLnZhbHVlc1tqXS5kYXRhW29mZnNldCArIGtdID0gdmFsdWVba107XG4gICAgfVxuICAgIHZlcnRleEJ1ZmZlcnMudmFsdWVzW2pdLnN1YkRhdGEoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVnaXN0cnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEdlbmVyYXRlcyBhIGNoZWNrZXJib2FyZCBwYXR0ZXJuIHRvIGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciB0ZXh0dXJlXG4vLyB3aGlsZSBhbiBpbWFnZSBsb2FkcyBvdmVyIHRoZSBuZXR3b3JrLlxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG4gICAgY29udGV4dC5jYW52YXMud2lkdGggPSBjb250ZXh0LmNhbnZhcy5oZWlnaHQgPSAxMjg7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjb250ZXh0LmNhbnZhcy5oZWlnaHQ7IHkgKz0gMTYpIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjb250ZXh0LmNhbnZhcy53aWR0aDsgeCArPSAxNikge1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAoeCBeIHkpICYgMTYgPyAnI0ZGRicgOiAnI0RERCc7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHgsIHksIDE2LCAxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNvbnRleHQuY2FudmFzO1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFV0aWxpdHkgPSByZXF1aXJlKCdmYW1vdXMtdXRpbGl0aWVzJyk7XG5cbnZhciB2ZXJ0ZXhXcmFwcGVyID0gcmVxdWlyZSgnZmFtb3VzLXdlYmdsLXNoYWRlcnMnKS52ZXJ0ZXg7XG52YXIgZnJhZ21lbnRXcmFwcGVyID0gcmVxdWlyZSgnZmFtb3VzLXdlYmdsLXNoYWRlcnMnKS5mcmFnbWVudDtcblxudmFyIFZFUlRFWF9TSEFERVIgPSAzNTYzMztcbnZhciBGUkFHTUVOVF9TSEFERVIgPSAzNTYzMjtcblxudmFyIGlkZW50aXR5TWF0cml4ID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuXG52YXIgVFlQRVMgPSB7XG4gICAgdW5kZWZpbmVkOiAnZmxvYXQgJyxcbiAgICAxOiAnZmxvYXQgJyxcbiAgICAyOiAndmVjMiAnLFxuICAgIDM6ICd2ZWMzICcsXG4gICAgNDogJ3ZlYzQgJyxcbiAgICAxNjogJ21hdDQgJ1xufTtcblxudmFyIGlucHV0VHlwZXMgPSB7XG4gICAgYmFzZUNvbG9yOiAndmVjMycsXG4gICAgbm9ybWFsOiAndmVjMycsXG4gICAgZ2xvc3NpbmVzczogJ2Zsb2F0JyxcbiAgICBtZXRhbG5lc3M6ICdmbG9hdCcsXG4gICAgcG9zaXRpb25PZmZzZXQ6ICd2ZXJ0J1xufTtcblxudmFyIG1hc2tzID0gIHtcbiAgICB2ZXJ0OiAxLFxuICAgIHZlYzM6IDIsXG4gICAgZmxvYXQ6IDRcbn07XG5cbnZhciB1bmlmb3JtTmFtZXMgPSBbXG4gICAgJ3BlcnNwZWN0aXZlJyxcbiAgICAndmlldycsXG4gICAgJ3Jlc29sdXRpb24nLFxuICAgICd0cmFuc2Zvcm0nLFxuICAgICdzaXplJyxcbiAgICAndGltZScsXG4gICAgJ29wYWNpdHknLFxuICAgICdtZXRhbG5lc3MnLFxuICAgICdnbG9zc2luZXNzJyxcbiAgICAnYmFzZUNvbG9yJyxcbiAgICAnbm9ybWFsJyxcbiAgICAncG9zaXRpb25PZmZzZXQnLFxuICAgICd1X0xpZ2h0UG9zaXRpb24nLFxuICAgICd1X0xpZ2h0Q29sb3InLFxuICAgICd1X0FtYmllbnRMaWdodCcsXG4gICAgJ3VfRmxhdFNoYWRpbmcnLFxuICAgICd1X051bUxpZ2h0cydcbl07XG5cbnZhciB1bmlmb3JtVmFsdWVzID0gW1xuICAgIGlkZW50aXR5TWF0cml4LFxuICAgIGlkZW50aXR5TWF0cml4LFxuICAgIFswLCAwLCAwXSxcbiAgICBpZGVudGl0eU1hdHJpeCxcbiAgICBbMSwgMSwgMV0sXG4gICAgMCxcbiAgICAxLFxuICAgIDAsXG4gICAgMCxcbiAgICBbMSwgMSwgMV0sXG4gICAgWzEsIDEsIDFdLFxuICAgIFswLCAwLCAwXSxcbiAgICBpZGVudGl0eU1hdHJpeCxcbiAgICBpZGVudGl0eU1hdHJpeCxcbiAgICBbMCwgMCwgMF0sXG4gICAgMCxcbiAgICAwXG5dO1xuXG52YXIgYXR0cmlidXRlTmFtZXMgPSBbJ3BvcycsICd0ZXhDb29yZCcsICdub3JtYWxzJ107XG52YXIgYXR0cmlidXRlVmFsdWVzID0gWzMsIDIsIDMsIDFdO1xuXG52YXIgdmFyeWluZ05hbWVzID0gWyd2X1RleHR1cmVDb29yZGluYXRlJywgJ3ZfTm9ybWFsJywgJ3ZfUG9zaXRpb24nXTtcbnZhciB2YXJ5aW5nVmFsdWVzID0gWzIsIDMsIDNdO1xuXG52YXIgaGVhZGVyID0gJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbic7XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGhhbmRsZXMgaW50ZXJhY3Rpb25zIHdpdGggdGhlIFdlYkdMIHNoYWRlciBwcm9ncmFtXG4gKiB1c2VkIGJ5IGEgc3BlY2lmaWMgY29udGV4dC4gIEl0IG1hbmFnZXMgY3JlYXRpb24gb2YgdGhlIHNoYWRlciBwcm9ncmFtXG4gKiBhbmQgdGhlIGF0dGFjaGVkIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy4gIEl0IGlzIGFsc28gaW4gY2hhcmdlIG9mXG4gKiBwYXNzaW5nIGFsbCB1bmlmb3JtcyB0byB0aGUgV2ViR0xDb250ZXh0LlxuICpcbiAqIEBjbGFzcyBQcm9ncmFtXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1dlYkdMX0NvbnRleHR9IGdsIENvbnRleHQgdG8gYmUgdXNlZCB0byBjcmVhdGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICovXG5cbmZ1bmN0aW9uIFByb2dyYW0oZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy50ZXh0dXJlU2xvdHMgPSAxO1xuXG4gICAgdGhpcy5yZWdpc3RlcmVkTWF0ZXJpYWxzID0ge307XG4gICAgdGhpcy5mbGFnZ2VkVW5pZm9ybXMgPSBbXTtcbiAgICB0aGlzLmNhY2hlZFVuaWZvcm1zICA9IHt9O1xuXG4gICAgdGhpcy5kZWZpbml0aW9uVmVjID0gW107XG4gICAgdGhpcy5kZWZpbml0aW9uRmxvYXQgPSBbXTtcbiAgICB0aGlzLmFwcGxpY2F0aW9uVmVjID0gW107XG4gICAgdGhpcy5hcHBsaWNhdGlvbkZsb2F0ID0gW107XG4gICAgdGhpcy5hcHBsaWNhdGlvblZlcnQgPSBbXTtcbiAgICB0aGlzLmRlZmluaXRpb25WZXJ0ID0gW107XG5cbiAgICB0aGlzLnJlc2V0UHJvZ3JhbSgpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIG1hdGVyaWFsIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCB0b1xuICogdGhlIHNoYWRlciBwcm9ncmFtLlxuICpcbiAqIEBtZXRob2QgcmVnaXN0ZXJNYXRlcmlhbFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGFyZ2V0IGlucHV0IG9mIG1hdGVyaWFsLlxuICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFsIENvbXBpbGVkIG1hdGVyaWFsIG9iamVjdCBiZWluZyB2ZXJpZmllZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgcHJvZ3JhbS5cbiAqL1xuXG5Qcm9ncmFtLnByb3RvdHlwZS5yZWdpc3Rlck1hdGVyaWFsID0gZnVuY3Rpb24gcmVnaXN0ZXJNYXRlcmlhbChuYW1lLCBtYXRlcmlhbCkge1xuICAgIHZhciBjb21waWxlZCA9IG1hdGVyaWFsO1xuICAgIHZhciB0eXBlID0gaW5wdXRUeXBlc1tuYW1lXTtcbiAgICB2YXIgbWFzayA9IG1hc2tzW3R5cGVdO1xuXG4gICAgaWYgKCh0aGlzLnJlZ2lzdGVyZWRNYXRlcmlhbHNbbWF0ZXJpYWwuX2lkXSAmIG1hc2spID09PSBtYXNrKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBrIGluIGNvbXBpbGVkLnVuaWZvcm1zKSB7XG4gICAgICAgIGlmICh1bmlmb3JtTmFtZXMuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHVuaWZvcm1OYW1lcy5wdXNoKGspO1xuICAgICAgICAgICAgdW5pZm9ybVZhbHVlcy5wdXNoKGNvbXBpbGVkLnVuaWZvcm1zW2tdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGsgaW4gY29tcGlsZWQudmFyeWluZ3MpIHtcbiAgICAgICAgaWYgKHZhcnlpbmdOYW1lcy5pbmRleE9mKGspID09PSAtMSkge1xuICAgICAgICAgICAgdmFyeWluZ05hbWVzLnB1c2goayk7XG4gICAgICAgICAgICB2YXJ5aW5nVmFsdWVzLnB1c2goY29tcGlsZWQudmFyeWluZ3Nba10ubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGsgaW4gY29tcGlsZWQuYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlTmFtZXMuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWVzLnB1c2goayk7XG4gICAgICAgICAgICBhdHRyaWJ1dGVWYWx1ZXMucHVzaChjb21waWxlZC5hdHRyaWJ1dGVzW2tdLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlZ2lzdGVyZWRNYXRlcmlhbHNbbWF0ZXJpYWwuX2lkXSB8PSBtYXNrO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Zsb2F0Jykge1xuICAgICAgICB0aGlzLmRlZmluaXRpb25GbG9hdC5wdXNoKG1hdGVyaWFsLmRlZmluZXMpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25GbG9hdC5wdXNoKCdmbG9hdCBmYV8nICsgbWF0ZXJpYWwuX2lkICsgJygpIHtcXG4gJyAgKyBjb21waWxlZC5nbHNsICsgJyBcXG59Jyk7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25GbG9hdC5wdXNoKCdpZiAoaW50KGFicyhJRCkpID09ICcgKyBtYXRlcmlhbC5faWQgKyAnKSByZXR1cm4gZmFfJyArIG1hdGVyaWFsLl9pZCAgKyAnKCk7Jyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT0gJ3ZlYzMnKSB7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvblZlYy5wdXNoKG1hdGVyaWFsLmRlZmluZXMpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25WZWMucHVzaCgndmVjMyBmYV8nICsgbWF0ZXJpYWwuX2lkICsgJygpIHtcXG4gJyAgKyBjb21waWxlZC5nbHNsICsgJyBcXG59Jyk7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25WZWMucHVzaCgnaWYgKGludChhYnMoSUQueCkpID09ICcgKyBtYXRlcmlhbC5faWQgKyAnKSByZXR1cm4gZmFfJyArIG1hdGVyaWFsLl9pZCArICcoKTsnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PSAndmVydCcpIHtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uVmVydC5wdXNoKG1hdGVyaWFsLmRlZmluZXMpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25WZXJ0LnB1c2goJ3ZlYzMgZmFfJyArIG1hdGVyaWFsLl9pZCArICcoKSB7XFxuICcgICsgY29tcGlsZWQuZ2xzbCArICcgXFxufScpO1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uVmVydC5wdXNoKCdpZiAoaW50KGFicyhJRC54KSkgPT0gJyArIG1hdGVyaWFsLl9pZCArICcpIHJldHVybiBmYV8nICsgbWF0ZXJpYWwuX2lkICsgJygpOycpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlc2V0UHJvZ3JhbSgpO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgYWxsIGNhY2hlZCB1bmlmb3JtcyBhbmQgYXR0cmlidXRlIGxvY2F0aW9ucy4gIEFzc2VtYmxlc1xuICogbmV3IGZyYWdtZW50IGFuZCB2ZXJ0ZXggc2hhZGVycyBhbmQgYmFzZWQgb24gbWF0ZXJpYWwgZnJvbVxuICogY3VycmVudGx5IHJlZ2lzdGVyZWQgbWF0ZXJpYWxzLiAgQXR0YWNoZXMgc2FpZCBzaGFkZXJzIHRvIG5ld1xuICogc2hhZGVyIHByb2dyYW0gYW5kIHVwb24gc3VjY2VzcyBsaW5rcyBwcm9ncmFtIHRvIHRoZSBXZWJHTFxuICogY29udGV4dC5cbiAqXG4gKiBAbWV0aG9kIHJlc2V0UHJvZ3JhbVxuICpcbiAqIEByZXR1cm4ge1Byb2dyYW19IEN1cnJlbnQgcHJvZ3JhbS5cbiAqL1xuUHJvZ3JhbS5wcm90b3R5cGUucmVzZXRQcm9ncmFtID0gZnVuY3Rpb24gcmVzZXRQcm9ncmFtKCkge1xuICAgIHZhciB2c0NodW5rRGVmaW5lcyA9IFtdO1xuICAgIHZhciB2c0NodW5rQXBwbGllcyA9IFtdO1xuICAgIHZhciBmc0NodW5rRGVmaW5lcyA9IFtdO1xuICAgIHZhciBmc0NodW5rQXBwbGllcyA9IFtdO1xuXG4gICAgdmFyIHZlcnRleEhlYWRlciA9IFtoZWFkZXJdO1xuICAgIHZhciBmcmFnbWVudEhlYWRlciA9IFtoZWFkZXJdO1xuXG4gICAgdmFyIGZyYWdtZW50U291cmNlO1xuICAgIHZhciB2ZXJ0ZXhTb3VyY2U7XG4gICAgdmFyIG1hdGVyaWFsO1xuICAgIHZhciBwcm9ncmFtO1xuICAgIHZhciBjaHVuaztcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGk7XG5cbiAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnMgICA9IFtdO1xuICAgIHRoaXMuYXR0cmlidXRlTG9jYXRpb25zID0ge307XG5cbiAgICB0aGlzLmF0dHJpYnV0ZU5hbWVzID0gVXRpbGl0eS5jbG9uZShhdHRyaWJ1dGVOYW1lcyk7XG4gICAgdGhpcy5hdHRyaWJ1dGVWYWx1ZXMgPSBVdGlsaXR5LmNsb25lKGF0dHJpYnV0ZVZhbHVlcyk7XG5cbiAgICB0aGlzLnZhcnlpbmdOYW1lcyA9IFV0aWxpdHkuY2xvbmUodmFyeWluZ05hbWVzKTtcbiAgICB0aGlzLnZhcnlpbmdWYWx1ZXMgPSBVdGlsaXR5LmNsb25lKHZhcnlpbmdWYWx1ZXMpO1xuXG4gICAgdGhpcy51bmlmb3JtTmFtZXMgPSBVdGlsaXR5LmNsb25lKHVuaWZvcm1OYW1lcyk7XG4gICAgdGhpcy51bmlmb3JtVmFsdWVzID0gVXRpbGl0eS5jbG9uZSh1bmlmb3JtVmFsdWVzKTtcblxuICAgIHRoaXMuZmxhZ2dlZFVuaWZvcm1zID0gW107XG4gICAgdGhpcy5jYWNoZWRVbmlmb3JtcyA9IHt9O1xuXG4gICAgZnJhZ21lbnRIZWFkZXIucHVzaCgndW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxuJyk7XG5cbiAgICBpZiAodGhpcy5hcHBsaWNhdGlvblZlcnQubGVuZ3RoID4gMSkge1xuICAgICAgICB2ZXJ0ZXhIZWFkZXIucHVzaCgndW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxuJyk7XG4gICAgfVxuXG4gICAgZm9yKGkgPSAwOyBpIDwgdGhpcy51bmlmb3JtTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IHRoaXMudW5pZm9ybU5hbWVzW2ldLCB2YWx1ZSA9IHRoaXMudW5pZm9ybVZhbHVlc1tpXTtcbiAgICAgICAgdmVydGV4SGVhZGVyLnB1c2goJ3VuaWZvcm0gJyArIFRZUEVTW3ZhbHVlLmxlbmd0aF0gKyBuYW1lICsgJztcXG4nKTtcbiAgICAgICAgZnJhZ21lbnRIZWFkZXIucHVzaCgndW5pZm9ybSAnICsgVFlQRVNbdmFsdWUubGVuZ3RoXSArIG5hbWUgKyAnO1xcbicpO1xuICAgIH1cblxuICAgIGZvcihpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IHRoaXMuYXR0cmlidXRlTmFtZXNbaV0sIHZhbHVlID0gdGhpcy5hdHRyaWJ1dGVWYWx1ZXNbaV07XG4gICAgICAgIHZlcnRleEhlYWRlci5wdXNoKCdhdHRyaWJ1dGUgJyArIFRZUEVTW3ZhbHVlXSArIG5hbWUgKyAnO1xcbicpO1xuICAgIH1cblxuICAgIGZvcihpID0gMDsgaSA8IHRoaXMudmFyeWluZ05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLnZhcnlpbmdOYW1lc1tpXSwgdmFsdWUgPSB0aGlzLnZhcnlpbmdWYWx1ZXNbaV07XG4gICAgICAgIHZlcnRleEhlYWRlci5wdXNoKCd2YXJ5aW5nICcgKyBUWVBFU1t2YWx1ZV0gICsgbmFtZSArICc7XFxuJyk7XG4gICAgICAgIGZyYWdtZW50SGVhZGVyLnB1c2goJ3ZhcnlpbmcgJyArIFRZUEVTW3ZhbHVlXSArIG5hbWUgKyAnO1xcbicpO1xuICAgIH1cblxuICAgIHZlcnRleFNvdXJjZSA9IHZlcnRleEhlYWRlci5qb2luKCcnKSArIHZlcnRleFdyYXBwZXJcbiAgICAgICAgLnJlcGxhY2UoJyN2ZXJ0X2RlZmluaXRpb25zJywgdGhpcy5kZWZpbml0aW9uVmVydC5qb2luKCdcXG4nKSlcbiAgICAgICAgLnJlcGxhY2UoJyN2ZXJ0X2FwcGxpY2F0aW9ucycsIHRoaXMuYXBwbGljYXRpb25WZXJ0LmpvaW4oJ1xcbicpKTtcblxuICAgIGZyYWdtZW50U291cmNlID0gZnJhZ21lbnRIZWFkZXIuam9pbignJykgKyBmcmFnbWVudFdyYXBwZXJcbiAgICAgICAgLnJlcGxhY2UoJyN2ZWNfZGVmaW5pdGlvbnMnLCB0aGlzLmRlZmluaXRpb25WZWMuam9pbignXFxuJykpXG4gICAgICAgIC5yZXBsYWNlKCcjdmVjX2FwcGxpY2F0aW9ucycsIHRoaXMuYXBwbGljYXRpb25WZWMuam9pbignXFxuJykpXG4gICAgICAgIC5yZXBsYWNlKCcjZmxvYXRfZGVmaW5pdGlvbnMnLCB0aGlzLmRlZmluaXRpb25GbG9hdC5qb2luKCdcXG4nKSlcbiAgICAgICAgLnJlcGxhY2UoJyNmbG9hdF9hcHBsaWNhdGlvbnMnLCB0aGlzLmFwcGxpY2F0aW9uRmxvYXQuam9pbignXFxuJykpO1xuXG4gICAgcHJvZ3JhbSA9IHRoaXMuZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIoXG4gICAgICAgIHByb2dyYW0sXG4gICAgICAgIHRoaXMuY29tcGlsZVNoYWRlcih0aGlzLmdsLmNyZWF0ZVNoYWRlcihWRVJURVhfU0hBREVSKSwgdmVydGV4U291cmNlKVxuICAgICk7XG5cbiAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcihcbiAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgdGhpcy5jb21waWxlU2hhZGVyKHRoaXMuZ2wuY3JlYXRlU2hhZGVyKEZSQUdNRU5UX1NIQURFUiksIGZyYWdtZW50U291cmNlKVxuICAgICk7XG5cbiAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgaWYgKCEgdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIHRoaXMuZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2xpbmsgZXJyb3I6ICcgKyB0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VW5pZm9ybXModGhpcy51bmlmb3JtTmFtZXMsIHRoaXMudW5pZm9ybVZhbHVlcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCB1bmlmb3JtIHZhbHVlIGFnYWluc3RcbiAqIHRoZSBjYWNoZWQgdmFsdWUgc3RvcmVkIG9uIHRoZSBQcm9ncmFtIGNsYXNzLiAgVXBkYXRlcyBhbmRcbiAqIGNyZWF0ZXMgbmV3IGVudHJpZXMgaW4gdGhlIGNhY2hlIHdoZW4gbmVjZXNzYXJ5LlxuICpcbiAqIEBtZXRob2QgdW5pZm9ybUlzQ2FjaGVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldE5hbWUgS2V5IG9mIHVuaWZvcm0gc3BlYyBiZWluZyBldmFsdWF0ZWQuXG4gKiBAcGFyYW0ge051bWJlcnxBcnJheX0gdmFsdWUgVmFsdWUgb2YgdW5pZm9ybSBzcGVjIGJlaW5nIGV2YWx1YXRlZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgdW5pZm9ybSBiZWluZyBzZXRcbiAqIGlzIGNhY2hlZC5cbiAqL1xuUHJvZ3JhbS5wcm90b3R5cGUudW5pZm9ybUlzQ2FjaGVkID0gZnVuY3Rpb24gKHRhcmdldE5hbWUsIHZhbHVlKSB7XG4gICAgaWYodGhpcy5jYWNoZWRVbmlmb3Jtc1t0YXJnZXROYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkVW5pZm9ybXNbdGFyZ2V0TmFtZV0gPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkVW5pZm9ybXNbdGFyZ2V0TmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgaWYodmFsdWVbaV0gIT09IHRoaXMuY2FjaGVkVW5pZm9ybXNbdGFyZ2V0TmFtZV1baV0pIHtcbiAgICAgICAgICAgICAgICBpID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlKGktLSkgdGhpcy5jYWNoZWRVbmlmb3Jtc1t0YXJnZXROYW1lXVtpXSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsc2UgaWYgKHRoaXMuY2FjaGVkVW5pZm9ybXNbdGFyZ2V0TmFtZV0gIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FjaGVkVW5pZm9ybXNbdGFyZ2V0TmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIGFsbCBwYXNzaW5nIG9mIHVuaWZvcm1zIHRvIFdlYkdMIGRyYXdpbmcgY29udGV4dC4gIFRoaXNcbiAqIGZ1bmN0aW9uIHdpbGwgZmluZCB0aGUgdW5pZm9ybSBsb2NhdGlvbiBhbmQgdGhlbiwgYmFzZWQgb25cbiAqIGEgdHlwZSBpbmZlcnJlZCBmcm9tIHRoZSBqYXZhc2NyaXB0IHZhbHVlIG9mIHRoZSB1bmlmb3JtLCBpdCB3aWxsIGNhbGxcbiAqIHRoZSBhcHByb3ByaWF0ZSBmdW5jdGlvbiB0byBwYXNzIHRoZSB1bmlmb3JtIHRvIFdlYkdMLiAgRmluYWxseSxcbiAqIHNldFVuaWZvcm1zIHdpbGwgaXRlcmF0ZSB0aHJvdWdoIHRoZSBwYXNzZWQgaW4gc2hhZGVyQ2h1bmtzIChpZiBhbnkpXG4gKiBhbmQgc2V0IHRoZSBhcHByb3ByaWF0ZSB1bmlmb3JtcyB0byBzcGVjaWZ5IHdoaWNoIGNodW5rcyB0byB1c2UuXG4gKlxuICogQG1ldGhvZCBzZXRVbmlmb3Jtc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHVuaWZvcm1OYW1lcyBBcnJheSBjb250YWluaW5nIHRoZSBrZXlzIG9mIGFsbCB1bmlmb3JtcyB0byBiZSBzZXQuXG4gKiBAcGFyYW0ge0FycmF5fSB1bmlmb3JtVmFsdWUgQXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIGFsbCB1bmlmb3JtcyB0byBiZSBzZXQuXG4gKlxuICogQHJldHVybiB7UHJvZ3JhbX0gQ3VycmVudCBwcm9ncmFtLlxuICovXG5Qcm9ncmFtLnByb3RvdHlwZS5zZXRVbmlmb3JtcyA9IGZ1bmN0aW9uICh1bmlmb3JtTmFtZXMsIHVuaWZvcm1WYWx1ZSkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIGxvY2F0aW9uO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgZmxhZztcbiAgICB2YXIgbGVuO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKCF0aGlzLnByb2dyYW0pIHJldHVybjtcblxuICAgIGxlbiA9IHVuaWZvcm1OYW1lcy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSB1bmlmb3JtTmFtZXNbaV07XG4gICAgICAgIHZhbHVlID0gdW5pZm9ybVZhbHVlW2ldO1xuXG4gICAgICAgIC8vIFJldHJlaXZlIHRoZSBjYWNoZWQgbG9jYXRpb24gb2YgdGhlIHVuaWZvcm0sXG4gICAgICAgIC8vIHJlcXVlc3RpbmcgYSBuZXcgbG9jYXRpb24gZnJvbSB0aGUgV2ViR0wgY29udGV4dFxuICAgICAgICAvLyBpZiBpdCBkb2VzIG5vdCB5ZXQgZXhpc3QuXG5cbiAgICAgICAgbG9jYXRpb24gPSB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNbbmFtZV0gfHwgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSk7XG4gICAgICAgIGlmICghbG9jYXRpb24pIGNvbnRpbnVlO1xuXG4gICAgICAgIHRoaXMudW5pZm9ybUxvY2F0aW9uc1tuYW1lXSA9IGxvY2F0aW9uO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBhbHJlYWR5IHNldCBmb3IgdGhlXG4gICAgICAgIC8vIGdpdmVuIHVuaWZvcm0uXG5cbiAgICAgICAgaWYgKHRoaXMudW5pZm9ybUlzQ2FjaGVkKG5hbWUsIHZhbHVlKSkgY29udGludWU7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBjb3JyZWN0IGZ1bmN0aW9uIGFuZCBwYXNzIHRoZSB1bmlmb3JtXG4gICAgICAgIC8vIHZhbHVlIHRvIFdlYkdMLlxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6ICBnbC51bmlmb3JtNGZ2KGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogIGdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHZhbHVlKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiAgZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE2OiBnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUpOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6ICBnbC51bmlmb3JtMWZ2KGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTogIGdsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93ICdjYW50IGxvYWQgdW5pZm9ybSBcIicgKyBuYW1lICsgJ1wiIHdpdGggdmFsdWU6JyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghIGlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKSAmJiBpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ3NldCB1bmlmb3JtIFwiJyArIG5hbWUgKyAnXCIgdG8gaW52YWxpZCB0eXBlIDonICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgc2hhZGVyIHNvdXJjZSB0byBzaGFkZXIgYW5kIGNvbXBpbGVzIHRoZSBpbnB1dCBzaGFkZXIuICBDaGVja3NcbiAqIGNvbXBpbGUgc3RhdHVzIGFuZCBsb2dzIGVycm9yIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAbWV0aG9kIGNvbXBpbGVTaGFkZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2hhZGVyIFByb2dyYW0gdG8gYmUgY29tcGlsZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIFNvdXJjZSB0byBiZSB1c2VkIGluIHRoZSBzaGFkZXIuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBDb21waWxlZCBzaGFkZXIuXG4gKi9cblByb2dyYW0ucHJvdG90eXBlLmNvbXBpbGVTaGFkZXIgPSBmdW5jdGlvbiBjb21waWxlU2hhZGVyKHNoYWRlciwgc291cmNlKSB7XG4gICAgdmFyIGkgPSAxO1xuXG4gICAgdGhpcy5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIGlmICghdGhpcy5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCB0aGlzLmdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdjb21waWxlIGVycm9yOiAnICsgdGhpcy5nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCcxOiAnICsgc291cmNlLnJlcGxhY2UoL1xcbi9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnXFxuJyArIChpKz0xKSArICc6ICc7IH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9ncmFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRleHR1cmUgaXMgYSBwcml2YXRlIGNsYXNzIHRoYXQgc3RvcmVzIGltYWdlIGRhdGFcbiAqIHRvIGJlIGFjY2Vzc2VkIGZyb20gYSBzaGFkZXIgb3IgdXNlZCBhcyBhIHJlbmRlciB0YXJnZXQuXG4gKlxuICogQGNsYXNzIFRleHR1cmVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUZXh0dXJlKGdsLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5pZCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aCB8fCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgMDtcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGdsLlJHQkE7XG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlIHx8IGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgdGhpcy5iaW5kKCk7XG5cbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmYWxzZSk7XG4gICAgXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsW29wdGlvbnMubWFnRmlsdGVyXSB8fCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2xbb3B0aW9ucy5taW5GaWx0ZXJdIHx8IGdsLk5FQVJFU1QpO1xuXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2xbb3B0aW9ucy53cmFwU10gfHwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2xbb3B0aW9ucy53cmFwU10gfHwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgbnVsbCk7XG5cbiAgICBpZiAob3B0aW9ucy5taXBtYXAgIT09IGZhbHNlICYmIGlzUG93ZXJPZlR3byh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkpIHtcbiAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgfVxuXG4gICAgdGhpcy51bmJpbmQoKTtcbn1cblxuLyoqXG4gKiBCaW5kcyB0aGlzIHRleHR1cmUgYXMgdGhlIHNlbGVjdGVkIHRhcmdldC5cbiAqXG4gKiBAbWV0aG9kIGJpbmRcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdW5pdCBUaGUgdGV4dHVyZSBzbG90IGluIHdoaWNoIHRvIHVwbG9hZCB0aGUgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgdGV4dHVyZSBpbnN0YW5jZS5cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIGJpbmQodW5pdCkge1xuICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgKHVuaXQgfHwgMCkpO1xuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmlkKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXJhc2VzIHRoZSB0ZXh0dXJlIGRhdGEgaW4gdGhlIGdpdmVuIHRleHR1cmUgc2xvdC5cbiAqXG4gKiBAbWV0aG9kIHVuYmluZFxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB1bml0IFRoZSB0ZXh0dXJlIHNsb3QgaW4gd2hpY2ggdG8gY2xlYW4gdGhlIGRhdGEuXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCB0ZXh0dXJlIGluc3RhbmNlLlxuICovXG5UZXh0dXJlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQodW5pdCkge1xuICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgKHVuaXQgfHwgMCkpO1xuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIGltYWdlIGRhdGEgaW4gdGhlIHRleHR1cmUgd2l0aCB0aGUgZ2l2ZW4gaW1hZ2UuXG4gKlxuICogQG1ldGhvZCBzZXRJbWFnZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7SW1hZ2V9IGltZyBUaGUgaW1hZ2Ugb2JqZWN0IHRvIHVwbG9hZCBwaXhlbCBkYXRhIGZyb20uXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IHRleHR1cmUgaW5zdGFuY2UuXG4gKi9cblRleHR1cmUucHJvdG90eXBlLnNldEltYWdlID0gZnVuY3Rpb24gc2V0SW1hZ2UoaW1nKSB7XG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuaWQpO1xuICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZm9ybWF0LCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBpbWcpO1xuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIGltYWdlIGRhdGEgaW4gdGhlIHRleHR1cmUgd2l0aCBhbiBhcnJheSBvZiBhcmJpdHJhcnkgZGF0YS5cbiAqXG4gKiBAbWV0aG9kIHNldEFycmF5XG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaW5wdXQgQXJyYXkgdG8gYmUgc2V0IGFzIGRhdGEgdG8gdGV4dHVyZS4gXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IHRleHR1cmUgaW5zdGFuY2UuXG4gKi9cblRleHR1cmUucHJvdG90eXBlLnNldEFycmF5ID0gZnVuY3Rpb24gc2V0QXJyYXkoaW5wdXQpIHtcbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5pZCk7XG4gICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5mb3JtYXQsIDEsIDEsIDAsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEdW1wcyB0aGUgcmdiLXBpeGVsIGNvbnRlbnRzIG9mIGEgdGV4dHVyZSBpbnRvIGFuIGFycmF5IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAqXG4gKiBAbWV0aG9kIHJlYWRCYWNrXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHgtb2Zmc2V0IGJldHdlZW4gdGV4dHVyZSBjb29yZGluYXRlcyBhbmQgc25hcHNob3RcbiAqIEBwYXJhbSB7TnVtYmVyfSB5LW9mZnNldCBiZXR3ZWVuIHRleHR1cmUgY29vcmRpbmF0ZXMgYW5kIHNuYXBzaG90XG4gKiBAcGFyYW0ge051bWJlcn0geC1kZXB0aCBvZiB0aGUgc25hcHNob3RcbiAqIEBwYXJhbSB7TnVtYmVyfSB5LWRlcHRoIG9mIHRoZSBzbmFwc2hvdFxuICogXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIHBpeGVscyBjb250YWluZWQgaW4gdGhlIHNuYXBzaG90LlxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5yZWFkQmFjayA9IGZ1bmN0aW9uIHJlYWRCYWNrKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBwaXhlbHM7XG4gICAgeCA9IHggfHwgMDtcbiAgICB5ID0geSB8fCAwO1xuICAgIHdpZHRoID0gd2lkdGggfHwgdGhpcy53aWR0aDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5oZWlnaHQ7XG4gICAgdmFyIGZiID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZiKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMuaWQsIDApO1xuICAgIGlmIChnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKSA9PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSkge1xuICAgICAgICBwaXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICBnbC5yZWFkUGl4ZWxzKHgsIHksIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscyk7XG4gICAgfVxuICAgIHJldHVybiBwaXhlbHM7XG59O1xuXG4vKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGJvdGggaW5wdXQgdmFsdWVzIGFyZSBwb3dlci1vZi10d28gbnVtYmVycy5cbiAqXG4gKiBAbWV0aG9kIGlzUG93ZXJPZlR3b1xuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggTnVtYmVyIHJlcHJlc2VudGluZyB0ZXh0dXJlIHdpZHRoLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBOdW1iZXIgcmVwcmVzZW50aW5nIHRleHR1cmUgaGVpZ2h0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gZGVub3Rpbmcgd2hldGhlciB0aGUgaW5wdXQgZGltZW5zaW9uc1xuICogYXJlIGJvdGggcG93ZXItb2YtdHdvIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gaXNQb3dlck9mVHdvKHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4gKHdpZHRoICYgd2lkdGggLSAxKSA9PT0gMCBcbiAgICAgICAgJiYgKGhlaWdodCAmIGhlaWdodCAtIDEpID09PSAwO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGV4dHVyZSA9IHJlcXVpcmUoJy4vVGV4dHVyZScpO1xudmFyIFByb2dyYW0gPSByZXF1aXJlKCcuL1Byb2dyYW0nKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL0J1ZmZlcicpO1xudmFyIEJ1ZmZlclJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9CdWZmZXJSZWdpc3RyeScpO1xudmFyIGNoZWNrZXJzID0gcmVxdWlyZSgnLi9DaGVja2VyYm9hcmQnKTtcbnZhciBQbGFuZSA9IHJlcXVpcmUoJ2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzJykuUGxhbmU7XG52YXIgc29ydGVyID0gcmVxdWlyZSgnLi9yYWRpeFNvcnQnKTtcblxudmFyIGlkZW50aXR5ID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuXG4vKipcbiAqIFdlYkdMUmVuZGVyZXIgaXMgYSBwcml2YXRlIGNsYXNzIHRoYXQgbWFuYWdlcyBhbGwgaW50ZXJhY3Rpb25zIHdpdGggdGhlIFdlYkdMXG4gKiBBUEkuICBFYWNoIGZyYW1lIGl0IHJlY2VpdmVzIGNvbW1hbmRzIGZyb20gdGhlIGNvbXBvc2l0b3IgYW5kIHVwZGF0ZXMgaXRzIHJlZ2lzdHJpZXNcbiAqIGFjY29yZGluZ2x5LiAgU3Vic2VxdWVudGx5LCB0aGUgZHJhdyBmdW5jdGlvbiBpcyBjYWxsZWQgYW5kIHRoZSBXZWJHTFJlbmRlcmVyXG4gKiBpc3N1ZXMgZHJhdyBjYWxscyBmb3IgYWxsIG1lc2hlcyBpbiBpdHMgcmVnaXN0cnkuXG4gKlxuICogQGNsYXNzIFdlYkdMUmVuZGVyZXJcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY2FudmFzIFRoZSBkb20gZWxlbWVudCB0aGF0IEdMIHdpbGwgcGFpbnQgaXRzZWxmIG9udG8uXG4gKlxuICovXG5mdW5jdGlvbiBXZWJHTFJlbmRlcmVyKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbCA9IHRoaXMuZ2V0V2ViR0xDb250ZXh0KHRoaXMuY2FudmFzKTtcblxuICAgIGdsLnBvbHlnb25PZmZzZXQoMC4xLCAwLjEpO1xuICAgIGdsLmVuYWJsZShnbC5QT0xZR09OX09GRlNFVF9GSUxMKTtcbiAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICBnbC5kZXB0aEZ1bmMoZ2wuTEVRVUFMKTtcbiAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcblxuICAgIHRoaXMubWVzaFJlZ2lzdHJ5ID0ge307XG4gICAgdGhpcy5tZXNoUmVnaXN0cnlLZXlzID0gW107XG5cbiAgICB0aGlzLmN1dG91dFJlZ2lzdHJ5ID0ge307XG4gICAgdGhpcy5jdXRvdXRSZWdpc3RyeUtleXMgPSBbXTtcbiAgICB0aGlzLmN1dG91dEdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogTGlnaHRzXG4gICAgICovXG5cbiAgICB0aGlzLm51bUxpZ2h0cyA9IDA7XG4gICAgdGhpcy5hbWJpZW50TGlnaHRDb2xvciA9IFswLCAwLCAwXTtcbiAgICB0aGlzLmxpZ2h0UmVnaXN0cnkgPSB7fTtcbiAgICB0aGlzLmxpZ2h0UmVnaXN0cnlLZXlzID0gW107XG4gICAgdGhpcy5saWdodFBvc2l0aW9ucyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICB0aGlzLmxpZ2h0Q29sb3JzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuXG4gICAgdGhpcy50ZXh0dXJlUmVnaXN0cnkgPSBbXTtcbiAgICB0aGlzLnRleENhY2hlID0ge307XG4gICAgdGhpcy5idWZmZXJSZWdpc3RyeSA9IG5ldyBCdWZmZXJSZWdpc3RyeShnbCk7XG4gICAgdGhpcy5wcm9ncmFtID0gbmV3IFByb2dyYW0oZ2wpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgYm91bmRBcnJheUJ1ZmZlcjogbnVsbCxcbiAgICAgICAgYm91bmRFbGVtZW50QnVmZmVyOiBudWxsLFxuICAgICAgICBsYXN0RHJhd246IG51bGwsXG4gICAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgZW5hYmxlZEF0dHJpYnV0ZXNLZXlzOiBbXVxuICAgIH07XG5cbiAgICB0aGlzLnJlc29sdXRpb25OYW1lID0gWydyZXNvbHV0aW9uJ107XG4gICAgdGhpcy5yZXNvbHV0aW9uVmFsdWVzID0gW107XG5cbiAgICB0aGlzLmNhY2hlZFNpemUgPSBbXTtcblxuICAgIHRoaXMucHJvamVjdGlvblRyYW5zZm9ybSA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXRyZWl2ZSB0aGUgV2ViR0xSZW5kZXJlciBjb250ZXh0IHVzaW5nIHNldmVyYWxcbiAqIGFjY2Vzc29ycy4gIEZvciBicm93c2VyIGNvbXBhdGFiaWxpdHkuICBUaHJvd3Mgb24gZXJyb3IuXG4gKlxuICogQG1ldGhvZCBnZXRXZWJHTENvbnRleHRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY2FudmFzIENhbnZhcyBlbGVtZW50IGZyb20gd2hpY2ggdGhlIGNvbnRleHQgaXMgcmV0cmVpdmVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gV2ViR0xDb250ZXh0IG9mIGNhbnZhcyBlbGVtZW50LlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5nZXRXZWJHTENvbnRleHQgPSBmdW5jdGlvbiBnZXRXZWJHTENvbnRleHQoY2FudmFzKSB7XG4gICAgdmFyIG5hbWVzID0gWyd3ZWJnbCcsICdleHBlcmltZW50YWwtd2ViZ2wnLCAnd2Via2l0LTNkJywgJ21vei13ZWJnbCddO1xuICAgIHZhciBjb250ZXh0ID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQobmFtZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0OiAnICsgZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQgPyBjb250ZXh0IDogZmFsc2U7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXcgYmFzZSBzcGVjIHRvIHRoZSBsaWdodCByZWdpc3RyeSBhdCBhIGdpdmVuIHBhdGguXG4gKlxuICogQG1ldGhvZCBjcmVhdGVMaWdodFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBQYXRoIHVzZWQgYXMgaWQgb2YgbmV3IGxpZ2h0IGluIGxpZ2h0UmVnaXN0cnkuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBOZXdseSBjcmVhdGVkIGxpZ2h0IHNwZWMuXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUxpZ2h0ID0gZnVuY3Rpb24gY3JlYXRlTGlnaHQocGF0aCkge1xuICAgIHRoaXMubnVtTGlnaHRzKys7XG4gICAgdGhpcy5saWdodFJlZ2lzdHJ5S2V5cy5wdXNoKHBhdGgpO1xuICAgIHJldHVybiB0aGlzLmxpZ2h0UmVnaXN0cnlbcGF0aF0gPSB7XG4gICAgICAgIGNvbG9yOiBbMCwgMCwgMF0sXG4gICAgICAgIHBvc2l0aW9uOiBbMCwgMCwgMF1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBBZGRzIGEgbmV3IGJhc2Ugc3BlYyB0byB0aGUgbWVzaCByZWdpc3RyeSBhdCBhIGdpdmVuIHBhdGguXG4gKlxuICogQG1ldGhvZCBjcmVhdGVNZXNoXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFBhdGggdXNlZCBhcyBpZCBvZiBuZXcgbWVzaCBpbiBtZXNoUmVnaXN0cnkuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBOZXdseSBjcmVhdGVkIG1lc2ggc3BlYy5cbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlTWVzaCA9IGZ1bmN0aW9uIGNyZWF0ZU1lc2gocGF0aCkge1xuICAgIHRoaXMubWVzaFJlZ2lzdHJ5S2V5cy5wdXNoKHBhdGgpO1xuICAgIHJldHVybiB0aGlzLm1lc2hSZWdpc3RyeVtwYXRoXSA9IHtcbiAgICAgICAgdW5pZm9ybUtleXM6IFsnb3BhY2l0eScsICd0cmFuc2Zvcm0nLCAnc2l6ZScsICdiYXNlQ29sb3InLCAncG9zaXRpb25PZmZzZXQnLCAndV9GbGF0U2hhZGluZyddLFxuICAgICAgICB1bmlmb3JtVmFsdWVzOiBbMSwgaWRlbnRpdHksIFswLCAwLCAwXSwgWzAuNSwgMC41LCAwLjVdLCBbMCwgMCwgMF0sIDBdLFxuICAgICAgICBidWZmZXJzOiB7fSxcbiAgICAgICAgZ2VvbWV0cnk6IG51bGwsXG4gICAgICAgIGRyYXdUeXBlOiBudWxsLFxuICAgICAgICB0ZXh0dXJlOiBudWxsXG4gICAgfTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIG9yIHJldHJlaXZlcyBjdXRvdXRcbiAqXG4gKiBAbWV0aG9kIGdldE9yU2V0Q3V0b3V0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFBhdGggdXNlZCBhcyBpZCBvZiBuZXcgbWVzaCBpbiBtZXNoUmVnaXN0cnkuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBOZXdseSBjcmVhdGVkIGN1dG91dCBzcGVjLlxuICovXG5cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmdldE9yU2V0Q3V0b3V0ID0gZnVuY3Rpb24gZ2V0T3JTZXRDdXRvdXQocGF0aCkge1xuICAgIHZhciBnZW9tZXRyeTtcblxuICAgIGlmICh0aGlzLmN1dG91dFJlZ2lzdHJ5W3BhdGhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1dG91dFJlZ2lzdHJ5W3BhdGhdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1dG91dEdlb21ldHJ5KSB7XG4gICAgICAgICAgICBnZW9tZXRyeSA9IHRoaXMuY3V0b3V0R2VvbWV0cnkgPSBQbGFuZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclJlZ2lzdHJ5LmFsbG9jYXRlKGdlb21ldHJ5LmlkLCAncG9zJywgZ2VvbWV0cnkuc3BlYy5idWZmZXJWYWx1ZXNbMF0sIDMpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJSZWdpc3RyeS5hbGxvY2F0ZShnZW9tZXRyeS5pZCwgJ3RleENvb3JkJywgZ2VvbWV0cnkuc3BlYy5idWZmZXJWYWx1ZXNbMV0sIDIpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJSZWdpc3RyeS5hbGxvY2F0ZShnZW9tZXRyeS5pZCwgJ25vcm1hbHMnLCBnZW9tZXRyeS5zcGVjLmJ1ZmZlclZhbHVlc1syXSwgMyk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclJlZ2lzdHJ5LmFsbG9jYXRlKGdlb21ldHJ5LmlkLCAnaW5kaWNlcycsIGdlb21ldHJ5LnNwZWMuYnVmZmVyVmFsdWVzWzNdLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3V0b3V0UmVnaXN0cnlLZXlzLnB1c2gocGF0aCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3V0b3V0UmVnaXN0cnlbcGF0aF0gPSB7XG4gICAgICAgICAgICB1bmlmb3JtS2V5czogWyd0cmFuc2Zvcm0nLCAnc2l6ZScsICdvcmlnaW4nLCAnYmFzZUNvbG9yJywgJ29wYWNpdHknXSxcbiAgICAgICAgICAgIHVuaWZvcm1WYWx1ZXM6IFtpZGVudGl0eSwgWzAsIDAsIDBdLCBbMCwgMCwgMF0sIFswLCAwLCAwXSwgMF0sXG4gICAgICAgICAgICBnZW9tZXRyeTogdGhpcy5jdXRvdXRHZW9tZXRyeS5pZCxcbiAgICAgICAgICAgIGRyYXdUeXBlOiA0XG4gICAgICAgIH07XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgb3IgcmV0cmVpdmVzIGN1dG91dFxuICpcbiAqIEBtZXRob2Qgc2V0Q3V0b3V0VW5pZm9ybVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBQYXRoIHVzZWQgYXMgaWQgb2YgY3V0b3V0IGluIGN1dG91dCByZWdpc3RyeS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB1bmlmb3JtTG9jYXRpb24gaWRlbnRpZmllciB1c2VkIHRvIHVwbG9hZCB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWUgb2YgdW5pZm9ybSBkYXRhIFxuICpcbiAqL1xuXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRDdXRvdXRVbmlmb3JtID0gZnVuY3Rpb24gc2V0Q3V0b3V0VW5pZm9ybShwYXRoLCB1bmlmb3JtTmFtZSwgdW5pZm9ybVZhbHVlKSB7XG4gICAgdmFyIGN1dG91dCA9IHRoaXMuZ2V0T3JTZXRDdXRvdXQocGF0aCk7XG5cbiAgICB2YXIgaW5kZXggPSBjdXRvdXQudW5pZm9ybUtleXMuaW5kZXhPZih1bmlmb3JtTmFtZSk7XG5cbiAgICBjdXRvdXQudW5pZm9ybVZhbHVlc1tpbmRleF0gPSB1bmlmb3JtVmFsdWU7XG59O1xuXG5cbi8qKlxuICogRWRpdHMgdGhlIG9wdGlvbnMgZmllbGQgb24gYSBtZXNoXG4gKlxuICogQG1ldGhvZCBzZXRNZXNoT3B0aW9uc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBQYXRoIHVzZWQgYXMgaWQgb2YgY3V0b3V0IGluIGN1dG91dCByZWdpc3RyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgb2YgZHJhdyBvcHRpb25zIGZvciBtZXNoXG4gKlxuKiovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRNZXNoT3B0aW9ucyA9IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMpIHtcbiAgICB2YXIgbWVzaCA9IHRoaXMubWVzaFJlZ2lzdHJ5W3BhdGhdIHx8IHRoaXMuY3JlYXRlTWVzaChwYXRoKTtcblxuICAgIG1lc2gub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgY29sb3Igb2YgdGhlIGZpeGVkIGludGVuc2l0eSBsaWdodGluZyBpbiB0aGUgc2NlbmVcbiAqXG4gKiBAbWV0aG9kIHNldEFtYmllbnRMaWdodENvbG9yXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdXNlZCBhcyBpZCBvZiBsaWdodFxuICogQHBhcmFtIHtOdW1iZXJ9IHJlZCBjaGFubmVsXG4gKiBAcGFyYW0ge051bWJlcn0gZ3JlZW4gY2hhbm5lbFxuICogQHBhcmFtIHtOdW1iZXJ9IGJsdWUgY2hhbm5lbFxuICpcbioqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0QW1iaWVudExpZ2h0Q29sb3IgPSBmdW5jdGlvbiBzZXRBbWJpZW50TGlnaHRDb2xvcihwYXRoLCByLCBnLCBiKSB7XG4gICAgdGhpcy5hbWJpZW50TGlnaHRDb2xvclswXSA9IHI7XG4gICAgdGhpcy5hbWJpZW50TGlnaHRDb2xvclsxXSA9IGc7XG4gICAgdGhpcy5hbWJpZW50TGlnaHRDb2xvclsyXSA9IGI7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGxpZ2h0IGluIHRoZSBzY2VuZVxuICpcbiAqIEBtZXRob2Qgc2V0TGlnaHRQb3NpdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHVzZWQgYXMgaWQgb2YgbGlnaHRcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IHBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0geSBwb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHogcG9zaXRpb25cbiAqXG4qKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldExpZ2h0UG9zaXRpb24gPSBmdW5jdGlvbiBzZXRMaWdodFBvc2l0aW9uKHBhdGgsIHgsIHksIHopIHtcbiAgICB2YXIgbGlnaHQgPSB0aGlzLmxpZ2h0UmVnaXN0cnlbcGF0aF0gfHwgdGhpcy5jcmVhdGVMaWdodChwYXRoKTtcblxuICAgIGxpZ2h0LnBvc2l0aW9uWzBdID0geDtcbiAgICBsaWdodC5wb3NpdGlvblsxXSA9IHk7XG4gICAgbGlnaHQucG9zaXRpb25bMl0gPSB6O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIENoYW5nZXMgdGhlIGNvbG9yIG9mIGEgZHluYW1pYyBpbnRlbnNpdHkgbGlnaHRpbmcgaW4gdGhlIHNjZW5lXG4gKlxuICogQG1ldGhvZCBzZXRMaWdodENvbG9yXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdXNlZCBhcyBpZCBvZiBsaWdodCBpbiBsaWdodCBSZWdpc3RyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSByZWQgY2hhbm5lbFxuICogQHBhcmFtIHtOdW1iZXJ9IGdyZWVuIGNoYW5uZWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBibHVlIGNoYW5uZWxcbiAqXG4qKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldExpZ2h0Q29sb3IgPSBmdW5jdGlvbiBzZXRMaWdodENvbG9yKHBhdGgsIHIsIGcsIGIpIHtcbiAgICB2YXIgbGlnaHQgPSB0aGlzLmxpZ2h0UmVnaXN0cnlbcGF0aF0gfHwgdGhpcy5jcmVhdGVMaWdodChwYXRoKTtcblxuICAgIGxpZ2h0LmNvbG9yWzBdID0gcjtcbiAgICBsaWdodC5jb2xvclsxXSA9IGc7XG4gICAgbGlnaHQuY29sb3JbMl0gPSBiO1xuICAgIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogQ29tcGlsZXMgbWF0ZXJpYWwgc3BlYyBpbnRvIHByb2dyYW0gc2hhZGVyXG4gKlxuICogQG1ldGhvZCBoYW5kbGVNYXRlcmlhSW5wdXRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gUGF0aCB1c2VkIGFzIGlkIG9mIGN1dG91dCBpbiBjdXRvdXQgcmVnaXN0cnkuXG4gKiBAcGFyYW0ge1N0cmluZ30gd2hpY2ggcmVuZGVyaW5nIGlucHV0IHRoZSBtYXRlcmlhbCBpcyBib3VuZCB0b1xuICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFsIHNwZWNcbiAqXG4qKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZU1hdGVyaWFsSW5wdXQgPSBmdW5jdGlvbiBoYW5kbGVNYXRlcmlhbElucHV0KHBhdGgsIG5hbWUsIG1hdGVyaWFsKSB7XG4gICAgdmFyIG1lc2ggPSB0aGlzLm1lc2hSZWdpc3RyeVtwYXRoXSB8fCB0aGlzLmNyZWF0ZU1lc2gocGF0aCk7XG5cbiAgICBtZXNoLnVuaWZvcm1WYWx1ZXNbbmFtZSA9PT0gJ2Jhc2VDb2xvcicgPyAzIDogNF1bMF0gPSAtIG1hdGVyaWFsLl9pZDtcbiAgICBpZiAobWF0ZXJpYWwudGV4dHVyZSkgbWVzaC50ZXh0dXJlID0gaGFuZGxlVGV4dHVyZS5jYWxsKHRoaXMsIG1hdGVyaWFsLnRleHR1cmUpO1xuICAgIHRoaXMucHJvZ3JhbS5yZWdpc3Rlck1hdGVyaWFsKG5hbWUsIG1hdGVyaWFsKTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVTaXplKCk7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIGdlb21ldHJ5IGRhdGEgb2YgYSBtZXNoXG4gKlxuICogQG1ldGhvZCBzZXRHZW9tZXRyeVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBQYXRoIHVzZWQgYXMgaWQgb2YgY3V0b3V0IGluIGN1dG91dCByZWdpc3RyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBHZW9tZXRyeSBvYmplY3QgY29udGFpbmluZyB2ZXJ0ZXggZGF0YSB0byBiZSBkcmF3blxuICogQHBhcmFtIHtOdW1iZXJ9IHByaW1pdGl2ZSBpZGVudGlmaWVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdpbGwgdGhlIGdlb21ldHJ5IGRhdGEgY2hhbmdlP1xuICpcbioqL1xuXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRHZW9tZXRyeSA9IGZ1bmN0aW9uIHNldEdlb21ldHJ5KHBhdGgsIGdlb21ldHJ5LCBkcmF3VHlwZSwgZHluYW1pYykge1xuICAgIHZhciBtZXNoID0gdGhpcy5tZXNoUmVnaXN0cnlbcGF0aF0gfHwgdGhpcy5jcmVhdGVNZXNoKHBhdGgpO1xuXG4gICAgbWVzaC5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgIG1lc2guZHJhd1R5cGUgPSBkcmF3VHlwZTtcbiAgICBtZXNoLmR5bmFtaWMgPSBkeW5hbWljO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVwbG9hZHMgYSBuZXcgdmFsdWUgZm9yIHRoZSB1bmlmb3JtIGRhdGEgd2hlbiB0aGUgbWVzaCBpcyBiZWluZyBkcmF3blxuICpcbiAqIEBtZXRob2Qgc2V0TWVzaFVuaWZvcm1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gUGF0aCB1c2VkIGFzIGlkIG9mIG1lc2ggaW4gbWVzaCByZWdpc3RyeVxuICogQHBhcmFtIHtTdHJpbmd9IHVuaWZvcm1Mb2NhdGlvbiBpZGVudGlmaWVyIHVzZWQgdG8gdXBsb2FkIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBvZiB1bmlmb3JtIGRhdGEgXG4gKlxuKiovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRNZXNoVW5pZm9ybSA9IGZ1bmN0aW9uIHNldE1lc2hVbmlmb3JtKHBhdGgsIHVuaWZvcm1OYW1lLCB1bmlmb3JtVmFsdWUpIHtcbiAgICB2YXIgbWVzaCA9IHRoaXMubWVzaFJlZ2lzdHJ5W3BhdGhdIHx8IHRoaXMuY3JlYXRlTWVzaChwYXRoKTtcblxuICAgIHZhciBpbmRleCA9IG1lc2gudW5pZm9ybUtleXMuaW5kZXhPZih1bmlmb3JtTmFtZSk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIG1lc2gudW5pZm9ybUtleXMucHVzaCh1bmlmb3JtTmFtZSk7XG4gICAgICAgIG1lc2gudW5pZm9ybVZhbHVlcy5wdXNoKHVuaWZvcm1WYWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtZXNoLnVuaWZvcm1WYWx1ZXNbaW5kZXhdID0gdW5pZm9ybVZhbHVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUcmlnZ2VycyB0aGUgJ2RyYXcnIHBoYXNlIG9mIHRoZSBXZWJHTFJlbmRlcmVyLiAgSXRlcmF0ZXMgdGhyb3VnaCByZWdpc3RyaWVzXG4gKiB0byBzZXQgdW5pZm9ybXMsIHNldCBhdHRyaWJ1dGVzIGFuZCBpc3N1ZSBkcmF3IGNvbW1hbmRzIGZvciByZW5kZXJhYmxlcy5cbiAqXG4gKiBAbWV0aG9kIGJ1ZmZlckRhdGFcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gUGF0aCB1c2VkIGFzIGlkIG9mIG1lc2ggaW4gbWVzaCByZWdpc3RyeVxuICogQHBhcmFtIHtOdW1iZXJ9IElkIG9mIGdlb21ldHJ5IGluIGdlb21ldHJ5IHJlZ2lzdHJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gQXR0cmlidXRlIGxvY2F0aW9uIG5hbWVcbiAqIEBwYXJhbSB7QXJyYXl9IFZlcnRleCBkYXRhIFxuICogQHBhcmFtIHtOdW1iZXJ9IFRoZSBkaW1lbnNpb25zIG9mIHRoZSB2ZXJ0ZXhcbiAqL1xuXG5cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmJ1ZmZlckRhdGEgPSBmdW5jdGlvbiBidWZmZXJEYXRhKHBhdGgsIGdlb21ldHJ5SWQsIGJ1ZmZlck5hbWUsIGJ1ZmZlclZhbHVlLCBidWZmZXJTcGFjaW5nKSB7XG4gICAgdGhpcy5idWZmZXJSZWdpc3RyeS5hbGxvY2F0ZShnZW9tZXRyeUlkLCBidWZmZXJOYW1lLCBidWZmZXJWYWx1ZSwgYnVmZmVyU3BhY2luZyk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVHJpZ2dlcnMgdGhlICdkcmF3JyBwaGFzZSBvZiB0aGUgV2ViR0xSZW5kZXJlci4gIEl0ZXJhdGVzIHRocm91Z2ggcmVnaXN0cmllc1xuICogdG8gc2V0IHVuaWZvcm1zLCBzZXQgYXR0cmlidXRlcyBhbmQgaXNzdWUgZHJhdyBjb21tYW5kcyBmb3IgcmVuZGVyYWJsZXMuXG4gKlxuICogQG1ldGhvZCBkcmF3XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlbmRlclN0YXRlIFBhcmFtZXRlcnMgcHJvdmlkZWQgYnkgdGhlIGNvbXBvc2l0b3IsIHRoYXRcbiAqIGFmZmVjdCB0aGUgcmVuZGVyaW5nIG9mIGFsbCByZW5kZXJhYmxlcy5cbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIGRyYXcocmVuZGVyU3RhdGUpIHtcbiAgICB2YXIgbWVzaDtcbiAgICB2YXIgYnVmZmVycztcbiAgICB2YXIgc2l6ZTtcbiAgICB2YXIgbGlnaHQ7XG4gICAgdmFyIHN0cmlkZTtcbiAgICB2YXIgY3V0b3V0O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGxpZ2h0c1xuICAgICAqL1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxpZ2h0UmVnaXN0cnlLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpZ2h0ID0gdGhpcy5saWdodFJlZ2lzdHJ5W3RoaXMubGlnaHRSZWdpc3RyeUtleXNbaV1dO1xuICAgICAgICBzdHJpZGUgPSBpICogNDtcbiAgICAgICAgLy8gQnVpbGQgdGhlIGxpZ2h0IHBvc2l0aW9ucycgNHg0IG1hdHJpeFxuICAgICAgICB0aGlzLmxpZ2h0UG9zaXRpb25zWzAgKyBzdHJpZGVdID0gbGlnaHQucG9zaXRpb25bMF07XG4gICAgICAgIHRoaXMubGlnaHRQb3NpdGlvbnNbMSArIHN0cmlkZV0gPSBsaWdodC5wb3NpdGlvblsxXTtcbiAgICAgICAgdGhpcy5saWdodFBvc2l0aW9uc1syICsgc3RyaWRlXSA9IGxpZ2h0LnBvc2l0aW9uWzJdO1xuICAgICAgICAvLyBCdWlsZCB0aGUgbGlnaHQgY29sb3JzJyA0eDQgbWF0cml4XG4gICAgICAgIHRoaXMubGlnaHRDb2xvcnNbMCArIHN0cmlkZV0gPSBsaWdodC5jb2xvclswXTtcbiAgICAgICAgdGhpcy5saWdodENvbG9yc1sxICsgc3RyaWRlXSA9IGxpZ2h0LmNvbG9yWzFdO1xuICAgICAgICB0aGlzLmxpZ2h0Q29sb3JzWzIgKyBzdHJpZGVdID0gbGlnaHQuY29sb3JbMl07XG4gICAgfVxuICAgIHRoaXMucHJvZ3JhbS5zZXRVbmlmb3JtcyhbJ3VfTnVtTGlnaHRzJ10sIFt0aGlzLm51bUxpZ2h0c10pO1xuICAgIHRoaXMucHJvZ3JhbS5zZXRVbmlmb3JtcyhbJ3VfQW1iaWVudExpZ2h0J10sIFt0aGlzLmFtYmllbnRMaWdodENvbG9yXSk7XG4gICAgdGhpcy5wcm9ncmFtLnNldFVuaWZvcm1zKFsndV9MaWdodFBvc2l0aW9uJ10sIFt0aGlzLmxpZ2h0UG9zaXRpb25zXSk7XG4gICAgdGhpcy5wcm9ncmFtLnNldFVuaWZvcm1zKFsndV9MaWdodENvbG9yJ10sIFt0aGlzLmxpZ2h0Q29sb3JzXSk7XG5cbiAgICB0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm1bMTFdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTFdO1xuXG4gICAgdGhpcy5wcm9ncmFtLnNldFVuaWZvcm1zKFsncGVyc3BlY3RpdmUnLCAndGltZScsICd2aWV3J10sIFt0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm0sIERhdGUubm93KCkgICUgMTAwMDAwIC8gMTAwMCwgcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybV0pO1xuICAgIHZhciBrZXlzID0gdGhpcy5tZXNoUmVnaXN0cnlLZXlzO1xuICAgIHZhciByZWdpc3RyeSA9IHRoaXMubWVzaFJlZ2lzdHJ5O1xuXG4gICAgdGhpcy5tZXNoUmVnaXN0cnlLZXlzID0gc29ydGVyKGtleXMsIHJlZ2lzdHJ5KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmN1dG91dFJlZ2lzdHJ5S2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjdXRvdXQgPSB0aGlzLmN1dG91dFJlZ2lzdHJ5W3RoaXMuY3V0b3V0UmVnaXN0cnlLZXlzW2ldXTtcbiAgICAgICAgYnVmZmVycyA9IHRoaXMuYnVmZmVyUmVnaXN0cnkucmVnaXN0cnlbY3V0b3V0Lmdlb21ldHJ5XTtcblxuICAgICAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkJMRU5EKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtLnNldFVuaWZvcm1zKGN1dG91dC51bmlmb3JtS2V5cywgY3V0b3V0LnVuaWZvcm1WYWx1ZXMpO1xuICAgICAgICB0aGlzLmRyYXdCdWZmZXJzKGJ1ZmZlcnMsIGN1dG91dC5kcmF3VHlwZSwgY3V0b3V0Lmdlb21ldHJ5KTtcbiAgICAgICAgdGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuQkxFTkQpO1xuICAgIH1cblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLm1lc2hSZWdpc3RyeUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWVzaCA9IHRoaXMubWVzaFJlZ2lzdHJ5W3RoaXMubWVzaFJlZ2lzdHJ5S2V5c1tpXV07XG4gICAgICAgIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlclJlZ2lzdHJ5LnJlZ2lzdHJ5W21lc2guZ2VvbWV0cnldO1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGlmIChtZXNoLnVuaWZvcm1WYWx1ZXNbMF0gPCAxKSB7XG4gICAgICAgICAgICBnbC5kZXB0aE1hc2soZmFsc2UpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayh0cnVlKTtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFidWZmZXJzKSBjb250aW51ZTtcblxuICAgICAgICBpZiAobWVzaC5vcHRpb25zKSB0aGlzLmhhbmRsZU9wdGlvbnMobWVzaC5vcHRpb25zKTtcbiAgICAgICAgaWYgKG1lc2gudGV4dHVyZSkgbWVzaC50ZXh0dXJlLmJpbmQoKTtcblxuICAgICAgICB0aGlzLnByb2dyYW0uc2V0VW5pZm9ybXMobWVzaC51bmlmb3JtS2V5cywgbWVzaC51bmlmb3JtVmFsdWVzKTtcbiAgICAgICAgdGhpcy5kcmF3QnVmZmVycyhidWZmZXJzLCBtZXNoLmRyYXdUeXBlLCBtZXNoLmdlb21ldHJ5KTtcblxuICAgICAgICBpZiAobWVzaC50ZXh0dXJlKSBtZXNoLnRleHR1cmUudW5iaW5kKCk7XG4gICAgICAgIGlmIChtZXNoLm9wdGlvbnMpIHRoaXMucmVzZXRPcHRpb25zKG1lc2gub3B0aW9ucyk7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIExvYWRzIHRoZSBidWZmZXJzIGFuZCBpc3N1ZXMgdGhlIGRyYXcgY29tbWFuZCBmb3IgYSBnZW9tZXRyeS5cbiAqXG4gKiBAbWV0aG9kIGRyYXdCdWZmZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZlcnRleEJ1ZmZlcnMgQWxsIGJ1ZmZlcnMgdXNlZCB0byBkcmF3IHRoZSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtb2RlIEVudW1lcmF0b3IgZGVmaW5pbmcgd2hhdCBwcmltaXRpdmUgdG8gZHJhd1xuICogQHBhcmFtIHtOdW1iZXJ9IGlkIElEIG9mIGdlb21ldHJ5IGJlaW5nIGRyYXduLlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3QnVmZmVycyA9IGZ1bmN0aW9uIGRyYXdCdWZmZXJzKHZlcnRleEJ1ZmZlcnMsIG1vZGUsIGlkKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICB2YXIgYXR0cmlidXRlO1xuICAgIHZhciBsb2NhdGlvbjtcbiAgICB2YXIgc3BhY2luZztcbiAgICB2YXIgb2Zmc2V0O1xuICAgIHZhciBidWZmZXI7XG4gICAgdmFyIGl0ZXI7XG4gICAgdmFyIGo7XG5cbiAgICBpdGVyID0gdmVydGV4QnVmZmVycy5rZXlzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXI7IGkrKykge1xuICAgICAgICBhdHRyaWJ1dGUgPSB2ZXJ0ZXhCdWZmZXJzLmtleXNbaV07XG5cbiAgICAgICAgLy8gRG8gbm90IHNldCB2ZXJ0ZXhBdHRyaWJQb2ludGVyIGlmIGluZGV4IGJ1ZmZlci5cblxuICAgICAgICBpZiAoYXR0cmlidXRlID09PSAnaW5kaWNlcycpIHtcbiAgICAgICAgICAgIGogPSBpOyBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHJlaXZlIHRoZSBhdHRyaWJ1dGUgbG9jYXRpb24gYW5kIG1ha2Ugc3VyZSBpdCBpcyBlbmFibGVkLlxuXG4gICAgICAgIGxvY2F0aW9uID0gdGhpcy5wcm9ncmFtLmF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyaWJ1dGVdO1xuXG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gLTEpIGNvbnRpbnVlO1xuICAgICAgICBpZiAobG9jYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0ucHJvZ3JhbSwgYXR0cmlidXRlKTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnNbYXR0cmlidXRlXSA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgaWYgKGxvY2F0aW9uID09PSAtMSkgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNbYXR0cmlidXRlXSkge1xuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5lbmFibGVkQXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNLZXlzLnB1c2goYXR0cmlidXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHJlaXZlIGJ1ZmZlciBpbmZvcm1hdGlvbiB1c2VkIHRvIHNldCBhdHRyaWJ1dGUgcG9pbnRlci5cblxuICAgICAgICBidWZmZXIgPSB2ZXJ0ZXhCdWZmZXJzLnZhbHVlc1tpXTtcbiAgICAgICAgc3BhY2luZyA9IHZlcnRleEJ1ZmZlcnMuc3BhY2luZ1tpXTtcbiAgICAgICAgb2Zmc2V0ID0gdmVydGV4QnVmZmVycy5vZmZzZXRbaV07XG4gICAgICAgIGxlbmd0aCA9IHZlcnRleEJ1ZmZlcnMubGVuZ3RoW2ldO1xuXG4gICAgICAgIC8vIFNraXAgYmluZEJ1ZmZlciBpZiBidWZmZXIgaXMgY3VycmVudGx5IGJvdW5kLlxuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmJvdW5kQXJyYXlCdWZmZXIgIT09IGJ1ZmZlcikge1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihidWZmZXIudGFyZ2V0LCBidWZmZXIuYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuYm91bmRBcnJheUJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmxhc3REcmF3biAhPT0gaWQpIHtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jYXRpb24sIHNwYWNpbmcsIGdsLkZMT0FULCBnbC5GQUxTRSwgMCwgNCAqIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIGFueSBhdHRyaWJ1dGVzIHRoYXQgbm90IGN1cnJlbnRseSBiZWluZyB1c2VkLlxuXG4gICAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy5zdGF0ZS5lbmFibGVkQXR0cmlidXRlc0tleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNbdGhpcy5zdGF0ZS5lbmFibGVkQXR0cmlidXRlc0tleXNbaV1dO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5lbmFibGVkQXR0cmlidXRlc1trZXldICYmIHZlcnRleEJ1ZmZlcnMua2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5wcm9ncmFtLmF0dHJpYnV0ZUxvY2F0aW9uc1trZXldKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNba2V5XSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCkge1xuXG4gICAgICAgIC8vIElmIGluZGV4IGJ1ZmZlciwgdXNlIGRyYXdFbGVtZW50cy5cblxuICAgICAgICBpZiAoaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBidWZmZXIgPSB2ZXJ0ZXhCdWZmZXJzLnZhbHVlc1tqXTtcbiAgICAgICAgICAgIG9mZnNldCA9IHZlcnRleEJ1ZmZlcnMub2Zmc2V0W2pdO1xuICAgICAgICAgICAgc3BhY2luZyA9IHZlcnRleEJ1ZmZlcnMuc3BhY2luZ1tqXTtcbiAgICAgICAgICAgIGxlbmd0aCA9IHZlcnRleEJ1ZmZlcnMubGVuZ3RoW2pdO1xuXG4gICAgICAgICAgICAvLyBTa2lwIGJpbmRCdWZmZXIgaWYgYnVmZmVyIGlzIGN1cnJlbnRseSBib3VuZC5cblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuYm91bmRFbGVtZW50QnVmZmVyICE9PSBidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGJ1ZmZlci50YXJnZXQsIGJ1ZmZlci5idWZmZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuYm91bmRFbGVtZW50QnVmZmVyID0gYnVmZmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMobW9kZSwgbGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMiAqIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKG1vZGUsIDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmxhc3REcmF3biA9IGlkO1xufTtcblxuLyoqXG4gKiBXcmFwcyBkcmF3IG1ldGhvZHMgaW4gYm91bmQgZnJhbWUgYnVmZmVyXG4gKlxuICogQG1ldGhvZCByZW5kZXJPZmZzY3JlZW5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgcmVuZGVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciBzZXR1cCBhbmQgYmVmb3JlIGNsZWFudXAuXG4gKiBAcGFyYW0ge0FycmF5fSBzaXplIFNpemUgb2YgZnJhbWVidWZmZXIgYmVpbmcgZHJhd24gdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gdGV4dHVyZSBMb2NhdGlvbiB3aGVyZSB0aGUgcmVuZGVyIGRhdGEgaXMgc3RvcmVkLlxuICovXG5mdW5jdGlvbiByZW5kZXJPZmZzY3JlZW4oY2FsbGJhY2ssIHNpemUsIHRleHR1cmUpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdmFyIGZyYW1lYnVmZmVyICA9IHRoaXMuZnJhbWVidWZmZXIgPyB0aGlzLmZyYW1lYnVmZmVyIDogdGhpcy5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdmFyIHJlbmRlcmJ1ZmZlciA9IHRoaXMucmVuZGVyYnVmZmVyID8gdGhpcy5yZW5kZXJidWZmZXIgOiB0aGlzLnJlbmRlcmJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlcik7XG5cbiAgICBpZiAoc2l6ZVswXSAhPSByZW5kZXJidWZmZXIud2lkdGggfHwgc2l6ZVsxXSAhPSByZW5kZXJidWZmZXIuaGVpZ2h0KSB7XG4gICAgICAgIHJlbmRlcmJ1ZmZlci53aWR0aCA9IHNpemVbMF07XG4gICAgICAgIHJlbmRlcmJ1ZmZlci5oZWlnaHQgPSBzaXplWzFdO1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHNpemVbMF0sIHNpemVbMV0pO1xuICAgIH1cblxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5pZCwgMCk7XG4gICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyKTtcblxuICAgIGlmICh0aGlzLmRlYnVnKSBjaGVja0ZyYW1lQnVmZmVyU3RhdHVzKGdsKTtcblxuICAgIGNhbGxiYWNrLmNhbGwodGhpcyk7XG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbn07XG5cbi8qKlxuICogRGlhZ25vc2VzIHRoZSBmYWlsZWQgaW50aWFsaXphdGlvbiBvZiBhbiBGQk8uXG4gKlxuICogQG1ldGhvZCBjaGVja0ZyYW1lQnVmZmVyU3RhdHVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRoZSBXZWJHTENvbnRleHQgdGhhdCBvd25zIHRoaXMgRkJPLlxuICovXG5mdW5jdGlvbiBjaGVja0ZyYW1lQnVmZmVyU3RhdHVzKGdsKSB7XG4gICAgdmFyIHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xuXG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpcbiAgICAgICAgICAgIHRocm93KFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UXCIpOyBicmVhaztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDpcbiAgICAgICAgICAgIHRocm93KFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlRcIik7IGJyZWFrO1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzpcbiAgICAgICAgICAgIHRocm93KFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXCIpOyBicmVhaztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpcbiAgICAgICAgICAgIHRocm93KFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfVU5TVVBQT1JURURcIik7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3coXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBcIiArIHN0YXR1cyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHBhcmVudCBjYW52YXMsIHNldHMgdGhlIHZpZXdwb3J0IHNpemUgb25cbiAqIHRoZSBXZWJHTCBjb250ZXh0IGFuZCB1cGRhdGVzIHRoZSByZXNvbHV0aW9uIHVuaWZvcm0gZm9yIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAqIFNpemUgaXMgcmV0cmVpdmVkIGZyb20gdGhlIGNvbnRhaW5lciBvYmplY3Qgb2YgdGhlIHJlbmRlcmVyLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlU2l6ZVxuICogXG4gKiBAcGFyYW0ge0FycmF5fSB3aWR0aCwgaGVpZ2h0IGFuZCBkZXB0aCBvZiBjYW52YXNcbiAqIFxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gdXBkYXRlU2l6ZShzaXplKSB7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgdGhpcy5jYWNoZWRTaXplWzBdID0gc2l6ZVswXTtcbiAgICAgICAgdGhpcy5jYWNoZWRTaXplWzFdID0gc2l6ZVsxXTtcbiAgICAgICAgdGhpcy5jYWNoZWRTaXplWzJdID0gKHNpemVbMF0gPiBzaXplWzFdKSA/IHNpemVbMF0gOiBzaXplWzFdO1xuICAgIH1cblxuICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5jYWNoZWRTaXplWzBdLCB0aGlzLmNhY2hlZFNpemVbMV0pO1xuXG4gICAgdGhpcy5yZXNvbHV0aW9uVmFsdWVzWzBdID0gdGhpcy5jYWNoZWRTaXplO1xuICAgIHRoaXMucHJvZ3JhbS5zZXRVbmlmb3Jtcyh0aGlzLnJlc29sdXRpb25OYW1lLCB0aGlzLnJlc29sdXRpb25WYWx1ZXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBXZWJHTCBkcmF3aW5nIGNvbnRleHQgYmFzZWQgb24gY3VzdG9tIHBhcmFtZXRlcnNcbiAqIGRlZmluZWQgb24gYSBtZXNoLlxuICpcbiAqIEBtZXRob2QgaGFuZGxlT3B0aW9uc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIERyYXcgc3RhdGUgb3B0aW9ucyB0byBiZSBzZXQgdG8gdGhlIGNvbnRleHQuXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZU9wdGlvbnMgPSBmdW5jdGlvbiBoYW5kbGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGlmICghb3B0aW9ucykgcmV0dXJuO1xuICAgIGlmIChvcHRpb25zLmJsZW5kaW5nKSBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkUpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIHN0YXRlIG9mIHRoZSBXZWJHTCBkcmF3aW5nIGNvbnRleHQgdG8gZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQG1ldGhvZCByZXNldE9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBEcmF3IHN0YXRlIG9wdGlvbnMgdG8gYmUgc2V0IHRvIHRoZSBjb250ZXh0LlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5yZXNldE9wdGlvbnMgPSBmdW5jdGlvbiByZXNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKCFvcHRpb25zKSByZXR1cm47XG4gICAgaWYgKG9wdGlvbnMuYmxlbmRpbmcpIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xufTtcblxuLyoqXG4gKiBMb2FkcyBhbiBpbWFnZSBmcm9tIGEgc3RyaW5nIG9yIEltYWdlIG9iamVjdCBhbmQgZXhlY3V0ZXMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGxvYWRJbWFnZVxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZ30gaW1nIFRoZSBpbnB1dCBpbWFnZSBkYXRhIHRvIGxvYWQgYXMgYW4gYXNzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZmlyZWQgd2hlblxuICogdGhlIGltYWdlIGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gSW1hZ2Ugb2JqZWN0IGJlaW5nIGxvYWRlZC5cbiAqL1xuZnVuY3Rpb24gbG9hZEltYWdlIChpbWcsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iaiA9ICh0eXBlb2YgaW1nID09PSAnc3RyaW5nJyA/IG5ldyBJbWFnZSgpIDogaW1nKSB8fCB7fTtcbiAgICBvYmouY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICBpZiAoISBvYmouc3JjKSBvYmouc3JjID0gaW1nO1xuICAgIGlmICghIG9iai5jb21wbGV0ZSkgb2JqLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHsgY2FsbGJhY2sob2JqKTsgfTtcbiAgICBlbHNlIGNhbGxiYWNrKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGxvYWRpbmcgb2YgdGV4dHVyZSBvYmplY3RzLlxuICpcbiAqIEBtZXRob2QgaGFuZGxlVGV4dHVyZVxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgVGhlIGlucHV0IHRleHR1cmUgb2JqZWN0IGNvbGxlY3RlZCBmcm9tIG1lc2guXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBUZXh0dXJlIGluc3RhbmNlIGxpbmtlZCB0byBpbnB1dCBkYXRhLlxuICovXG5mdW5jdGlvbiBoYW5kbGVUZXh0dXJlKGlucHV0KSB7XG4gICAgdmFyIHNvdXJjZSA9IGlucHV0LmRhdGE7XG4gICAgdmFyIHRleHR1cmVJZCA9IGlucHV0LmlkO1xuICAgIHZhciBvcHRpb25zID0gaW5wdXQub3B0aW9ucztcbiAgICB2YXIgdGV4dHVyZSA9IHRoaXMudGV4dHVyZVJlZ2lzdHJ5W3RleHR1cmVJZF07XG5cbiAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMuZ2wsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGV4dHVyZS5zZXRBcnJheShzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAod2luZG93ICYmIHNvdXJjZSBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0ZXh0dXJlLnNyYyA9IHRleHR1cmU7XG4gICAgICAgICAgICB0ZXh0dXJlLnNldEltYWdlKGNoZWNrZXJzKTtcbiAgICAgICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5zZXRJbWFnZShzb3VyY2UpO1xuICAgICAgICAgICAgICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgdGV4dHVyZS5zZXRJbWFnZShzb3VyY2UpOyB9LCAxNik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygc291cmNlKSB7XG4gICAgICAgICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0ZXh0dXJlLnNldEltYWdlKGNoZWNrZXJzKTtcbiAgICAgICAgICAgIGxvYWRJbWFnZShzb3VyY2UsIGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnNldEltYWdlKGltZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGV4dHVyZVJlZ2lzdHJ5W3RleHR1cmVJZF0gPSB0ZXh0dXJlO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYkdMUmVuZGVyZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEJ1ZmZlcjogcmVxdWlyZSgnLi9CdWZmZXInKSxcbiAgICBCdWZmZXJSZWdpc3RyeTogcmVxdWlyZSgnLi9CdWZmZXJSZWdpc3RyeScpLFxuICAgIENoZWNrZXJib2FyZDogcmVxdWlyZSgnLi9DaGVja2VyYm9hcmQnKSxcbiAgICBQcm9ncmFtOiByZXF1aXJlKCcuL1Byb2dyYW0nKSxcbiAgICBXZWJHTFJlbmRlcmVyOiByZXF1aXJlKCcuL1dlYkdMUmVuZGVyZXInKSxcbiAgICBUZXh0dXJlOiByZXF1aXJlKCcuL1RleHR1cmUnKVxufTtcbiIsInZhciByYWRpeEJpdHMgPSAxMSxcbiAgICBtYXhSYWRpeCA9IDEgPDwgKHJhZGl4Qml0cyksXG4gICAgcmFkaXhNYXNrID0gbWF4UmFkaXggLSAxLFxuICAgIGJ1Y2tldHMgPSBuZXcgQXJyYXkobWF4UmFkaXggKiBNYXRoLmNlaWwoNjQgLyByYWRpeEJpdHMpKSxcbiAgICBtc2JNYXNrID0gMSA8PCAoKDMyIC0gMSkgJSByYWRpeEJpdHMpLFxuICAgIGxhc3RNYXNrID0gKG1zYk1hc2sgPDwgMSkgLSAxLFxuICAgIHBhc3NDb3VudCA9ICgoMzIgLyByYWRpeEJpdHMpICsgMC45OTk5OTk5OTk5OTk5OTkpIHwgMCxcbiAgICBtYXhPZmZzZXQgPSBtYXhSYWRpeCAqIChwYXNzQ291bnQgLSAxKSxcbiAgICBub3JtYWxpemVyID0gTWF0aC5wb3coMjAsIDYpO1xuXG52YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xudmFyIGZsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbnZhciBpbnRWaWV3ID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcblxuZnVuY3Rpb24gY29tcChsaXN0LCByZWdpc3RyeSwgaSkge1xuICAgIHZhciBrZXkgPSBsaXN0W2ldO1xuICAgIHJldHVybiByZWdpc3RyeVtrZXldLnVuaWZvcm1WYWx1ZXNbMV1bMTRdICsgbm9ybWFsaXplcjtcbn1cblxuZnVuY3Rpb24gbXV0YXRvcihsaXN0LCByZWdpc3RyeSwgaSwgdmFsdWUpIHtcbiAgICB2YXIga2V5ID0gbGlzdFtpXTtcbiAgICByZWdpc3RyeVtrZXldLnVuaWZvcm1WYWx1ZXNbMV1bMTRdID0gaW50VG9GbG9hdCh2YWx1ZSkgLSBub3JtYWxpemVyO1xuICAgIHJldHVybiBrZXk7XG59XG5cblxuZnVuY3Rpb24gZmxvYXRUb0ludChrKSB7XG4gICAgZmxvYXRWaWV3WzBdID0gaztcbiAgICByZXR1cm4gaW50Vmlld1swXTtcbn1cblxuZnVuY3Rpb24gaW50VG9GbG9hdChrKSB7XG4gICAgaW50Vmlld1swXSA9IGs7XG4gICAgcmV0dXJuIGZsb2F0Vmlld1swXTtcbn1cblxuZnVuY3Rpb24gc29ydChsaXN0LCByZWdpc3RyeSkge1xuICAgIHZhciBwYXNzID0gMDtcbiAgICB2YXIgb3V0ID0gW107XG5cbiAgICB2YXIgaSwgaiwgaywgbiwgZGl2LCBvZmZzZXQsIHN3YXAsIGlkLCBzdW0sIHRzdW0sIHNpemU7XG5cbiAgICBwYXNzQ291bnQgPSAoKDMyIC8gcmFkaXhCaXRzKSArIDAuOTk5OTk5OTk5OTk5OTk5KSB8IDA7XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gbWF4UmFkaXggKiBwYXNzQ291bnQ7IGkgPCBuOyBpKyspIGJ1Y2tldHNbaV0gPSAwO1xuXG4gICAgZm9yIChpID0gMCwgbiA9IGxpc3QubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGRpdiA9IGZsb2F0VG9JbnQoY29tcChsaXN0LCByZWdpc3RyeSwgaSkpO1xuICAgICAgICBkaXYgXj0gZGl2ID4+IDMxIHwgMHg4MDAwMDAwMDtcbiAgICAgICAgZm9yIChqID0gMCwgayA9IDA7IGogPCBtYXhPZmZzZXQ7IGogKz0gbWF4UmFkaXgsIGsgKz0gcmFkaXhCaXRzKSB7XG4gICAgICAgICAgICBidWNrZXRzW2ogKyAoZGl2ID4+PiBrICYgcmFkaXhNYXNrKV0rKztcbiAgICAgICAgfVxuICAgICAgICBidWNrZXRzW2ogKyAoZGl2ID4+PiBrICYgbGFzdE1hc2spXSsrO1xuICAgIH1cblxuICAgIGZvciAoaiA9IDA7IGogPD0gbWF4T2Zmc2V0OyBqICs9IG1heFJhZGl4KSB7XG4gICAgICAgIGZvciAoaWQgPSBqLCBzdW0gPSAwOyBpZCA8IGogKyBtYXhSYWRpeDsgaWQrKykge1xuICAgICAgICAgICAgdHN1bSA9IGJ1Y2tldHNbaWRdICsgc3VtO1xuICAgICAgICAgICAgYnVja2V0c1tpZF0gPSBzdW0gLSAxO1xuICAgICAgICAgICAgc3VtID0gdHN1bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoLS1wYXNzQ291bnQpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbiA9IGxpc3QubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBkaXYgPSBmbG9hdFRvSW50KGNvbXAobGlzdCwgcmVnaXN0cnksIGkpKTtcbiAgICAgICAgICAgIG91dFsrK2J1Y2tldHNbZGl2ICYgcmFkaXhNYXNrXV0gPSBtdXRhdG9yKGxpc3QsIHJlZ2lzdHJ5LCBpLCBkaXYgXj0gZGl2ID4+IDMxIHwgMHg4MDAwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dhcCA9IG91dCwgb3V0ID0gbGlzdCwgbGlzdCA9IHN3YXA7XG4gICAgICAgIHdoaWxlICgrK3Bhc3MgPCBwYXNzQ291bnQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBsaXN0Lmxlbmd0aCwgb2Zmc2V0ID0gcGFzcyAqIG1heFJhZGl4LCBzaXplID0gcGFzcyAqIHJhZGl4Qml0czsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGRpdiA9IGZsb2F0VG9JbnQoY29tcChsaXN0LCByZWdpc3RyeSwgaSkpO1xuICAgICAgICAgICAgICAgIG91dFsrK2J1Y2tldHNbb2Zmc2V0ICsgKGRpdiA+Pj4gc2l6ZSAmIHJhZGl4TWFzayldXSA9IGxpc3RbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2FwID0gb3V0LCBvdXQgPSBsaXN0LCBsaXN0ID0gc3dhcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIG4gPSBsaXN0Lmxlbmd0aCwgb2Zmc2V0ID0gcGFzcyAqIG1heFJhZGl4LCBzaXplID0gcGFzcyAqIHJhZGl4Qml0czsgaSA8IG47IGkrKykge1xuICAgICAgICBkaXYgPSBmbG9hdFRvSW50KGNvbXAobGlzdCwgcmVnaXN0cnksIGkpKTtcbiAgICAgICAgb3V0WysrYnVja2V0c1tvZmZzZXQgKyAoZGl2ID4+PiBzaXplICYgbGFzdE1hc2spXV0gPSBtdXRhdG9yKGxpc3QsIHJlZ2lzdHJ5LCBpLCBkaXYgXiAofmRpdiA+PiAzMSB8IDB4ODAwMDAwMDApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZpcnR1YWxFbGVtZW50ID0gcmVxdWlyZSgnZmFtb3VzLWRvbS1yZW5kZXJlcnMnKS5WaXJ0dWFsRWxlbWVudDtcbnZhciBzdHJpcCA9IHJlcXVpcmUoJ2ZhbW91cy11dGlsaXRpZXMnKS5zdHJpcDtcbnZhciBmbGF0Q2xvbmUgPSByZXF1aXJlKCdmYW1vdXMtdXRpbGl0aWVzJykuZmxhdENsb25lO1xuXG52YXIgQ29udGV4dCA9IHJlcXVpcmUoJy4vQ29udGV4dCcpO1xuXG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIG5ldyBDb21wb3NpdG9yLCB1c2VkIGZvciByb3V0aW5nIGNvbW1hbmRzIHJlY2VpdmVkIGZyb20gdGhlXG4gKiBXZWJXb3JrZXIgdG8gdGhlIFdlYkdMIGFuZCBET00gcmVuZGVyZXIuXG4gKlxuICogQGNsYXNzIENvbXBvc2l0b3JcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb21wb3NpdG9yKCkge1xuICAgIHRoaXMuX2NvbnRleHRzID0ge307XG4gICAgdGhpcy5fb3V0Q29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLl9pbkNvbW1hbmRzID0gW107XG5cbiAgICB0aGlzLmNsZWFyQ29tbWFuZHMoKTtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYW4gZXZlbnQgdG8gYmUgc2VudCB0byB0aGUgV2ViV29ya2VyIHRoZSBuZXh0IHRpbWUgdGhlIG91dCBjb21tYW5kXG4gKiBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICpcbiAqIEBtZXRob2Qgc2VuZEV2ZW50XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCAgICByZW5kZXIgcGF0aCB0byB0aGUgbm9kZSB0aGUgZXZlbnQgc2hvdWxkIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmVkIG9uICgqdGFyZ2V0ZWQgZXZlbnQqKVxuICogQHBhcmFtICB7U3RyaW5nfSBldiAgICAgIGV2ZW50IHR5cGVcbiAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZCBldmVudCBvYmplY3QgKHNlcmlhbGl6YWJsZSB1c2luZyBzdHJ1Y3R1cmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmluZyBhbGdvcml0aG0pXG4gKi9cbkNvbXBvc2l0b3IucHJvdG90eXBlLnNlbmRFdmVudCA9IGZ1bmN0aW9uIHNlbmRFdmVudChwYXRoLCBldiwgcGF5bG9hZCkge1xuICAgIHRoaXMuX291dENvbW1hbmRzLnB1c2goJ1dJVEgnLCBwYXRoLCAnVFJJR0dFUicsIGV2LCBwYXlsb2FkKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIG1ldGhvZCB1c2VkIGJ5IGBkcmF3Q29tbWFuZHNgLlxuICpcbiAqIEBtZXRob2QgaGFuZGxlV2l0aFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gY29tbWFuZHMgICAgIHJlbWFpbmluZyBtZXNzYWdlIHF1ZXVlIHJlY2VpdmVkIGZyb20gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdlYldvcmtlciwgdXNlZCB0byBzaGlmdCBzaW5nbGUgbWVzc2FnZXMgZnJvbVxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS5oYW5kbGVXaXRoID0gZnVuY3Rpb24gaGFuZGxlV2l0aCAoaXRlcmF0b3IsIGNvbW1hbmRzKSB7XG4gICAgdmFyIHBhdGggPSBjb21tYW5kc1tpdGVyYXRvcl07XG4gICAgdmFyIHBhdGhBcnIgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldE9yU2V0Q29udGV4dChwYXRoQXJyLnNoaWZ0KCkpO1xuICAgIHJldHVybiBjb250ZXh0LnJlY2VpdmUocGF0aEFyciwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB0b3AtbGV2ZWwgVmlydHVhbEVsZW1lbnQgYXR0YWNoZWQgdG8gdGhlIHBhc3NlZCBpbiBkb2N1bWVudFxuICogc2VsZWN0b3IuXG4gKiBJZiBubyBzdWNoIGVsZW1lbnQgZXhpc3RzLCBvbmUgd2lsbCBiZSBpbnN0YW50aWF0ZWQsIHRoZXJlZm9yZSByZXByZXNlbnRpbmdcbiAqIHRoZSBlcXVpdmFsZW50IG9mIGEgQ29udGV4dCBpbiB0aGUgTWFpbiBUaHJlYWQuXG4gKlxuICogQG1ldGhvZCBnZXRPclNldENvbnRleHRcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzZWxlY3RvciAgICAgICAgICAgIGRvY3VtZW50IHF1ZXJ5IHNlbGVjdG9yIHVzZWQgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlldmluZyB0aGUgRE9NIG5vZGUgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmlydHVhbEVsZW1lbnQgc2hvdWxkIGJlIGF0dGFjaGVkIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdFxuICogQHJldHVybiB7VmlydHVhbEVsZW1lbnR9IHJlc3VsdC5ET00gIGZpbmFsIFZpcnR1YWxFbGVtZW50XG4gKi9cbkNvbXBvc2l0b3IucHJvdG90eXBlLmdldE9yU2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldE9yU2V0Q29udGV4dChzZWxlY3Rvcikge1xuICAgIGlmICh0aGlzLl9jb250ZXh0c1tzZWxlY3Rvcl0pIHJldHVybiB0aGlzLl9jb250ZXh0c1tzZWxlY3Rvcl07XG4gICAgZWxzZSByZXR1cm4gKHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXSA9IG5ldyBDb250ZXh0KHNlbGVjdG9yLCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBtZXRob2QgdXNlZCBieSBgZHJhd0NvbW1hbmRzYC5cbiAqXG4gKiBAbWV0aG9kIGdpdmVTaXplRm9yXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBjb21tYW5kcyAgICAgcmVtYWluaW5nIG1lc3NhZ2UgcXVldWUgcmVjZWl2ZWQgZnJvbSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2ViV29ya2VyLCB1c2VkIHRvIHNoaWZ0IHNpbmdsZSBtZXNzYWdlcyBmcm9tXG4gKi9cbkNvbXBvc2l0b3IucHJvdG90eXBlLmdpdmVTaXplRm9yID0gZnVuY3Rpb24gZ2l2ZVNpemVGb3IoaXRlcmF0b3IsIGNvbW1hbmRzKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gY29tbWFuZHNbaXRlcmF0b3JdO1xuICAgIHZhciBzaXplID0gdGhpcy5nZXRPclNldENvbnRleHQoc2VsZWN0b3IpLmdldFJvb3RTaXplKCk7XG4gICAgdGhpcy5zZW5kUmVzaXplKHNlbGVjdG9yLCBzaXplKTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChzZWxlY3RvciA9PT0gJ2JvZHknKVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9zZW50UmVzaXplKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VuZFJlc2l6ZShzZWxlY3RvciwgX3RoaXMuZ2V0T3JTZXRDb250ZXh0KHNlbGVjdG9yKS5nZXRSb290U2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBtZXRob2QgdXNlZCBmb3Igbm90aWZ5aW5nIHRoZSBXZWJXb3JrZXIgYWJvdXQgZXh0ZXJuYWxseVxuICogcmVzaXplZCBjb250ZXh0cyAoZS5nLiBieSByZXNpemluZyB0aGUgYnJvd3NlciB3aW5kb3cpLlxuICpcbiAqIEBtZXRob2Qgc2VuZFJlc2l6ZVxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHNlbGVjdG9yICAgIHJlbmRlciBwYXRoIHRvIHRoZSBub2RlIChjb250ZXh0KSB0aGF0IHNob3VsZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSByZXNpemVkXG4gKiBAcGFyYW0gIHtBcnJheX0gc2l6ZSAgICAgICAgIG5ldyBjb250ZXh0IHNpemVcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuc2VuZFJlc2l6ZSA9IGZ1bmN0aW9uIHNlbmRSZXNpemUgKHNlbGVjdG9yLCBzaXplKSB7XG4gICAgdGhpcy5fb3V0Q29tbWFuZHMucHVzaCgnV0lUSCcsIHNlbGVjdG9yLCAnVFJJR0dFUicsICdDT05URVhUX1JFU0laRScsIHNpemUpO1xuICAgIHRoaXMuX3NlbnRSZXNpemUgPSB0cnVlO1xufTtcblxuQ29tcG9zaXRvci5wcm90b3R5cGUuX3dyYXBQcm94eUZ1bmN0aW9uID0gZnVuY3Rpb24gX3dyYXBQcm94eUZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50c1tpXSA9IHN0cmlwKGZsYXRDbG9uZShhcmd1bWVudHNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5fb3V0Q29tbWFuZHMucHVzaCgnSU5WT0tFJywgaWQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG59O1xuXG5Db21wb3NpdG9yLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiBpbnZva2UgKHRhcmdldCwgbWV0aG9kTmFtZSwgYXJncywgZnVuY3Rpb25BcmdzKSB7XG4gICAgdmFyIHRhcmdldE9iamVjdCA9IHdpbmRvd1t0YXJnZXRdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmdW5jdGlvbkFyZ3NbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJnc1tpXSA9IHRoaXMuX3dyYXBQcm94eUZ1bmN0aW9uKGZ1bmN0aW9uQXJnc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0YXJnZXRPYmplY3RbbWV0aG9kTmFtZV0uYXBwbHkodGFyZ2V0T2JqZWN0LCBhcmdzKTtcbn07XG5cbi8qKlxuICogUHJvY2Vzc2VzIHRoZSBwcmV2aW91c2x5IHZpYSBgcmVjZWl2ZUNvbW1hbmRzYCB1cGRhdGVkIGluY29taW5nIFwiaW5cIlxuICogY29tbWFuZCBxdWV1ZS5cbiAqIENhbGxlZCBieSBUaHJlYWRNYW5hZ2VyLlxuICpcbiAqIEBtZXRob2QgZHJhd0NvbW1hbmRzXG4gKlxuICogQHJldHVybiB7QXJyYXl9IG91dENvbW1hbmRzICBzZXQgb2YgY29tbWFuZHMgdG8gYmUgc2VudCBiYWNrIHRvIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXZWJXb3JrZXJcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuZHJhd0NvbW1hbmRzID0gZnVuY3Rpb24gZHJhd0NvbW1hbmRzKCkge1xuICAgIHZhciBjb21tYW5kcyA9IHRoaXMuX2luQ29tbWFuZHM7XG4gICAgdmFyIGxvY2FsSXRlcmF0b3IgPSAwO1xuICAgIHZhciBjb21tYW5kID0gY29tbWFuZHNbbG9jYWxJdGVyYXRvcl07XG4gICAgd2hpbGUgKGNvbW1hbmQpIHtcbiAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlICdXSVRIJzpcbiAgICAgICAgICAgICAgICBsb2NhbEl0ZXJhdG9yID0gdGhpcy5oYW5kbGVXaXRoKCsrbG9jYWxJdGVyYXRvciwgY29tbWFuZHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdJTlZPS0UnOlxuICAgICAgICAgICAgICAgIHRoaXMuaW52b2tlKFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnTkVFRF9TSVpFX0ZPUic6XG4gICAgICAgICAgICAgICAgdGhpcy5naXZlU2l6ZUZvcigrK2xvY2FsSXRlcmF0b3IsIGNvbW1hbmRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb21tYW5kID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBTd2l0Y2ggdG8gYXNzb2NpYXRpdmUgYXJyYXlzIGhlcmUuLi5cblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9jb250ZXh0cykge1xuICAgICAgICB0aGlzLl9jb250ZXh0c1trZXldLmRyYXcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fb3V0Q29tbWFuZHM7XG59O1xuXG4vKipcbiAqIFVzZWQgYnkgVGhyZWFkTWFuYWdlciB0byB1cGRhdGUgdGhlIGludGVyYWwgcXVldWUgb2YgaW5jb21pbmcgY29tbWFuZHMuXG4gKiBSZWNlaXZpbmcgY29tbWFuZHMgZG9lcyBub3QgaW1tZWRpYXRlbHkgc3RhcnQgdGhlIHJlZGVybmluZyBwcm9jZXNzLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBjb21tYW5kcyAgICAgY29tbWFuZCBxdWV1ZSB0byBiZSBwcm9jZXNzZWQgYnkgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0b3IncyBgZHJhd0NvbW1hbmRzYCBtZXRob2RcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUucmVjZWl2ZUNvbW1hbmRzID0gZnVuY3Rpb24gcmVjZWl2ZUNvbW1hbmRzKGNvbW1hbmRzKSB7XG4gICAgdmFyIGxlbiA9IGNvbW1hbmRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2luQ29tbWFuZHMucHVzaChjb21tYW5kc1tpXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBGbHVzaGVzIHRoZSBxdWV1ZSBvZiBvdXRnb2luZyBcIm91dFwiIGNvbW1hbmRzLlxuICogQ2FsbGVkIGJ5IFRocmVhZE1hbmFnZXIuXG4gKlxuICogQG1ldGhvZCBjbGVhckNvbW1hbmRzXG4gKi9cbkNvbXBvc2l0b3IucHJvdG90eXBlLmNsZWFyQ29tbWFuZHMgPSBmdW5jdGlvbiBjbGVhckNvbW1hbmRzKCkge1xuICAgIHRoaXMuX2luQ29tbWFuZHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9vdXRDb21tYW5kcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3NlbnRSZXNpemUgPSBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9zaXRvcjtcbiIsInZhciBXZWJHTFJlbmRlcmVyID0gcmVxdWlyZSgnZmFtb3VzLXdlYmdsLXJlbmRlcmVycycpLldlYkdMUmVuZGVyZXI7XG52YXIgQ2FtZXJhID0gcmVxdWlyZSgnZmFtb3VzLWNvbXBvbmVudHMnKS5DYW1lcmE7XG52YXIgRE9NUmVuZGVyZXIgPSByZXF1aXJlKCdmYW1vdXMtZG9tLXJlbmRlcmVycycpLkRPTVJlbmRlcmVyO1xuXG5mdW5jdGlvbiBDb250ZXh0KHNlbGVjdG9yLCBjb21wb3NpdG9yKSB7XG4gICAgdGhpcy5fY29tcG9zaXRvciA9IGNvbXBvc2l0b3I7XG4gICAgdGhpcy5fcm9vdEVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKHRoaXMuX3Jvb3RFbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy51cGRhdGVTaXplLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHZhciBET01MYXllckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgRE9NTGF5ZXJFbC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBET01MYXllckVsLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICBET01MYXllckVsLnN0eWxlLnRyYW5zZm9ybVN0eWxlID0gJ3ByZXNlcnZlLTNkJztcbiAgICBET01MYXllckVsLnN0eWxlLndlYmtpdFRyYW5zZm9ybVN0eWxlID0gJ3ByZXNlcnZlLTNkJztcbiAgICB0aGlzLl9yb290RWwuYXBwZW5kQ2hpbGQoRE9NTGF5ZXJFbCk7XG4gICAgdGhpcy5ET01SZW5kZXJlciA9IG5ldyBET01SZW5kZXJlcihET01MYXllckVsLCBzZWxlY3RvciwgY29tcG9zaXRvcik7IFxuIFxuICAgIHRoaXMuV2ViR0xSZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xuXG4gICAgdGhpcy5fcmVuZGVyU3RhdGUgPSB7XG4gICAgICAgIHByb2plY3Rpb25UeXBlOiBDYW1lcmEuT1JUSE9HUkFQSElDX1BST0pFQ1RJT04sXG4gICAgICAgIHBlcnNwZWN0aXZlVHJhbnNmb3JtOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSksXG4gICAgICAgIHZpZXdUcmFuc2Zvcm06IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdKSxcbiAgICAgICAgdmlld0RpcnR5OiBmYWxzZSxcbiAgICAgICAgcGVyc3BlY3RpdmVEaXJ0eTogZmFsc2VcbiAgICB9O1xuXG4gICAgdGhpcy5fc2l6ZSA9IFtdO1xuICAgIHRoaXMuX2NoaWxkcmVuID0ge307XG4gICAgdGhpcy5fZWxlbWVudEhhc2ggPSB7fTtcblxuICAgIHRoaXMuX21lc2hUcmFuc2Zvcm0gPSBbXTtcbiAgICB0aGlzLl9tZXNoU2l6ZSA9IFswLCAwLCAwXTtcblxuICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xufVxuXG5Db250ZXh0LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdTaXplID0gdGhpcy5ET01SZW5kZXJlci5fZ2V0U2l6ZSgpO1xuXG4gICAgdmFyIHdpZHRoID0gbmV3U2l6ZVswXTtcbiAgICB2YXIgaGVpZ2h0ID0gbmV3U2l6ZVsxXTtcblxuICAgIHRoaXMuX3NpemVbMF0gPSB3aWR0aDtcbiAgICB0aGlzLl9zaXplWzFdID0gaGVpZ2h0O1xuICAgIHRoaXMuX3NpemVbMl0gPSAod2lkdGggPiBoZWlnaHQpID8gd2lkdGggOiBoZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggID0gd2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLldlYkdMUmVuZGVyZXIudXBkYXRlU2l6ZSh0aGlzLl9zaXplKTtcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5Db250ZXh0LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gZHJhdygpIHtcbiAgICB0aGlzLkRPTVJlbmRlcmVyLmRyYXcodGhpcy5fcmVuZGVyU3RhdGUpO1xuICAgIGlmICh0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuV2ViR0xSZW5kZXJlci5kcmF3KHRoaXMuX3JlbmRlclN0YXRlKTtcblxuICAgIGlmICh0aGlzLl9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5KSB0aGlzLl9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuX3JlbmRlclN0YXRlLnZpZXdEaXJ0eSkgdGhpcy5fcmVuZGVyU3RhdGUudmlld0RpcnR5ID0gZmFsc2U7XG59O1xuXG5Db250ZXh0LnByb3RvdHlwZS5nZXRSb290U2l6ZSA9IGZ1bmN0aW9uIGdldFJvb3RTaXplKCkge1xuICAgIHJldHVybiB0aGlzLkRPTVJlbmRlcmVyLmdldFNpemUoKTtcbn07XG5cbkNvbnRleHQucHJvdG90eXBlLmluaXRXZWJHTCA9IGZ1bmN0aW9uIGluaXRXZWJHTCgpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuY2FudmFzLmNsYXNzTmFtZSA9ICdmYW1vdXMtd2ViZ2wnO1xuICAgIHRoaXMuX3Jvb3RFbC5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgdGhpcy5XZWJHTFJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIodGhpcy5jYW52YXMpO1xuICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xufTtcblxuQ29udGV4dC5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uIHJlY2VpdmUocGF0aEFyciwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgdmFyIHBvaW50ZXI7XG4gICAgdmFyIHBhcmVudEVsO1xuICAgIHZhciBlbGVtZW50O1xuICAgIHZhciBpZDtcbiAgICB2YXIgbG9jYWxJdGVyYXRvciA9IGl0ZXJhdG9yO1xuXG4gICAgdmFyIGNvbW1hbmQgPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgIHRoaXMuRE9NUmVuZGVyZXIubG9hZFBhdGgocGF0aCk7XG4gICAgdGhpcy5ET01SZW5kZXJlci5maW5kVGFyZ2V0KCk7XG4gICAgd2hpbGUgKGNvbW1hbmQpIHtcblxuICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ0lOSVRfRE9NJzpcbiAgICAgICAgICAgICAgICB0aGlzLkRPTVJlbmRlcmVyLmluc2VydEVsKGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdDSEFOR0VfVFJBTlNGT1JNJzpcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCAxNiA7IGkrKykgdGhpcy5fbWVzaFRyYW5zZm9ybVtpXSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG5cbiAgICAgICAgICAgICAgICB0aGlzLkRPTVJlbmRlcmVyLnNldE1hdHJpeCh0aGlzLl9tZXNoVHJhbnNmb3JtKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLldlYkdMUmVuZGVyZXIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuV2ViR0xSZW5kZXJlci5zZXRDdXRvdXRVbmlmb3JtKHBhdGgsICd0cmFuc2Zvcm0nLCB0aGlzLl9tZXNoVHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQ0hBTkdFX1NJWkUnOlxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG5cbiAgICAgICAgICAgICAgICB0aGlzLkRPTVJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuV2ViR0xSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNoU2l6ZVswXSA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNoU2l6ZVsxXSA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLnNldEN1dG91dFVuaWZvcm0ocGF0aCwgJ3NpemUnLCB0aGlzLl9tZXNoU2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdDSEFOR0VfUFJPUEVSVFknOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuV2ViR0xSZW5kZXJlci5nZXRPclNldEN1dG91dChwYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLkRPTVJlbmRlcmVyLnNldFByb3BlcnR5KGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdDSEFOR0VfQ09OVEVOVCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5XZWJHTFJlbmRlcmVyLmdldE9yU2V0Q3V0b3V0KHBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuRE9NUmVuZGVyZXIuc2V0Q29udGVudChjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQ0hBTkdFX0FUVFJJQlVURSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5XZWJHTFJlbmRlcmVyLmdldE9yU2V0Q3V0b3V0KHBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuRE9NUmVuZGVyZXIuc2V0QXR0cmlidXRlKGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdBRERfQ0xBU1MnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuV2ViR0xSZW5kZXJlci5nZXRPclNldEN1dG91dChwYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLkRPTVJlbmRlcmVyLmFkZENsYXNzKGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0pOyBcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnUkVNT1ZFX0NMQVNTJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLldlYkdMUmVuZGVyZXIuZ2V0T3JTZXRDdXRvdXQocGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ET01SZW5kZXJlci5yZW1vdmVDbGFzcyhjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQUREX0VWRU5UX0xJU1RFTkVSJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLldlYkdMUmVuZGVyZXIuZ2V0T3JTZXRDdXRvdXQocGF0aCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG5cbiAgICAgICAgICAgICAgICB0aGlzLkRPTVJlbmRlcmVyLmFkZEV2ZW50TGlzdGVuZXIocGF0aCwgdHlwZSwgcHJvcGVydGllcywgcHJldmVudERlZmF1bHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHTF9TRVRfRFJBV19PUFRJT05TJzogXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuaW5pdFdlYkdMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLnNldE1lc2hPcHRpb25zKHBhdGgsIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHTF9BTUJJRU5UX0xJR0hUJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5pbml0V2ViR0woKTtcbiAgICAgICAgICAgICAgICB0aGlzLldlYkdMUmVuZGVyZXIuc2V0QW1iaWVudExpZ2h0Q29sb3IoXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHTF9MSUdIVF9QT1NJVElPTic6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuaW5pdFdlYkdMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLnNldExpZ2h0UG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHTF9MSUdIVF9DT0xPUic6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuaW5pdFdlYkdMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLnNldExpZ2h0Q29sb3IoXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdNQVRFUklBTF9JTlBVVCc6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuaW5pdFdlYkdMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLmhhbmRsZU1hdGVyaWFsSW5wdXQoXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHTF9TRVRfR0VPTUVUUlknOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLmluaXRXZWJHTCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuV2ViR0xSZW5kZXJlci5zZXRHZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0dMX1VOSUZPUk1TJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5pbml0V2ViR0woKTtcbiAgICAgICAgICAgICAgICB0aGlzLldlYkdMUmVuZGVyZXIuc2V0TWVzaFVuaWZvcm0oXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHTF9CVUZGRVJfREFUQSc6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuaW5pdFdlYkdMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLmJ1ZmZlckRhdGEoXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdQSU5IT0xFX1BST0pFQ1RJT04nOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnByb2plY3Rpb25UeXBlID0gQ2FtZXJhLlBJTkhPTEVfUFJPSkVDVElPTjtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMV0gPSAtMSAvIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnT1JUSE9HUkFQSElDX1BST0pFQ1RJT04nOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnByb2plY3Rpb25UeXBlID0gQ2FtZXJhLk9SVEhPR1JBUEhJQ19QUk9KRUNUSU9OO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzExXSA9IDA7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFJBTlNGT1JNJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzBdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzFdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzJdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzNdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bNF0gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bNV0gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bNl0gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bN10gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVs4XSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVs5XSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVsxMF0gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bMTFdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bMTJdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzEzXSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVsxNF0gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bMTVdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1dJVEgnOiByZXR1cm4gbG9jYWxJdGVyYXRvciAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBjb21tYW5kID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxJdGVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGV4dDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgVGhyZWFkTWFuYWdlciBpcyBiZWluZyB1cGRhdGVkIGJ5IGFuIEVuZ2luZSBieSBjb25zZWN1dGl2ZWx5IGNhbGxpbmcgaXRzXG4gKiBgdXBkYXRlYCBtZXRob2QuIEl0IGNhbiBlaXRoZXIgbWFuYWdlIGEgcmVhbCBXZWItV29ya2VyIG9yIHRoZSBnbG9iYWxcbiAqIEZhbW91cyBjb3JlIHNpbmdsZXRvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbXBvc2l0b3IgPSBuZXcgQ29tcG9zaXRvcigpO1xuICogXG4gKiAvLyBVc2luZyBhIFdlYiBXb3JrZXJcbiAqIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKCd3b3JrZXIuYnVuZGxlLmpzJyk7XG4gKiB2YXIgdGhyZWFkbWFuZ2VyID0gbmV3IFRocmVhZE1hbmFnZXIod29ya2VyLCBjb21wb3NpdG9yKTtcbiAqIFxuICogLy8gV2l0aG91dCB1c2luZyBhIFdlYiBXb3JrZXJcbiAqIHZhciB0aHJlYWRtYW5nZXIgPSBuZXcgVGhyZWFkTWFuYWdlcihGYW1vdXMsIGNvbXBvc2l0b3IpO1xuICogXG4gKiBAY2xhc3MgIFRocmVhZE1hbmFnZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogXG4gKiBAcGFyYW0ge0ZhbW91c3xXb3JrZXJ9IHRocmVhZCAgICAgICAgVGhlIHRocmVhZCBiZWluZyB1c2VkIHRvIHJlY2VpdmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcyBmcm9tIGFuZCBwb3N0IG1lc3NhZ2VzIHRvLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEV4cGVjdGVkIHRvIGV4cG9zZSBhIFdlYldvcmtlci1saWtlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQVBJLCB3aGljaCBtZWFucyBwcm92aWRpbmcgYSB3YXkgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW4gZm9yIHVwZGF0ZXMgYnkgc2V0dGluZyBpdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgb25tZXNzYWdlYCBwcm9wZXJ0eSBhbmQgc2VuZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXMgdXNpbmcgYHBvc3RNZXNzYWdlYC5cbiAqIEBwYXJhbSB7Q29tcG9zaXRvcn0gY29tcG9zaXRvciAgICAgICBhbiBpbnN0YW5jZSBvZiBDb21wb3NpdG9yIHVzZWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0IGVucXVldWVkIGRyYXcgY29tbWFuZHMgZnJvbSB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHNlbnQgdG8gdGhlIHRocmVhZFxuICovXG5mdW5jdGlvbiBUaHJlYWRNYW5hZ2VyICh0aHJlYWQsIGNvbXBvc2l0b3IpIHtcbiAgICB0aGlzLl90aHJlYWQgPSB0aHJlYWQ7XG4gICAgdGhpcy5fY29tcG9zaXRvciA9IGNvbXBvc2l0b3I7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX3RocmVhZC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgX3RoaXMuX2NvbXBvc2l0b3IucmVjZWl2ZUNvbW1hbmRzKGV2LmRhdGEgPyBldi5kYXRhIDogZXYpO1xuICAgIH07XG4gICAgdGhpcy5fdGhyZWFkLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbWV0aG9kIGJlaW5nIGludm9rZWQgYnkgdGhlIEVuZ2luZSBvbiBldmVyeSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC5cbiAqIFVzZWQgZm9yIHVwZGF0aW5nIHRoZSBub3Rpb24gb2YgdGltZSB3aXRoaW4gdGhlIG1hbmFnZWQgdGhyZWFkIGJ5IHNlbmRpbmdcbiAqIGEgRlJBTUUgY29tbWFuZCBhbmQgc2VuZGluZyBtZXNzYWdlcyB0byBcbiAqIFxuICogQG1ldGhvZCB1cGRhdGVcbiAqIFxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lIHVuaXggdGltZXN0YW1wIHRvIGJlIHBhc3NlZCBkb3duIHRvIHRoZSB3b3JrZXIgYXMgYVxuICogICAgICAgICAgICAgICAgICAgICAgIEZSQU1FIGNvbW1hbmRcbiAqL1xuVGhyZWFkTWFuYWdlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICh0aW1lKSB7XG4gICAgdGhpcy5fdGhyZWFkLnBvc3RNZXNzYWdlKFsnRlJBTUUnLCB0aW1lXSk7XG4gICAgdmFyIHRocmVhZE1lc3NhZ2VzID0gdGhpcy5fY29tcG9zaXRvci5kcmF3Q29tbWFuZHMoKTtcbiAgICB0aGlzLl90aHJlYWQucG9zdE1lc3NhZ2UodGhyZWFkTWVzc2FnZXMpO1xuICAgIHRoaXMuX2NvbXBvc2l0b3IuY2xlYXJDb21tYW5kcygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaHJlYWRNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBDb21wb3NpdG9yOiByZXF1aXJlKCcuL0NvbXBvc2l0b3InKSxcbiAgICBUaHJlYWRNYW5hZ2VyOiByZXF1aXJlKCcuL1RocmVhZE1hbmFnZXInKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNlc3Npb25IaXN0b3J5U3VwcG9ydCA9IHdpbmRvdy5oaXN0b3J5ICYmIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSAmJiB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGU7XG5cbi8qKlxuICogQSBzdGF0ZWxlc3Mgc2hpbSBmb3IgaGFzaCByb3V0aW5nLiBVc2VkIGJ5IHJvdXRlci5cbiAqICAgU3VwcG9ydHMgaGFzaCBiYW5nIHJvdXRpbmcgYW5kIEhUTUw1IHB1c2hTdGF0ZS5cbiAqICAgRmFsbHMgYmFjayB0byBoYXNoIGJhbmcgdXJscyB3aGVuIHB1c2hTdGF0ZSBpcyBub3Qgc3VwcG9ydGVkLlxuICogICBJbXBsZW1lbnRzIHN1YnNldCBvZiBXM0Mgc3BlYyBpbiByZXNwZWN0IHRvXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTAxMTMvaGlzdG9yeS5odG1sI2hpc3RvcnktMFxuICpcbiAqIEBIaXN0b3J5XG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGhpc3RvcnkgPSBIaXN0b3J5KCk7XG4gKiBjb25zb2xlLmxvZyhoaXN0b3J5Lmhhc2hCYW5nVXJscyk7XG4gKiBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgZG9jdW1lbnQudGl0bGUsICcvcm91dGUnKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmhhc2hCYW5nVXJscyBmb3JjZSBoaXN0b3J5IHRvIHVzZSBVUkxzXG4gKiAgIGluIHRoZSBmb3JtIG9mIC8jIS9yb3V0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHJvb3RcbiAqL1xuZnVuY3Rpb24gSGlzdG9yeShvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhpc3RvcnkpKSByZXR1cm4gbmV3IEhpc3Rvcnkob3B0aW9ucyk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl9yb290ID0gb3B0aW9ucy5yb290IHx8ICcnO1xuICAgIHRoaXMuX3Nlc3Npb25IaXN0b3J5U3VwcG9ydCA9IHNlc3Npb25IaXN0b3J5U3VwcG9ydDtcbiAgICB0aGlzLmhhc2hCYW5nVXJscyA9IG9wdGlvbnMuaGFzaEJhbmdVcmxzIHx8ICF0aGlzLl9zZXNzaW9uSGlzdG9yeVN1cHBvcnQ7XG4gICAgdGhpcy5fbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG59XG5cbi8qKlxuICogQHByb3BlcnR5IHtCb29sZWFufSBoYXNoQmFuZ1VybHNcbiAqIEByZWFkb25seVxuICovXG5IaXN0b3J5LnByb3RvdHlwZS5oYXNoQmFuZ1VybHMgPSBmYWxzZTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb24gZXZlcnkgc3RhdGUgY2hhbmdlLlxuICpcbiAqIEBtZXRob2Qgb25TdGF0ZUNoYW5nZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgY2FsbGJhY2sgdG8gaW52b2tlIG9uIHN0YXRlIGNoYW5nZVxuICpcbiAqIEByZXR1cm4ge0hpc3Rvcnl9IHRoaXNcbiAqL1xuSGlzdG9yeS5wcm90b3R5cGUub25TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIG9uU3RhdGVDaGFuZ2UoaGFuZGxlcikge1xuICAgIC8vIHByZWZlciBIVE1MNSBoaXN0b3J5IEFQSSBvdmVyIGhhc2hjaGFuZ2Ugd2hlbiBwb3NzaWJsZVxuICAgIGlmICh0aGlzLl9zZXNzaW9uSGlzdG9yeVN1cHBvcnQpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgaGFuZGxlcik7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwdXNoc3RhdGUnLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5oYXNoQmFuZ1VybHMgJiYgJ29uaGFzaGNoYW5nZScgaW4gd2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgaGFuZGxlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBvbmx5IHBvc3NpYmxlIHNvbHV0aW9uIGF0IHRoaXMgcG9pbnQgaXMgdG8gdXNlIGFuIHVnbHkgY29tYmluYXRpb25cbiAgICAgICAgLy8gb2Ygc2V0SW50ZXJ2YWwgYW5kIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVyZWdpc3RlciBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyIHRoYXQgaGFzIGJlZW4gcHJldmlvdXNseSByZWdpc3RlcmVkXG4gKiAgIHRocm91Z2ggb25TdGF0ZUNoYW5nZS5cbiAqXG4gKiBAbWV0aG9kIG9mZlN0YXRlQ2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBoYW5kbGVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB0aHJvdWdoIG9uU3RhdGVDaGFuZ2VcbiAqXG4gKiBAcmV0dXJuIHtIaXN0b3J5fSB0aGlzXG4gKi9cbkhpc3RvcnkucHJvdG90eXBlLm9mZlN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gb2ZmU3RhdGVDaGFuZ2UoaGFuZGxlcikge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGhhbmRsZXIpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwdXNoc3RhdGUnLCBoYW5kbGVyKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIGhhbmRsZXIpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTaGltIGZvciB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGVcbiAqIFxuICogQG1ldGhvZCBwdXNoU3RhdGVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW1zIHtPYmplY3R9IGRhdGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0aHJvdWdoIHNlc3Npb24gQVBJIGlmIHBvc3NpYmxlLFxuICogICBub3QgYWNjZXNzYWJsZSBsYXRlciBvbiwgdXNlZCB0byBtYWtlIGFyZ3VtZW50cyBsaXN0IGNvbXBsYWludCB3aXRoIFczQ1xuICogICBzcGVjXG4gKiBAcGFyYW1zIHtTdHJpbmc9ZG9jdW1lbnQudGl0bGV9IHRpdGxlIG5ldyBkb2N1bWVudCB0aXRsZSwgbm90IGFzc29jaWF0ZWQgd2l0aFxuICogICBuZXcgc3RhdGVcbiAqIEBwYXJhbXMge1N0cmluZ30gdXJsXG4gKlxuICogQHJldHVybiB7SGlzdG9yeX0gdGhpc1xuICovXG5IaXN0b3J5LnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbiBwdXNoU3RhdGUoZGF0YSwgdGl0bGUsIHVybCkge1xuICAgIGRvY3VtZW50LnRpdGxlID0gdGl0bGUgfHwgZG9jdW1lbnQudGl0bGU7XG4gICAgaWYgKHRoaXMuaGFzaEJhbmdVcmxzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXNzaW9uSGlzdG9yeVN1cHBvcnQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShkYXRhLCB0aXRsZSwgJyMhJyArIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHVybDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKGRhdGEsIHRpdGxlLCB1cmwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2hpbSBmb3Igd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlXG4gKiBcbiAqIEBtZXRob2QgcmVwbGFjZVN0YXRlXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtcyB7T2JqZWN0fSBkYXRhIHN0YXRlIG9iamVjdCBwYXNzZWQgdGhyb3VnaCBzZXNzaW9uIEFQSSBpZiBwb3NzaWJsZSxcbiAqICAgbm90IGFjY2Vzc2FibGUgbGF0ZXIgb24sIHVzZWQgdG8gbWFrZSBhcmd1bWVudHMgbGlzdCBjb21wbGFpbnQgd2l0aCBXM0NcbiAqICAgc3BlY1xuICogQHBhcmFtcyB7U3RyaW5nPWRvY3VtZW50LnRpdGxlfSB0aXRsZSBuZXcgZG9jdW1lbnQgdGl0bGUsIG5vdCBhc3NvY2lhdGVkIHdpdGhcbiAqICAgbmV3IHN0YXRlXG4gKiBAcGFyYW1zIHtTdHJpbmd9IHVybFxuICpcbiAqIEByZXR1cm4ge0hpc3Rvcnl9IHRoaXNcbiAqL1xuSGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gcmVwbGFjZVN0YXRlKGRhdGEsIHRpdGxlLCB1cmwpIHtcbiAgICBkb2N1bWVudC50aXRsZSA9IHRpdGxlIHx8IGRvY3VtZW50LnRpdGxlO1xuICAgIGlmICh0aGlzLmhhc2hCYW5nVXJscykge1xuICAgICAgICBpZiAodGhpcy5fc2Vzc2lvbkhpc3RvcnlTdXBwb3J0KSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoZGF0YSwgdGl0bGUsICcjIScgKyB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXJsID0gKCcnICsgd2luZG93LmxvY2F0aW9uKS5zcGxpdCgnIycpWzBdICsgJyMhJyArIHVybDtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHVybCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShkYXRhLCB0aXRsZSwgdXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBjdXJyZW50IG5vcm1hbGl6ZWQgc3RhdGUgKHJvdXRlZCBwYXRobmFtZSkuXG4gKiBOb3QgY29tcGxpYW50IHdpdGggW1czQyBzcGVjIDUuNCBTZXNzaW9uIGhpc3RvcnkgYW5kXG4gKiBuYXZpZ2F0aW9uXShodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwMTEzL2hpc3RvcnkuaHRtbClcbiAqXG4gKiBAbWV0aG9kIGdldFN0YXRlXG4gKlxuICogQHJldHVybiB7U3RyaW5nfG51bGx9IHN0YXRlIGFzIG5vcm1hbGl6ZWQgcGF0aG5hbWVcbiAqL1xuSGlzdG9yeS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuX2xvY2F0aW9uLnBhdGhuYW1lLm1hdGNoKCdeJyArIHRoaXMuX3Jvb3QpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNoQmFuZ1VybHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSSh0aGlzLl9sb2NhdGlvbi5wYXRobmFtZSkuc3Vic3RyaW5nKHRoaXMuX3Jvb3QubGVuZ3RoKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhpc3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfSGlzdG9yeSA9IHJlcXVpcmUoJy4vSGlzdG9yeScpO1xuXG4vKipcbiAqIEEgc2ltcGxlIHJvdXRlciBzdXBwb3J0aW5nIEhUTUw1IHB1c2hTdGF0ZSBhbmQgaGFzaGJhbmcgIHJvdXRpbmcgKFwiIyEvXCIpLlxuICogXG4gKiBAZXhhbXBsZVxuICogdmFyIHJvdXRlciA9IFJvdXRlcih7XG4gKiAgICAgJy9leGFtcGxlLXJvdXRlLTAnOiBmdW5jdGlvbigpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJy9leGFtcGxlLXJvdXRlLTAnKTtcbiAqICAgICB9LFxuICogICAgICcvZXhhbXBsZS1yb3V0ZS0xJzogZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCcvZXhhbXBsZS1yb3V0ZS0xJyk7XG4gKiAgICAgfSxcbiAqICAgICAnL2V4YW1wbGUtcm91dGUtMic6IGZ1bmN0aW9uKCkge1xuICogICAgICAgICBjb25zb2xlLmxvZygnL2V4YW1wbGUtcm91dGUtMicpO1xuICogICAgIH0sXG4gKiAgICAgJy9leGFtcGxlLXJvdXRlLTMnOiBmdW5jdGlvbigpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJy9leGFtcGxlLXJvdXRlLTMnKTtcbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiB2YXIgY3VycmVudFN0YXRlID0gMDtcbiAqIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICogICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDQpIHJldHVybiBjbGVhclRpbWVvdXQoaW50ZXJ2YWwpO1xuICogICAgIHJvdXRlci5uYXZpZ2F0ZSgnL2V4YW1wbGUtcm91dGUtJyArIGN1cnJlbnRTdGF0ZSwgeyBpbnZva2U6IHRydWUgfSk7XG4gKiAgICAgY3VycmVudFN0YXRlKys7XG4gKiB9LCAxMDAwKTtcbiAqIFxuICogQGNsYXNzIFJvdXRlclxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJvdXRlc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zaWxlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5oYXNoQmFuZ1VybHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb3h5XG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5yb290XG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMudmFsaWRhdGUgY2hlY2sgZm9yIHVua25vd24gcm91dGVzXG4gKi9cbmZ1bmN0aW9uIFJvdXRlcihyb3V0ZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUm91dGVyKSkgcmV0dXJuIG5ldyBSb3V0ZXIocm91dGVzLCBvcHRpb25zKTtcbiAgICBcbiAgICByb3V0ZXMgPSByb3V0ZXMgfHwge307XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLl9yb290ID0gb3B0aW9ucy5yb290IHx8ICcnO1xuXG4gICAgdGhpcy5fcm91dGVzID0gW107XG4gICAgdGhpcy5wcm94eSA9IG9wdGlvbnMucHJveHkgfHwge307XG4gICAgaWYgKG9wdGlvbnMudmFsaWRhdGUpIHRoaXMudmFsaWRhdGUgPSB0cnVlO1xuXG4gICAgLy8gQXZvaWRzIGN5bGljIHJvdXRpbmcgYnkgc3RvcmluZyB0aGUgbGFzdCByb3V0ZWQgc3RhdGVcbiAgICAvLyBTZWVtcyBsaWtlIFczQyBzcGVjIGRvZXNuJ3QgbWVudGlvbiBpZiBwdXNoU3RhdGUgZXZlbnQgc2hvdWxkIGJlXG4gICAgLy8gZGlzcGF0Y2hlZCBvbiBwYWdlIGxvYWQuXG4gICAgdGhpcy5fbGFzdFN0YXRlID0gbnVsbDtcblxuICAgIF9hZGRJbml0aWFsUm91dGVzLmNhbGwodGhpcywgcm91dGVzKTtcblxuICAgIHRoaXMuX2hpc3RvcnkgPSBfSGlzdG9yeSh7XG4gICAgICAgIGhhc2hCYW5nVXJsczogb3B0aW9ucy5oYXNoQmFuZ1VybHMsXG4gICAgICAgIHJvb3Q6IHRoaXMuX3Jvb3RcbiAgICB9KS5vblN0YXRlQ2hhbmdlKF9vblN0YXRlQ2hhbmdlLmJpbmQodGhpcykpO1xuXG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy5zdGFydCgpO1xufVxuXG4vKipcbiAqIFN0YXJ0cyB0aGUgcm91dGVyIGJ5IGludm9raW5nIHRoZSByb3V0ZSBoYW5kbGVyIGJvdW5kIHRvIHRoZSBjdXJyZW50XG4gKiAgIHBhdGhuYW1lLiBXaWxsIGJlIGNhbGxlZCBieSBjb25zdHJ1Y3RvciwgdW5sZXNzIHNpbGVudCBvcHRpb24gaXNcbiAqICAgaW4gdXNlLlxuICpcbiAqIEBtZXRob2Qgc3RhcnRcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcmV0dXJuIHtSb3V0ZXJ9IHRoaXNcbiAqL1xuUm91dGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIHRoaXMuaW52b2tlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE5hdmlnYXRlcyB0byB0aGUgZ2l2ZW4gcm91dGUuIElmIG5vIHJvdXRlIGlzIGdpdmUsIG5hdmlnYXRlIHRvIHRoZSBjdXJyZW50XG4gKiAgIHBhdGhuYW1lICh1c2VkIGR1cmluZyBpbml0aWFsaXphdGlvbikuXG4gKlxuICogQG1ldGhvZCBuYXZpZ2F0ZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGU9Y3VycmVudCBwYXRobmFtZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMucmVwbGFjZVxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmludm9rZVxuICpcbiAqIEByZXR1cm4ge1JvdXRlcn0gdGhpc1xuICovXG5Sb3V0ZXIucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24gbmF2aWdhdGUoc3RhdGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuX2hpc3RvcnkuZ2V0U3RhdGUoKTtcbiAgICBpZiAodGhpcy5fbGFzdFN0YXRlID09PSBzdGF0ZSkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgbWV0aG9kID0gb3B0aW9ucy5yZXBsYWNlID8gJ3JlcGxhY2VTdGF0ZScgOiAncHVzaFN0YXRlJztcbiAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0obnVsbCwgbnVsbCwgc3RhdGUpO1xuXG4gICAgaWYgKG9wdGlvbnMuaW52b2tlKSB0aGlzLmludm9rZSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEeW5hbWljYWxseSBhZGRzIGEgcm91dGUgdG8gdGhlIHJlZ2lzdGVyLlxuICpcbiAqIEBtZXRob2QgYWRkUm91dGVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IHJvdXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKlxuICogQHJldHVybiB7Um91dGVyfSB0aGlzXG4gKi9cblJvdXRlci5wcm90b3R5cGUuYWRkUm91dGUgPSBmdW5jdGlvbiBhZGRSb3V0ZShyb3V0ZSwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2Ygcm91dGUgPT09ICdzdHJpbmcnKSByb3V0ZSA9IF9jcmVhdGVSZWdFeHBSb3V0ZShyb3V0ZSk7XG4gICAgdGhpcy5fcm91dGVzLnB1c2goeyByZWdFeHA6IHJvdXRlLCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIHRoZSBoYW5kbGVyIGJvdW5kIHRvIHRoZSBnaXZlbiBzdGF0ZS5cbiAqXG4gKiBAbWV0aG9kIGludm9rZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGU9Y3VycmVudCBwYXRobmFtZV0gcm91dGVcbiAqXG4gKiBAcmV0dXJuIHtSb3V0ZXJ9IHRoaXNcbiAqL1xuUm91dGVyLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiBpbnZva2Uoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fbGFzdFN0YXRlID09PSBzdGF0ZSkgcmV0dXJuIHRoaXM7XG4gICAgc3RhdGUgPSBzdGF0ZSB8fCB0aGlzLl9oaXN0b3J5LmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlID09PSBudWxsKSByZXR1cm47XG4gICAgdmFyIHVua25vd24gPSB0aGlzLl9yb3V0ZXMuZXZlcnkoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBfY2hlY2tSb3V0ZS5jYWxsKHRoaXMsIHJvdXRlLCBzdGF0ZSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm91dGUuaGFuZGxlciA9PT0gJ3N0cmluZycgJiYgdGhpcy5wcm94eVtyb3V0ZS5oYW5kbGVyXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJveHlbcm91dGUuaGFuZGxlcl0uYXBwbHkobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdXRlLmhhbmRsZXIuYXBwbHkobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICB9LmJpbmQodGhpcykpO1xuICAgIGlmICh1bmtub3duICYmIHRoaXMudmFsaWRhdGUpIHRocm93IG5ldyBFcnJvcignVW5rbm93biByb3V0ZScpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2NoZWNrUm91dGUocm91dGUsIHN0YXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlLm1hdGNoKHJvdXRlLnJlZ0V4cCk7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIG5vIHN1cHBvcnQgZm9yIG5lc3RlZCBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDEpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVSZWdFeHBSb3V0ZShyb3V0ZSkge1xuICAgIC8vIFRPRE8gY291bGQgYmUgZXh0ZW5kZWQgdG8gc3BsYXRzIGV0Yy5cbiAgICByb3V0ZSA9IHJvdXRlLnJlcGxhY2UoL1xcOlxcdysvLCBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgcGFyYW0gPSBwYXJhbS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIHJldHVybiAnKCcgKyBwYXJhbSArICcpJztcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyByb3V0ZSArICckJyk7XG59XG5cbmZ1bmN0aW9uIF9vblN0YXRlQ2hhbmdlKCkge1xuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgICB0aGlzLmludm9rZSgpO1xufVxuXG5mdW5jdGlvbiBfYWRkSW5pdGlhbFJvdXRlcyhyb3V0ZXMsIHNjb3BlKSB7XG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAgIHNjb3BlID0gc2NvcGUgfHwgJyc7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocm91dGVzKSkge1xuICAgICAgICAvLyBjb21wb3NpbmcgbmVzdGVkIHNldHMgb2YgcmVndWxhciBleHByZXNzaW9ucyBvZiByZWd1bGFyIGV4cHJlc3Npb25zXG4gICAgICAgIC8vIGluY2x1ZGluZyBsb29rYXJvdW5kcyBtaWdodCBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIEZvciBub3csXG4gICAgICAgIC8vIHRob3NlIGNhbid0IGJlIHRyYXZlcnNlZC5cbiAgICAgICAgcm91dGVzLmZvckVhY2goZnVuY3Rpb24ocm91dGVTcGVjKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFJvdXRlKHJvdXRlU3BlYy5yb3V0ZSwgcm91dGVTcGVjLmhhbmRsZXIpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIHJvdXRlIGluIHJvdXRlcykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSByb3V0ZXNbcm91dGVdO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCB0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFJvdXRlKHNjb3BlICsgcm91dGUsIHJvdXRlc1tyb3V0ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX2FkZEluaXRpYWxSb3V0ZXMuY2FsbCh0aGlzLCByb3V0ZXNbcm91dGVdLCBzY29wZSArIHJvdXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSb3V0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEhpc3Rvcnk6IHJlcXVpcmUoJy4vSGlzdG9yeScpLFxuICAgIFJvdXRlcjogcmVxdWlyZSgnLi9Sb3V0ZXInKVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcywgY3VzdG9tRG9jdW1lbnQpIHtcbiAgdmFyIGRvYyA9IGN1c3RvbURvY3VtZW50IHx8IGRvY3VtZW50O1xuICBpZiAoZG9jLmNyZWF0ZVN0eWxlU2hlZXQpIHtcbiAgICB2YXIgc2hlZXQgPSBkb2MuY3JlYXRlU3R5bGVTaGVldCgpXG4gICAgc2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgICByZXR1cm4gc2hlZXQub3duZXJOb2RlO1xuICB9IGVsc2Uge1xuICAgIHZhciBoZWFkID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0sXG4gICAgICAgIHN0eWxlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG5cbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmJ5VXJsID0gZnVuY3Rpb24odXJsKSB7XG4gIGlmIChkb2N1bWVudC5jcmVhdGVTdHlsZVNoZWV0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVN0eWxlU2hlZXQodXJsKS5vd25lck5vZGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLFxuICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuXG4gICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgbGluay5ocmVmID0gdXJsO1xuXG4gICAgaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICByZXR1cm4gbGluaztcbiAgfVxufTtcbiIsInZhciBjc3MgPSBcImh0bWwge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBtYXJnaW46IDBweDtcXG4gICAgcGFkZGluZzogMHB4O1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1zdHlsZTogcHJlc2VydmUtM2Q7XFxuICAgIHRyYW5zZm9ybS1zdHlsZTogcHJlc2VydmUtM2Q7XFxufVxcblxcbmJvZHkge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIG1hcmdpbjogMHB4O1xcbiAgICBwYWRkaW5nOiAwcHg7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLXN0eWxlOiBwcmVzZXJ2ZS0zZDtcXG4gICAgdHJhbnNmb3JtLXN0eWxlOiBwcmVzZXJ2ZS0zZDtcXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIC13ZWJraXQtcGVyc3BlY3RpdmU6IDA7XFxuICAgIHBlcnNwZWN0aXZlOiBub25lO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4uZmFtb3VzLWNvbnRhaW5lciwgLmZhbW91cy1ncm91cCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwcHg7XFxuICAgIGxlZnQ6IDBweDtcXG4gICAgYm90dG9tOiAwcHg7XFxuICAgIHJpZ2h0OiAwcHg7XFxuICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1zdHlsZTogcHJlc2VydmUtM2Q7XFxuICAgIHRyYW5zZm9ybS1zdHlsZTogcHJlc2VydmUtM2Q7XFxuICAgIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5mYW1vdXMtZ3JvdXAge1xcbiAgICB3aWR0aDogMHB4O1xcbiAgICBoZWlnaHQ6IDBweDtcXG4gICAgbWFyZ2luOiAwcHg7XFxuICAgIHBhZGRpbmc6IDBweDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkO1xcbiAgICB0cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkO1xcbn1cXG5cXG4uZmEtc3VyZmFjZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiAwJSAwJTtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogMCUgMCU7XFxuICAgIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkO1xcbiAgICB0cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkOyAvKiBwZXJmb3JtYW5jZSAqL1xcbiAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBwb2ludGVyLWV2ZW50czogYXV0bztcXG4gICAgei1pbmRleDogMTsgLyogSEFDSyB0byBhY2NvdW50IGZvciBicm93c2VyIGlzc3VlcyB3aXRoIGV2ZW50aW5nIG9uIHRoZSBzYW1lIHotcGxhbmUqL1xcbn1cXG5cXG4uZmEtY29udGVudCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuLmZhbW91cy1jb250YWluZXItZ3JvdXAge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5mYS1jb250YWluZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuY2FudmFzLmZhbW91cy13ZWJnbCB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IDE7XFxuICAgIHRvcDogMHB4O1xcbiAgICBsZWZ0OiAwcHg7XFxufVwiOyAocmVxdWlyZShcIi9Vc2Vycy9tb3JnYW50aGVwbGFudC9EZXNrdG9wL2Vhc2luZy9ub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtc3R5bGVzaGVldHMvbm9kZV9tb2R1bGVzL2Nzc2lmeVwiKSkoY3NzKTsgbW9kdWxlLmV4cG9ydHMgPSBjc3M7IiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2ZhbW91cy5jc3MnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRleHR1cmVSZWdpc3RyeSA9IHJlcXVpcmUoJy4vVGV4dHVyZVJlZ2lzdHJ5Jyk7XG5cbi8qKiBcbiAqIEEgbGlzdCBvZiBnbHNsIGV4cHJlc3Npb25zIHdoaWNoIGNhbiBpbnRlcmZhY2Ugd2l0aCBqYXZhc2NyaXB0IGRhdGEgYW5kXG4gKiBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlciB0byBidWlsZCBjdXN0b20gc2hhZGVycy4gXG4gKlxuICovXG52YXIgZXhwcmVzc2lvbnMgPSB7fTtcblxudmFyIHNuaXBwZXRzID0ge1xuXG4gICAgLyogQWJzIC0gVGhlIGFicyBmdW5jdGlvbiByZXR1cm5zIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB4LCBpLmUuIHggd2hlbiB4IGlzIHBvc2l0aXZlIG9yIHplcm8gYW5kIC14IGZvciBuZWdhdGl2ZSB4LiBUaGUgaW5wdXQgcGFyYW1ldGVyIGNhbiBiZSBhIGZsb2F0aW5nIHNjYWxhciBvciBhIGZsb2F0IHZlY3Rvci4gSW4gY2FzZSBvZiBhIGZsb2F0IHZlY3RvciB0aGUgb3BlcmF0aW9uIGlzIGRvbmUgY29tcG9uZW50LXdpc2UuXG4gICAgICovIFxuXG4gICAgYWJzOiB7Z2xzbDogJ2FicyglMSk7J30sXG4gICAgLyogU2lnbiAtIFRoZSBzaWduIGZ1bmN0aW9uIHJldHVybnMgMS4wIHdoZW4geCBpcyBwb3NpdGl2ZSwgMC4wIHdoZW4geCBpcyB6ZXJvIGFuZCAtMS4wIHdoZW4geCBpcyBuZWdhdGl2ZS4gVGhlIGlucHV0IHBhcmFtZXRlciBjYW4gYmUgYSBmbG9hdGluZyBzY2FsYXIgb3IgYSBmbG9hdCB2ZWN0b3IuIEluIGNhc2Ugb2YgYSBmbG9hdCB2ZWN0b3IgdGhlIG9wZXJhdGlvbiBpcyBkb25lIGNvbXBvbmVudC13aXNlLiAqL1xuXG5cbiAgICBzaWduOiB7Z2xzbDogJ3NpZ24oJTEpOyd9LFxuXG4gICAgLyogRmxvb3IgLSBUaGUgZmxvb3IgZnVuY3Rpb24gcmV0dXJucyB0aGUgbGFyZ2VzdCBpbnRlZ2VyIG51bWJlciB0aGF0IGlzIHNtYWxsZXIgb3IgZXF1YWwgdG8geC4gVGhlIGlucHV0IHBhcmFtZXRlciBjYW4gYmUgYSBmbG9hdGluZyBzY2FsYXIgb3IgYSBmbG9hdCB2ZWN0b3IuIEluIGNhc2Ugb2YgYSBmbG9hdCB2ZWN0b3IgdGhlIG9wZXJhdGlvbiBpcyBkb25lIGNvbXBvbmVudC13aXNlLiAqL1xuXG4gICAgZmxvb3I6IHtnbHNsOiAnZmxvb3IoJTEpOyd9LFxuXG4gICAgLyogQ2VpbGluZyAtIFRoZSBjZWlsaW5nIGZ1bmN0aW9uIHJldHVybnMgdGhlIHNtYWxsZXN0IG51bWJlciB0aGF0IGlzIGxhcmdlciBvciBlcXVhbCB0byB4LiBUaGUgaW5wdXQgcGFyYW1ldGVyIGNhbiBiZSBhIGZsb2F0aW5nIHNjYWxhciBvciBhIGZsb2F0IHZlY3Rvci4gSW4gY2FzZSBvZiBhIGZsb2F0IHZlY3RvciB0aGUgb3BlcmF0aW9uIGlzIGRvbmUgY29tcG9uZW50LXdpc2UuICovXG5cbiAgICBjZWlsaW5nOiB7Z2xzbDogJ2NlaWwoJTEpOyd9LFxuXG4gICAgLyogVGhlIG1vZCBleHByZXNzaW9uIHJldHVybnMgdGhlIHJlbWFpbmVkIG9mIHRoZSBkaXZpc2lvbiBvcGVyYXRpb24gb2YgdGhlIHR3byBpbnB1dHMuICovXG4gICAgbW9kOiB7Z2xzbDogJ21vZCglMSwgJTIpOyd9LFxuXG4gICAgLyogTWluIC0gVGhlIG1pbiBmdW5jdGlvbiByZXR1cm5zIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gYXJndW1lbnRzLiBUaGUgaW5wdXQgcGFyYW1ldGVycyBjYW4gYmUgZmxvYXRpbmcgc2NhbGFycyBvciBmbG9hdCB2ZWN0b3JzLiBJbiBjYXNlIG9mIGZsb2F0IHZlY3RvcnMgdGhlIG9wZXJhdGlvbiBpcyBkb25lIGNvbXBvbmVudC13aXNlLiAqL1xuXG4gICAgbWluOiB7Z2xzbDogJ21pbiglMSwgJTIpOyd9LFxuXG4gICAgLyogTWF4IC0gVGhlIG1heCBmdW5jdGlvbiByZXR1cm5zIHRoZSBsYXJnZXIgb2YgdGhlIHR3byBhcmd1bWVudHMuIFRoZSBpbnB1dCBwYXJhbWV0ZXJzIGNhbiBiZSBmbG9hdGluZyBzY2FsYXJzIG9yIGZsb2F0IHZlY3RvcnMuIEluIGNhc2Ugb2YgZmxvYXQgdmVjdG9ycyB0aGUgb3BlcmF0aW9uIGlzIGRvbmUgY29tcG9uZW50LXdpc2UuICovIFxuXG4gICAgbWF4OiB7Z2xzbDogJ21heCglMSwgJTIpOyd9LFxuICAgIC8qIENsYW1wIC0gVGhlIGNsYW1wIGZ1bmN0aW9uIHJldHVybnMgeCBpZiBpdCBpcyBsYXJnZXIgdGhhbiBtaW5WYWwgYW5kIHNtYWxsZXIgdGhhbiBtYXhWYWwuIEluIGNhc2UgeCBpcyBzbWFsbGVyIHRoYW4gbWluVmFsLCBtaW5WYWwgaXMgcmV0dXJuZWQuIElmIHggaXMgbGFyZ2VyIHRoYW4gbWF4VmFsLCBtYXhWYWwgaXMgcmV0dXJuZWQuIFRoZSBpbnB1dCBwYXJhbWV0ZXJzIGNhbiBiZSBmbG9hdGluZyBzY2FsYXJzIG9yIGZsb2F0IHZlY3RvcnMuIEluIGNhc2Ugb2YgZmxvYXQgdmVjdG9ycyB0aGUgb3BlcmF0aW9uIGlzIGRvbmUgY29tcG9uZW50LXdpc2UuICovXG5cbiAgICBjbGFtcDoge2dsc2w6ICdjbGFtcCglMSwgJTIsICUzKTsnfSxcblxuICAgIC8qIE1peCAtIFRoZSBtaXggZnVuY3Rpb24gcmV0dXJucyB0aGUgbGluZWFyIGJsZW5kIG9mIHggYW5kIHksIGkuZS4gdGhlIHByb2R1Y3Qgb2YgeCBhbmQgKDEgLSBhKSBwbHVzIHRoZSBwcm9kdWN0IG9mIHkgYW5kIGEuIFRoZSBpbnB1dCBwYXJhbWV0ZXJzIGNhbiBiZSBmbG9hdGluZyBzY2FsYXJzIG9yIGZsb2F0IHZlY3RvcnMuIEluIGNhc2Ugb2YgZmxvYXQgdmVjdG9ycyB0aGUgb3BlcmF0aW9uIGlzIGRvbmUgY29tcG9uZW50LXdpc2UuICovXG5cbiAgICBtaXg6IHtnbHNsOiAnbWl4KCUxLCAlMiwgJTMpOyd9LFxuXG4gICAgLyogU3RlcCAtIFRoZSBzdGVwIGZ1bmN0aW9uIHJldHVybnMgMC4wIGlmIHggaXMgc21hbGxlciB0aGVuIGVkZ2UgYW5kIG90aGVyd2lzZSAxLjAuIFRoZSBpbnB1dCBwYXJhbWV0ZXJzIGNhbiBiZSBmbG9hdGluZyBzY2FsYXJzIG9yIGZsb2F0IHZlY3RvcnMuIEluIGNhc2Ugb2YgZmxvYXQgdmVjdG9ycyB0aGUgb3BlcmF0aW9uIGlzIGRvbmUgY29tcG9uZW50LXdpc2UuICovXG5cbiAgICBzdGVwOiB7Z2xzbDogJ3N0ZXAoJTEsICUyLCAlMyk7J30sXG4gICAgXG4gICAgLyogU21vb3Roc3RlcCAtIFRoZSBzbW9vdGhzdGVwIGZ1bmN0aW9uIHJldHVybnMgMC4wIGlmIHggaXMgc21hbGxlciB0aGVuIGVkZ2UwIGFuZCAxLjAgaWYgeCBpcyBsYXJnZXIgdGhhbiBlZGdlMS4gT3RoZXJ3aXNlIHRoZSByZXR1cm4gdmFsdWUgaXMgaW50ZXJwb2xhdGVkIGJldHdlZW4gMC4wIGFuZCAxLjAgdXNpbmcgSGVybWl0ZSBwb2x5bm9taXJhbHMuIFRoZSBpbnB1dCBwYXJhbWV0ZXJzIGNhbiBiZSBmbG9hdGluZyBzY2FsYXJzIG9yIGZsb2F0IHZlY3RvcnMuIEluIGNhc2Ugb2YgZmxvYXQgdmVjdG9ycyB0aGUgb3BlcmF0aW9uIGlzIGRvbmUgY29tcG9uZW50LXdpc2UuICovIFxuXG4gICAgc21vb3Roc3RlcDoge2dsc2w6ICdzbW9vdGhzdGVwKCUxKTsnfSxcblxuXG4gICAgLyogZnJhZ0Nvb3JkIC0gVGhlIGZyYWdDb29yZCBmdW5jdGlvbiByZXR1cm5zIHRoZSBmcmFnbWVudCdzIHBvc2l0aW9uIGluIHNjcmVlbnNwYWNlLiAqL1xuXG4gICAgZnJhZ0Nvb3JkOiB7Z2xzbDogJ2dsX0ZyYWdDb2xvci54eTsnfSxcblxuICAgIC8qIFNpbiAtIFRoZSBzaW4gZnVuY3Rpb24gcmV0dXJucyB0aGUgc2luZSBvZiBhbiBhbmdsZSBpbiByYWRpYW5zLiBUaGUgaW5wdXQgcGFyYW1ldGVyIGNhbiBiZSBhIGZsb2F0aW5nIHNjYWxhciBvciBhIGZsb2F0IHZlY3Rvci4gSW4gY2FzZSBvZiBhIGZsb2F0IHZlY3RvciB0aGUgc2luZSBpcyBjYWxjdWxhdGVkIHNlcGFyYXRlbHkgZm9yIGV2ZXJ5IGNvbXBvbmVudC4gKi9cblxuXG4gICAgc2luOiB7Z2xzbDogJ3NpbiglMSk7J30sXG5cbiAgICAvKiBDb3MgLSBUaGUgY29zIGZ1bmN0aW9uIHJldHVybnMgdGhlIGNvc2luZSBvZiBhbiBhbmdsZSBpbiByYWRpYW5zLiBUaGUgaW5wdXQgcGFyYW1ldGVyIGNhbiBiZSBhIGZsb2F0aW5nIHNjYWxhciBvciBhIGZsb2F0IHZlY3Rvci4gKi9cblxuICAgIGNvczoge2dsc2w6ICdjb3MoJTEpOyd9LFxuXG4gICAgLyogUG93IC0gVGhlIHBvd2VyIGZ1bmN0aW9uIHJldHVybnMgeCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mIHkuIFRoZSBpbnB1dCBwYXJhbWV0ZXJzIGNhbiBiZSBmbG9hdGluZyBzY2FsYXJzIG9yIGZsb2F0IHZlY3RvcnMuIEluIGNhc2Ugb2YgZmxvYXQgdmVjdG9ycyB0aGUgb3BlcmF0aW9uIGlzIGRvbmUgY29tcG9uZW50LXdpc2UuICovIFxuXG4gICAgcG93OiB7Z2xzbDogJ3BvdyglMSwgJTIpOyd9LFxuXG4gICAgLyogU3FydCAtIFRoZSBzcXJ0IGZ1bmN0aW9uIHJldHVybnMgdGhlIHNxdWFyZSByb290IG9mIHguIFRoZSBpbnB1dCBwYXJhbWV0ZXIgY2FuIGJlIGEgZmxvYXRpbmcgc2NhbGFyIG9yIGEgZmxvYXQgdmVjdG9yLiBJbiBjYXNlIG9mIGEgZmxvYXQgdmVjdG9yIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi8gXG5cbiAgICAvKiBmcmFnQ29vcmQgLSBUaGUgdGltZSBmdW5jdGlvbiByZXR1cm5zIHRoZSBlbGFwc2VkIHRpbWUgaW4gdGhlIHVuaXggZXBvY2ggaW4gbWlsbGlzZWNvbmRzLiovXG5cbiAgICB0aW1lOiB7Z2xzbDogJ3RpbWU7J30sXG5cbiAgICAvKiBUaGUgQWRkIGZ1bmN0aW9uIHRha2VzIHR3byBpbnB1dHMsIGFkZHMgdGhlbSB0b2dldGhlciBhbmQgb3V0cHV0cyB0aGUgcmVzdWx0LiBUaGlzIGFkZGl0aW9uIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQgb24gYSBwZXIgY2hhbm5lbCBiYXNpcywgbWVhbmluZyB0aGF0IHRoZSBpbnB1dHMnIFIgY2hhbm5lbHMgZ2V0IGFkZGVkLCBHIGNoYW5uZWxzIGdldCBhZGRlZCwgQiBjaGFubmVscyBnZXQgYWRkZWQsIGV0Yy4gQm90aCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBjaGFubmVscyB1bmxlc3Mgb25lIG9mIHRoZW0gaXMgYSBzaW5nbGUgQ29uc3RhbnQgdmFsdWUuIENvbnN0YW50cyBjYW4gYmUgYWRkZWQgdG8gYSB2ZWN0b3Igd2l0aCBhbnkgbnVtYmVyIG9mIGlucHV0cy4gKi9cbiAgICBhZGQ6IHtnbHNsOiAnJTEgKyAlMjsnfSxcblxuICAgIC8qIFRoZSBBZGQgZnVuY3Rpb24gdGFrZXMgdHdvIGlucHV0cywgYWRkcyB0aGVtIHRvZ2V0aGVyIGFuZCBvdXRwdXRzIHRoZSByZXN1bHQuIFRoaXMgYWRkaXRpb24gb3BlcmF0aW9uIGlzIHBlcmZvcm1lZCBvbiBhIHBlciBjaGFubmVsIGJhc2lzLCBtZWFuaW5nIHRoYXQgdGhlIGlucHV0cycgUiBjaGFubmVscyBnZXQgYWRkZWQsIEcgY2hhbm5lbHMgZ2V0IGFkZGVkLCBCIGNoYW5uZWxzIGdldCBhZGRlZCwgZXRjLiBCb3RoIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYW5uZWxzIHVubGVzcyBvbmUgb2YgdGhlbSBpcyBhIHNpbmdsZSBDb25zdGFudCB2YWx1ZS4gQ29uc3RhbnRzIGNhbiBiZSBhZGRlZCB0byBhIHZlY3RvciB3aXRoIGFueSBudW1iZXIgb2YgaW5wdXRzLiAqL1xuICAgIG11bHRpcGx5OiB7Z2xzbDogJyUxICogJTI7J30sXG5cblxuICAgIC8qIFRoZSBub3JtYWwgZnVuY3Rpb24gcmV0dXJucyB0aGUgMy1kaW1lbnNpb25hbCBzdXJmYWNlIG5vcm1hbCwgd2hpY2ggaXMgYSB2ZWN0b3IgdGhhdCBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSB0YW5nZW50IHBsYW5lIGF0IHRoYXQgcG9pbnQuKi9cbiAgICBub3JtYWw6IHtnbHNsOicodl9Ob3JtYWwgKyAxLjApICogMC41Oyd9LFxuXG4gICAgLyogVGhlIHV2IGZ1bmN0aW9uIHJldHVybnMgdGhlIDItZGltZW5zaW9uYWwgdmVjdG9yIHRoYXQgbWFwcyB0aGUgb2JqZWN0J3MgMy1kaW1lbnNpb25hbCB2ZXJ0aWNlcyB0byBhIDJEIHBsYW5lLiAqL1xuICAgIHV2OiB7Z2xzbDondmVjMyh2X1RleHR1cmVDb29yZGluYXRlLCAxKTsnfSxcblxuICAgIC8qIFRoZSBtZXNoIHBvc2l0aW9uIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRyYW5zZm9ybWVkIGZyYWdtZW50J3MgcG9zaXRpb24gaW4gd29ybGQtc3BhY2UuICAqL1xuICAgIG1lc2hQb3NpdGlvbjoge2dsc2w6Jyh2X1Bvc2l0aW9uICsgMS4wKSAqIDAuNTsnfSxcblxuXG4gICAgLyogVGhlIGltYWdlIGZ1bmN0aW9uIGZldGNoZXMgdGhlIG1vZGVsJ3MgKi9cbiAgICBpbWFnZToge2dsc2w6J3RleHR1cmUyRChpbWFnZSwgdl9UZXh0dXJlQ29vcmRpbmF0ZSkucmdiOyd9LFxuXG5cbiAgICAvKiBUaGUgY29uc3RhbnQgZnVuY3Rpb24gcmV0dXJucyBhIHN0YXRpYyB2YWx1ZSB3aGljaCBpcyBkZWZpbmVkIGF0IGNvbXBpbGUtdGltZSB0aGF0IGNhbm5vdCBiZSBjaGFuZ2VkIGR5bmFtaWNhbGx5LiovXG4gICAgY29uc3RhbnQ6IHtnbHNsOiAnJTE7J30sXG4gICAgXG4gICAgLyogVGhlIFBhcmFtZXRlciBleHByZXNzaW9uIGhhcyB2YWx1ZXMgdGhhdCBjYW4gYmUgbW9kaWZpZWQgKGR5bmFtaWNhbGx5IGR1cmluZyBydW50aW1lIGluIHNvbWUgY2FzZXMpIGluIGEgTWF0ZXJpYWxJbnN0YW5jZSBvZiB0aGUgYmFzZSBtYXRlcmlhbCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXIuIFRoZXNlIGV4cHJlc3Npb25zIHNob3VsZCBiZSBnaXZlbiB1bmlxdWUgbmFtZXMsIHZpYSB0aGUgUGFyYW1ldGVyIE5hbWUgcHJvcGVydHksIHRvIGJlIHVzZWQgd2hlbiBpZGVudGlmeWluZyB0aGUgc3BlY2lmaWMgcGFyYW1ldGVyIGluIHRoZSBNYXRlcmlhbEluc3RhbmNlLiBJZiB0d28gcGFyYW1ldGVycyBvZiB0aGUgc2FtZSB0eXBlIGhhdmUgdGhlIHNhbWUgbmFtZSBpbiB0aGUgc2FtZSBtYXRlcmlhbCwgdGhleSB3aWxsIGJlIGFzc3VtZWQgdG8gYmUgdGhlIHNhbWUgcGFyYW1ldGVyLiBDaGFuZ2luZyB0aGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlciBpbiB0aGUgTWF0ZXJpYWxJbnN0YW5jZSB3b3VsZCBjaGFuZ2UgdGhlIHZhbHVlIG9mIGJvdGggdGhlIHBhcmFtZXRlciBleHByZXNzaW9ucyBpbiB0aGUgbWF0ZXJpYWwuIEEgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHBhcmFtZXRlciB3aWxsIGFsc28gYmUgc2V0IGluIHRoZSBiYXNlIG1hdGVyaWFsLiBUaGlzIHdpbGwgYmUgdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIgaW4gdGhlIE1hdGVyaWFsSW5zdGFuY2UgdW5sZXNzIGl0IGlzIG92ZXJyaWRkZW4gYW5kIG1vZGlmaWVkIHRoZXJlLiAqL1xuXG4gICAgcGFyYW1ldGVyOiB7dW5pZm9ybXM6IHtwYXJhbWV0ZXI6IDF9LCBnbHNsOiAncGFyYW1ldGVyOyd9XG59O1xuXG5leHByZXNzaW9ucy5yZWdpc3RlckV4cHJlc3Npb24gPSBmdW5jdGlvbiByZWdpc3RlckV4cHJlc3Npb24obmFtZSwgc2NoZW1hKSB7XG4gICAgdGhpc1tuYW1lXSA9IGZ1bmN0aW9uIChpbnB1dHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRlcmlhbChuYW1lLCBzY2hlbWEsIGlucHV0cywgb3B0aW9ucyk7XG4gICAgfTtcbn07XG5cbmZvciAodmFyIG5hbWUgaW4gc25pcHBldHMpIHtcbiAgICBleHByZXNzaW9ucy5yZWdpc3RlckV4cHJlc3Npb24obmFtZSwgc25pcHBldHNbbmFtZV0pO1xufVxuXG4vKipcbiAqIE1hdGVyaWFsIGlzIGEgcHVibGljIGNsYXNzIHRoYXQgY29tcG9zZXMgYSBtYXRlcmlhbC1ncmFwaCBvdXQgb2YgZXhwcmVzc2lvbnNcbiAqXG4gKlxuICogQGNsYXNzIE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdG9uIG9mIG5hc2NlbnQgZXhwcmVzc2lvbiB3aXRoIHNoYWRlciBjb2RlLCBpbnB1dHMgYW5kIHVuaWZvcm1zXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IG9mIE1hdGVyaWFsIGV4cHJlc3Npb25zLCBpbWFnZXMsIG9yIGNvbnN0YW50XG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIG9mIHVuaWZvcm0gZGF0YSBvZiBmbG9hdCwgdmVjMiwgdmVjMywgdmVjNFxuICovXG5cbmZ1bmN0aW9uIE1hdGVyaWFsKG5hbWUsIGNodW5rLCBpbnB1dHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzID8gKEFycmF5LmlzQXJyYXkoaW5wdXRzKSA/IGlucHV0cyA6IFtpbnB1dHNdKTogW107XG4gICAgdGhpcy51bmlmb3JtcyA9IG9wdGlvbnMudW5pZm9ybXMgfHwge307XG4gICAgdGhpcy52YXJ5aW5ncyA9IG9wdGlvbnMudmFyeWluZ3M7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzO1xuICAgIGlmIChvcHRpb25zLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gb3B0aW9ucy50ZXh0dXJlLl9faXNBVGV4dHVyZV9fID8gb3B0aW9ucy50ZXh0dXJlIDogVGV4dHVyZVJlZ2lzdHJ5LnJlZ2lzdGVyKG51bGwsIG9wdGlvbnMudGV4dHVyZSk7XG4gICAgfVxuXG4gICAgdGhpcy5faWQgPSBNYXRlcmlhbC5pZCsrO1xuXG4gICAgdGhpcy5pbnZhbGlkYXRpb25zID0gW107XG59XG5cbk1hdGVyaWFsLmlkID0gMTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIG1hdGVyaWFsIGdyYXBoXG4gKlxuICogQG1ldGhvZCB0cmF2ZXJzZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGludm9rZWQgdXBvbiBldmVyeSBleHByZXNzaW9uIGluIHRoZSBncmFwaFxuICovXG5cbk1hdGVyaWFsLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uIHRyYXZlcnNlKGNhbGxiYWNrKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMuaW5wdXRzICYmIHRoaXMuaW5wdXRzLmxlbmd0aCwgaWR4ID0gLTE7XG5cbiAgICB3aGlsZSAoKytpZHggPCBsZW4pIHRyYXZlcnNlLmNhbGwodGhpcy5pbnB1dHNbaWR4XSwgY2FsbGJhY2ssIGlkeCk7XG5cbiAgICBjYWxsYmFjayh0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTWF0ZXJpYWwucHJvdG90eXBlLnNldFVuaWZvcm0gPSBmdW5jdGlvbiBzZXRVbmlmb3JtKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtc1tuYW1lXSA9IHZhbHVlO1xuXG4gICAgdGhpcy5pbnZhbGlkYXRpb25zLnB1c2gobmFtZSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIG1hdGVyaWFsIGdyYXBoIGludG8gY2h1bmtcbiAqXG4gKiBAbWV0aG9kIF9jb21waWxlXG4gKiBAcHJvdGVjdGVkXG4gKlxuICovXG5cbk1hdGVyaWFsLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgIHZhciBnbHNsID0gJyc7XG4gICAgdmFyIHVuaWZvcm1zID0ge307XG4gICAgdmFyIHZhcnlpbmdzID0ge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICB2YXIgZGVmaW5lcyA9IFtdO1xuICAgIHZhciB0ZXh0dXJlO1xuXG4gICAgdGhpcy50cmF2ZXJzZShmdW5jdGlvbiAobm9kZSwgZGVwdGgpIHtcbiAgICAgICAgaWYgKCEgbm9kZS5jaHVuaykgcmV0dXJuO1xuICAgICAgICBnbHNsICs9ICd2ZWMzICcgKyBtYWtlTGFiZWwobm9kZSkgKyAnPScgKyBwcm9jZXNzR0xTTChub2RlLmNodW5rLmdsc2wsIG5vZGUuaW5wdXRzKSArICdcXG4gJztcbiAgICAgICAgaWYgKG5vZGUudW5pZm9ybXMpIGV4dGVuZCh1bmlmb3Jtcywgbm9kZS51bmlmb3Jtcyk7XG4gICAgICAgIGlmIChub2RlLnZhcnlpbmdzKSBleHRlbmQodmFyeWluZ3MsIG5vZGUudmFyeWluZ3MpO1xuICAgICAgICBpZiAobm9kZS5hdHRyaWJ1dGVzKSBleHRlbmQoYXR0cmlidXRlcywgbm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKG5vZGUuY2h1bmsuZGVmaW5lcykgZGVmaW5lcy5wdXNoKG5vZGUuY2h1bmsuZGVmaW5lcyk7XG4gICAgICAgIGlmIChub2RlLnRleHR1cmUpIHRleHR1cmUgPSBub2RlLnRleHR1cmU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBfaWQ6IHRoaXMuX2lkLFxuICAgICAgICBnbHNsOiBnbHNsICsgJ3JldHVybiAnICsgbWFrZUxhYmVsKHRoaXMpICsgJzsnLFxuICAgICAgICBkZWZpbmVzOiBkZWZpbmVzLmpvaW4oJ1xcbicpLFxuICAgICAgICB1bmlmb3JtczogdW5pZm9ybXMsXG4gICAgICAgIHZhcnlpbmdzOiB2YXJ5aW5ncyxcbiAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgdGV4dHVyZTogdGV4dHVyZVxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBleHRlbmQgKGEsIGIpIHsgZm9yICh2YXIgayBpbiBiKSBhW2tdID0gYltrXTsgfVxuXG5mdW5jdGlvbiBwcm9jZXNzR0xTTChzdHIsIGlucHV0cykge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJVxcZC9nLCBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gbWFrZUxhYmVsKGlucHV0c1tzWzFdLTFdKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1ha2VMYWJlbCAobikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG4pKSByZXR1cm4gYXJyYXlUb1ZlYyhuKTtcbiAgICBpZiAodHlwZW9mIG4gPT0gJ29iamVjdCcpIHJldHVybiAnZmFfJyArIChuLl9pZCk7XG4gICAgZWxzZSByZXR1cm4gSlNPTi5zdHJpbmdpZnkobik7XG59XG5cbmZ1bmN0aW9uIGFycmF5VG9WZWMoYXJyYXkpIHtcbiAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiAndmVjJyArIGxlbiArICcoJyArIGFycmF5LmpvaW4oJywnKSAgKyAnKSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwcmVzc2lvbnM7XG5leHByZXNzaW9ucy5NYXRlcmlhbCA9IE1hdGVyaWFsO1xuZXhwcmVzc2lvbnMuVGV4dHVyZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBjb25zb2xlLmVycm9yKCdUZXh0dXJlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBydW4gaW5zaWRlIG9mIGEgd29ya2VyJyk7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25zLmltYWdlKFtdLCB7IHRleHR1cmU6IHNvdXJjZSB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qXG4gKiBBIHNpbmdsZXRvbiBvYmplY3QgdGhhdCBob2xkcyB0ZXh0dXJlIGluc3RhbmNlcyBpbiBhIHJlZ2lzdHJ5IHdoaWNoXG4gKiBjYW4gYmUgYWNjZXNzZWQgYnkga2V5LiAgQWxsb3dzIGZvciB0ZXh0dXJlIHNoYXJpbmcgYW5kIGVhc3kgcmVmZXJlbmNpbmcuXG4gKlxuICogQHN0YXRpY1xuICogQGNsYXNzIFRleHR1cmVSZWdpc3RyeVxuICovXG52YXIgVGV4dHVyZVJlZ2lzdHJ5ID0ge1xuXHRyZWdpc3RyeToge30sXG5cdHRleHR1cmVJZHM6IDFcbn07XG5cbi8qXG4gKiBSZWdpc3RlcnMgYSBuZXcgVGV4dHVyZSBvYmplY3Qgd2l0aCBhIHVuaXF1ZSBpZCBhbmQgaW5wdXQgcGFyYW1ldGVycyB0byBiZVxuICogaGFuZGxlZCBieSB0aGUgV2ViR0xSZW5kZXJlci4gIElmIG5vIGFjY2Vzc29yIGlzIGlucHV0IHRoZSB0ZXh0dXJlIHdpbGwgYmUgXG4gKiBjcmVhdGVkIGJ1dCBub3Qgc3RvcmUgaW4gdGhlIHJlZ2lzdHJ5LlxuICpcbiAqIEBtZXRob2QgcmVnaXN0ZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXNzb3IgS2V5IHVzZWQgdG8gbGF0ZXIgYWNjZXNzIHRoZSB0ZXh0dXJlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXkgfCBTdHJpbmd9IGRhdGEgRGF0YSB0byBiZSB1c2VkIGluIHRoZSBXZWJHTFJlbmRlcmVyIHRvXG4gKiBnZW5lcmF0ZSB0ZXh0dXJlIGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIGFmZmVjdCB0aGUgcmVuZGVyaW5nIG9mIHRoZVxuICogV2ViR0wgdGV4dHVyZS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IE5ld2x5IGdlbmVyYXRlZCB0ZXh0dXJlIG9iamVjdC5cbiAqL1xuVGV4dHVyZVJlZ2lzdHJ5LnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoYWNjZXNzb3IsIGRhdGEsIG9wdGlvbnMpIHtcblx0aWYgKGFjY2Vzc29yKSByZXR1cm4gKHRoaXMucmVnaXN0cnlbYWNjZXNzb3JdID0geyBpZDogdGhpcy50ZXh0dXJlSWRzKyssIF9faXNBVGV4dHVyZV9fOiB0cnVlLCBkYXRhOiBkYXRhLCBvcHRpb25zOiBvcHRpb25zIH0pO1xuXHRlbHNlIHJldHVybiB7IGlkOiB0aGlzLnRleHR1cmVJZHMrKywgZGF0YTogZGF0YSwgX19pc0FUZXh0dXJlX186IHRydWUsIG9wdGlvbnM6IG9wdGlvbnMgfTtcbn07XG5cbi8qXG4gKiBSZXRyZWl2ZXMgdGhlIHRleHR1cmUgb2JqZWN0IGZyb20gcmVnaXN0cnkuICBUaHJvd3MgaWYgbm8gdGV4dHVyZSBpc1xuICogZm91bmQgYXQgZ2l2ZW4ga2V5LlxuICpcbiAqIEBtZXRob2QgZ2V0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2Vzc29yIEtleSBvZiBhIGRlc2lyZWQgdGV4dHVyZSBpbiB0aGUgcmVnaXN0cnkuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBEZXNpcmVkIHRleHR1cmUgb2JqZWN0LlxuICovXG5UZXh0dXJlUmVnaXN0cnkuZ2V0ID0gZnVuY3Rpb24gZ2V0KGFjY2Vzc29yKSB7XG5cdGlmICghdGhpcy5yZWdpc3RyeVthY2Nlc3Nvcl0pIHtcblx0XHR0aHJvdyAnVGV4dHVyZSBcIicgKyBhY2Nlc3NvciArICdcIiBub3QgZm91bmQhJztcblx0fVxuXHRlbHNlIHtcblx0XHRyZXR1cm4gdGhpcy5yZWdpc3RyeVthY2Nlc3Nvcl07XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlUmVnaXN0cnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIE1hdGVyaWFsOiByZXF1aXJlKCcuL01hdGVyaWFsJyksXG4gICAgVGV4dHVyZVJlZ2lzdHJ5OiByZXF1aXJlKCcuL1RleHR1cmVSZWdpc3RyeScpXG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJ2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzJyk7XG5cbi8qKlxuICogVGhlIE1lc2ggY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIHByb3ZpZGluZyB0aGUgQVBJIGZvciBob3dcbiAqIGEgUmVuZGVyTm9kZSB3aWxsIGludGVyYWN0IHdpdGggdGhlIFdlYkdMIEFQSSBieSBhZGRpbmdcbiAqIGEgc2V0IG9mIGNvbW1hbmRzIHRvIHRoZSByZW5kZXJlci5cbiAqXG4gKiBAY2xhc3MgTWVzaFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcmVuZGVyYWJsZVxuICogQHBhcmFtIHtMb2NhbERpc3BhdGNofSBkaXNwYXRjaCBMb2NhbERpc3BhdGNoIHRvIGJlIHJldHJpZXZlZFxuICogQHBhcmFtIHtvYmplY3R9IE9wdGlvbnMgT3B0aW9uYWwgcGFyYW1zIGZvciBjb25maWd1cmluZyBNZXNoXG4gKi9cbmZ1bmN0aW9uIE1lc2ggKG5vZGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZSA9IFtdO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX2luRHJhdyA9IGZhbHNlO1xuICAgIHRoaXMudmFsdWUgPSB7XG4gICAgICAgIGRyYXdPcHRpb25zOiB7fSxcbiAgICAgICAgY29sb3I6IG51bGwsXG4gICAgICAgIGV4cHJlc3Npb25zOiB7fSxcbiAgICAgICAgZ2VvbWV0cnk6IG51bGwsXG4gICAgICAgIGZsYXRTaGFkaW5nOiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zKSB0aGlzLnNldERyYXdPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuX2lkID0gbm9kZS5hZGRDb21wb25lbnQodGhpcyk7XG59XG5cbi8qKlxuICogUGFzcyBjdXN0b20gb3B0aW9ucyB0byBNZXNoLCBzdWNoIGFzIGEgMyBlbGVtZW50IG1hcFxuICogd2hpY2ggZGlzcGxhY2VzIHRoZSBwb3NpdGlvbiBvZiBlYWNoIHZlcnRleCBpbiB3b3JsZCBzcGFjZS5cbiAqXG4gKiBAbWV0aG9kIHNldERyYXdPcHRpb25zXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTWVzaC5wcm90b3R5cGUuc2V0RHJhd09wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zIChvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMudmFsdWUuZHJhd09wdGlvbnMuYmxlbmRNb2RlKSB7XG4gICAgICAgIHRoaXMudmFsdWUuZHJhd09wdGlvbnMuYmxlbmRNb2RlID0gb3B0aW9ucy5ibGVuZE1vZGU7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0dMX1NFVF9EUkFXX09QVElPTlMnKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWVzaCdzIGN1c3RvbSBvcHRpb25zLlxuICpcbiAqIEBtZXRob2QgZ2V0RHJhd09wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IE9wdGlvbnNcbiAqL1xuTWVzaC5wcm90b3R5cGUuZ2V0RHJhd09wdGlvbnMgPSBmdW5jdGlvbiBnZXREcmF3T3B0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuZHJhd09wdGlvbnM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZ2VvbWV0cnkgb2YgYSBtZXNoLlxuICpcbiAqIEBtZXRob2Qgc2V0R2VvbWV0cnlcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeSBpbnN0YW5jZSB0byBiZSBhc3NvY2lhdGVkIHdpdGggdGhlIG1lc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zIFZhcmlvdXMgY29uZmlndXJhdGlvbnMgZm9yIGdlb21ldHJpZXMuXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1lc2gucHJvdG90eXBlLnNldEdlb21ldHJ5ID0gZnVuY3Rpb24gc2V0R2VvbWV0cnkgKGdlb21ldHJ5LCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBnZW9tZXRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCFHZW9tZXRyeVtnZW9tZXRyeV0pIHRocm93ICdJbnZhbGlkIGdlb21ldHJ5OiBcIicgKyBnZW9tZXRyeSArICdcIi4nO1xuICAgICAgICBlbHNlIGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5W2dlb21ldHJ5XShvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52YWx1ZS5nZW9tZXRyeSAhPT0gZ2VvbWV0cnkgfHwgdGhpcy5faW5EcmF3KSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnR0xfU0VUX0dFT01FVFJZJyk7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKGdlb21ldHJ5LmlkKTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goZ2VvbWV0cnkuc3BlYy50eXBlKTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goZ2VvbWV0cnkuc3BlYy5keW5hbWljKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgdGhpcy52YWx1ZS5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGdlb21ldHJ5IG9mIGEgbWVzaC5cbiAqXG4gKiBAbWV0aG9kIGdldEdlb21ldHJ5XG4gKiBAcmV0dXJucyB7R2VvbWV0cnl9IGdlb21ldHJ5IEdlb21ldHJ5IG9mIG1lc2hcbiAqL1xuTWVzaC5wcm90b3R5cGUuZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuZ2VvbWV0cnk7XG59O1xuXG4vKipcbiogQ2hhbmdlcyB0aGUgY29sb3Igb2YgTWVzaCwgcGFzc2luZyBlaXRoZXIgYSBtYXRlcmlhbCBleHByZXNzaW9uIG9yXG4qIGNvbG9yIHVzaW5nIHRoZSAnQ29sb3InIHV0aWxpdHkgY29tcG9uZW50LlxuKlxuKiBAbWV0aG9kIHNldEJhc2VDb2xvclxuKiBAcGFyYW0ge09iamVjdHxDb2xvcn0gTWF0ZXJpYWwsIGltYWdlLCB2ZWMzLCBvciBDb2xvciBpbnN0YW5jZVxuKiBAY2hhaW5hYmxlXG4qL1xuTWVzaC5wcm90b3R5cGUuc2V0QmFzZUNvbG9yID0gZnVuY3Rpb24gc2V0QmFzZUNvbG9yIChjb2xvcikge1xuICAgIHZhciB1bmlmb3JtVmFsdWU7XG5cbiAgICBpZiAoY29sb3IuX2NvbXBpbGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZS5leHByZXNzaW9ucy5iYXNlQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgdW5pZm9ybVZhbHVlID0gY29sb3IuX2NvbXBpbGUoKTsgXG4gICAgfSBlbHNlIGlmIChjb2xvci5nZXROb3JtYWxpemVkUkdCKSB7XG4gICAgICAgIHRoaXMudmFsdWUuZXhwcmVzc2lvbnMuYmFzZUNvbG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZS5jb2xvciA9IGNvbG9yO1xuICAgICAgICB1bmlmb3JtVmFsdWUgPSBjb2xvci5nZXROb3JtYWxpemVkUkdCKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIC8vIElmIGEgbWF0ZXJpYWwgZXhwcmVzc2lvblxuICAgICAgICBpZiAoY29sb3IuX2NvbXBpbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ01BVEVSSUFMX0lOUFVUJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIGNvbG9yIGNvbXBvbmVudFxuICAgICAgICBlbHNlIGlmIChjb2xvci5nZXROb3JtYWxpemVkUkdCKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdHTF9VTklGT1JNUycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ2Jhc2VDb2xvcicpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKHVuaWZvcm1WYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBlaXRoZXIgdGhlIG1hdGVyaWFsIGV4cHJlc3Npb24gb3IgdGhlIGNvbG9yIGluc3RhbmNlIG9mIE1lc2guXG4gKlxuICogQG1ldGhvZCBnZXRCYXNlQ29sb3JcbiAqIEByZXR1cm5zIHtNYXRlcmlhbEV4cHJlc3N8Q29sb3J9XG4gKi9cbk1lc2gucHJvdG90eXBlLmdldEJhc2VDb2xvciA9IGZ1bmN0aW9uIGdldEJhc2VDb2xvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuZXhwcmVzc2lvbnMuYmFzZUNvbG9yIHx8IHRoaXMudmFsdWUuY29sb3I7XG59O1xuXG4vKipcbiAqIENoYW5nZSB3aGV0aGVyIHRoZSBNZXNoIGlzIGFmZmVjdGVkIGJ5IGxpZ2h0LiBEZWZhdWx0IGlzIHRydWUuXG4gKlxuICogQG1ldGhvZCBzZXRGbGF0U2hhZGluZ1xuICogQHBhcmFtIHtib29sZWFufSBCb29sZWFuXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1lc2gucHJvdG90eXBlLnNldEZsYXRTaGFkaW5nID0gZnVuY3Rpb24gc2V0RmxhdFNoYWRpbmcgKGJvb2wpIHtcbiAgICBpZiAodGhpcy5faW5EcmF3IHx8IHRoaXMudmFsdWUuZmxhdFNoYWRpbmcgIT09IGJvb2wpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdHTF9VTklGT1JNUycpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgndV9mbGF0U2hhZGluZycpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCh0aGlzLnZhbHVlLmZsYXRTaGFkaW5nID8gMSA6IDApOyAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZS5mbGF0U2hhZGluZyA9IGJvb2w7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYm9vbGVhbiBmb3Igd2hldGhlciBNZXNoIGlzIGFmZmVjdGVkIGJ5IGxpZ2h0LlxuICpcbiAqIEBtZXRob2QgZ2V0RmxhdFNoYWRpbmdcbiAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuXG4gKi9cbk1lc2gucHJvdG90eXBlLmdldEZsYXRTaGFkaW5nID0gZnVuY3Rpb24gZ2V0RmxhdFNoYWRpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLmZsYXRTaGFkaW5nO1xufTtcblxuXG4vKipcbiAqIERlZmluZXMgYSAzLWVsZW1lbnQgbWFwIHdoaWNoIGlzIHVzZWQgdG8gcHJvdmlkZSBzaWduaWZpY2FudCBwaHlzaWNhbFxuICogZGV0YWlsIHRvIHRoZSBzdXJmYWNlIGJ5IHBlcnR1cmJpbmcgdGhlIGZhY2luZyBkaXJlY3Rpb24gb2YgZWFjaCBpbmRpdmlkdWFsXG4gKiBwaXhlbC5cbiAqXG4gKiBAbWV0aG9kIG5vcm1hbFxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBNYXRlcmlhbCwgSW1hZ2Ugb3IgdmVjM1xuICogQHJldHVybiB7RWxlbWVudH0gY3VycmVudCBNZXNoXG4gKi9cbk1lc2gucHJvdG90eXBlLnNldE5vcm1hbHMgPSBmdW5jdGlvbiBzZXROb3JtYWxzIChtYXRlcmlhbEV4cHJlc3Npb24pIHtcbiAgICBpZiAobWF0ZXJpYWxFeHByZXNzaW9uLl9jb21waWxlKSB7XG4gICAgICAgIHRoaXMudmFsdWUuZXhwcmVzc2lvbnMubm9ybWFscyA9IG1hdGVyaWFsRXhwcmVzc2lvbjtcbiAgICAgICAgbWF0ZXJpYWxFeHByZXNzaW9uID0gbWF0ZXJpYWxFeHByZXNzaW9uLl9jb21waWxlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2godHlwZW9mIG1hdGVyaWFsRXhwcmVzc2lvbiA9PT0gJ251bWJlcicgPyAnVU5JRk9STV9JTlBVVCcgOiAnTUFURVJJQUxfSU5QVVQnKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnbm9ybWFsJyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2gobWF0ZXJpYWxFeHByZXNzaW9uKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBOb3JtYWxzIGV4cHJlc3Npb24gb2YgTWVzaFxuICpcbiAqIEBtZXRob2QgZ2V0Tm9ybWFsc1xuICogQHJldHVybnMgVGhlIG5vcm1hbHMgZXhwcmVzc2lvbiBmb3IgTWVzaFxuICovXG5NZXNoLnByb3RvdHlwZS5nZXROb3JtYWxzID0gZnVuY3Rpb24gZ2V0Tm9ybWFscyAobWF0ZXJpYWxFeHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuZXhwcmVzc2lvbnMubm9ybWFscztcbn07XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgZ2xvc3NpbmVzcyBvZiB0aGUgbWVzaCBmcm9tIGVpdGhlciBhIG1hdGVyaWFsIGV4cHJlc3Npb24gb3IgYVxuICogc2NhbGFyIHZhbHVlXG4gKlxuICogQG1ldGhvZCBzZXRHbG9zc2luZXNzXG4gKiBAcGFyYW0ge01hdGVyaWFsRXhwcmVzc2lvbnxOdW1iZXJ9XG4gKiBAcGFyYW0ge09iamVjdH0gT3B0aW9uYWwgdHdlZW5pbmcgcGFyYW1ldGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDYWxsYmFja1xuICogQGNoYWluYWJsZVxuICovXG5NZXNoLnByb3RvdHlwZS5zZXRHbG9zc2luZXNzID0gZnVuY3Rpb24gc2V0R2xvc3NpbmVzcyAobWF0ZXJpYWxFeHByZXNzaW9uLCB0cmFuc2l0aW9uLCBjYikge1xuICAgIHZhciBnbG9zc2luZXNzO1xuXG4gICAgaWYgKG1hdGVyaWFsRXhwcmVzc2lvbi5fY29tcGlsZSkge1xuICAgICAgICB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLmdsb3NzaW5lc3MgPSBtYXRlcmlhbEV4cHJlc3Npb247XG4gICAgICAgIGdsb3NzaW5lc3MgPSBtYXRlcmlhbEV4cHJlc3Npb24uX2NvbXBpbGUoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUuZXhwcmVzc2lvbnMuZ2xvc3NpbmVzcyA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWUuZ2xvc3NpbmVzcyA9IG1hdGVyaWFsRXhwcmVzc2lvbjtcbiAgICAgICAgZ2xvc3NpbmVzcyA9IHRoaXMudmFsdWUuZ2xvc3NpbmVzcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChtYXRlcmlhbEV4cHJlc3Npb24uX2NvbXBpbGUgPyAnR0xfVU5JRk9STVMnIDogJ01BVEVSSUFMX0lOUFVUJyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ2dsb3NzaW5lc3MnKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChnbG9zc2luZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIG1hdGVyaWFsIGV4cHJlc3Npb24gb3Igc2NhbGFyIHZhbHVlIGZvciBnbG9zc2luZXNzLlxuICpcbiAqIEBtZXRob2QgZ2V0R2xvc3NpbmVzc1xuICogQHJldHVybnMge01hdGVyaWFsRXhwcmVzc3xOdW1iZXJ9XG4gKi9cbk1lc2gucHJvdG90eXBlLmdldEdsb3NzaW5lc3MgPSBmdW5jdGlvbiBnZXRHbG9zc2luZXNzICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5leHByZXNzaW9ucy5nbG9zc2luZXNzIHx8IHRoaXMudmFsdWUuZ2xvc3NpbmVzcztcbn07XG5cbi8qKlxuICogRGVmaW5lcyAzIGVsZW1lbnQgbWFwIHdoaWNoIGRpc3BsYWNlcyB0aGUgcG9zaXRpb24gb2YgZWFjaCB2ZXJ0ZXggaW4gd29ybGRcbiAqIHNwYWNlLlxuICpcbiAqIEBtZXRob2Qgc2V0UG9zaXRpb25PZmZzZXRcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0ge01hdGVyaWFsRXhwcmVzc2lvbnxBcnJheX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25hbCB0d2VlbmluZyBwYXJhbWV0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENhbGxiYWNrXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1lc2gucHJvdG90eXBlLnNldFBvc2l0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gcG9zaXRpb25PZmZzZXQgKG1hdGVyaWFsRXhwcmVzc2lvbiwgdHJhbnNpdGlvbiwgY2IpIHtcbiAgICB2YXIgdW5pZm9ybVZhbHVlO1xuXG4gICAgaWYgKG1hdGVyaWFsRXhwcmVzc2lvbi5fY29tcGlsZSkge1xuICAgICAgICB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLnBvc2l0aW9uT2Zmc2V0ID0gbWF0ZXJpYWxFeHByZXNzaW9uO1xuICAgICAgICB1bmlmb3JtVmFsdWUgPSBtYXRlcmlhbEV4cHJlc3Npb24uX2NvbXBpbGUoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUuZXhwcmVzc2lvbnMucG9zaXRpb25PZmZzZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlLnBvc2l0aW9uT2Zmc2V0ID0gbWF0ZXJpYWxFeHByZXNzaW9uO1xuICAgICAgICB1bmlmb3JtVmFsdWUgPSB0aGlzLnZhbHVlLnBvc2l0aW9uT2Zmc2V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKG1hdGVyaWFsRXhwcmVzc2lvbi5fY29tcGlsZSA/ICdNQVRFUklBTF9JTlBVVCcgOiAnR0xfVU5JRk9STVMnKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgncG9zaXRpb25PZmZzZXQnKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCh1bmlmb3JtVmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgcG9zaXRpb24gb2Zmc2V0LlxuICpcbiAqIEBtZXRob2QgZ2V0UG9zaXRpb25PZmZzZXRcbiAqIEByZXR1cm5zIHtNYXRlcmlhbEV4cHJlc3N8TnVtYmVyfVxuICovXG5NZXNoLnByb3RvdHlwZS5nZXRQb3NpdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldFBvc2l0aW9uT2Zmc2V0IChtYXRlcmlhbEV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5leHByZXNzaW9ucy5wb3NpdGlvbk9mZnNldCB8fCB0aGlzLnZhbHVlLnBvc2l0aW9uT2Zmc2V0O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1lc2gncyBjdXN0b20gb3B0aW9ucy5cbiAqXG4gKiBAbWV0aG9kIGdldERyYXdPcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBPcHRpb25zXG4gKi9cbk1lc2gucHJvdG90eXBlLmdldE1hdGVyaWFsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiBnZXRNYXRlcmlhbEV4cHJlc3Npb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5leHByZXNzaW9ucztcbn07XG5cbk1lc2gucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuTWVzaC5wcm90b3R5cGUuX3B1c2hJbnZhbGlkYXRpb25zID0gZnVuY3Rpb24gcHVzaEludmFsaWRhdGlvbnMgKGV4cHJlc3Npb25OYW1lKSB7XG4gICAgdmFyIHVuaWZvcm1LZXk7XG4gICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnZhbHVlLmV4cHJlc3Npb25zW2V4cHJlc3Npb25OYW1lXTtcbiAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgaSA9IGV4cHJlc3Npb24uaW52YWxpZGF0aW9ucy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHVuaWZvcm1LZXkgPSBleHByZXNzaW9uLmludmFsaWRhdGlvbnMucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCgnR0xfVU5JRk9STVMnKTtcbiAgICAgICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHVuaWZvcm1LZXkpO1xuICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQoZXhwcmVzc2lvbi51bmlmb3Jtc1t1bmlmb3JtS2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiogU2VuZHMgZHJhdyBjb21tYW5kcyB0byB0aGUgcmVuZGVyZXJcbipcbiogQHByaXZhdGVcbiogQG1ldGhvZCBvblVwZGF0ZVxuKi9cbk1lc2gucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24gb25VcGRhdGUgKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5fbm9kZTtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9jaGFuZ2VRdWV1ZTtcblxuICAgIGlmIChub2RlKSB7XG4gICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKCdXSVRIJyk7XG4gICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKG5vZGUuZ2V0TG9jYXRpb24oKSk7XG5cbiAgICAgICAgaWYgKHRoaXMudmFsdWUuZ2VvbWV0cnkpIHtcbiAgICAgICAgaSA9IHRoaXMudmFsdWUuZ2VvbWV0cnkuc3BlYy5pbnZhbGlkYXRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVySW5kZXggPSB0aGlzLnZhbHVlLmdlb21ldHJ5LnNwZWMuaW52YWxpZGF0aW9ucy5wb3AoKTtcbiAgICAgICAgICAgICAgICBub2RlLnNlbmREcmF3Q29tbWFuZCgnR0xfQlVGRkVSX0RBVEEnKTtcbiAgICAgICAgICAgICAgICBub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLnZhbHVlLmdlb21ldHJ5LmlkKTtcbiAgICAgICAgICAgICAgICBub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLnZhbHVlLmdlb21ldHJ5LnNwZWMuYnVmZmVyTmFtZXNbaV0pO1xuICAgICAgICAgICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMudmFsdWUuZ2VvbWV0cnkuc3BlYy5idWZmZXJWYWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMudmFsdWUuZ2VvbWV0cnkuc3BlYy5idWZmZXJTcGFjaW5nc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhbnkgaW52YWxpZGF0aW9ucyBleGlzdCwgcHVzaCB0aGVtIGludG8gdGhlIHF1ZXVlXG4gICAgICAgIGlmICh0aGlzLnZhbHVlLmNvbG9yICYmIHRoaXMudmFsdWUuY29sb3IuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQoJ0dMX1VOSUZPUk1TJyk7XG4gICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCgnYmFzZUNvbG9yJyk7XG4gICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLnZhbHVlLmNvbG9yLmdldE5vcm1hbGl6ZWRSR0IoKSk7XG4gICAgICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHRoaXMuX2lkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGFueSBpbnZhbGlkYXRpb25zIGV4aXN0LCBwdXNoIHRoZW0gaW50byB0aGUgcXVldWVcbiAgICAgICAgdGhpcy5fcHVzaEludmFsaWRhdGlvbnMoJ2Jhc2VDb2xvcicpO1xuICAgICAgICB0aGlzLl9wdXNoSW52YWxpZGF0aW9ucygncG9zaXRpb25PZmZzZXQnKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBub2RlLnNlbmREcmF3Q29tbWFuZChxdWV1ZVtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIH1cblxufTtcblxuTWVzaC5wcm90b3R5cGUub25Nb3VudCA9IGZ1bmN0aW9uIG9uTW91bnQgKG5vZGUsIGlkKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5faWQgPSBpZDtcblxuICAgIHRoaXMuZHJhdygpO1xufTtcblxuTWVzaC5wcm90b3R5cGUub25EaXNtb3VudCA9IGZ1bmN0aW9uIG9uRGlzbW91bnQgKCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5vbkhpZGUoKTtcbn07XG5cbk1lc2gucHJvdG90eXBlLm9uU2hvdyA9IGZ1bmN0aW9uIG9uU2hvdyAoKSB7XG4gICAgLy9UT0RPXG59O1xuXG5NZXNoLnByb3RvdHlwZS5vbkhpZGUgPSBmdW5jdGlvbiBvbkhpZGUgKCkge1xuICAgIC8vVE9ET1xufTtcblxuLyoqXG4gKiBSZWNlaXZlcyB0cmFuc2Zvcm0gY2hhbmdlIHVwZGF0ZXMgZnJvbSB0aGUgc2NlbmUgZ3JhcGguXG4gKlxuICogQHByaXZhdGVcbiAqL1xuTWVzaC5wcm90b3R5cGUub25UcmFuc2Zvcm1DaGFuZ2UgPSBmdW5jdGlvbiBvblRyYW5zZm9ybUNoYW5nZSAodHJhbnNmb3JtKSB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0dMX1VOSUZPUk1TJyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ3RyYW5zZm9ybScpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKHRyYW5zZm9ybSk7ICAgICAgICBcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbi8qKlxuICogUmVjZWl2ZXMgc2l6ZSBjaGFuZ2UgdXBkYXRlcyBmcm9tIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5NZXNoLnByb3RvdHlwZS5vblNpemVDaGFuZ2UgPSBmdW5jdGlvbiBvblNpemVDaGFuZ2UgKHNpemUpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnR0xfVU5JRk9STVMnKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnc2l6ZScpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKHNpemUpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBSZWNlaXZlcyBvcGFjaXR5IGNoYW5nZSB1cGRhdGVzIGZyb20gdGhlIHNjZW5lIGdyYXBoLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk1lc2gucHJvdG90eXBlLm9uT3BhY2l0eUNoYW5nZSA9IGZ1bmN0aW9uIG9uT3BhY2l0eUNoYW5nZSAob3BhY2l0eSkge1xuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdHTF9VTklGT1JNUycpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdvcGFjaXR5Jyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2gob3BhY2l0eSk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxuTWVzaC5wcm90b3R5cGUub25BZGRVSUV2ZW50ID0gZnVuY3Rpb24gb25BZGRVSUV2ZW50IChVSUV2ZW50LCBtZXRob2RzLCBwcm9wZXJ0aWVzKSB7XG4gICAgLy9UT0RPXG59O1xuXG5NZXNoLnByb3RvdHlwZS5fcmVxdWVzdFVwZGF0ZSA9IGZ1bmN0aW9uIF9yZXF1ZXN0VXBkYXRlICgpIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuTWVzaC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLm9uVHJhbnNmb3JtQ2hhbmdlKHRoaXMuX25vZGUuZ2V0VHJhbnNmb3JtKCkpO1xuICAgIHRoaXMub25TaXplQ2hhbmdlKHRoaXMuX25vZGUuZ2V0U2l6ZSgpKTtcbiAgICB0aGlzLm9uT3BhY2l0eUNoYW5nZSh0aGlzLl9ub2RlLmdldE9wYWNpdHkoKSk7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG59O1xuXG5NZXNoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gZHJhdyAoKSB7XG4gICAgdmFyIGtleTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgdGhpcy5faW5EcmF3ID0gdHJ1ZTtcblxuICAgIHRoaXMuaW5pdCgpO1xuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgIGlmICh2YWx1ZS5nZW9tZXRyeSAhPSBudWxsKSB0aGlzLnNldEdlb21ldHJ5KHZhbHVlLmdlb21ldHJ5KTtcbiAgICBpZiAodmFsdWUuY29sb3IgIT0gbnVsbCkgdGhpcy5zZXRCYXNlQ29sb3IodmFsdWUuY29sb3IpO1xuICAgIGlmICh2YWx1ZS5kcmF3T3B0aW9ucyAhPSBudWxsKSB0aGlzLnNldERyYXdPcHRpb25zKHZhbHVlLmRyYXdPcHRpb25zKTtcbiAgICBpZiAodmFsdWUuZmxhdFNoYWRpbmcgIT0gbnVsbCkgdGhpcy5zZXRGbGF0U2hhZGluZyh2YWx1ZS5mbGF0U2hhZGluZyk7XG4gICAgaWYgKHZhbHVlLm5vcm1hbHMgIT0gbnVsbCkgdGhpcy5zZXROb3JtYWxzKHZhbHVlLm5vcm1hbHMpO1xuICAgIGlmICh2YWx1ZS5nbG9zc2luZXNzICE9IG51bGwpIHRoaXMuc2V0R2xvc3NpbmVzcyh2YWx1ZS5nbG9zc2luZXNzKTtcbiAgICBpZiAodmFsdWUucG9zaXRpb25PZmZzZXQgIT0gbnVsbCkgdGhpcy5zZXRQb3NpdGlvbk9mZnNldCh2YWx1ZS5wb3NpdGlvbk9mZnNldCk7XG5cbiAgICB0aGlzLl9pbkRyYXcgPSBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzaDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWVzaDogcmVxdWlyZSgnLi9NZXNoJyksXG4gICAgUG9pbnRMaWdodDogcmVxdWlyZSgnLi9saWdodHMvUG9pbnRMaWdodCcpLFxuICAgIEFtYmllbnRMaWdodDogcmVxdWlyZSgnLi9saWdodHMvQW1iaWVudExpZ2h0JyksXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGlnaHQgPSByZXF1aXJlKCcuL0xpZ2h0Jyk7XG5cblxuLyoqXG4gKiBBbWJpZW50TGlnaHQgZXh0ZW5kcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBMaWdodC4gSXQgc2V0cyB0aGUgYW1iaWVuY2UgaW5cbiAqIHRoZSBzY2VuZS4gQW1iaWVuY2UgaXMgYSBsaWdodCBzb3VyY2UgdGhhdCBlbWl0cyBsaWdodCBpbiB0aGUgZW50aXJlXG4gKiBzY2VuZSwgZXZlbmx5LlxuICpcbiAqIEBjbGFzcyBBbWJpZW50TGlnaHRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGNvbXBvbmVudFxuICogQHBhcmFtIHtMb2NhbERpc3BhdGNofSBkaXNwYXRjaCBMb2NhbERpc3BhdGNoIHRvIGJlIHJldHJpZXZlZFxuICogZnJvbSB0aGUgY29ycmVzcG9uZGluZyBSZW5kZXIgTm9kZVxuICovXG5mdW5jdGlvbiBBbWJpZW50TGlnaHQobm9kZSkge1xuICAgIExpZ2h0LmNhbGwodGhpcywgbm9kZSk7XG4gICAgdGhpcy5jb21tYW5kcy5jb2xvciA9ICdHTF9BTUJJRU5UX0xJR0hUJztcbn07XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBDbGFzczogJ0FtYmllbnRMaWdodCdcbipcbiogQG1ldGhvZCB0b1N0cmluZ1xuKiBAcmV0dXJuIHtzdHJpbmd9IGRlZmluaXRpb25cbiovXG5BbWJpZW50TGlnaHQudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0FtYmllbnRMaWdodCc7XG59O1xuXG4vKipcbiAqIEV4dGVuZHMgTGlnaHQgY29uc3RydWN0b3JcbiAqL1xuQW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGlnaHQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIEFtYmllbnRMaWdodCBhcyB0aGUgY29uc3RydWN0b3JcbiAqL1xuQW1iaWVudExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFtYmllbnRMaWdodDtcblxubW9kdWxlLmV4cG9ydHMgPSBBbWJpZW50TGlnaHQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIGJsdWVwcmludCBmb3IgYWxsIGxpZ2h0IGNvbXBvbmVudHMgZm9yIGluaGVyaXRpbmcgY29tbW9uIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogQGNsYXNzIExpZ2h0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBjb21wb25lbnRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgY29udHJvbGxpbmcgbm9kZVxuICogZnJvbSB0aGUgY29ycmVzcG9uZGluZyBSZW5kZXIgTm9kZVxuICovXG5mdW5jdGlvbiBMaWdodChub2RlKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX2NvbG9yO1xuICAgIHRoaXMuY29tbWFuZHMgPSB7IGNvbG9yOiAnR0xfTElHSFRfQ09MT1InIH07XG59O1xuXG4vKipcbiogUmV0dXJucyB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgQ2xhc3M6ICdMaWdodCdcbipcbiogQG1ldGhvZCB0b1N0cmluZ1xuKiBAcmV0dXJuIHtTdHJpbmd9IGRlZmluaXRpb25cbiovXG5MaWdodC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnTGlnaHQnO1xufTtcblxuLyoqXG4qIENoYW5nZXMgdGhlIGNvbG9yIG9mIHRoZSBsaWdodCwgdXNpbmcgdGhlICdDb2xvcicgdXRpbGl0eSBjb21wb25lbnQuXG4qXG4qIEBtZXRob2Qgc2V0Q29sb3JcbiogQHBhcmFtIHtDb2xvcn0gQ29sb3IgaW5zdGFuY2VcbiogQGNoYWluYWJsZVxuKi9cbkxpZ2h0LnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uIHNldENvbG9yKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvci5nZXROb3JtYWxpemVkUkdCKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMucXVldWUucHVzaCh0aGlzLmNvbW1hbmRzLmNvbG9yKTtcbiAgICB2YXIgcmdiID0gdGhpcy5fY29sb3IuZ2V0Tm9ybWFsaXplZFJHQigpO1xuICAgIHRoaXMucXVldWUucHVzaChyZ2JbMF0pO1xuICAgIHRoaXMucXVldWUucHVzaChyZ2JbMV0pO1xuICAgIHRoaXMucXVldWUucHVzaChyZ2JbMl0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4qIFJldHVybnMgdGhlIGN1cnJlbnQgY29sb3IuXG5cbiogQG1ldGhvZCBnZXRDb2xvclxuKiBAcmV0dXJucyB7Q29sb3J9IENvbG9yLlxuKi9cbkxpZ2h0LnByb3RvdHlwZS5nZXRDb2xvciA9IGZ1bmN0aW9uIGdldENvbG9yKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbn07XG5cbi8qKlxuKiBTZW5kcyBkcmF3IGNvbW1hbmRzIHRvIHRoZSByZW5kZXJlclxuKlxuKiBAcHJpdmF0ZVxuKiBAbWV0aG9kIG9uVXBkYXRlXG4qL1xuTGlnaHQucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24gY2xlYW4oKSB7XG4gICAgdmFyIHBhdGggPSB0aGlzLl9ub2RlLmdldExvY2F0aW9uKCk7XG5cbiAgICB0aGlzLl9ub2RlXG4gICAgICAgIC5zZW5kRHJhd0NvbW1hbmQoJ1dJVEgnKVxuICAgICAgICAuc2VuZERyYXdDb21tYW5kKHBhdGgpO1xuXG4gICAgdmFyIGkgPSB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMucXVldWUuc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbG9yICYmIHRoaXMuX2NvbG9yLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5jb21tYW5kcy5jb2xvcik7XG4gICAgICAgIHZhciByZ2IgPSB0aGlzLl9jb2xvci5nZXROb3JtYWxpemVkUkdCKCk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHJnYlswXSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHJnYlsxXSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHJnYlsyXSk7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sodGhpcy5faWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpZ2h0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGlnaHQgPSByZXF1aXJlKCcuL0xpZ2h0Jyk7XG5cbi8qKlxuICogUG9pbnRMaWdodCBleHRlbmRzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIExpZ2h0LiBQb2ludExpZ2h0IGlzIGEgbGlnaHQgc291cmNlXG4gKiB0aGF0IGVtaXRzIGxpZ2h0IGluIGFsbCBkaXJlY3Rpb25zIGZyb20gYSBwb2ludCBpbiBzcGFjZS5cbiAqXG4gKiBAY2xhc3MgUG9pbnRMaWdodFxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IGRpc3BhdGNoIExvY2FsRGlzcGF0Y2ggdG8gYmUgcmV0cmlldmVkXG4gKiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIFJlbmRlciBOb2RlXG4gKi9cbmZ1bmN0aW9uIFBvaW50TGlnaHQobm9kZSkge1xuICAgIExpZ2h0LmNhbGwodGhpcywgbm9kZSk7XG4gICAgdGhpcy5jb21tYW5kcy5wb3NpdGlvbiA9ICdHTF9MSUdIVF9QT1NJVElPTic7XG4gICAgdGhpcy5vblRyYW5zZm9ybUNoYW5nZShub2RlLmdldFRyYW5zZm9ybSgpKTtcbn07XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBDbGFzczogJ1BvaW50TGlnaHQnXG4qXG4qIEBtZXRob2QgdG9TdHJpbmdcbiogQHJldHVybiB7c3RyaW5nfSBkZWZpbml0aW9uXG4qL1xuUG9pbnRMaWdodC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnUG9pbnRMaWdodCc7XG59O1xuXG4vKipcbiAqIEV4dGVuZHMgTGlnaHQgY29uc3RydWN0b3JcbiAqL1xuUG9pbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExpZ2h0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyBQb2ludExpZ2h0IGFzIHRoZSBjb25zdHJ1Y3RvclxuICovXG5Qb2ludExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50TGlnaHQ7XG5cbi8qKlxuICogUmVjZWl2ZXMgdHJhbnNmb3JtIGNoYW5nZSB1cGRhdGVzIGZyb20gdGhlIHNjZW5lIGdyYXBoLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblBvaW50TGlnaHQucHJvdG90eXBlLm9uVHJhbnNmb3JtQ2hhbmdlID0gZnVuY3Rpb24gb25UcmFuc2Zvcm1DaGFuZ2UgKHRyYW5zZm9ybSkge1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5faWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZS5wdXNoKHRoaXMuY29tbWFuZHMucG9zaXRpb24pO1xuICAgIHRoaXMucXVldWUucHVzaCh0cmFuc2Zvcm1bMTJdKTtcbiAgICB0aGlzLnF1ZXVlLnB1c2godHJhbnNmb3JtWzEzXSk7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKHRyYW5zZm9ybVsxNF0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludExpZ2h0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmFtb3VzUGxhdGZvcm0gPSByZXF1aXJlKCdmYW1vdXMnKTtcbnZhciBDb21wb3NpdG9yID0gRmFtb3VzUGxhdGZvcm0ucmVuZGVyZXJzLkNvbXBvc2l0b3I7XG52YXIgVGhyZWFkTWFuYWdlciA9IEZhbW91c1BsYXRmb3JtLnJlbmRlcmVycy5UaHJlYWRNYW5hZ2VyO1xudmFyIEVuZ2luZSA9IEZhbW91c1BsYXRmb3JtLmVuZ2luZTtcbnZhciByb290ID0gRmFtb3VzUGxhdGZvcm0uY29yZS5yb290O1xudmFyIEhUTUxFbGVtZW50ID0gRmFtb3VzUGxhdGZvcm0uZG9tUmVuZGVyYWJsZXMuSFRNTEVsZW1lbnQ7XG52YXIgRmFtb3VzID0gRmFtb3VzUGxhdGZvcm0uY29yZS5GYW1vdXM7XG52YXIgRE9NRWxlbWVudCA9IEZhbW91c1BsYXRmb3JtLmRvbVJlbmRlcmFibGVzLkRPTUVsZW1lbnQ7XG52YXIgU2l6ZSA9IEZhbW91c1BsYXRmb3JtLmNvbXBvbmVudHMuU2l6ZTtcbnZhciBSb3RhdGlvbiA9IEZhbW91c1BsYXRmb3JtLmNvbXBvbmVudHMuUm90YXRpb247XG52YXIgQWxpZ24gPSBGYW1vdXNQbGF0Zm9ybS5jb21wb25lbnRzLkFsaWduO1xudmFyIE1vdW50UG9pbnQgPSBGYW1vdXNQbGF0Zm9ybS5jb21wb25lbnRzLk1vdW50UG9pbnQ7XG52YXIgT3JpZ2luID0gRmFtb3VzUGxhdGZvcm0uY29tcG9uZW50cy5PcmlnaW47XG52YXIgUG9zaXRpb24gPSBGYW1vdXNQbGF0Zm9ybS5jb21wb25lbnRzLlBvc2l0aW9uO1xudmFyIENsb2NrID0gRmFtb3VzUGxhdGZvcm0uY29yZS5DbG9ja1xudmFyIEVhc2luZyA9IEZhbW91c1BsYXRmb3JtLnRyYW5zaXRpb25zLkN1cnZlcztcbnZhciBNZXNoID0gRmFtb3VzUGxhdGZvcm0ud2ViZ2xSZW5kZXJhYmxlcy5NZXNoO1xudmFyIFNwaGVyZSA9IEZhbW91c1BsYXRmb3JtLndlYmdsR2VvbWV0cmllcy5TcGhlcmU7XG52YXIgQ29sb3IgPSBGYW1vdXNQbGF0Zm9ybS51dGlsaXRpZXMuQ29sb3I7XG52YXIgUG9pbnRMaWdodCA9IEZhbW91c1BsYXRmb3JtLndlYmdsUmVuZGVyYWJsZXMuUG9pbnRMaWdodDtcbnZhciBBbWJpZW50TGlnaHQgPSBGYW1vdXNQbGF0Zm9ybS53ZWJnbFJlbmRlcmFibGVzLkFtYmllbnRMaWdodDtcblxuLy92YXIgQXBwID0gcmVxdWlyZSgnLi9BcHAuanMnKVxuLy8gQm9pbGVycGxhdGVcbnZhciBjb21wb3NpdG9yID0gbmV3IENvbXBvc2l0b3IoKTtcbnZhciB0aHJlYWRtYW5nZXIgPSBuZXcgVGhyZWFkTWFuYWdlcihGYW1vdXMsIGNvbXBvc2l0b3IpO1xudmFyIGVuZ2luZSA9IG5ldyBFbmdpbmUoKTtcbmVuZ2luZS51cGRhdGUodGhyZWFkbWFuZ2VyKTtcblxuXG52YXIgcGFkZGluZyA9IDA7XG52YXIgd2lkdGggPSA0MDAgLSBwYWRkaW5nICogMjtcbnZhciBoZWlnaHQgPSAxNTAgLSBwYWRkaW5nICogMjtcblxudmFyIHRhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vhc2luZy1jdXJ2ZS10YWJsZScpO1xudmFyIHJvd3MgPSB0YWJsZS5yb3dzO1xuZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJvdyA9IHJvd3NbaV07XG4gICAgdmFyIHRkcyA9IHJvdy5xdWVyeVNlbGVjdG9yQWxsKCd0ZCcpO1xuICAgIGlmICh0ZHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgXG4gICAgICAgIHZhciBuYW1lID0gdGRzWzBdLmlubmVyVGV4dCB8fCB0ZHNbMF0udGV4dENvbnRlbnRcbiAgICAgICAgdmFyIGN1cnZlID0gRWFzaW5nW25hbWVdO1xuICAgICAgICAvLyBEcmF3IHRoZSBjdXJ2ZSBvbiB0aGUgY2FudmFzLlxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobmFtZSArICctZ3JhcGgnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIG1heFggPSAxMDA7XG4gICAgICAgIHZhciBib3VuZHMgPSBmaW5kQm91bmRzKGN1cnZlLCBtYXhYKTtcbiAgICAgICAgdmFyIG1pblkgPSBib3VuZHMubWluO1xuICAgICAgICB2YXIgbWF4WSA9IGJvdW5kcy5tYXg7XG4gICAgICAgIHZhciBzY2FsZSA9IChtYXhZIC0gbWluWSk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjMDAwJztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG1heFg7IHQrKykge1xuICAgICAgICAgICAgdmFyIHYgPSBjdXJ2ZSh0IC8gbWF4WCk7XG4gICAgICAgICAgICB2YXIgeCA9IHQgKiAod2lkdGggLyBtYXhYKSArIHBhZGRpbmc7XG4gICAgICAgICAgICB2YXIgeSA9IGhlaWdodCAtICgodiAtIG1pblkpIC8gc2NhbGUpICogaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgICAgIGN0eC5saW5lVG8ofn54LCB+fnkpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAvLyBEaXNwbGF5IGEgZGVtbyBpbiB0aGUgY29udGFpbmVyXG4gICAgICAgIC8vdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5hbWUgKyAnLWNvbnRhaW5lcicpO1xuICAgICAgICB2YXIgZmFDb250ZXh0ID0gRmFtb3VzLmNyZWF0ZUNvbnRleHQoJyMnK25hbWUgKyAnLWNvbnRhaW5lcicpXG4gICAgICAgIHZhciBub2RlID0gZmFDb250ZXh0LmFkZENoaWxkKClcbiAgICAgICAgdmFyIHNpemUgPSBuZXcgU2l6ZShub2RlKS5zZXRNb2RlKDEsMSkuc2V0QWJzb2x1dGUoNDAsNDApXG4gICAgICAgIHZhciBhbGlnbiA9IG5ldyBBbGlnbihub2RlKVxuICAgICAgICB2YXIgb3JpZ2luID0gbmV3IE9yaWdpbihub2RlKS5zZXQoMC41LDAuNSlcbiAgICAgICAgdmFyIGVsID0gbmV3IERPTUVsZW1lbnQobm9kZSx7XG4gICAgICAgICAgcHJvcGVydGllczp7XG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjOGNkMGQzJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLy8gdmFyIG1lc2ggPSBuZXcgTWVzaChub2RlKVxuICAgICAgICAvLyBtZXNoLnNldEdlb21ldHJ5KG5ldyBTcGhlcmUoeyBkZXRhaWw6IDEwMCB9KSlcbiAgICAgICAgLy8gdmFyIGNvbG9yID0gbmV3IENvbG9yKCkuc2V0KCdyZ2InLCAzMiwgMTI4LCAyMzApXG4gICAgICAgIC8vIG1lc2guc2V0QmFzZUNvbG9yKGNvbG9yKVxuICAgICAgXG4gICAgICAgIG1ha2VBbmltKGFsaWduLCBjdXJ2ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZUFuaW0oYWxnLCBjdXJ2ZSkge1xuICAgIHZhciBnb1JpZ2h0ID0gZnVuY3Rpb24oKSB7IFxuICAgICAgICAgYWxnLnNldCguNzUsIDAsIDAsIHsgZHVyYXRpb246IDIwMDAsIGN1cnZlOiBjdXJ2ZSB9LCBnb0xlZnQpOyBcbiAgfVxuICAgIHZhciBnb0xlZnQgPSBmdW5jdGlvbigpIHsgYWxnLnNldCgwLCAwLCAwLHsgZHVyYXRpb246IDIwMDAsIGN1cnZlOiBjdXJ2ZSB9LCBnb1JpZ2h0KTsgfVxuICAgIGdvUmlnaHQoKTtcbn1cblxuZnVuY3Rpb24gZmluZEJvdW5kcyhmbiwgZGl2aXNpb25zKSB7XG4gICAgdmFyIG1pbiA9IDA7XG4gICAgdmFyIG1heCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXZpc2lvbnM7IGkrKykge1xuICAgICAgICB2YXIgbiA9IGZuKGkgLyBkaXZpc2lvbnMpO1xuICAgICAgICBpZiAobWF4IDwgbikgbWF4ID0gbjtcbiAgICAgICAgaWYgKG1pbiA+IG4pIG1pbiA9IG47XG4gICAgfVxuICAgIHJldHVybiB7IG1pbjogbWluLCBtYXg6IG1heCB9O1xufSJdfQ==
